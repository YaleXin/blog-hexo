<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yalexin.gitee.io",root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="实验包括两个小实验，第一个是仿真Cache，第二个是针对不同情况下，用不同的方式实现矩阵转置。 话不多说，打开电脑，带上键盘，开启实验！"><meta property="og:type" content="article"><meta property="og:title" content="CS:APP-Cache Lab"><meta property="og:url" content="https://yalexin.gitee.io/2023/10/03/CS-APP-Cache-Lab/index.html"><meta property="og:site_name" content="黄阿信"><meta property="og:description" content="实验包括两个小实验，第一个是仿真Cache，第二个是针对不同情况下，用不同的方式实现矩阵转置。 话不多说，打开电脑，带上键盘，开启实验！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.yalexin.top/image-20230922161616482.png"><meta property="og:image" content="https://cdn.yalexin.top/image-20230922162712713.png"><meta property="og:image" content="https://cdn.yalexin.top/image-20230922162905389.png"><meta property="og:image" content="https://cdn.yalexin.top/image-20230922164403227.png"><meta property="og:image" content="https://cdn.yalexin.top/image-20230922202026860.png"><meta property="article:published_time" content="2023-10-03T07:16:06.000Z"><meta property="article:modified_time" content="2023-10-16T15:12:46.188Z"><meta property="article:author" content="YaleXin"><meta property="article:tag" content="性能调优"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.yalexin.top/image-20230922161616482.png"><link rel="canonical" href="https://yalexin.gitee.io/2023/10/03/CS-APP-Cache-Lab/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>CS:APP-Cache Lab | 黄阿信</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">黄阿信</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">要么改变世界，要么适应世界。</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签<span class="badge">118</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类<span class="badge">13</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档<span class="badge">125</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-fw fa-book"></i> 留言板</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i> 友链</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yalexin.gitee.io/2023/10/03/CS-APP-Cache-Lab/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/cat_mouse.jpg"><meta itemprop="name" content="YaleXin"><meta itemprop="description" content="学渣一枚"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="黄阿信"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> CS:APP-Cache Lab</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-10-03 15:16:06" itemprop="dateCreated datePublished" datetime="2023-10-03T15:16:06+08:00">2023-10-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-10-16 23:12:46" itemprop="dateModified" datetime="2023-10-16T23:12:46+08:00">2023-10-16</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a></span></span><span id="/2023/10/03/CS-APP-Cache-Lab/" class="post-meta-item leancloud_visitors" data-flag-title="CS:APP-Cache Lab" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>6.6k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>实验包括两个小实验，第一个是仿真Cache，第二个是针对不同情况下，用不同的方式实现矩阵转置。</p><p>话不多说，打开电脑，带上键盘，开启实验！<a id="more"></a></p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part-A"></a>Part-A</h2><p>第一部分要求我们模拟一个缓存模块，使得其能够计算在给定缓存信息后，面对特定的访存序列，给出最终总的缓存名中、缓存缺失和缓存冲突（替换）的数量。</p><p>缓存的信息如下给出：</p><ul><li><code>s</code>：表明有$2^s$个组</li><li><code>E</code>：每组有<code>E</code>个缓存行</li><li><code>b</code>：块的大小是$2^b$个位（好像是字节，不是位，我是按照字节来处理的）</li></ul><p>访存序列由文件给出，该文件中由若干行组成，每行由以下形式组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[space]operation address,size</span><br></pre></td></tr></table></figure><p><code>operation</code>为以下四者之一：</p><ul><li><p>I：指令加载（我们不需要处理该类型）</p></li><li><p>M：数据修改</p></li><li><p>L：数据加载</p></li><li><p>S：数据保存</p></li></ul><p>在本实验中，我们只关心<code>operation</code>和<code>address</code>，而且，我们还有以下两个有用的点：</p><ul><li><p>L或者S最多造成1个”缓存不命中“</p></li><li><p>数据修改M可以视为数据加载，然后存储到同一个地址，因此一个M操作可以造成下面两种情况：</p><ul><li>①：两个命中</li><li>②：一个不命中和一个名中（可能还有一个替换）</li></ul></li></ul><p>由于我们需要设计一个通用的，即能够处理任意合理的<code>s-E-b</code>组合，因此我们不能够在代码中用数组进行固定缓存组数或者行数，而应该使用<strong>链表</strong>。</p><p>首先，对于缓存，必然是由若干组组成，为了方便，我们要记下缓存总的组数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CacheStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> groupCnt;</span><br><span class="line">	<span class="comment">// 指向第一组    </span></span><br><span class="line">    GroupItem* groupItemHead;</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure><p>而对于每一组，同样为了方便，我们要记下该组内有多少行（当然我们也可以在结构体<code>Cache</code>中记录，因为每组内的行数肯定是一样的），我们要记录下该组内用了几行（用于快速判断组内是否已经满了从而进行替换操作），由于我们发生冲突是，使用的是<code>LRU</code>（最近最少使用）策略进行替换，我们还需要记录每行最后一次被访问的时间戳，因此我们可以给每组加一个时钟，因此每个组的结构可以设计成如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GroupStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lineCnt;</span><br><span class="line">    <span class="keyword">int</span> used;</span><br><span class="line">    <span class="keyword">int</span> clock;</span><br><span class="line">    <span class="comment">// 指向改组内的第一行</span></span><br><span class="line">    LineItem* lineItemHead;</span><br><span class="line">    <span class="comment">// 指向下一组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GroupStruct</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;GroupItem;</span><br></pre></td></tr></table></figure><p>而对于每一行，我们要设置一个id，以及有效位，块的大小（也可以在结构体<code>Cache</code>中记录），以及最后一次访问的时间戳：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LineItemStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> valid;</span><br><span class="line">    <span class="keyword">int</span> blockSize;</span><br><span class="line">    <span class="keyword">int</span> insertClock;</span><br><span class="line">    <span class="comment">// 指向下一行</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LineItemStruct</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; LineItem;</span><br></pre></td></tr></table></figure><p>设计好这些数据后，完整的代码就呼之欲出了，由于代码比较冗长，大家可以到<a href="https://github.com/YaleXin/CS-APP3e-Labs/blob/main/Cache-Lab/csim.c" target="_blank" rel="noopener">【GitHub】</a>上参考</p><p>值得注意的是，处理L和S的逻辑是一样的，因为都是要先判断缓存中存不存在，不存在则加载进来，最后不管怎么样，都会更新时钟，因此可以把这两个处理函数合二为一，但是为了体现模块化思想，我还是保留了。</p><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">./test-csim</span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">TEST_CSIM_RESULTS=27</span><br></pre></td></tr></table></figure><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part-B"></a>Part-B</h2><p>上面的实验是开胃菜，只要有一些程序设计思想的应该都能做出来，该部分的实验才是需要花点时间的。</p><p>我们先来一个最简单的，将<code>transpose_submit</code>改为下面的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时只注册我们的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerFunctions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Register your solution function */</span></span><br><span class="line">    registerTransFunction(transpose_submit, transpose_submit_desc); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register any additional transpose functions */</span></span><br><span class="line"><span class="comment">//    registerTransFunction(trans, trans_desc); </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">./test-trans -M 32 -N 32</span><br><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:869, misses:1184, evictions:1152</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1184</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1184</span><br></pre></td></tr></table></figure><p>我们可以看到，没有任何优化的情况下，缓存缺失有<code>1184</code>次，离目标<code>&lt;300</code>还很远。</p><p>我们再来看看访存情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0 &gt; debug.txt</span><br><span class="line">cat debug.txt</span><br><span class="line">S 10c080,1 miss </span><br><span class="line">L 18c0c0,8 miss </span><br><span class="line">L 18c0a4,4 miss </span><br><span class="line">L 18c0a0,4 hit </span><br><span class="line">L 10c0a0,4 miss eviction </span><br><span class="line">S 14c0a0,4 miss eviction </span><br><span class="line">L 10c0a4,4 miss eviction </span><br><span class="line">S 14c120,4 miss </span><br><span class="line">L 10c0a8,4 hit </span><br><span class="line">S 14c1a0,4 miss </span><br><span class="line">L 10c0ac,4 hit </span><br><span class="line">S 14c220,4 miss </span><br><span class="line">L 10c0b0,4 hit </span><br><span class="line">S 14c2a0,4 miss </span><br><span class="line">L 10c0b4,4 hit </span><br><span class="line">S 14c320,4 miss </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>从结果来看，我们知道了两个数组之间的地址差为<code>0x14c0a0-0x10c0a0=0x40000</code>.</p><p>此外，我们还知道s=5,E=1,b=5,即一共32组，每组一行，每块2^5=32字节,即一个块可以放8个int类型数据。</p><p>对于一个32位地址，会按照下面的格式进行解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------</span><br><span class="line">|  id(22-bit) | groupId(5-bit) | block-offset(5-bit) |</span><br><span class="line">------------------------------------------------------</span><br></pre></td></tr></table></figure><p>意味着代码中的A数组起始地址和B数组起始地址都会被映射到同一组，准确来说，对于地址<code>&amp;A[i][j]</code>和<code>&amp;B[i][j]</code>都会被映射到同一组，但是对应的id不同。数组A和数组B元素对应的组号大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A || B:</span><br><span class="line">0...0 1...1 2..2 3...3</span><br><span class="line">4...4 ................</span><br><span class="line">8...8 ................</span><br><span class="line">12...12 ................</span><br><span class="line">16...16 ................</span><br><span class="line">20...20 ................</span><br><span class="line">24...44 ................</span><br><span class="line">28...28 ................</span><br></pre></td></tr></table></figure><p>即<code>groupID_A[0][0]=groupID_B[0][0]=0</code>，<code>groupID_A[1][0]=groupID_B[1][0]=4</code></p><p>因此我们应该尽量避免访问完数组A后立马访问数组B，避免将刚刚加载进缓存的数据因为冲突而被替换出去，由于每行可以放8个元素，因此如果我们可以保障连续读取的8个数字在同一组是最好的情况，因此我们可以将数组分块遍历。此外，我们的局部变量个数比较少的时候，会使用寄存器保存他们，引用它们不会对缓存造成影响，因此我们要善于利用局部变量。</p><h3 id="32-32"><a href="#32-32" class="headerlink" title="32*32"></a>32*32</h3><p>我们可以分块成8*8的矩阵，一开始的时候，我们可以一次性读取A数组的8个数字（<code>A[0][0]~A[0][7]</code>），因为这8个数字都是在同一行，读取完后缓存情况如下，绿色代表在缓存中，每个数字代表该元素对应的组号</p><p><img src="https://cdn.yalexin.top/image-20230922161616482.png" alt="image-20230922161616482"></p><p>下一步就是进行转置操作，由于数组B和数组A对应位置的元素将会映射到同一组，因此缓存中会先进行替换，再逐一加载进缓存，第一次转置完毕后， 缓存中都是数组B的元素：</p><p><img src="https://cdn.yalexin.top/image-20230922162712713.png" alt="image-20230922162712713"></p><p>下图表示转置情况，黄色代表转置完毕：</p><p><img src="https://cdn.yalexin.top/image-20230922162905389.png" alt="image-20230922162905389"></p><p><strong>接下来是重点了</strong>，由于我们缓存中有大量的数组B的数据，我们应该利用这点，我们先读取<code>A[1][1]~A[1][7]</code>共7个数字，此时会发生一次缓存替换，先不管，然后将这些数据进行转置，转置过程只会在保存<code>B[1][1]</code>时候发生缓存替换，后面<code>B[2][1]~B[7][1]</code>都缓存命中，转置后的情况为：</p><p><img src="https://cdn.yalexin.top/image-20230922164403227.png" alt="image-20230922164403227"></p><p>按照这个思路，继续完成这个小矩阵剩余部分，再转到下一个小矩阵即可，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (M == <span class="number">32</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bi = <span class="number">0</span>; bi &lt; <span class="number">4</span>; bi++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bj = <span class="number">0</span>; bj &lt; <span class="number">4</span>; bj++) &#123;</span><br><span class="line">                <span class="comment">// 上面是迭代分块矩阵的逻辑（32 / 8 = 4）</span></span><br><span class="line">                <span class="comment">// 下面是小矩阵内从按行进行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    tmp1 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span>];</span><br><span class="line">                    tmp2 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">                    tmp3 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">2</span>];</span><br><span class="line">                    tmp4 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">3</span>];</span><br><span class="line">                    tmp5 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">4</span>];</span><br><span class="line">                    tmp6 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">5</span>];</span><br><span class="line">                    tmp7 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">6</span>];</span><br><span class="line">                    tmp8 = A[bi * <span class="number">8</span> + k][bj * <span class="number">8</span> + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[bj * <span class="number">8</span>][bi * <span class="number">8</span> + k] = tmp1;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">1</span>][bi * <span class="number">8</span> + k] = tmp2;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">2</span>][bi * <span class="number">8</span> + k] = tmp3;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">3</span>][bi * <span class="number">8</span> + k] = tmp4;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">4</span>][bi * <span class="number">8</span> + k] = tmp5;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">5</span>][bi * <span class="number">8</span> + k] = tmp6;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">6</span>][bi * <span class="number">8</span> + k] = tmp7;</span><br><span class="line">                    B[bj * <span class="number">8</span> + <span class="number">7</span>][bi * <span class="number">8</span> + k] = tmp8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"> ./test-trans -M 32 -N 32</span><br><span class="line"> Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1765, misses:288, evictions:256</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=288</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:288</span><br></pre></td></tr></table></figure><p>低于300，满足测试要求。</p><h3 id="64-64"><a href="#64-64" class="headerlink" title="64*64"></a>64*64</h3><p>如果我们仍然以分块的方式进行，由于前4行和后4行都映射到同一组，我们只能以4*4的分块方式：</p><p><img src="https://cdn.yalexin.top/image-20230922202026860.png" alt="image-20230922202026860"></p><p>但是很遗憾，按照4*4的逻辑，我们只能拿一点分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./test-trans -M 64 -N 64</span><br><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:6497, misses:1700, evictions:1668</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1700</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1700</span><br></pre></td></tr></table></figure><p>距离1300还有一定差距。</p><p>进一步优化的代码我实在想不出了，参考了<a href="https://zhuanlan.zhihu.com/p/484657229" target="_blank" rel="noopener">【别人的做法】</a>：</p><p>仍然是考虑8*8，但是在8*8中，又继续分4*4，处理过程如下：</p><ul><li>第一步，利用局部变量将<code>A</code>的左上和右上一次性复制给<code>B</code>，处理完成后，缓存中是B的左上和右上部分</li><li>第二步，用本地变量把<code>B</code>的右上角存储下来，此时缓存名中</li><li>第三步，将<code>A</code>的左下复制给<code>B</code>的右上</li><li>第四步，利用上述存储<code>B</code>的右上角的本地变量，把<code>A</code>的右上复制给<code>B</code>的左下</li><li>第五步，把<code>A</code>的右下复制给<code>B</code>的右下</li></ul><p>由于这部分不是我写的，代码就参照<a href="https://github.com/YaleXin/CS-APP3e-Labs/blob/main/Cache-Lab/trans.c" target="_blank" rel="noopener">【GitHub】</a>即可</p><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"> ./test-trans -M 64 -N 64</span><br><span class="line"> </span><br><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:9017, misses:1228, evictions:1196</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1228</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1228</span><br></pre></td></tr></table></figure><p>低于1300，达到要求！</p><h3 id="61-67"><a href="#61-67" class="headerlink" title="61*67"></a>61*67</h3><p>由于不是方阵，因此想要愉快地进行优化，没啥路子，而且数组A和数组B对应位置不一定会映射到同一组，真要优化起来，估计很复杂，试一下暴力破解！从8*8开始，到16*16，最后发现16*16的方式可以通过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">16</span>)</span><br><span class="line">            <span class="comment">// 要注意不能超出边界N 下面的循环同理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; i + <span class="number">16</span> &amp;&amp; k &lt; N; k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = j; l &lt; j + <span class="number">16</span> &amp;&amp; l &lt; M; l++)</span><br><span class="line">                    B[l][k] = A[k][l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">./test-trans -M 61 -N 67</span><br><span class="line"></span><br><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:6186, misses:1993, evictions:1961</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1993</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1993</span><br></pre></td></tr></table></figure><p>低于2000，满足条件！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遍历数组时候，尽量以行的方式进行，因为我们可以最大化利用缓存。</p><hr></div><div class="reward-container"><div>假如对您有所帮助，那就请我喝咖啡吧~~</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/WeChat.png" alt="YaleXin 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/images/Alipay.jpg" alt="YaleXin 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" rel="tag"><i class="fa fa-tag"></i> 性能调优</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/10/02/CS-APP-Architecture-Lab/" rel="prev" title="CS:APP-Architecture Lab"><i class="fa fa-chevron-left"></i> CS:APP-Architecture Lab</a></div><div class="post-nav-item"> <a href="/2023/11/14/CS-APP-Shell-Lab/" rel="next" title="CS:APP-Shell Lab">CS:APP-Shell Lab<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 文章结束------</div></div></div></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A"><span class="nav-number">1.</span> <span class="nav-text">Part-A</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B"><span class="nav-number">2.</span> <span class="nav-text">Part-B</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#32-32"><span class="nav-number">2.1.</span> <span class="nav-text">32*32</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-64"><span class="nav-number">2.2.</span> <span class="nav-text">64*64</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-67"><span class="nav-number">2.3.</span> <span class="nav-text">61*67</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="YaleXin" src="/uploads/cat_mouse.jpg"><p class="site-author-name" itemprop="name">YaleXin</p><div class="site-description" itemprop="description">学渣一枚</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">125</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">118</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2020 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-fas fa-heartbeat"></i></span> <span class="author" itemprop="copyrightHolder">YaleXin</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">494k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">7:29</span></div> <span>本站已在此等候您 <span id="dnum" style="color:#35b8ff">0</span> 天</span> <span><span id="hnum" style="color:#35b8ff">0</span> 小时 <span id="mnum" style="color:#35b8ff">0</span> 分 <span id="snum" style="color:#35b8ff">0</span> 秒</span><script>var now=new Date;function createtime(){var n=new Date("02/21/2020 11:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("dnum").innerHTML=dnum,document.getElementById("hnum").innerHTML=hnum,document.getElementById("mnum").innerHTML=mnum,document.getElementById("snum").innerHTML=snum}setInterval("createtime()",250)</script><div class="powered-by"> <span>powered by</span> <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span> <span class="site-uv" title="总访客量"><span>总访客量：</span><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="site-pv" title="总访问量"><span>总访问量：</span><span id="busuanzi_value_site_pv"></span></span></span></div><script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=CjaKbRAizU0DNH3B4Hllhtwp-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id'     : 'CjaKbRAizU0DNH3B4Hllhtwp-gzGzoHsz',
            'X-LC-Key'    : 'B61jy2Xnwe90oJ2dtUeF6HHU',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.min.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script></body></html>